CCS PCH C Compiler, Version 5.117, 2295               09-Apr-24 21:32

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\rdTap\rdTap.lst

               ROM used:   14312 bytes (44%)
                           Largest free fragment is 18452
               RAM used:   2426 (67%) at main() level
                           2463 (68%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   3600
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   0304
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0378
006C:  BTFSS  FA3.5
006E:  GOTO   0078
0072:  BTFSC  FA4.5
0074:  GOTO   04E2
0078:  BTFSS  FB6.7
007A:  GOTO   0084
007E:  BTFSC  FB7.7
0080:  GOTO   046C
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #define DEBUG_ASCII     0
.................... #define DEBUG_SBD       0
.................... #define MCP3208_ENABLED 0
.................... #define STARTUP_BLINKS  150
.................... 
.................... 
.................... #include "rdTap.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 01,C0
00F4:  DATA 80,41
00F6:  DATA 00,C1
00F8:  DATA 81,40
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 00,C1
010C:  DATA 81,40
010E:  DATA 01,C0
0110:  DATA 80,41
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 01,C0
011C:  DATA 80,41
011E:  DATA 00,C1
0120:  DATA 81,40
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 00,C1
0134:  DATA 81,40
0136:  DATA 01,C0
0138:  DATA 80,41
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 01,C0
0154:  DATA 80,41
0156:  DATA 00,C1
0158:  DATA 81,40
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 00,C1
0174:  DATA 81,40
0176:  DATA 01,C0
0178:  DATA 80,41
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 01,C0
018C:  DATA 80,41
018E:  DATA 00,C1
0190:  DATA 81,40
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 00,C1
019C:  DATA 81,40
019E:  DATA 01,C0
01A0:  DATA 80,41
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 01,C0
01B4:  DATA 80,41
01B6:  DATA 00,C1
01B8:  DATA 81,40
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  DATA 00,C1
01CC:  DATA 81,40
01CE:  DATA 01,C0
01D0:  DATA 80,41
01D2:  DATA 00,C1
01D4:  DATA 81,40
01D6:  DATA 01,C0
01D8:  DATA 80,41
01DA:  DATA 01,C0
01DC:  DATA 80,41
01DE:  DATA 00,C1
01E0:  DATA 81,40
01E2:  CLRF   FF7
01E4:  ADDLW  F2
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  RETURN 0
01F2:  DATA 00,C0
01F4:  DATA C1,01
01F6:  DATA C3,03
01F8:  DATA 02,C2
01FA:  DATA C6,06
01FC:  DATA 07,C7
01FE:  DATA 05,C5
0200:  DATA C4,04
0202:  DATA CC,0C
0204:  DATA 0D,CD
0206:  DATA 0F,CF
0208:  DATA CE,0E
020A:  DATA 0A,CA
020C:  DATA CB,0B
020E:  DATA C9,09
0210:  DATA 08,C8
0212:  DATA D8,18
0214:  DATA 19,D9
0216:  DATA 1B,DB
0218:  DATA DA,1A
021A:  DATA 1E,DE
021C:  DATA DF,1F
021E:  DATA DD,1D
0220:  DATA 1C,DC
0222:  DATA 14,D4
0224:  DATA D5,15
0226:  DATA D7,17
0228:  DATA 16,D6
022A:  DATA D2,12
022C:  DATA 13,D3
022E:  DATA 11,D1
0230:  DATA D0,10
0232:  DATA F0,30
0234:  DATA 31,F1
0236:  DATA 33,F3
0238:  DATA F2,32
023A:  DATA 36,F6
023C:  DATA F7,37
023E:  DATA F5,35
0240:  DATA 34,F4
0242:  DATA 3C,FC
0244:  DATA FD,3D
0246:  DATA FF,3F
0248:  DATA 3E,FE
024A:  DATA FA,3A
024C:  DATA 3B,FB
024E:  DATA 39,F9
0250:  DATA F8,38
0252:  DATA 28,E8
0254:  DATA E9,29
0256:  DATA EB,2B
0258:  DATA 2A,EA
025A:  DATA EE,2E
025C:  DATA 2F,EF
025E:  DATA 2D,ED
0260:  DATA EC,2C
0262:  DATA E4,24
0264:  DATA 25,E5
0266:  DATA 27,E7
0268:  DATA E6,26
026A:  DATA 22,E2
026C:  DATA E3,23
026E:  DATA E1,21
0270:  DATA 20,E0
0272:  DATA A0,60
0274:  DATA 61,A1
0276:  DATA 63,A3
0278:  DATA A2,62
027A:  DATA 66,A6
027C:  DATA A7,67
027E:  DATA A5,65
0280:  DATA 64,A4
0282:  DATA 6C,AC
0284:  DATA AD,6D
0286:  DATA AF,6F
0288:  DATA 6E,AE
028A:  DATA AA,6A
028C:  DATA 6B,AB
028E:  DATA 69,A9
0290:  DATA A8,68
0292:  DATA 78,B8
0294:  DATA B9,79
0296:  DATA BB,7B
0298:  DATA 7A,BA
029A:  DATA BE,7E
029C:  DATA 7F,BF
029E:  DATA 7D,BD
02A0:  DATA BC,7C
02A2:  DATA B4,74
02A4:  DATA 75,B5
02A6:  DATA 77,B7
02A8:  DATA B6,76
02AA:  DATA 72,B2
02AC:  DATA B3,73
02AE:  DATA B1,71
02B0:  DATA 70,B0
02B2:  DATA 50,90
02B4:  DATA 91,51
02B6:  DATA 93,53
02B8:  DATA 52,92
02BA:  DATA 96,56
02BC:  DATA 57,97
02BE:  DATA 55,95
02C0:  DATA 94,54
02C2:  DATA 9C,5C
02C4:  DATA 5D,9D
02C6:  DATA 5F,9F
02C8:  DATA 9E,5E
02CA:  DATA 5A,9A
02CC:  DATA 9B,5B
02CE:  DATA 99,59
02D0:  DATA 58,98
02D2:  DATA 88,48
02D4:  DATA 49,89
02D6:  DATA 4B,8B
02D8:  DATA 8A,4A
02DA:  DATA 4E,8E
02DC:  DATA 8F,4F
02DE:  DATA 8D,4D
02E0:  DATA 4C,8C
02E2:  DATA 44,84
02E4:  DATA 85,45
02E6:  DATA 87,47
02E8:  DATA 46,86
02EA:  DATA 82,42
02EC:  DATA 43,83
02EE:  DATA 41,81
02F0:  DATA 80,40
*
03E2:  DATA 41,54
03E4:  DATA 45,30
03E6:  DATA 0D,00
03E8:  DATA 41,54
03EA:  DATA 26,4B
03EC:  DATA 30,0D
03EE:  DATA 00,00
03F0:  DATA 41,54
03F2:  DATA 2B,53
03F4:  DATA 42,44
03F6:  DATA 4D,54
03F8:  DATA 41,3D
03FA:  DATA 31,0D
03FC:  DATA 00,00
03FE:  DATA 41,54
0400:  DATA 2B,43
0402:  DATA 52,49
0404:  DATA 53,0D
0406:  DATA 00,00
0408:  DATA 41,54
040A:  DATA 45,30
040C:  DATA 0D,00
040E:  DATA 41,54
0410:  DATA 26,4B
0412:  DATA 30,0D
0414:  DATA 00,00
0416:  DATA 41,54
0418:  DATA 2B,53
041A:  DATA 42,44
041C:  DATA 4D,54
041E:  DATA 41,3D
0420:  DATA 31,0D
0422:  DATA 00,00
0424:  DATA 41,54
0426:  DATA 2B,53
0428:  DATA 42,44
042A:  DATA 57,42
042C:  DATA 3D,25
042E:  DATA 6C,75
0430:  DATA 0D,00
0432:  DATA 41,54
0434:  DATA 2B,53
0436:  DATA 42,44
0438:  DATA 49,58
043A:  DATA 0D,00
043C:  DATA 41,54
043E:  DATA 2B,53
0440:  DATA 42,44
0442:  DATA 44,30
0444:  DATA 0D,00
0446:  DATA 41,54
0448:  DATA 45,30
044A:  DATA 0D,00
044C:  DATA 41,54
044E:  DATA 26,4B
0450:  DATA 30,0D
0452:  DATA 00,00
0454:  DATA 41,54
0456:  DATA 2B,53
0458:  DATA 42,44
045A:  DATA 4D,54
045C:  DATA 41,3D
045E:  DATA 31,0D
0460:  DATA 00,00
0462:  DATA 41,54
0464:  DATA 2B,53
0466:  DATA 42,44
0468:  DATA 52,42
046A:  DATA 0D,00
*
084C:  MOVLB  9
084E:  MOVF   x94,W
0850:  MULWF  x96
0852:  MOVFF  FF3,01
0856:  MOVFF  FF4,00
085A:  MULWF  x97
085C:  MOVF   FF3,W
085E:  ADDWF  00,F
0860:  MOVF   x95,W
0862:  MULWF  x96
0864:  MOVF   FF3,W
0866:  ADDWFC 00,W
0868:  MOVWF  02
086A:  MOVLB  0
086C:  RETURN 0
*
0F24:  TBLRD*+
0F26:  MOVF   FF5,F
0F28:  BZ    0F42
0F2A:  MOVFF  FF6,97E
0F2E:  MOVFF  FF7,97F
0F32:  MOVFF  FF5,987
0F36:  RCALL  0F14
0F38:  MOVFF  97E,FF6
0F3C:  MOVFF  97F,FF7
0F40:  BRA    0F24
0F42:  RETURN 0
*
11B6:  TBLRD*+
11B8:  MOVFF  FF6,97F
11BC:  MOVFF  FF7,980
11C0:  MOVFF  FF5,987
11C4:  RCALL  0F14
11C6:  MOVFF  97F,FF6
11CA:  MOVFF  980,FF7
11CE:  MOVLB  9
11D0:  DECFSZ x7E,F
11D2:  BRA    11D6
11D4:  BRA    11DA
11D6:  MOVLB  0
11D8:  BRA    11B6
11DA:  MOVLB  0
11DC:  GOTO   145C (RETURN)
11E0:  MOVFF  FEA,986
11E4:  MOVFF  FE9,985
11E8:  MOVLB  9
11EA:  SWAPF  x7F,W
11EC:  IORLW  F0
11EE:  MOVWF  x81
11F0:  ADDWF  x81,F
11F2:  ADDLW  E2
11F4:  MOVWF  x82
11F6:  ADDLW  32
11F8:  MOVWF  x84
11FA:  MOVF   x7F,W
11FC:  ANDLW  0F
11FE:  ADDWF  x82,F
1200:  ADDWF  x82,F
1202:  ADDWF  x84,F
1204:  ADDLW  E9
1206:  MOVWF  x83
1208:  ADDWF  x83,F
120A:  ADDWF  x83,F
120C:  SWAPF  x7E,W
120E:  ANDLW  0F
1210:  ADDWF  x83,F
1212:  ADDWF  x84,F
1214:  RLCF   x83,F
1216:  RLCF   x84,F
1218:  COMF   x84,F
121A:  RLCF   x84,F
121C:  MOVF   x7E,W
121E:  ANDLW  0F
1220:  ADDWF  x84,F
1222:  RLCF   x81,F
1224:  MOVLW  07
1226:  MOVWF  x80
1228:  MOVLW  0A
122A:  DECF   x83,F
122C:  ADDWF  x84,F
122E:  BNC   122A
1230:  DECF   x82,F
1232:  ADDWF  x83,F
1234:  BNC   1230
1236:  DECF   x81,F
1238:  ADDWF  x82,F
123A:  BNC   1236
123C:  DECF   x80,F
123E:  ADDWF  x81,F
1240:  BNC   123C
1242:  MOVLW  09
1244:  MOVWF  FEA
1246:  MOVLW  80
1248:  MOVWF  FE9
124A:  MOVLW  07
124C:  ANDWF  x85,W
124E:  BCF    x85.6
1250:  ADDWF  FE9,F
1252:  MOVLW  00
1254:  ADDWFC FEA,F
1256:  MOVF   FE9,W
1258:  SUBLW  84
125A:  BNZ   1264
125C:  MOVF   FEA,W
125E:  SUBLW  09
1260:  BNZ   1264
1262:  BSF    x85.6
1264:  MOVF   FEF,W
1266:  MOVWF  00
1268:  BNZ   127A
126A:  BTFSC  x85.6
126C:  BRA    127A
126E:  BTFSC  x85.4
1270:  BRA    129C
1272:  BTFSC  x85.3
1274:  BRA    127A
1276:  MOVLW  20
1278:  BRA    1280
127A:  BSF    x85.3
127C:  BCF    x85.4
127E:  MOVLW  30
1280:  ADDWF  00,F
1282:  MOVFF  FEA,97F
1286:  MOVFF  FE9,97E
128A:  MOVFF  00,987
128E:  MOVLB  0
1290:  RCALL  0F14
1292:  MOVFF  97F,FEA
1296:  MOVFF  97E,FE9
129A:  MOVLB  9
129C:  MOVF   FEE,W
129E:  BTFSS  x85.6
12A0:  BRA    1256
12A2:  MOVLB  0
12A4:  GOTO   146A (RETURN)
*
28CC:  ADDWF  FE8,W
28CE:  CLRF   FF7
28D0:  RLCF   FF7,F
28D2:  ADDLW  E7
28D4:  MOVWF  FF6
28D6:  MOVLW  28
28D8:  ADDWFC FF7,F
28DA:  TBLRD*-
28DC:  MOVF   FF5,W
28DE:  MOVWF  FFA
28E0:  TBLRD*
28E2:  MOVF   FF5,W
28E4:  MOVWF  FF9
28E6:  DATA 32,25
28E8:  DATA 64,25
28EA:  DATA A6,25
28EC:  DATA E4,25
28EE:  DATA 22,26
28F0:  DATA B6,26
28F2:  DATA 4A,27
28F4:  DATA 8C,27
*
2C6A:  ADDWF  FE8,W
2C6C:  CLRF   FF7
2C6E:  RLCF   FF7,F
2C70:  ADDLW  85
2C72:  MOVWF  FF6
2C74:  MOVLW  2C
2C76:  ADDWFC FF7,F
2C78:  TBLRD*-
2C7A:  MOVF   FF5,W
2C7C:  MOVWF  FFA
2C7E:  TBLRD*
2C80:  MOVF   FF5,W
2C82:  MOVWF  FF9
2C84:  DATA C0,29
2C86:  DATA F0,29
2C88:  DATA 32,2A
2C8A:  DATA 6E,2A
2C8C:  DATA AA,2A
2C8E:  DATA B6,2A
2C90:  DATA 06,2B
2C92:  DATA 48,2B
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses NOPUT
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... //#fuses WDT512
.................... #fuses WDT1024
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... 
.................... 
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
*
12CE:  MOVFF  97F,985
12D2:  MOVFF  97E,984
12D6:  MOVLB  9
12D8:  MOVF   x82,F
12DA:  BNZ   12E0
12DC:  MOVF   x83,F
12DE:  BZ    1326
12E0:  MOVFF  981,FEA
12E4:  MOVFF  980,FE9
12E8:  MOVF   FEF,F
12EA:  BZ    1326
....................      *s++ = *s2++;
12EC:  MOVFF  985,03
12F0:  MOVF   x84,W
12F2:  INCF   x84,F
12F4:  BTFSC  FD8.2
12F6:  INCF   x85,F
12F8:  MOVWF  x86
12FA:  MOVFF  03,987
12FE:  MOVFF  981,FEA
1302:  MOVF   x80,W
1304:  INCF   x80,F
1306:  BTFSC  FD8.2
1308:  INCF   x81,F
130A:  MOVWF  FE9
130C:  MOVFF  FEF,988
1310:  MOVFF  03,FEA
1314:  MOVFF  986,FE9
1318:  MOVFF  988,FEF
131C:  MOVF   x82,W
131E:  BTFSC  FD8.2
1320:  DECF   x83,F
1322:  DECF   x82,F
1324:  BRA    12D8
....................   for (; n > 0; n--)
1326:  MOVF   x82,F
1328:  BNZ   132E
132A:  MOVF   x83,F
132C:  BZ    1348
....................      *s++ = '\0';
132E:  MOVFF  985,FEA
1332:  MOVF   x84,W
1334:  INCF   x84,F
1336:  BTFSC  FD8.2
1338:  INCF   x85,F
133A:  MOVWF  FE9
133C:  CLRF   FEF
133E:  MOVF   x82,W
1340:  BTFSC  FD8.2
1342:  DECF   x83,F
1344:  DECF   x82,F
1346:  BRA    1326
.................... 
....................   return(s1);
1348:  MOVFF  97E,01
134C:  MOVFF  97F,02
1350:  MOVLB  0
1352:  GOTO   1614 (RETURN)
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
*
0B5A:  MOVFF  97F,FEA
0B5E:  MOVLB  9
0B60:  MOVFF  97E,FE9
0B64:  MOVF   x80,W
0B66:  SUBWF  FEF,W
0B68:  BZ    0B8E
....................       if (*s == '\0')
0B6A:  MOVFF  97F,03
0B6E:  MOVFF  97E,FE9
0B72:  MOVFF  03,FEA
0B76:  MOVF   FEF,F
0B78:  BNZ   0B82
....................          return(0);
0B7A:  MOVLW  00
0B7C:  MOVWF  01
0B7E:  MOVWF  02
0B80:  BRA    0B96
0B82:  INCF   x7E,F
0B84:  BTFSC  FD8.2
0B86:  INCF   x7F,F
0B88:  MOVLB  0
0B8A:  BRA    0B5A
0B8C:  MOVLB  9
....................    return(s);
0B8E:  MOVFF  97E,01
0B92:  MOVFF  97F,02
0B96:  MOVLB  0
0B98:  RETURN 0
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0AC8:  MOVFF  97D,97F
0ACC:  MOVFF  97C,97E
0AD0:  MOVFF  97F,FEA
0AD4:  MOVLB  9
0AD6:  MOVFF  97E,FE9
0ADA:  MOVF   FEF,F
0ADC:  BZ    0AEA
0ADE:  INCF   x7E,F
0AE0:  BTFSC  FD8.2
0AE2:  INCF   x7F,F
0AE4:  MOVLB  0
0AE6:  BRA    0AD0
0AE8:  MOVLB  9
....................    return(sc - s);
0AEA:  MOVF   x7C,W
0AEC:  SUBWF  x7E,W
0AEE:  MOVWF  00
0AF0:  MOVF   x7D,W
0AF2:  SUBWFB x7F,W
0AF4:  MOVWF  03
0AF6:  MOVFF  00,01
0AFA:  MOVWF  02
0AFC:  MOVLB  0
0AFE:  GOTO   0C1E (RETURN)
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
068A:  MOVLW  09
068C:  MOVWF  FEA
068E:  MOVLW  90
0690:  MOVWF  FE9
0692:  MOVF   FEF,W
0694:  BZ    06B8
0696:  MOVLW  02
0698:  MOVWF  01
069A:  MOVLW  BF
069C:  MOVWF  00
069E:  CLRWDT
06A0:  DECFSZ 00,F
06A2:  BRA    069E
06A4:  DECFSZ 01,F
06A6:  BRA    069A
06A8:  MOVLW  96
06AA:  MOVWF  00
06AC:  DECFSZ 00,F
06AE:  BRA    06AC
06B0:  BRA    06B2
06B2:  CLRWDT
06B4:  DECFSZ FEF,F
06B6:  BRA    0696
06B8:  RETURN 0
*
12A8:  MOVLW  09
12AA:  MOVLB  9
12AC:  SUBWF  x7F,F
12AE:  BNC   12C8
12B0:  MOVLW  09
12B2:  MOVWF  FEA
12B4:  MOVLW  7F
12B6:  MOVWF  FE9
12B8:  BCF    FD8.0
12BA:  RRCF   FEF,F
12BC:  MOVF   FEF,W
12BE:  BZ    12C8
12C0:  BRA    12C4
12C2:  CLRWDT
12C4:  DECFSZ FEF,F
12C6:  BRA    12C2
12C8:  MOVLB  0
12CA:  GOTO   150C (RETURN)
.................... 
.................... /* 
.................... Parameters and devices are stored in 1024 byte EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x0000
.................... #define DEVICE_CRC_ADDRESS 0x0002
.................... 
.................... #define PARAM_ADDRESS      0x0004 /* parameters go from 4 to 127 ... 123 bytes max */ 
.................... #define DEVICE_ADDRESS     0x0080 /* devices go from 128 to 1024 ... 896 bytes max */
.................... 
.................... 
.................... /* uart1 is for modbus and set in modbus_int_uart */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600, errors)	
*
04CC:  BTFSS  FA4.5
04CE:  BRA    04CC
04D0:  MOVFF  FA6,20
04D4:  MOVFF  F7A,01
04D8:  BTFSS  20.1
04DA:  BRA    04E0
04DC:  BCF    FA6.4
04DE:  BSF    FA6.4
04E0:  RETURN 0
*
198E:  BTFSS  FA4.4
1990:  BRA    198E
1992:  MOVWF  F79
1994:  RETURN 0
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
05C2:  BCF    FC6.7
05C4:  BCF    F9E.3
05C6:  MOVFF  98D,FC9
05CA:  MOVLW  02
05CC:  BTFSC  FC6.7
05CE:  BRA    05DA
05D0:  BTFSC  FC7.2
05D2:  BRA    05D0
05D4:  MOVLW  00
05D6:  BTFSC  FC5.6
05D8:  MOVLW  01
05DA:  MOVWF  01
05DC:  RETURN 0
*
0DC6:  BCF    FC6.6
0DC8:  BSF    FC5.3
0DCA:  BTFSC  FC5.3
0DCC:  BRA    0DCA
0DCE:  BTFSC  00.0
0DD0:  BCF    FC5.5
0DD2:  BTFSS  00.0
0DD4:  BSF    FC5.5
0DD6:  BSF    FC5.4
0DD8:  BTFSC  FC5.4
0DDA:  BRA    0DD8
0DDC:  MOVFF  FC9,01
0DE0:  RETURN 0
.................... 
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /* device types for struct_device */
.................... #define DEV_TYPE_DISABLED       0
.................... 
.................... /* modbus slave on RS-485 bus */
.................... #define DEV_TYPE_MODBUS_1       1
.................... #define DEV_TYPE_MODBUS_2       2
.................... #define DEV_TYPE_MODBUS_3       3
.................... #define DEV_TYPE_MODBUS_4       4
.................... #define DEV_TYPE_MODBUS_5       5
.................... #define DEV_TYPE_MODBUS_6       6
.................... #define DEV_TYPE_MODBUS_16      7
.................... #define DEV_TYPE_MODBUS_MAX     7
.................... 
.................... /* I2C slave on I2C bus */
.................... #define DEV_TYPE_I2C_READ_8     16
.................... #define DEV_TYPE_I2C_READ_16    17
.................... #define DEV_TYPE_I2C_READ_24    18
.................... #define DEV_TYPE_I2C_READ_32    19
.................... #define DEV_TYPE_I2C_WRITE_8    20
.................... #define DEV_TYPE_I2C_WRITE_16   21
.................... #define DEV_TYPE_I2C_WRITE_24   22
.................... #define DEV_TYPE_I2C_WRITE_32   23
.................... #define DEV_TYPE_I2C_MAX        23
.................... 
.................... /* local registers on this device */
.................... #define DEV_TYPE_LOCAL_READ_16  32
.................... #define DEV_TYPE_LOCAL_WRITE_16 33
.................... #define DEV_TYPE_LOCAL_MAX      33
.................... 
.................... 
.................... 
.................... /* serial port speeds */
.................... #define DEV_SERIAL_9600  0
.................... #define DEV_SERIAL_19200 1
.................... 
.................... 
.................... #define DEV_MAX_N 64
.................... 
.................... #include "worldDeviceTypes.h"
.................... /* Continental Control Systems, Watt Node Modbus */
.................... #define DEVICE_TYPE_WORLD_WNC_BASIC           1  /* 1000, 34 */
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED        2
.................... #define DEVICE_TYPE_WORLD_WNC_CONFIGURATION   3
.................... #define DEVICE_TYPE_WORLD_WNC_DIAGNOSTIC      4
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED_ENERGY 5  /* 1100, 38 */
.................... 
.................... /* APRS World, XRW2G */
.................... #define DEVICE_TYPE_WORLD_XRW2G_BASIC         100 /* 0, 46 */
.................... #define DEVICE_TYPE_WORLD_XRW2G_DIAGNOSTIC    101
.................... #define DEVICE_TYPE_WORLD_XRW2G_CONFIGURATION 102
.................... 
.................... /* Morningstar, Relay Driver */
.................... #define DEVICE_TYPE_WORLD_RD1_RAM             200 /* 0, 18 */
.................... #define DEVICE_TYPE_WORLD_RD1_COILS           201 /* 0, 4 */
.................... 
.................... /* Morningstar, Tri-Star */
.................... #define DEVICE_TYPE_WORLD_TS_RAM              300 /* 8, 21 */
.................... #define DEVICE_TYPE_WORLD_TS_COILS            301
.................... #define DEVICE_TYPE_WORLD_TS_EEPROM           302
.................... #define DEVICE_TYPE_WORLD_TS_KWH              303 /* 57388, 3 */
.................... 
.................... /* Morningstar, Tri-Star MPPT */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_SCALING                  320 /* 0, 4 */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_FILTERED_ADC             321 /* 24, 38 */
.................... 
.................... /* Advancetech, Adam 4xxx MODBUS */
.................... #define ADAM_4XXX_ANALOG_CURRENT                          400 /* 0, 8 */
.................... 
.................... /* smaller block definitions for SatCon PVS50 ... not implemented or seen in the wild. Do not use */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_SOFTWARE           500 /* 30009, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_ACTIVE_FAULTS      501 /* 30017, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_DC                 502 /* 30020, 4 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_CURRENT    503 /* 30035, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_VOLTAGE    504 /* 30040, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_POWER           505 /* 30043, 5 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_GROUND_IMPEDANCE   506 /* 30049, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT     507 /* 30050, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT_AVG 508 /* 30089, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH         509 /* 30090, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH_AVG     510 /* 30129, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_KWH                511 /* 30131, 8 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_TIMERS             512 /* 30275, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STATE              513 /* 30279, 2 */
.................... 
.................... /* SatCon PVS50 inverter. Manual has +30001 offset. */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_0      520 /* 9, 40 registers ... error, should be 41 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_1      521 /* 50, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_2      522 /* 90, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_3      523 /* 131, 8 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_4      524 /* 175, 2 registers ... not programmed at west point! */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_5      525 /* 275, 6 registers ... */
.................... 
.................... 
.................... /* PC&S Multitek MP850MPDV19PE CUSTOM 1 */
.................... /* Registers re-arranged to be consecutive, starting with reg 0 */
.................... /* Values are 32-bit Floating Point */
.................... /* Register list: */
.................... /* 0 - V 1 ... Voltage */
.................... /* 2 - I 1 ... Current */
.................... /* 4 - kW Sum */
.................... /* 6 - kWHr (Import) */
.................... /* 8 - kWd  (Import) ... Demand over last 3 minutes */
.................... /* 10 - Ad ... Demand current over last 3 minutes*/
.................... /* 12 - kWHr (Export) */
.................... /* 14 - A.h */
.................... /* 16 - Max kWd (Import) */
.................... /* 18 - Max Ad */
.................... 
.................... #define DEVICE_TYPE_WORLD_M850MPD_CUSTOM_1	 600 /* 0, 20 registers */
.................... 
.................... 
.................... #define DEVICE_TYPE_WORLD_SHUNTMONITOR_BASIC  700 /* 0, 32 registers */
.................... 
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_BASIC      800 /* 0, 39 registers */
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_CONFIG     801 /* 1000, 15 registers */
.................... 
.................... /* Midnite Solar Classic - based on 2011-05-21 specification */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_BASIC       900 /* 4113, 31 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_WIND_CURVE  901 /* 4300, 16 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_RESTING     902 /* 4274, 3  registers */
.................... 
.................... /* APRS World POE Monitor */
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_BASIC    1000 
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_CONFIG   1001
.................... 
.................... /* APRS World watchdog Arlo */
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_BASIC  1100
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_CONFIG 1101
.................... 
.................... /* China HUM temperature and relative humidity sensor */
.................... #define DEVICE_TYPE_WORLD_HUM_TEMPERATURE      1200
.................... #define DEVICE_TYPE_WORLD_HUM_RELATIVEHUMIDITY 1201
.................... 
.................... /* "Center" brand soundmeter */
.................... #define TYPE_TYPE_WORLD_SOUNDMETER_CENTER      1300
.................... 
.................... /* PS2Tap */
.................... #define DEVICE_TYPE_WORLD_PS2TAP_BASIC         1400 /* 0, 19 registers */
.................... 
.................... /* Veris E50 Series Power Meter */
.................... #define DEVICE_TYPE_WORLD_VERISE50_BASIC       1500 /* 256, 54 registers */
.................... 
.................... 
.................... /* Note: List not complete.  Reference master list in WorldDataCollector. */
.................... 
.................... 
.................... /* generic rsdata */
.................... #define DEVICE_TYPE_WORLD_RSDATA               32000 /* Integer */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT         32001 /* IEEE-754 single precision floating point (32-bit) data */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT_LITTLE  32002 
.................... 
.................... 
.................... typedef struct {
.................... 	int8  type;           /* device query type */
.................... 	int16 typeWorld;      /* see worldDeviceTypes.h for defines */
.................... 	int8  transmitEvery;
.................... 	int8  networkAddress; /* modbus or I2C address */
.................... 	int32 serialNumber;   /* APRS World or other serial number */
.................... 	int16 startRegister;
.................... 	int8  nRegisters;
.................... 	int8  serialSpeed;    /* see rsTap.h for defines */
.................... } struct_device;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  now_poll;
.................... 	int8  world_timeout;
.................... 	int8  factory_unlocked;
.................... 	int8  led_on_green;
.................... 	int16 sbd_cycle;
.................... } struct_timer;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  rException;
.................... 	int8  rResult[256];
.................... 	int8  rResultLength;
.................... 	int8  deviceNumber;
.................... 	int16 measurementNumber;
.................... } struct_qbuff;
.................... 
.................... typedef struct {
.................... 	int8 buff[256];
.................... 	int8 buff_pos;
.................... 	int8 buff_ready;
.................... 
.................... 	int8  packet_length;
.................... 	int32 query_id;
.................... 	int32 device_serial;
.................... 	int16 network_address;
.................... 	int16 function;
.................... 	int16 start_address;
.................... 	int8  n_words;
.................... 	int8  data_start_offset;
.................... 	int16 crc;
.................... 
.................... 	int8  resultException;
.................... 	int8  resultLength;
.................... } struct_query;
.................... 
.................... typedef struct {
.................... 	int8  serial_prefix;
.................... 	int16 serial_number;
.................... 	
.................... 	int16 live_interval;
.................... 
.................... 	/* Iridium SBD or other limited bandwidth transmission */
.................... 	/* 0 is no SBD, 1...5 is SBD modem with power switch on CONTROL pin 1...5 */
.................... 	int8  sbd_config;
.................... 
.................... 	/*	
.................... 	every n'th live transmission we transmit the SBD data
.................... 	Interval should be at least 10 minutes to allow for full retry cycle	
.................... 	on cycle before transmit, we clear previous buffer and turn on modem 
.................... 	*/
.................... 	int16 sbd_every;
.................... 
.................... } struct_config;
.................... 
.................... /* global structures */
.................... struct_device device[DEV_MAX_N];
.................... struct_timer  timers;
.................... struct_qbuff  qbuff;
.................... struct_query  query;
.................... struct_config config;
.................... 
.................... #include "i2c_access_rdTap.c"
.................... int16 i2c_register_read16(int8 i2c_address, int8 regaddr) {
.................... 	int8 msb, lsb;
.................... 
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address);
.................... 	i2c_write(regaddr);
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address | 1);  // read cycle
.................... 	msb=i2c_read(1);
.................... 	lsb=i2c_read(0);                                
.................... 	i2c_stop();
.................... 
.................... 	return make16(msb,lsb);
.................... }
.................... 
.................... void i2c_buff_read(int8 i2c_address, int8 regaddr, int8 *data, int8 count) {
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
*
1C92:  BSF    FC5.0
1C94:  BTFSC  FC5.0
1C96:  BRA    1C94
.................... 	delay_us(15);
1C98:  CLRWDT
1C9A:  MOVLW  09
1C9C:  MOVWF  00
1C9E:  DECFSZ 00,F
1CA0:  BRA    1C9E
1CA2:  NOP   
.................... 	i2c_write(i2c_address);
1CA4:  MOVFF  982,98D
1CA8:  CALL   05C2
.................... 	i2c_write(regaddr);
1CAC:  MOVFF  983,98D
1CB0:  CALL   05C2
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
1CB4:  BSF    FC5.1
1CB6:  BTFSC  FC5.1
1CB8:  BRA    1CB6
.................... 	delay_us(15);
1CBA:  CLRWDT
1CBC:  MOVLW  09
1CBE:  MOVWF  00
1CC0:  DECFSZ 00,F
1CC2:  BRA    1CC0
1CC4:  NOP   
.................... 	i2c_write(i2c_address | 1);  // read cycle
1CC6:  MOVLB  9
1CC8:  MOVF   x82,W
1CCA:  IORLW  01
1CCC:  MOVWF  x87
1CCE:  MOVWF  x8D
1CD0:  MOVLB  0
1CD2:  CALL   05C2
.................... 
.................... 	/* stop reading before last byte */	
.................... 	while ( count-- != 1 ) {
1CD6:  MOVLB  9
1CD8:  MOVF   x86,W
1CDA:  DECF   x86,F
1CDC:  SUBLW  01
1CDE:  BZ    1D00
.................... 		*data=i2c_read(1);
1CE0:  MOVFF  985,FEA
1CE4:  MOVFF  984,FE9
1CE8:  MOVLW  01
1CEA:  MOVWF  00
1CEC:  MOVLB  0
1CEE:  CALL   0DC6
1CF2:  MOVFF  01,FEF
.................... 		data++;
1CF6:  MOVLB  9
1CF8:  INCF   x84,F
1CFA:  BTFSC  FD8.2
1CFC:  INCF   x85,F
1CFE:  BRA    1CD8
.................... 	}
.................... 
.................... 	/* send last byte with a NAK */
.................... 	*data=i2c_read(0);                                
1D00:  MOVFF  985,FEA
1D04:  MOVFF  984,FE9
1D08:  CLRF   00
1D0A:  MOVLB  0
1D0C:  CALL   0DC6
1D10:  MOVFF  01,FEF
.................... 	i2c_stop();
1D14:  BSF    FC5.2
1D16:  BTFSC  FC5.2
1D18:  BRA    1D16
1D1A:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void i2c_register_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start();
*
3078:  BSF    FC5.0
307A:  BTFSC  FC5.0
307C:  BRA    307A
.................... 	delay_us(15);                                                 
307E:  CLRWDT
3080:  MOVLW  09
3082:  MOVWF  00
3084:  DECFSZ 00,F
3086:  BRA    3084
3088:  NOP   
.................... 	i2c_write(i2c_address); // write cycle                       
308A:  MOVFF  988,98D
308E:  CALL   05C2
.................... 	i2c_write(regaddr);  // write cycle         
3092:  MOVFF  989,98D
3096:  CALL   05C2
.................... 	i2c_write(make8(value,1));
309A:  MOVFF  98B,98D
309E:  CALL   05C2
.................... 	i2c_write(make8(value,0));
30A2:  MOVFF  98A,98D
30A6:  CALL   05C2
.................... 	i2c_stop();
30AA:  BSF    FC5.2
30AC:  BTFSC  FC5.2
30AE:  BRA    30AC
30B0:  GOTO   33C4 (RETURN)
.................... }
.................... 
.................... void i2c_register_write32(int8 i2c_address, int8 regaddr, int32 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle     
.................... 	i2c_write(make8(value,3));
.................... 	i2c_write(make8(value,2));    
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... #include "mcp3208_rdTap.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
.................... 	output_high(CS_ADC0);
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
.................... 	output_high(MCP3208_DIN);
.................... 
.................... 
.................... 	if ( ch<8 ) {
.................... 		output_low(CS_ADC0);
.................... 	} else {
.................... 		output_low(CS_ADC1);
.................... 		ch-=8;
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
.................... 		c=0b00011;
.................... 	else if ( 1 == ch ) 
.................... 		c=0b10011;
.................... 	else if ( 2 == ch ) 
.................... 		c=0b01011;
.................... 	else if ( 3 == ch ) 
.................... 		c=0b11011;
.................... 	else if ( 4 == ch )
.................... 		c=0b00111;
.................... 	else if ( 5 == ch ) 
.................... 		c=0b10111;
.................... 	else if ( 6 == ch )
.................... 		c=0b01111;
.................... 	else
.................... 		c=0b11111;
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		output_bit(MCP3208_DIN,c&1);
.................... 		c=c>>1;
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 
.................... 	value=0;
.................... 	for ( i=0 ; i<14 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 	bit_clear(value,13);
.................... 	bit_clear(value,12);
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
.................... 
.................... 	return value;
.................... }
.................... 
.................... #include "uart_sc16is740_rdTap.c"
.................... /* register map for SC16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
*
0DE2:  BSF    FC5.0
0DE4:  BTFSC  FC5.0
0DE6:  BRA    0DE4
.................... 	delay_us(15);
0DE8:  CLRWDT
0DEA:  MOVLW  09
0DEC:  MOVWF  00
0DEE:  DECFSZ 00,F
0DF0:  BRA    0DEE
0DF2:  NOP   
.................... 	i2c_write(UART_ADDR);
0DF4:  MOVLW  9A
0DF6:  MOVLB  9
0DF8:  MOVWF  x8D
0DFA:  MOVLB  0
0DFC:  CALL   05C2
.................... 	i2c_write(regaddr<<3);
0E00:  MOVLB  9
0E02:  RLCF   x7B,W
0E04:  MOVWF  x7D
0E06:  RLCF   x7D,F
0E08:  RLCF   x7D,F
0E0A:  MOVLW  F8
0E0C:  ANDWF  x7D,F
0E0E:  MOVFF  97D,98D
0E12:  MOVLB  0
0E14:  CALL   05C2
.................... 	i2c_start();
0E18:  BSF    FC5.1
0E1A:  BTFSC  FC5.1
0E1C:  BRA    0E1A
.................... 	delay_us(15);
0E1E:  CLRWDT
0E20:  MOVLW  09
0E22:  MOVWF  00
0E24:  DECFSZ 00,F
0E26:  BRA    0E24
0E28:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
0E2A:  MOVLW  9B
0E2C:  MOVLB  9
0E2E:  MOVWF  x8D
0E30:  MOVLB  0
0E32:  CALL   05C2
.................... 	data=i2c_read(0);
0E36:  CLRF   00
0E38:  RCALL  0DC6
0E3A:  MOVFF  01,97C
.................... 	i2c_stop();
0E3E:  BSF    FC5.2
0E40:  BTFSC  FC5.2
0E42:  BRA    0E40
.................... 
.................... 	return data;
0E44:  MOVLB  9
0E46:  MOVFF  97C,01
0E4A:  MOVLB  0
0E4C:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
05DE:  BSF    FC5.0
05E0:  BTFSC  FC5.0
05E2:  BRA    05E0
.................... 	delay_us(15);                                                 
05E4:  CLRWDT
05E6:  MOVLW  09
05E8:  MOVWF  00
05EA:  DECFSZ 00,F
05EC:  BRA    05EA
05EE:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
05F0:  MOVLW  9A
05F2:  MOVLB  9
05F4:  MOVWF  x8D
05F6:  MOVLB  0
05F8:  RCALL  05C2
.................... 	i2c_write(regaddr<< 3);  // write cycle         
05FA:  MOVLB  9
05FC:  RLCF   x88,W
05FE:  MOVWF  x8A
0600:  RLCF   x8A,F
0602:  RLCF   x8A,F
0604:  MOVLW  F8
0606:  ANDWF  x8A,F
0608:  MOVFF  98A,98D
060C:  MOVLB  0
060E:  RCALL  05C2
.................... 	i2c_write(data);
0610:  MOVFF  989,98D
0614:  RCALL  05C2
.................... 	i2c_stop();
0616:  BSF    FC5.2
0618:  BTFSC  FC5.2
061A:  BRA    0618
061C:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
0F14:  MOVLB  9
0F16:  CLRF   x88
0F18:  MOVFF  987,989
0F1C:  MOVLB  0
0F1E:  CALL   05DE
0F22:  RETURN 0
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
0E4E:  MOVLW  05
0E50:  MOVLB  9
0E52:  MOVWF  x7B
0E54:  MOVLB  0
0E56:  RCALL  0DE2
0E58:  MOVF   01,W
0E5A:  ANDLW  01
0E5C:  MOVWF  01
0E5E:  RETURN 0
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
0E60:  MOVLB  9
0E62:  CLRF   x7B
0E64:  MOVLB  0
0E66:  RCALL  0DE2
0E68:  MOVF   01,W
*
1040:  MOVLB  9
1042:  CLRF   x7B
1044:  MOVLB  0
1046:  RCALL  0DE2
1048:  MOVF   01,W
*
1068:  MOVLB  9
106A:  CLRF   x7B
106C:  MOVLB  0
106E:  RCALL  0DE2
1070:  MOVF   01,W
*
10B2:  MOVLB  9
10B4:  CLRF   x7B
10B6:  MOVLB  0
10B8:  RCALL  0DE2
10BA:  MOVF   01,W
*
110E:  MOVLB  9
1110:  CLRF   x7B
1112:  MOVLB  0
1114:  RCALL  0DE2
1116:  MOVF   01,W
*
1136:  MOVLB  9
1138:  CLRF   x7B
113A:  MOVLB  0
113C:  RCALL  0DE2
113E:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
061E:  MOVLW  03
0620:  MOVLB  9
0622:  MOVWF  x88
0624:  MOVLW  80
0626:  MOVWF  x89
0628:  MOVLB  0
062A:  RCALL  05DE
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
062C:  MOVLB  9
062E:  CLRF   x88
0630:  MOVFF  97A,989
0634:  MOVLB  0
0636:  RCALL  05DE
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
0638:  MOVLW  01
063A:  MOVLB  9
063C:  MOVWF  x88
063E:  CLRF   x89
0640:  MOVLB  0
0642:  RCALL  05DE
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
0644:  MOVLW  03
0646:  MOVLB  9
0648:  MOVWF  x88
064A:  MOVLW  BF
064C:  MOVWF  x89
064E:  MOVLB  0
0650:  RCALL  05DE
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
0652:  MOVLW  02
0654:  MOVLB  9
0656:  MOVWF  x88
0658:  MOVLW  10
065A:  MOVWF  x89
065C:  MOVLB  0
065E:  RCALL  05DE
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
0660:  MOVLW  03
0662:  MOVLB  9
0664:  MOVWF  x88
0666:  MOVWF  x89
0668:  MOVLB  0
066A:  RCALL  05DE
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
066C:  MOVLW  01
066E:  MOVLB  9
0670:  MOVWF  x88
0672:  CLRF   x89
0674:  MOVLB  0
0676:  RCALL  05DE
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
0678:  MOVLW  02
067A:  MOVLB  9
067C:  MOVWF  x88
067E:  MOVLW  07
0680:  MOVWF  x89
0682:  MOVLB  0
0684:  RCALL  05DE
0686:  GOTO   071E (RETURN)
.................... }
.................... 
.................... 
.................... #include "param_rdTap.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0762:  MOVF   x98,W
0764:  XORWF  x99,W
0766:  MOVWF  01
*
09DE:  MOVF   x98,W
09E0:  XORWF  x99,W
09E2:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
0972:  MOVLB  9
0974:  CLRF   x83
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0976:  MOVFF  982,985
097A:  MOVF   x81,W
097C:  BTFSC  FD8.2
097E:  DECF   x82,F
0980:  DECF   x81,F
0982:  MOVWF  x84
0984:  MOVF   x84,F
0986:  BNZ   098C
0988:  MOVF   x85,F
098A:  BZ    09F0
.................... 		*data = read_eeprom( address++ );
098C:  MOVFF  980,03
0990:  MOVF   x7F,W
0992:  MOVWF  FE9
0994:  MOVFF  03,FEA
0998:  MOVF   x7E,W
099A:  MOVWF  03
099C:  MOVF   x7D,W
099E:  INCF   x7D,F
09A0:  BTFSC  FD8.2
09A2:  INCF   x7E,F
09A4:  MOVWF  x86
09A6:  MOVFF  03,987
09AA:  MOVFF  FF2,988
09AE:  BCF    FF2.7
09B0:  MOVFF  987,F75
09B4:  MOVFF  986,F74
09B8:  BCF    F7F.6
09BA:  BCF    F7F.7
09BC:  BSF    F7F.0
09BE:  MOVF   F73,W
09C0:  BTFSC  x88.7
09C2:  BSF    FF2.7
09C4:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
09C6:  MOVFF  980,03
09CA:  MOVF   x7F,W
09CC:  MOVWF  FE9
09CE:  MOVFF  03,FEA
09D2:  MOVFF  FEF,984
09D6:  MOVFF  983,998
09DA:  MOVFF  984,999
*
09E4:  MOVFF  01,983
.................... 		data++;
09E8:  INCF   x7F,F
09EA:  BTFSC  FD8.2
09EC:  INCF   x80,F
09EE:  BRA    0976
.................... 	}
.................... 	return crc;
09F0:  MOVFF  983,01
09F4:  MOVLB  0
09F6:  RETURN 0
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
*
072E:  MOVLB  9
0730:  CLRF   x96
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0732:  MOVFF  995,998
0736:  MOVF   x94,W
0738:  BTFSC  FD8.2
073A:  DECF   x95,F
073C:  DECF   x94,F
073E:  MOVWF  x97
0740:  MOVF   x97,F
0742:  BNZ   0748
0744:  MOVF   x98,F
0746:  BZ    07C6
.................... 		restart_wdt();
0748:  CLRWDT
.................... 		crc = xor_crc(crc,*data);
074A:  MOVFF  993,03
074E:  MOVF   x92,W
0750:  MOVWF  FE9
0752:  MOVFF  03,FEA
0756:  MOVFF  FEF,997
075A:  MOVFF  996,998
075E:  MOVFF  997,999
*
0768:  MOVFF  01,996
.................... 		write_eeprom( address++, *data++ );
076C:  MOVF   x91,W
076E:  MOVWF  03
0770:  MOVF   x90,W
0772:  INCF   x90,F
0774:  BTFSC  FD8.2
0776:  INCF   x91,F
0778:  MOVWF  x97
077A:  MOVFF  03,998
077E:  MOVF   x93,W
0780:  MOVWF  03
0782:  MOVF   x92,W
0784:  INCF   x92,F
0786:  BTFSC  FD8.2
0788:  INCF   x93,F
078A:  MOVWF  FE9
078C:  MOVFF  03,FEA
0790:  MOVFF  FEF,999
0794:  MOVF   FF2,W
0796:  MOVWF  00
0798:  BCF    FF2.7
079A:  MOVFF  998,F75
079E:  MOVFF  997,F74
07A2:  MOVFF  999,F73
07A6:  BCF    F7F.6
07A8:  BCF    F7F.7
07AA:  BSF    F7F.2
07AC:  MOVLB  F
07AE:  MOVLW  55
07B0:  MOVWF  F7E
07B2:  MOVLW  AA
07B4:  MOVWF  F7E
07B6:  BSF    F7F.1
07B8:  BTFSC  F7F.1
07BA:  BRA    07B8
07BC:  BCF    F7F.2
07BE:  MOVF   00,W
07C0:  IORWF  FF2,F
07C2:  MOVLB  9
07C4:  BRA    0732
.................... 	}
.................... 
.................... 	return crc;
07C6:  MOVFF  996,01
07CA:  MOVLB  0
07CC:  RETURN 0
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
07CE:  MOVLW  05
07D0:  MOVLB  9
07D2:  MOVWF  x8E
07D4:  MOVLW  83
07D6:  MOVWF  x8D
07D8:  CLRF   x91
07DA:  MOVLW  04
07DC:  MOVWF  x90
07DE:  MOVFF  98E,993
07E2:  MOVFF  98D,992
07E6:  CLRF   x95
07E8:  MOVLW  08
07EA:  MOVWF  x94
07EC:  MOVLB  0
07EE:  RCALL  072E
07F0:  MOVFF  01,98C
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
07F4:  MOVF   FF2,W
07F6:  MOVWF  00
07F8:  BCF    FF2.7
07FA:  CLRF   F75
07FC:  CLRF   F74
07FE:  MOVFF  98C,F73
0802:  BCF    F7F.6
0804:  BCF    F7F.7
0806:  BSF    F7F.2
0808:  MOVLB  F
080A:  MOVLW  55
080C:  MOVWF  F7E
080E:  MOVLW  AA
0810:  MOVWF  F7E
0812:  BSF    F7F.1
0814:  BTFSC  F7F.1
0816:  BRA    0814
0818:  BCF    F7F.2
081A:  MOVF   00,W
081C:  IORWF  FF2,F
081E:  MOVLB  0
0820:  RETURN 0
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0822:  MOVLW  96
0824:  MOVLB  3
0826:  MOVWF  x64
.................... //	fprintf(world,"# writing default parameters\r\n");
.................... 
.................... 	config.serial_prefix='A';
0828:  MOVLW  41
082A:  MOVLB  5
082C:  MOVWF  x83
.................... 	config.serial_number=4820;
082E:  MOVLW  12
0830:  MOVWF  x85
0832:  MOVLW  D4
0834:  MOVWF  x84
.................... 		/* 
.................... 			A4797 Fairway UAF (SBD in slot 5 closest to power connector)
.................... 			A4800 Fairway UVic (SBD in slot 1)
.................... 			A4810 Uvic Spare Fairway panel (SBD in slot 1)
.................... 			A4820 JJJ Bench (SBD in slot 1)
.................... 		*/
.................... 
.................... 	/* data to internet on STREAM_WORLD port */
.................... 	config.live_interval=10; 
0836:  CLRF   x87
0838:  MOVLW  0A
083A:  MOVWF  x86
.................... 
.................... 	/* Iridium SBD requires dcswc_module_rockblock which provides an I2C UART */
.................... 	config.sbd_config=1;   /* physical slot for module. Used for power control */
083C:  MOVLW  01
083E:  MOVWF  x88
.................... 	config.sbd_every=90; /* send SBD message every this number of live_interval */
0840:  CLRF   x8A
0842:  MOVLW  5A
0844:  MOVWF  x89
....................                            /* with 10 second live interval, 4320 => SBD every 12 hours */
....................                            /* with 10 second live interval, 1080 => SBD every 3 hours */			
....................                            /* with 10 second live interval, 90 => SBD every 15 minutes */
.................... 				
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0846:  MOVLB  0
0848:  RCALL  07CE
084A:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS,(void *)&config, sizeof(config)); 
*
09F8:  MOVLW  05
09FA:  MOVLB  9
09FC:  MOVWF  x7C
09FE:  MOVLW  83
0A00:  MOVWF  x7B
0A02:  CLRF   x7E
0A04:  MOVLW  04
0A06:  MOVWF  x7D
0A08:  MOVFF  97C,980
0A0C:  MOVFF  97B,97F
0A10:  CLRF   x82
0A12:  MOVLW  08
0A14:  MOVWF  x81
0A16:  MOVLB  0
0A18:  RCALL  0972
0A1A:  MOVFF  01,97A
.................... 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
0A1E:  MOVFF  FF2,97B
0A22:  BCF    FF2.7
0A24:  CLRF   F75
0A26:  CLRF   F74
0A28:  BCF    F7F.6
0A2A:  BCF    F7F.7
0A2C:  BSF    F7F.0
0A2E:  MOVF   F73,W
0A30:  MOVLB  9
0A32:  BTFSC  x7B.7
0A34:  BSF    FF2.7
0A36:  SUBWF  x7A,W
0A38:  BZ    0A40
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_param_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_param_file();
0A3A:  MOVLB  0
0A3C:  RCALL  0822
0A3E:  MOVLB  9
.................... 	}
0A40:  MOVLB  0
0A42:  GOTO   370E (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "paramDevice_rdTap.c"
.................... void write_device_file() {
.................... 	int8 crc;
.................... 
.................... 
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(DEVICE_ADDRESS,(void *)&device,sizeof(device));
*
086E:  MOVLB  9
0870:  MOVLW  21
0872:  MOVWF  x8E
0874:  CLRF   x91
0876:  MOVLW  80
0878:  MOVWF  x90
087A:  CLRF   x93
087C:  MOVFF  98E,992
0880:  MOVLW  03
0882:  MOVWF  x95
0884:  MOVLW  40
0886:  MOVWF  x94
0888:  MOVLB  0
088A:  RCALL  072E
088C:  MOVFF  01,98D
.................... 	/* write the CRC that was calculated on the structure */
.................... 	write_eeprom(DEVICE_CRC_ADDRESS,crc);
0890:  MOVF   FF2,W
0892:  MOVWF  00
0894:  BCF    FF2.7
0896:  CLRF   F75
0898:  MOVLW  02
089A:  MOVWF  F74
089C:  MOVFF  98D,F73
08A0:  BCF    F7F.6
08A2:  BCF    F7F.7
08A4:  BSF    F7F.2
08A6:  MOVLB  F
08A8:  MOVLW  55
08AA:  MOVWF  F7E
08AC:  MOVLW  AA
08AE:  MOVWF  F7E
08B0:  BSF    F7F.1
08B2:  BTFSC  F7F.1
08B4:  BRA    08B2
08B6:  BCF    F7F.2
08B8:  MOVF   00,W
08BA:  IORWF  FF2,F
08BC:  MOVLB  0
08BE:  RETURN 0
.................... 
.................... //	fprintf(STREAM_WORLD,"# write_device_file crc=%u\r\n",crc);
.................... }
.................... 
.................... /* load device configuration from program memory */
.................... void write_default_device_file(void) {
.................... 	int8 i;
.................... 
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
08C0:  MOVLW  96
08C2:  MOVLB  3
08C4:  MOVWF  x64
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# disabling all devices\r\n");
.................... #endif
.................... 
.................... 	/* disable all devices */
.................... 	for ( i=0 ; i<DEV_MAX_N ; i++ ) {
08C6:  MOVLB  9
08C8:  CLRF   x8C
08CA:  MOVF   x8C,W
08CC:  SUBLW  3F
08CE:  BNC   08F4
.................... 		device[i].type=DEV_TYPE_DISABLED;	
08D0:  CLRF   x95
08D2:  MOVFF  98C,994
08D6:  CLRF   x97
08D8:  MOVLW  0D
08DA:  MOVWF  x96
08DC:  MOVLB  0
08DE:  RCALL  084C
08E0:  MOVLW  21
08E2:  MOVLB  9
08E4:  ADDWF  01,W
08E6:  MOVWF  FE9
08E8:  MOVLW  00
08EA:  ADDWFC 02,W
08EC:  MOVWF  FEA
08EE:  CLRF   FEF
.................... 	}
.................... 
.................... #if 0
.................... 	/* UAF Fairway */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4790; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4791; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4792; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Fairway on A4800 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4806; /*  4264646 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4808; /* 4264648 */
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4807; /* 4264647 */ 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Spare Panel on A4810 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4801; /* 4264641 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4802; /* 4264642 */ 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38; 
.................... 	device[2].serialNumber=('A'<<16) + 4803; /* 4264643 */
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 1
08F0:  INCF   x8C,F
08F2:  BRA    08CA
.................... 	/* JJJ Test board on A4820 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
08F4:  MOVLW  10
08F6:  MOVWF  21
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
08F8:  MOVLW  7D
08FA:  MOVWF  23
08FC:  CLRF   22
.................... 	device[0].transmitEvery=1;
08FE:  MOVLW  01
0900:  MOVWF  24
.................... 	device[0].networkAddress=0x3e;
0902:  MOVLW  3E
0904:  MOVWF  25
.................... 	device[0].serialNumber=('A'<<16) + 4821; 
0906:  CLRF   29
0908:  MOVLW  41
090A:  MOVWF  28
090C:  MOVLW  12
090E:  MOVWF  27
0910:  MOVLW  D5
0912:  MOVWF  26
.................... 	device[0].startRegister=0;
0914:  CLRF   2B
0916:  CLRF   2A
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
0918:  MOVLW  06
091A:  MOVWF  2C
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
091C:  MOVLW  10
091E:  MOVWF  2E
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0920:  MOVLW  7D
0922:  MOVWF  30
0924:  CLRF   2F
.................... 	device[1].transmitEvery=1;
0926:  MOVLW  01
0928:  MOVWF  31
.................... 	device[1].networkAddress=0x36;
092A:  MOVLW  36
092C:  MOVWF  32
.................... 	device[1].serialNumber=('A'<<16) + 4822; 
092E:  CLRF   36
0930:  MOVLW  41
0932:  MOVWF  35
0934:  MOVLW  12
0936:  MOVWF  34
0938:  MOVLW  D6
093A:  MOVWF  33
.................... 	device[1].startRegister=0;
093C:  CLRF   38
093E:  CLRF   37
.................... 	device[1].nRegisters=32;
0940:  MOVLW  20
0942:  MOVWF  39
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
0944:  MOVLW  10
0946:  MOVWF  3B
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0948:  MOVLW  7D
094A:  MOVWF  3D
094C:  CLRF   3C
.................... 	device[2].transmitEvery=1;
094E:  MOVLW  01
0950:  MOVWF  3E
.................... 	device[2].networkAddress=0x38;
0952:  MOVLW  38
0954:  MOVWF  3F
.................... 	device[2].serialNumber=('A'<<16) + 4823; 
0956:  CLRF   43
0958:  MOVLW  41
095A:  MOVWF  42
095C:  MOVLW  12
095E:  MOVWF  41
0960:  MOVLW  D7
0962:  MOVWF  40
.................... 	device[2].startRegister=0;
0964:  CLRF   45
0966:  CLRF   44
.................... 	device[2].nRegisters=32;
0968:  MOVLW  20
096A:  MOVWF  46
.................... #endif
.................... 
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# write_device_file()\r\n");
.................... #endif
.................... 
.................... 	write_device_file();
096C:  MOVLB  0
096E:  RCALL  086E
0970:  RETURN 0
.................... }
.................... 
.................... void read_device_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(DEVICE_ADDRESS,(void *)&device, sizeof(device)); 
*
0A46:  MOVLB  9
0A48:  MOVLW  21
0A4A:  MOVWF  x7B
0A4C:  CLRF   x7E
0A4E:  MOVLW  80
0A50:  MOVWF  x7D
0A52:  CLRF   x80
0A54:  MOVFF  97B,97F
0A58:  MOVLW  03
0A5A:  MOVWF  x82
0A5C:  MOVLW  40
0A5E:  MOVWF  x81
0A60:  MOVLB  0
0A62:  RCALL  0972
0A64:  MOVFF  01,97A
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# read_device_file crc=%u\r\n",crc);
.................... #endif
.................... 
.................... 	if ( crc != read_eeprom(DEVICE_CRC_ADDRESS) ) {
0A68:  MOVFF  FF2,97B
0A6C:  BCF    FF2.7
0A6E:  CLRF   F75
0A70:  MOVLW  02
0A72:  MOVWF  F74
0A74:  BCF    F7F.6
0A76:  BCF    F7F.7
0A78:  BSF    F7F.0
0A7A:  MOVF   F73,W
0A7C:  MOVLB  9
0A7E:  BTFSC  x7B.7
0A80:  BSF    FF2.7
0A82:  SUBWF  x7A,W
0A84:  BZ    0A8C
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_device_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_device_file();
0A86:  MOVLB  0
0A88:  RCALL  08C0
0A8A:  MOVLB  9
.................... 	}
0A8C:  MOVLB  0
0A8E:  GOTO   3712 (RETURN)
.................... }
.................... 
.................... void devicesDump(void) {
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... 
.................... 	fprintf(STREAM_WORLD,"# dumping all enabled devices:\r\n");
.................... 	for ( i=0 ; i<16 ; i++ ) {
.................... 		restart_wdt();
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[i].type ) 
.................... 			continue;
.................... 
.................... 		fprintf(STREAM_WORLD,"device[%u]\r\n",i);
.................... 		fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[i].type);
.................... 		fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[i].transmitEvery);
.................... 		fprintf(STREAM_WORLD,"\tnetworkAddress=%u\r\n",device[i].networkAddress);
.................... 		fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 			make8(device[i].serialNumber,3),
.................... 			make8(device[i].serialNumber,2),
.................... 			make8(device[i].serialNumber,1),
.................... 			make8(device[i].serialNumber,0)
.................... 		);
.................... 		fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[i].startRegister);
.................... 		fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[i].nRegisters);
.................... 	}
.................... 	fprintf(STREAM_WORLD,"# done\r\n");
.................... #endif
.................... }
.................... 
.................... #include "modbus_int_uart_rdTap.c"
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //// MASTER API:                                                                      ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /*Some defines so we can use identifiers to set things up*/
.................... #define MODBUS_TYPE_MASTER 99999
.................... #define MODBUS_TYPE_SLAVE 88888
.................... #define MODBUS_INT_RDA 77777
.................... #define MODBUS_INT_RDA2 66666
.................... #define MODBUS_INT_EXT 55555
.................... 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER
.................... 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA  // Select between external interrupt
.................... #define MODBUS_SERIAL_BAUD 9600
.................... #define MODBUS_SERIAL_RX_PIN       NET_RX   // Data receive pin
.................... #define MODBUS_SERIAL_TX_PIN       NET_TX   // Data transmit pin
.................... #define MODBUS_SERIAL_ENABLE_PIN   RS485_DE   // Controls DE pin.  RX low, TX high.
.................... #define MODBUS_SERIAL_RX_ENABLE    RS485_NOT_RE   // Controls RE pin.  Should keep low.
.................... #define MODBUS_SERIAL_TIMEOUT      100000     //in us
.................... 
.................... 
.................... #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, parity=N, stream=MODBUS_SERIAL, errors)
*
0336:  BTFSS  F9E.5
0338:  BRA    0336
033A:  MOVFF  FAB,20
033E:  MOVFF  FAE,01
0342:  BTFSS  20.1
0344:  BRA    034A
0346:  BCF    FAB.4
0348:  BSF    FAB.4
034A:  RETURN 0
*
174C:  BTFSS  F9E.4
174E:  BRA    174C
1750:  MOVWF  FAD
1752:  GOTO   175E (RETURN)
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);}
.................... 
.................... 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer
.................... 
.................... 
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
.................... 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................     if(address)\
....................     {\
....................         while(!modbus_kbhit() && --modbus_serial_wait)\
....................             delay_us(1);\
....................         if(!modbus_serial_wait)\
....................             modbus_rx.error=TIMEOUT;\
....................     }\
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... //#byte TXSTA=getenv("sfr:TXSTA")
.................... #byte TXSTA=0xfad
.................... #bit TRMT=TXSTA.1
.................... 
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }   
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    int8 b[2];
....................    int16 d;
.................... } modbus_serial_crc;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void rcv_on(void) {
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
.................... 	while(kbhit(MODBUS_SERIAL)) {
*
0A92:  BTFSS  F9E.5
0A94:  BRA    0A9A
.................... 		fgetc(MODBUS_SERIAL);
0A96:  RCALL  0336
0A98:  BRA    0A92
.................... 	}  
.................... 	
.................... 	clear_interrupt(INT_RDA);
0A9A:  MOVF   FAE,W
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE);
.................... 	output_low(RS485_DE);
0A9C:  BCF    F94.5
0A9E:  BCF    F8B.5
.................... 	enable_interrupts(INT_RDA);
0AA0:  BSF    F9D.5
0AA2:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init()
.................... {
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
0AA4:  BCF    F94.5
0AA6:  BCF    F8B.5
.................... 
....................    RCV_ON();
0AA8:  RCALL  0A92
.................... 
.................... //   setup_timer_2(T2_DIV_BY_16,249,5);   //10ms interrupts
....................    setup_timer_2(T2_DIV_BY_16,249,10);   //20ms interrupts
0AAA:  MOVLW  48
0AAC:  IORLW  06
0AAE:  MOVWF  FCA
0AB0:  MOVLW  F9
0AB2:  MOVWF  FCB
.................... 
....................    enable_interrupts(GLOBAL);
0AB4:  MOVLW  C0
0AB6:  IORWF  FF2,F
0AB8:  GOTO   3718 (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... void modbus_enable_timeout(int1 enable)
.................... {
....................    disable_interrupts(INT_TIMER2);
*
02F2:  BCF    F9D.1
....................    if (enable) {
02F4:  MOVLB  9
02F6:  MOVF   x9C,F
02F8:  BZ    0300
....................       set_timer2(0);
02FA:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2);
02FC:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2);
02FE:  BSF    F9D.1
....................    }
0300:  MOVLB  0
0302:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... #int_timer2
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
0304:  MOVLB  5
0306:  MOVF   x90,W
0308:  SUBLW  02
030A:  BNZ   0320
030C:  MOVF   x91,F
030E:  BNZ   0320
0310:  MOVF   x92,F
0312:  BNZ   0320
0314:  BTFSC  x8F.0
0316:  BRA    0320
....................    {
....................       modbus_rx.len-=2;
0318:  MOVLW  02
031A:  SUBWF  x94,F
....................       modbus_serial_new=TRUE;
031C:  BSF    x8F.0
....................    }
031E:  BRA    0322
....................    else
....................       modbus_serial_new=FALSE;
0320:  BCF    x8F.0
.................... 
....................    modbus_serial_crc.d=0xFFFF;
0322:  SETF   x92
0324:  SETF   x91
....................    modbus_serial_state=MODBUS_GETADDY;
0326:  CLRF   x90
....................    modbus_enable_timeout(FALSE);
0328:  MOVLB  9
032A:  CLRF   x9C
032C:  MOVLB  0
032E:  RCALL  02F2
0330:  BCF    F9E.1
0332:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................   int8 uIndex ; // will index into CRC lookup table
.................... 
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
034C:  MOVLB  5
034E:  MOVF   x92,W
0350:  MOVLB  9
0352:  XORWF  x9C,W
0354:  MOVWF  x9D
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
0356:  CLRF   03
0358:  MOVF   x9D,W
035A:  MOVLB  0
035C:  RCALL  00D2
035E:  MOVWF  01
0360:  MOVLB  5
0362:  MOVF   x91,W
0364:  XORWF  01,W
0366:  MOVWF  x92
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0368:  CLRF   03
036A:  MOVLB  9
036C:  MOVF   x9D,W
036E:  MOVLB  0
0370:  RCALL  01E2
0372:  MOVFF  FE8,591
0376:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c)
.................... {
....................    fputc(c, MODBUS_SERIAL);
*
1756:  MOVLB  9
1758:  MOVF   x90,W
175A:  MOVLB  0
175C:  BRA    174C
175E:  CLRF   19
1760:  BTFSC  FF2.7
1762:  BSF    19.7
1764:  BCF    FF2.7
....................    modbus_calc_crc(c);
1766:  MOVFF  990,99C
176A:  CALL   034C
176E:  BTFSC  19.7
1770:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
1772:  CLRWDT
1774:  MOVLW  44
1776:  MOVWF  00
1778:  DECFSZ 00,F
177A:  BRA    1778
177C:  BRA    177E
177E:  RETURN 0
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
.................... #int_rda
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
.................... #int_rda2
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT)
.................... #int_ext
.................... #else
.................... #error Please define a correct interrupt source
.................... #endif
.................... void incomming_modbus_serial() {
....................    char c;
.................... 
....................    c=fgetc(MODBUS_SERIAL);
*
0378:  RCALL  0336
037A:  MOVFF  01,99B
.................... 
....................    if (!modbus_serial_new)
037E:  MOVLB  5
0380:  BTFSC  x8F.0
0382:  BRA    03DA
....................    {
....................       if(modbus_serial_state == MODBUS_GETADDY)
0384:  MOVF   x90,F
0386:  BNZ   0398
....................       {
....................          modbus_serial_crc.d = 0xFFFF;
0388:  SETF   x92
038A:  SETF   x91
....................          modbus_rx.address = c;
038C:  MOVFF  99B,593
....................          modbus_serial_state++;
0390:  INCF   x90,F
....................          modbus_rx.len = 0;
0392:  CLRF   x94
....................          modbus_rx.error=0;
0394:  CLRF   x96
....................       }
0396:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETFUNC)
0398:  DECFSZ x90,W
039A:  BRA    03A4
....................       {
....................          modbus_rx.func = c;
039C:  MOVFF  99B,595
....................          modbus_serial_state++;
03A0:  INCF   x90,F
....................       }
03A2:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETDATA)
03A4:  MOVF   x90,W
03A6:  SUBLW  02
03A8:  BNZ   03C6
....................       {
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;}
03AA:  INCFSZ x94,W
03AC:  BRA    03B2
03AE:  MOVLW  FE
03B0:  MOVWF  x94
....................          modbus_rx.data[modbus_rx.len]=c;
03B2:  MOVLW  97
03B4:  ADDWF  x94,W
03B6:  MOVWF  FE9
03B8:  MOVLW  05
03BA:  MOVWF  FEA
03BC:  BTFSC  FD8.0
03BE:  INCF   FEA,F
03C0:  MOVFF  99B,FEF
....................          modbus_rx.len++;
03C4:  INCF   x94,F
....................       }
.................... 
....................       modbus_calc_crc(c);
03C6:  MOVFF  99B,99C
03CA:  MOVLB  0
03CC:  RCALL  034C
....................       modbus_enable_timeout(TRUE);
03CE:  MOVLW  01
03D0:  MOVLB  9
03D2:  MOVWF  x9C
03D4:  MOVLB  0
03D6:  RCALL  02F2
03D8:  MOVLB  5
....................    }
03DA:  BCF    F9E.5
03DC:  MOVLB  0
03DE:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func)
.................... {
....................    modbus_serial_crc.d=0xFFFF;
*
1780:  MOVLB  5
1782:  SETF   x92
1784:  SETF   x91
....................    modbus_serial_new=FALSE;
1786:  BCF    x8F.0
.................... 
....................    RCV_OFF();
1788:  BCF    F9D.5
....................    
....................    output_high(MODBUS_SERIAL_ENABLE_PIN);
178A:  BCF    F94.5
178C:  BSF    F8B.5
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
178E:  CLRWDT
1790:  MOVLW  F2
1792:  MOVWF  00
1794:  DECFSZ 00,F
1796:  BRA    1794
.................... 
....................    modbus_serial_putc(to);
1798:  MOVFF  98D,990
179C:  MOVLB  0
179E:  RCALL  1756
....................    modbus_serial_putc(func);
17A0:  MOVFF  98E,990
17A4:  RCALL  1756
17A6:  RETURN 0
.................... }
.................... 
.................... void modbus_serial_send_stop()
.................... {
....................    int8 crc_low, crc_high;
.................... 
.................... 
....................    crc_high=modbus_serial_crc.b[1];
17A8:  MOVFF  592,98E
....................    crc_low=modbus_serial_crc.b[0];
17AC:  MOVFF  591,98D
.................... 
....................    modbus_serial_putc(crc_high);
17B0:  MOVFF  98E,990
17B4:  RCALL  1756
....................    modbus_serial_putc(crc_low);
17B6:  MOVFF  98D,990
17BA:  RCALL  1756
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................    WAIT_FOR_HW_BUFFER();
17BC:  BTFSS  FAD.1
17BE:  BRA    17BC
.................... #endif
....................     
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
17C0:  CLRWDT
17C2:  MOVLW  F2
17C4:  MOVWF  00
17C6:  DECFSZ 00,F
17C8:  BRA    17C6
.................... 
.................... 
....................    RCV_ON();
17CA:  CALL   0A92
.................... 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
17CE:  BCF    F94.5
17D0:  BCF    F8B.5
.................... 
....................    modbus_serial_crc.d=0xFFFF;
17D2:  MOVLB  5
17D4:  SETF   x92
17D6:  SETF   x91
17D8:  MOVLB  0
17DA:  RETURN 0
.................... 
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
17DC:  MOVLB  5
17DE:  BTFSC  x8F.0
17E0:  BRA    17EA
....................       return FALSE;
17E2:  MOVLW  00
17E4:  MOVWF  01
17E6:  BRA    17FC
17E8:  BRA    17F6
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
17EA:  BTFSS  x95.7
17EC:  BRA    17F6
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
17EE:  MOVFF  597,596
....................       modbus_rx.len = 1;
17F2:  MOVLW  01
17F4:  MOVWF  x94
....................    }
....................    modbus_serial_new=FALSE;
17F6:  BCF    x8F.0
....................    return TRUE;
17F8:  MOVLW  01
17FA:  MOVWF  01
17FC:  MOVLB  0
17FE:  RETURN 0
.................... }
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... /*MODBUS Master Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
*
1BFA:  MOVFF  982,98D
1BFE:  MOVLW  01
1C00:  MOVLB  9
1C02:  MOVWF  x8E
1C04:  MOVLB  0
1C06:  RCALL  1780
.................... 
....................    modbus_serial_putc(make8(start_address,1));
1C08:  MOVFF  984,990
1C0C:  RCALL  1756
....................    modbus_serial_putc(make8(start_address,0));
1C0E:  MOVFF  983,990
1C12:  RCALL  1756
.................... 
....................    modbus_serial_putc(make8(quantity,1));
1C14:  MOVFF  986,990
1C18:  RCALL  1756
....................    modbus_serial_putc(make8(quantity,0));
1C1A:  MOVFF  985,990
1C1E:  RCALL  1756
.................... 
....................    modbus_serial_send_stop();
1C20:  RCALL  17A8
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
1C22:  MOVLB  9
1C24:  MOVF   x82,F
1C26:  BZ    1C7A
1C28:  MOVLB  0
1C2A:  RCALL  17DC
1C2C:  MOVF   01,F
1C2E:  BNZ   1C62
1C30:  MOVLW  FF
1C32:  MOVLB  5
1C34:  ADDWF  x8B,F
1C36:  BTFSS  FD8.0
1C38:  ADDWF  x8C,F
1C3A:  BTFSS  FD8.0
1C3C:  ADDWF  x8D,F
1C3E:  BTFSS  FD8.0
1C40:  ADDWF  x8E,F
1C42:  MOVF   x8B,F
1C44:  BNZ   1C58
1C46:  MOVF   x8C,F
1C48:  BNZ   1C58
1C4A:  MOVF   x8D,F
1C4C:  BNZ   1C58
1C4E:  MOVF   x8E,F
1C50:  BTFSS  FD8.2
1C52:  BRA    1C58
1C54:  MOVLB  0
1C56:  BRA    1C62
1C58:  CLRWDT
1C5A:  NOP   
1C5C:  MOVLB  9
1C5E:  BRA    1C28
1C60:  MOVLB  0
1C62:  MOVLB  5
1C64:  MOVF   x8B,F
1C66:  BNZ   1C78
1C68:  MOVF   x8C,F
1C6A:  BNZ   1C78
1C6C:  MOVF   x8D,F
1C6E:  BNZ   1C78
1C70:  MOVF   x8E,F
1C72:  BNZ   1C78
1C74:  MOVLW  0C
1C76:  MOVWF  x96
1C78:  MOVLB  9
1C7A:  MOVLB  5
1C7C:  CLRF   x8E
1C7E:  MOVLW  01
1C80:  MOVWF  x8D
1C82:  MOVLW  86
1C84:  MOVWF  x8C
1C86:  MOVLW  A0
1C88:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
1C8A:  MOVFF  596,01
1C8E:  MOVLB  0
1C90:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
*
2D48:  MOVFF  982,98D
2D4C:  MOVLW  02
2D4E:  MOVLB  9
2D50:  MOVWF  x8E
2D52:  MOVLB  0
2D54:  CALL   1780
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2D58:  MOVFF  984,990
2D5C:  CALL   1756
....................    modbus_serial_putc(make8(start_address,0));
2D60:  MOVFF  983,990
2D64:  CALL   1756
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2D68:  MOVFF  986,990
2D6C:  CALL   1756
....................    modbus_serial_putc(make8(quantity,0));
2D70:  MOVFF  985,990
2D74:  CALL   1756
.................... 
....................    modbus_serial_send_stop();
2D78:  CALL   17A8
....................       
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2D7C:  MOVLB  9
2D7E:  MOVF   x82,F
2D80:  BZ    2DD6
2D82:  MOVLB  0
2D84:  CALL   17DC
2D88:  MOVF   01,F
2D8A:  BNZ   2DBE
2D8C:  MOVLW  FF
2D8E:  MOVLB  5
2D90:  ADDWF  x8B,F
2D92:  BTFSS  FD8.0
2D94:  ADDWF  x8C,F
2D96:  BTFSS  FD8.0
2D98:  ADDWF  x8D,F
2D9A:  BTFSS  FD8.0
2D9C:  ADDWF  x8E,F
2D9E:  MOVF   x8B,F
2DA0:  BNZ   2DB4
2DA2:  MOVF   x8C,F
2DA4:  BNZ   2DB4
2DA6:  MOVF   x8D,F
2DA8:  BNZ   2DB4
2DAA:  MOVF   x8E,F
2DAC:  BTFSS  FD8.2
2DAE:  BRA    2DB4
2DB0:  MOVLB  0
2DB2:  BRA    2DBE
2DB4:  CLRWDT
2DB6:  NOP   
2DB8:  MOVLB  9
2DBA:  BRA    2D82
2DBC:  MOVLB  0
2DBE:  MOVLB  5
2DC0:  MOVF   x8B,F
2DC2:  BNZ   2DD4
2DC4:  MOVF   x8C,F
2DC6:  BNZ   2DD4
2DC8:  MOVF   x8D,F
2DCA:  BNZ   2DD4
2DCC:  MOVF   x8E,F
2DCE:  BNZ   2DD4
2DD0:  MOVLW  0C
2DD2:  MOVWF  x96
2DD4:  MOVLB  9
2DD6:  MOVLB  5
2DD8:  CLRF   x8E
2DDA:  MOVLW  01
2DDC:  MOVWF  x8D
2DDE:  MOVLW  86
2DE0:  MOVWF  x8C
2DE2:  MOVLW  A0
2DE4:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2DE6:  MOVFF  596,01
2DEA:  MOVLB  0
2DEC:  GOTO   3182 (RETURN)
.................... }
.................... 
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
*
1898:  MOVFF  982,98D
189C:  MOVLW  03
189E:  MOVLB  9
18A0:  MOVWF  x8E
18A2:  MOVLB  0
18A4:  RCALL  1780
.................... 
....................    modbus_serial_putc(make8(start_address,1));
18A6:  MOVFF  984,990
18AA:  RCALL  1756
....................    modbus_serial_putc(make8(start_address,0));
18AC:  MOVFF  983,990
18B0:  RCALL  1756
.................... 
....................    modbus_serial_putc(make8(quantity,1));
18B2:  MOVFF  986,990
18B6:  RCALL  1756
....................    modbus_serial_putc(make8(quantity,0));
18B8:  MOVFF  985,990
18BC:  RCALL  1756
.................... 
....................    modbus_serial_send_stop();
18BE:  RCALL  17A8
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
18C0:  MOVLB  9
18C2:  MOVF   x82,F
18C4:  BZ    1918
18C6:  MOVLB  0
18C8:  RCALL  17DC
18CA:  MOVF   01,F
18CC:  BNZ   1900
18CE:  MOVLW  FF
18D0:  MOVLB  5
18D2:  ADDWF  x8B,F
18D4:  BTFSS  FD8.0
18D6:  ADDWF  x8C,F
18D8:  BTFSS  FD8.0
18DA:  ADDWF  x8D,F
18DC:  BTFSS  FD8.0
18DE:  ADDWF  x8E,F
18E0:  MOVF   x8B,F
18E2:  BNZ   18F6
18E4:  MOVF   x8C,F
18E6:  BNZ   18F6
18E8:  MOVF   x8D,F
18EA:  BNZ   18F6
18EC:  MOVF   x8E,F
18EE:  BTFSS  FD8.2
18F0:  BRA    18F6
18F2:  MOVLB  0
18F4:  BRA    1900
18F6:  CLRWDT
18F8:  NOP   
18FA:  MOVLB  9
18FC:  BRA    18C6
18FE:  MOVLB  0
1900:  MOVLB  5
1902:  MOVF   x8B,F
1904:  BNZ   1916
1906:  MOVF   x8C,F
1908:  BNZ   1916
190A:  MOVF   x8D,F
190C:  BNZ   1916
190E:  MOVF   x8E,F
1910:  BNZ   1916
1912:  MOVLW  0C
1914:  MOVWF  x96
1916:  MOVLB  9
1918:  MOVLB  5
191A:  CLRF   x8E
191C:  MOVLW  01
191E:  MOVWF  x8D
1920:  MOVLW  86
1922:  MOVWF  x8C
1924:  MOVLW  A0
1926:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
1928:  MOVFF  596,01
192C:  MOVLB  0
192E:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
*
1800:  MOVFF  982,98D
1804:  MOVLW  04
1806:  MOVLB  9
1808:  MOVWF  x8E
180A:  MOVLB  0
180C:  RCALL  1780
.................... 
....................    modbus_serial_putc(make8(start_address,1));
180E:  MOVFF  984,990
1812:  RCALL  1756
....................    modbus_serial_putc(make8(start_address,0));
1814:  MOVFF  983,990
1818:  RCALL  1756
.................... 
.................... 
....................    modbus_serial_putc(make8(quantity,1));
181A:  MOVFF  986,990
181E:  RCALL  1756
....................    modbus_serial_putc(make8(quantity,0));
1820:  MOVFF  985,990
1824:  RCALL  1756
.................... 
....................    modbus_serial_send_stop();
1826:  RCALL  17A8
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
1828:  MOVLB  9
182A:  MOVF   x82,F
182C:  BZ    1880
182E:  MOVLB  0
1830:  RCALL  17DC
1832:  MOVF   01,F
1834:  BNZ   1868
1836:  MOVLW  FF
1838:  MOVLB  5
183A:  ADDWF  x8B,F
183C:  BTFSS  FD8.0
183E:  ADDWF  x8C,F
1840:  BTFSS  FD8.0
1842:  ADDWF  x8D,F
1844:  BTFSS  FD8.0
1846:  ADDWF  x8E,F
1848:  MOVF   x8B,F
184A:  BNZ   185E
184C:  MOVF   x8C,F
184E:  BNZ   185E
1850:  MOVF   x8D,F
1852:  BNZ   185E
1854:  MOVF   x8E,F
1856:  BTFSS  FD8.2
1858:  BRA    185E
185A:  MOVLB  0
185C:  BRA    1868
185E:  CLRWDT
1860:  NOP   
1862:  MOVLB  9
1864:  BRA    182E
1866:  MOVLB  0
1868:  MOVLB  5
186A:  MOVF   x8B,F
186C:  BNZ   187E
186E:  MOVF   x8C,F
1870:  BNZ   187E
1872:  MOVF   x8D,F
1874:  BNZ   187E
1876:  MOVF   x8E,F
1878:  BNZ   187E
187A:  MOVLW  0C
187C:  MOVWF  x96
187E:  MOVLB  9
1880:  MOVLB  5
1882:  CLRF   x8E
1884:  MOVLW  01
1886:  MOVWF  x8D
1888:  MOVLW  86
188A:  MOVWF  x8C
188C:  MOVLW  A0
188E:  MOVWF  x8B
.................... 
.................... 
.................... 
....................    return modbus_rx.error;
1890:  MOVFF  596,01
1894:  MOVLB  0
1896:  RETURN 0
.................... }
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
*
2DF0:  MOVFF  983,98D
2DF4:  MOVLW  05
2DF6:  MOVLB  9
2DF8:  MOVWF  x8E
2DFA:  MOVLB  0
2DFC:  CALL   1780
.................... 
....................    modbus_serial_putc(make8(output_address,1));
2E00:  MOVFF  985,990
2E04:  CALL   1756
....................    modbus_serial_putc(make8(output_address,0));
2E08:  MOVFF  984,990
2E0C:  CALL   1756
.................... 
....................    if(on)
2E10:  MOVLB  9
2E12:  MOVF   x86,F
2E14:  BZ    2E22
....................        modbus_serial_putc(0xFF);
2E16:  SETF   x90
2E18:  MOVLB  0
2E1A:  CALL   1756
2E1E:  BRA    2E2A
2E20:  MOVLB  9
....................    else
....................        modbus_serial_putc(0x00);
2E22:  CLRF   x90
2E24:  MOVLB  0
2E26:  CALL   1756
....................    
....................    modbus_serial_putc(0x00);
2E2A:  MOVLB  9
2E2C:  CLRF   x90
2E2E:  MOVLB  0
2E30:  CALL   1756
.................... 
....................    modbus_serial_send_stop();
2E34:  CALL   17A8
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2E38:  MOVLB  9
2E3A:  MOVF   x83,F
2E3C:  BZ    2E92
2E3E:  MOVLB  0
2E40:  CALL   17DC
2E44:  MOVF   01,F
2E46:  BNZ   2E7A
2E48:  MOVLW  FF
2E4A:  MOVLB  5
2E4C:  ADDWF  x8B,F
2E4E:  BTFSS  FD8.0
2E50:  ADDWF  x8C,F
2E52:  BTFSS  FD8.0
2E54:  ADDWF  x8D,F
2E56:  BTFSS  FD8.0
2E58:  ADDWF  x8E,F
2E5A:  MOVF   x8B,F
2E5C:  BNZ   2E70
2E5E:  MOVF   x8C,F
2E60:  BNZ   2E70
2E62:  MOVF   x8D,F
2E64:  BNZ   2E70
2E66:  MOVF   x8E,F
2E68:  BTFSS  FD8.2
2E6A:  BRA    2E70
2E6C:  MOVLB  0
2E6E:  BRA    2E7A
2E70:  CLRWDT
2E72:  NOP   
2E74:  MOVLB  9
2E76:  BRA    2E3E
2E78:  MOVLB  0
2E7A:  MOVLB  5
2E7C:  MOVF   x8B,F
2E7E:  BNZ   2E90
2E80:  MOVF   x8C,F
2E82:  BNZ   2E90
2E84:  MOVF   x8D,F
2E86:  BNZ   2E90
2E88:  MOVF   x8E,F
2E8A:  BNZ   2E90
2E8C:  MOVLW  0C
2E8E:  MOVWF  x96
2E90:  MOVLB  9
2E92:  MOVLB  5
2E94:  CLRF   x8E
2E96:  MOVLW  01
2E98:  MOVWF  x8D
2E9A:  MOVLW  86
2E9C:  MOVWF  x8C
2E9E:  MOVLW  A0
2EA0:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2EA2:  MOVFF  596,01
2EA6:  MOVLB  0
2EA8:  GOTO   3204 (RETURN)
.................... }
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
2EAC:  MOVFF  986,98D
2EB0:  MOVLW  06
2EB2:  MOVLB  9
2EB4:  MOVWF  x8E
2EB6:  MOVLB  0
2EB8:  CALL   1780
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
2EBC:  MOVFF  988,990
2EC0:  CALL   1756
....................    modbus_serial_putc(make8(reg_address,0));
2EC4:  MOVFF  987,990
2EC8:  CALL   1756
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
2ECC:  MOVFF  98A,990
2ED0:  CALL   1756
....................    modbus_serial_putc(make8(reg_value,0));
2ED4:  MOVFF  989,990
2ED8:  CALL   1756
.................... 
....................    modbus_serial_send_stop();
2EDC:  CALL   17A8
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2EE0:  MOVLB  9
2EE2:  MOVF   x86,F
2EE4:  BZ    2F3A
2EE6:  MOVLB  0
2EE8:  CALL   17DC
2EEC:  MOVF   01,F
2EEE:  BNZ   2F22
2EF0:  MOVLW  FF
2EF2:  MOVLB  5
2EF4:  ADDWF  x8B,F
2EF6:  BTFSS  FD8.0
2EF8:  ADDWF  x8C,F
2EFA:  BTFSS  FD8.0
2EFC:  ADDWF  x8D,F
2EFE:  BTFSS  FD8.0
2F00:  ADDWF  x8E,F
2F02:  MOVF   x8B,F
2F04:  BNZ   2F18
2F06:  MOVF   x8C,F
2F08:  BNZ   2F18
2F0A:  MOVF   x8D,F
2F0C:  BNZ   2F18
2F0E:  MOVF   x8E,F
2F10:  BTFSS  FD8.2
2F12:  BRA    2F18
2F14:  MOVLB  0
2F16:  BRA    2F22
2F18:  CLRWDT
2F1A:  NOP   
2F1C:  MOVLB  9
2F1E:  BRA    2EE6
2F20:  MOVLB  0
2F22:  MOVLB  5
2F24:  MOVF   x8B,F
2F26:  BNZ   2F38
2F28:  MOVF   x8C,F
2F2A:  BNZ   2F38
2F2C:  MOVF   x8D,F
2F2E:  BNZ   2F38
2F30:  MOVF   x8E,F
2F32:  BNZ   2F38
2F34:  MOVLW  0C
2F36:  MOVWF  x96
2F38:  MOVLB  9
2F3A:  MOVLB  5
2F3C:  CLRF   x8E
2F3E:  MOVLW  01
2F40:  MOVWF  x8D
2F42:  MOVLW  86
2F44:  MOVWF  x8C
2F46:  MOVLW  A0
2F48:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2F4A:  MOVFF  596,01
2F4E:  MOVLB  0
2F50:  GOTO   325A (RETURN)
.................... }
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity,
....................                            int8 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = (int8)((quantity/8));
....................    
....................    if(quantity%8)
....................       count++;      
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
....................    
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < quantity; ++i)
....................    {
....................       modbus_serial_putc(make8(values[i],1));
....................       modbus_serial_putc(make8(values[i],0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... exception modbus_write_multiple_registers_flip(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
2F54:  BCF    FD8.0
2F56:  MOVLB  9
2F58:  RLCF   x87,W
2F5A:  MOVWF  02
2F5C:  RLCF   x88,W
2F5E:  MOVFF  02,98C
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
2F62:  MOVFF  984,98D
2F66:  MOVLW  10
2F68:  MOVWF  x8E
2F6A:  MOVLB  0
2F6C:  CALL   1780
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2F70:  MOVFF  986,990
2F74:  CALL   1756
....................    modbus_serial_putc(make8(start_address,0));
2F78:  MOVFF  985,990
2F7C:  CALL   1756
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2F80:  MOVFF  988,990
2F84:  CALL   1756
....................    modbus_serial_putc(make8(quantity,0));
2F88:  MOVFF  987,990
2F8C:  CALL   1756
....................    
....................    modbus_serial_putc(count);
2F90:  MOVFF  98C,990
2F94:  CALL   1756
.................... 
....................    for(i=0; i < quantity; ++i)
2F98:  MOVLB  9
2F9A:  CLRF   x8B
2F9C:  MOVF   x88,F
2F9E:  BNZ   2FA6
2FA0:  MOVF   x87,W
2FA2:  SUBWF  x8B,W
2FA4:  BC    2FFE
....................    {
....................       modbus_serial_putc(make8(values[i],0));
2FA6:  CLRF   03
2FA8:  MOVFF  98B,02
2FAC:  BCF    FD8.0
2FAE:  RLCF   02,F
2FB0:  RLCF   03,F
2FB2:  MOVF   02,W
2FB4:  ADDWF  x89,W
2FB6:  MOVWF  FE9
2FB8:  MOVF   x8A,W
2FBA:  ADDWFC 03,W
2FBC:  MOVWF  FEA
2FBE:  MOVFF  FEC,98E
2FC2:  MOVF   FED,F
2FC4:  MOVFF  FEF,990
2FC8:  MOVLB  0
2FCA:  CALL   1756
....................       modbus_serial_putc(make8(values[i],1));
2FCE:  CLRF   03
2FD0:  MOVLB  9
2FD2:  MOVFF  98B,02
2FD6:  BCF    FD8.0
2FD8:  RLCF   02,F
2FDA:  RLCF   03,F
2FDC:  MOVF   02,W
2FDE:  ADDWF  x89,W
2FE0:  MOVWF  FE9
2FE2:  MOVF   x8A,W
2FE4:  ADDWFC 03,W
2FE6:  MOVWF  FEA
2FE8:  MOVFF  FEC,990
2FEC:  MOVF   FED,F
2FEE:  MOVFF  FEF,98D
2FF2:  MOVLB  0
2FF4:  CALL   1756
2FF8:  MOVLB  9
2FFA:  INCF   x8B,F
2FFC:  BRA    2F9C
....................    }
.................... 
....................    modbus_serial_send_stop();
2FFE:  MOVLB  0
3000:  CALL   17A8
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
3004:  MOVLB  9
3006:  MOVF   x84,F
3008:  BZ    305E
300A:  MOVLB  0
300C:  CALL   17DC
3010:  MOVF   01,F
3012:  BNZ   3046
3014:  MOVLW  FF
3016:  MOVLB  5
3018:  ADDWF  x8B,F
301A:  BTFSS  FD8.0
301C:  ADDWF  x8C,F
301E:  BTFSS  FD8.0
3020:  ADDWF  x8D,F
3022:  BTFSS  FD8.0
3024:  ADDWF  x8E,F
3026:  MOVF   x8B,F
3028:  BNZ   303C
302A:  MOVF   x8C,F
302C:  BNZ   303C
302E:  MOVF   x8D,F
3030:  BNZ   303C
3032:  MOVF   x8E,F
3034:  BTFSS  FD8.2
3036:  BRA    303C
3038:  MOVLB  0
303A:  BRA    3046
303C:  CLRWDT
303E:  NOP   
3040:  MOVLB  9
3042:  BRA    300A
3044:  MOVLB  0
3046:  MOVLB  5
3048:  MOVF   x8B,F
304A:  BNZ   305C
304C:  MOVF   x8C,F
304E:  BNZ   305C
3050:  MOVF   x8D,F
3052:  BNZ   305C
3054:  MOVF   x8E,F
3056:  BNZ   305C
3058:  MOVLW  0C
305A:  MOVWF  x96
305C:  MOVLB  9
305E:  MOVLB  5
3060:  CLRF   x8E
3062:  MOVLW  01
3064:  MOVWF  x8D
3066:  MOVLW  86
3068:  MOVWF  x8C
306A:  MOVLW  A0
306C:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
306E:  MOVFF  596,01
3072:  MOVLB  0
3074:  GOTO   3298 (RETURN)
.................... }
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(int8 address, int8 byte_count, 
....................                             modbus_read_sub_request *request)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < (byte_count/7); i+=7)
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(int8 address, int8 byte_count, 
....................                             modbus_write_sub_request *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start,
....................                                     int16 read_quantity, int16 write_start,
....................                                     int16 write_quantity,
....................                                     int16 *write_registers_value)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(read_start,1));
....................    modbus_serial_putc(make8(read_start,0));
.................... 
....................    modbus_serial_putc(make8(read_quantity,1));
....................    modbus_serial_putc(make8(read_quantity,0));
.................... 
....................    modbus_serial_putc(make8(write_start, 1));
....................    modbus_serial_putc(make8(write_start, 0));
.................... 
....................    modbus_serial_putc(make8(write_quantity, 1));
....................    modbus_serial_putc(make8(write_quantity, 0));
.................... 
....................    modbus_serial_putc((int8)(2*write_quantity));
.................... 
....................    for(i=0; i < write_quantity ; i+=2)
....................    {
....................       modbus_serial_putc(make8(write_registers_value[i], 1));
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(FIFO_address, 1));
....................    modbus_serial_putc(make8(FIFO_address, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... #else
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*reg_data);
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... #endif
.................... 
.................... #include "iridium_sbd_rdTap.c"
.................... #define SBD_DEBUG 1
.................... 
.................... typedef struct {
.................... 	/* +SBDIX data from most recent */
.................... 	/* result from modem */
.................... 	int8  sbdix_response[42];
.................... 	/* parsed into */
.................... 	int8  sbdix_mo_status;
.................... 	int16 sbdix_mo_msn;
.................... 	int8  sbdix_mt_status;
.................... 	int16 sbdix_mt_msn;
.................... 	int16 sbdix_mt_length;
.................... 	int8  sbdix_mt_queued;
.................... 
.................... 
.................... 	/* "Mobile Originated" message from us to network */
.................... 	int8  mo_state;
.................... 	int8  mo_buff[272];
.................... 	int16 mo_length;
.................... 	int8  mo_try;
.................... 	int8  mo_sbdix_wait;
.................... 
.................... 	/* "Mobile Terminated" messages from network to us */
.................... 	int8  mt_ready;
.................... 	int8  mt_state;
.................... 	int8  mt_buff[256];
.................... 	int16 mt_length;
.................... 	int16 mt_checksum;
.................... 	
.................... 	/* ring alert */
.................... 	int8  ring_flag;
.................... 	int8  ring_state;
.................... 
.................... 	/* modem talking to us for status, AT commands, etc */
.................... 	int8 mr_ready;          /* 1=> message ready for consumption */
.................... 	int8 mr_buff[64];
.................... 	int8 mr_length;
.................... 	int8 mr_disable;
.................... } struct_iridium_sbd;
.................... 
.................... struct_iridium_sbd sbd={0};
.................... 
.................... int8 a_to_uint8(int8 *s) {
*
0B02:  MOVLB  9
0B04:  CLRF   x7E
....................    int8 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
0B06:  MOVFF  97D,FEA
0B0A:  MOVFF  97C,FE9
0B0E:  MOVF   FEF,W
0B10:  SUBLW  20
0B12:  BNZ   0B1C
....................       s++;
0B14:  INCF   x7C,F
0B16:  BTFSC  FD8.2
0B18:  INCF   x7D,F
0B1A:  BRA    0B06
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
0B1C:  MOVFF  97D,FEA
0B20:  MOVFF  97C,FE9
0B24:  MOVFF  FEF,97F
0B28:  MOVF   x7F,W
0B2A:  SUBLW  2F
0B2C:  BC    0B52
0B2E:  MOVF   x7F,W
0B30:  SUBLW  39
0B32:  BNC   0B52
....................       value *= 10;
0B34:  MOVF   x7E,W
0B36:  MULLW  0A
0B38:  MOVFF  FF3,97E
....................       value += (*s-'0');
0B3C:  MOVFF  97D,FEA
0B40:  MOVFF  97C,FE9
0B44:  MOVLW  30
0B46:  SUBWF  FEF,W
0B48:  ADDWF  x7E,F
....................       s++;
0B4A:  INCF   x7C,F
0B4C:  BTFSC  FD8.2
0B4E:  INCF   x7D,F
0B50:  BRA    0B1C
....................    }
.................... 
....................    return value;
0B52:  MOVFF  97E,01
0B56:  MOVLB  0
0B58:  RETURN 0
.................... }
.................... 
.................... int16 a_to_uint16(int8 *s) {
*
0B9A:  MOVLB  9
0B9C:  CLRF   x7F
0B9E:  CLRF   x7E
....................    int16 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
0BA0:  MOVFF  97D,FEA
0BA4:  MOVFF  97C,FE9
0BA8:  MOVF   FEF,W
0BAA:  SUBLW  20
0BAC:  BNZ   0BB6
....................       s++;
0BAE:  INCF   x7C,F
0BB0:  BTFSC  FD8.2
0BB2:  INCF   x7D,F
0BB4:  BRA    0BA0
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
0BB6:  MOVFF  97D,FEA
0BBA:  MOVFF  97C,FE9
0BBE:  MOVFF  FEF,980
0BC2:  MOVF   x80,W
0BC4:  SUBLW  2F
0BC6:  BC    0C04
0BC8:  MOVF   x80,W
0BCA:  SUBLW  39
0BCC:  BNC   0C04
....................       value *= 10;
0BCE:  MOVFF  97F,995
0BD2:  MOVFF  97E,994
0BD6:  CLRF   x97
0BD8:  MOVLW  0A
0BDA:  MOVWF  x96
0BDC:  MOVLB  0
0BDE:  RCALL  084C
0BE0:  MOVFF  02,97F
0BE4:  MOVFF  01,97E
....................       value += (*s-'0');
0BE8:  MOVFF  97D,FEA
0BEC:  MOVLB  9
0BEE:  MOVFF  97C,FE9
0BF2:  MOVLW  30
0BF4:  SUBWF  FEF,W
0BF6:  ADDWF  x7E,F
0BF8:  MOVLW  00
0BFA:  ADDWFC x7F,F
....................       s++;
0BFC:  INCF   x7C,F
0BFE:  BTFSC  FD8.2
0C00:  INCF   x7D,F
0C02:  BRA    0BB6
....................    }
.................... 
....................    return value;
0C04:  MOVFF  97E,01
0C08:  MOVFF  97F,02
0C0C:  MOVLB  0
0C0E:  RETURN 0
.................... }
.................... 
.................... void iridium_sbdix_parse(void) {
.................... 	int8 *p;
.................... 
.................... 	/*
.................... 	 * Quick check of potential validity of response:
.................... 	 * a) valid response would need to be at least 24 characters
.................... 	 * +SBDIX: 0, 25, 0, 0, 0, 0	
.................... 	 * 012345678901234567890123456789
.................... 	 *           1         2
.................... 	 * b) mo_status always starts at character 8
.................... 	 * */
.................... 	if ( strlen(sbd.sbdix_response) < 24 || ! isdigit(sbd.sbdix_response[8] ) ) {
0C10:  MOVLW  06
0C12:  MOVLB  9
0C14:  MOVWF  x7D
0C16:  MOVLW  96
0C18:  MOVWF  x7C
0C1A:  MOVLB  0
0C1C:  BRA    0AC8
0C1E:  MOVFF  02,97D
0C22:  MOVFF  01,97C
0C26:  MOVLB  9
0C28:  MOVF   x7D,F
0C2A:  BNZ   0C32
0C2C:  MOVF   x7C,W
0C2E:  SUBLW  17
0C30:  BC    0C48
0C32:  MOVLB  6
0C34:  MOVF   x9E,W
0C36:  SUBLW  2F
0C38:  BTFSS  FD8.0
0C3A:  BRA    0C40
0C3C:  MOVLB  9
0C3E:  BRA    0C48
0C40:  MOVF   x9E,W
0C42:  SUBLW  39
0C44:  BC    0C4C
0C46:  MOVLB  9
.................... 		/* if not a digit or too short, then we give up */
.................... 		return;
0C48:  BRA    0DC0
0C4A:  MOVLB  6
.................... 	}
.................... 	sbd.sbdix_mo_status=a_to_uint8(sbd.sbdix_response+8);
0C4C:  MOVLW  06
0C4E:  MOVLB  9
0C50:  MOVWF  x7D
0C52:  MOVLW  9E
0C54:  MOVWF  x7C
0C56:  MOVLB  0
0C58:  RCALL  0B02
0C5A:  MOVFF  01,6C0
.................... 
.................... 	/* mo_msn (with preceeding space) starts after comma */
.................... 	p = strchr(sbd.sbdix_response+9,',');
0C5E:  MOVLW  06
0C60:  MOVLB  9
0C62:  MOVWF  x7F
0C64:  MOVLW  9F
0C66:  MOVWF  x7E
0C68:  MOVLW  2C
0C6A:  MOVWF  x80
0C6C:  MOVLB  0
0C6E:  RCALL  0B5A
0C70:  MOVFF  02,97B
0C74:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0C78:  MOVLB  9
0C7A:  MOVF   x7A,F
0C7C:  BNZ   0C84
0C7E:  MOVF   x7B,F
0C80:  BNZ   0C84
.................... 		/* not found */
.................... 		return;
0C82:  BRA    0DC0
.................... 	}
.................... 	p++; /* swallow the ',' */
0C84:  INCF   x7A,F
0C86:  BTFSC  FD8.2
0C88:  INCF   x7B,F
.................... 	sbd.sbdix_mo_msn=a_to_uint16(p);
0C8A:  MOVFF  97B,97D
0C8E:  MOVFF  97A,97C
0C92:  MOVLB  0
0C94:  RCALL  0B9A
0C96:  MOVFF  02,6C2
0C9A:  MOVFF  01,6C1
.................... 
.................... 	/* mt_status (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0C9E:  MOVLW  01
0CA0:  MOVLB  9
0CA2:  ADDWF  x7A,W
0CA4:  MOVWF  x7C
0CA6:  MOVLW  00
0CA8:  ADDWFC x7B,W
0CAA:  MOVWF  x7D
0CAC:  MOVWF  x7F
0CAE:  MOVFF  97C,97E
0CB2:  MOVLW  2C
0CB4:  MOVWF  x80
0CB6:  MOVLB  0
0CB8:  RCALL  0B5A
0CBA:  MOVFF  02,97B
0CBE:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0CC2:  MOVLB  9
0CC4:  MOVF   x7A,F
0CC6:  BNZ   0CCE
0CC8:  MOVF   x7B,F
0CCA:  BNZ   0CCE
.................... 		/* not found */
.................... 		return;
0CCC:  BRA    0DC0
.................... 	}
.................... 	p++; /* swallow the ',' */
0CCE:  INCF   x7A,F
0CD0:  BTFSC  FD8.2
0CD2:  INCF   x7B,F
.................... 	sbd.sbdix_mt_status=a_to_uint8(p);
0CD4:  MOVFF  97B,97D
0CD8:  MOVFF  97A,97C
0CDC:  MOVLB  0
0CDE:  RCALL  0B02
0CE0:  MOVFF  01,6C3
.................... 
.................... 	/* mt_msn (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0CE4:  MOVLW  01
0CE6:  MOVLB  9
0CE8:  ADDWF  x7A,W
0CEA:  MOVWF  x7C
0CEC:  MOVLW  00
0CEE:  ADDWFC x7B,W
0CF0:  MOVWF  x7D
0CF2:  MOVWF  x7F
0CF4:  MOVFF  97C,97E
0CF8:  MOVLW  2C
0CFA:  MOVWF  x80
0CFC:  MOVLB  0
0CFE:  RCALL  0B5A
0D00:  MOVFF  02,97B
0D04:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0D08:  MOVLB  9
0D0A:  MOVF   x7A,F
0D0C:  BNZ   0D14
0D0E:  MOVF   x7B,F
0D10:  BNZ   0D14
.................... 		/* not found */
.................... 		return;
0D12:  BRA    0DC0
.................... 	}
.................... 	p++; /* swallow the ',' */
0D14:  INCF   x7A,F
0D16:  BTFSC  FD8.2
0D18:  INCF   x7B,F
.................... 	sbd.sbdix_mt_msn=a_to_uint16(p);
0D1A:  MOVFF  97B,97D
0D1E:  MOVFF  97A,97C
0D22:  MOVLB  0
0D24:  RCALL  0B9A
0D26:  MOVFF  02,6C5
0D2A:  MOVFF  01,6C4
.................... 
.................... 	/* mt_length (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0D2E:  MOVLW  01
0D30:  MOVLB  9
0D32:  ADDWF  x7A,W
0D34:  MOVWF  x7C
0D36:  MOVLW  00
0D38:  ADDWFC x7B,W
0D3A:  MOVWF  x7D
0D3C:  MOVWF  x7F
0D3E:  MOVFF  97C,97E
0D42:  MOVLW  2C
0D44:  MOVWF  x80
0D46:  MOVLB  0
0D48:  RCALL  0B5A
0D4A:  MOVFF  02,97B
0D4E:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0D52:  MOVLB  9
0D54:  MOVF   x7A,F
0D56:  BNZ   0D5E
0D58:  MOVF   x7B,F
0D5A:  BNZ   0D5E
.................... 		/* not found */
.................... 		return;
0D5C:  BRA    0DC0
.................... 	}
.................... 	p++; /* swallow the ',' */
0D5E:  INCF   x7A,F
0D60:  BTFSC  FD8.2
0D62:  INCF   x7B,F
.................... 	sbd.sbdix_mt_length=a_to_uint16(p);
0D64:  MOVFF  97B,97D
0D68:  MOVFF  97A,97C
0D6C:  MOVLB  0
0D6E:  RCALL  0B9A
0D70:  MOVFF  02,6C7
0D74:  MOVFF  01,6C6
.................... 
.................... 	/* mt_queued (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0D78:  MOVLW  01
0D7A:  MOVLB  9
0D7C:  ADDWF  x7A,W
0D7E:  MOVWF  x7C
0D80:  MOVLW  00
0D82:  ADDWFC x7B,W
0D84:  MOVWF  x7D
0D86:  MOVWF  x7F
0D88:  MOVFF  97C,97E
0D8C:  MOVLW  2C
0D8E:  MOVWF  x80
0D90:  MOVLB  0
0D92:  RCALL  0B5A
0D94:  MOVFF  02,97B
0D98:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0D9C:  MOVLB  9
0D9E:  MOVF   x7A,F
0DA0:  BNZ   0DA8
0DA2:  MOVF   x7B,F
0DA4:  BNZ   0DA8
.................... 		/* not found */
.................... 		return;
0DA6:  BRA    0DC0
.................... 	}
.................... 	p++; /* swallow the ',' */
0DA8:  INCF   x7A,F
0DAA:  BTFSC  FD8.2
0DAC:  INCF   x7B,F
.................... 	sbd.sbdix_mt_queued=a_to_uint8(p);
0DAE:  MOVFF  97B,97D
0DB2:  MOVFF  97A,97C
0DB6:  MOVLB  0
0DB8:  RCALL  0B02
0DBA:  MOVFF  01,6C8
0DBE:  MOVLB  9
.................... 
.................... #if DEBUG_SBD
0DC0:  MOVLB  0
0DC2:  GOTO   3746 (RETURN)
.................... 	fprintf(STREAM_WORLD,"# iridium_sbdix_parse():\r\n");
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_status   = %d\n",sbd.sbdix_mo_status);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_msn      = %lu\n",sbd.sbdix_mo_msn);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_status   = %d\n",sbd.sbdix_mt_status);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_msn      = %lu\n",sbd.sbdix_mt_msn);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_length   = %lu\n",sbd.sbdix_mt_length);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_queued   = %d\n",sbd.sbdix_mt_queued);
.................... #endif
.................... 
.................... }
.................... 
.................... #if 0
.................... void _iridium_on(void) {
.................... 	/* turn power switch on */
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_high(CTRL_0); break;
.................... 		case 2: output_high(CTRL_1); break;
.................... 		case 3: output_high(CTRL_2); break;
.................... 		case 4: output_high(CTRL_3); break;
.................... 		case 5: output_high(CTRL_4); break;
.................... 	}
.................... 	
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000000);
.................... 
.................... }
.................... 
.................... void _iridium_off(void) {
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_low(CTRL_0); break;
.................... 		case 2: output_low(CTRL_1); break;
.................... 		case 3: output_low(CTRL_2); break;
.................... 		case 4: output_low(CTRL_3); break;
.................... 		case 5: output_low(CTRL_4); break;
.................... 	}
.................... 
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000010);
.................... }
.................... #endif
.................... 
.................... void iridium_mr_clear(void) {
.................... 	sbd.mr_ready=0;
*
0ABC:  MOVLB  8
0ABE:  CLRF   xE6
.................... 	sbd.mr_length=0;
0AC0:  MOVLB  9
0AC2:  CLRF   x27
0AC4:  MOVLB  0
0AC6:  RETURN 0
.................... }
.................... 
.................... void iridium_mo_clear(void) {
.................... 	sbd.mo_length=0;
*
1356:  MOVLB  7
1358:  CLRF   xDB
135A:  CLRF   xDA
.................... 	sbd.mo_state=0;
135C:  MOVLB  6
135E:  CLRF   xC9
1360:  MOVLB  0
1362:  RETURN 0
.................... }
.................... 
.................... void iridium_mt_clear(void) {
.................... 	sbd.mt_length=0;
.................... 	sbd.mt_state=0;
.................... }
.................... 
.................... /* if we have characters to be received, this function reads them */
.................... void iridium_getc(void) {
.................... 	int8 c;
.................... 
.................... 
.................... 	/* read character from UART */
.................... 	c = uart_getc();
*
0E6A:  MOVFF  01,97A
.................... 
.................... 
.................... 	if ( '\r' == c ) {
0E6E:  MOVLB  9
0E70:  MOVF   x7A,W
0E72:  SUBLW  0D
0E74:  BNZ   0E78
.................... 		/* except when receiving binary data, we don't care about '\r' */
.................... 		return;
0E76:  BRA    0F0C
.................... 	}
.................... 
.................... 	/* modem always appears to send '\r' '\n' */
.................... 	
.................... 
.................... 	if ( 0 == sbd.mr_ready ) {
0E78:  MOVLB  8
0E7A:  MOVF   xE6,F
0E7C:  BNZ   0F0E
.................... 		/* receiving data */
.................... 
.................... 		if ( '\n' == c && 0==sbd.mr_length ) {
0E7E:  MOVLB  9
0E80:  MOVF   x7A,W
0E82:  SUBLW  0A
0E84:  BNZ   0E8C
0E86:  MOVF   x27,F
0E88:  BNZ   0E8C
.................... 			/* responses usually appear to be \r\nOK\r\n ... this skips the empty message */
.................... 			return;
0E8A:  BRA    0F0C
.................... 		}
.................... 
.................... 		
.................... 		/* check for 'SBDRING' message and deal with it accordingly */
.................... 		if ( 'S'==sbd.mr_buff[0] && 'B'==sbd.mr_buff[1] && 'D'==sbd.mr_buff[2] 
.................... 			&& 'R'==sbd.mr_buff[3] && 'I'==sbd.mr_buff[4] && 'N'==sbd.mr_buff[5] && 'G'==c ) {
0E8C:  MOVLB  8
0E8E:  MOVF   xE7,W
0E90:  SUBLW  53
0E92:  BNZ   0ED0
0E94:  MOVF   xE8,W
0E96:  SUBLW  42
0E98:  BNZ   0ED0
0E9A:  MOVF   xE9,W
0E9C:  SUBLW  44
0E9E:  BNZ   0ED0
0EA0:  MOVF   xEA,W
0EA2:  SUBLW  52
0EA4:  BNZ   0ED0
0EA6:  MOVF   xEB,W
0EA8:  SUBLW  49
0EAA:  BNZ   0ED0
0EAC:  MOVF   xEC,W
0EAE:  SUBLW  4E
0EB0:  BNZ   0ED0
0EB2:  MOVLB  9
0EB4:  MOVF   x7A,W
0EB6:  SUBLW  47
0EB8:  BTFSC  FD8.2
0EBA:  BRA    0EC0
0EBC:  MOVLB  8
0EBE:  BRA    0ED0
.................... 			sbd.ring_flag=1;
0EC0:  MOVLW  01
0EC2:  MOVLB  8
0EC4:  MOVWF  xE4
.................... 			iridium_mr_clear();
0EC6:  MOVLB  0
0EC8:  RCALL  0ABC
.................... 			return;
0ECA:  MOVLB  9
0ECC:  BRA    0F0C
0ECE:  MOVLB  8
.................... 		 }
.................... 
.................... 		if ( '\n' == c ) {
0ED0:  MOVLB  9
0ED2:  MOVF   x7A,W
0ED4:  SUBLW  0A
0ED6:  BNZ   0EF2
.................... 			/* replace '\n' with '\0' */
.................... 			sbd.mr_buff[sbd.mr_length]='\0';
0ED8:  MOVLW  E7
0EDA:  ADDWF  x27,W
0EDC:  MOVWF  FE9
0EDE:  MOVLW  08
0EE0:  MOVWF  FEA
0EE2:  BTFSC  FD8.0
0EE4:  INCF   FEA,F
0EE6:  CLRF   FEF
.................... 			
.................... 			/* mark that we have a message ready */
.................... 			sbd.mr_ready=1;
0EE8:  MOVLW  01
0EEA:  MOVLB  8
0EEC:  MOVWF  xE6
.................... 
.................... 			/* done */
.................... 			return;
0EEE:  MOVLB  9
0EF0:  BRA    0F0C
.................... 		}
.................... 
.................... 
.................... 		/* put in response buffer if not full */
.................... 		if ( sbd.mr_length < ( sizeof(sbd.mr_buff) - 1 ) ) {
0EF2:  MOVF   x27,W
0EF4:  SUBLW  3E
0EF6:  BNC   0F0C
.................... 			sbd.mr_buff[sbd.mr_length]=c;
0EF8:  MOVLW  E7
0EFA:  ADDWF  x27,W
0EFC:  MOVWF  FE9
0EFE:  MOVLW  08
0F00:  MOVWF  FEA
0F02:  BTFSC  FD8.0
0F04:  INCF   FEA,F
0F06:  MOVFF  97A,FEF
.................... 			sbd.mr_length++;
0F0A:  INCF   x27,F
.................... 		} else {
0F0C:  MOVLB  8
.................... 			/* buffer is full ... do nothing and wait for message to be terminated */
.................... 		}
.................... 	}
0F0E:  MOVLB  0
0F10:  GOTO   377E (RETURN)
.................... }
.................... 
.................... void iridium_ringing(void) {
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_ringing() sbd.ring_state=%u\r\n",sbd.ring_state);
.................... #endif
.................... 
.................... 	if ( 0 == sbd.ring_state ) {
.................... 		/* nothing to do */
.................... 		return;
.................... 	}else if ( 1 == sbd.ring_state ) {
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"ATE0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.ring_state ) {
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT&K0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}	
.................... 	} else if ( 5 == sbd.ring_state ) {
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}
.................... 	} else if ( 7 == sbd.ring_state ) {
.................... 		/* send 'AT+CRIS' to determine why we rang */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+CRIS\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.ring_state ) {
.................... 		/* parse CRIS response. But in reality, with an SBD only device it can only be SBD message that causes us to ring */
.................... 	} 
.................... 
.................... }
.................... 
.................... void iridium_mo_send(void) {
.................... 	int16 l;
.................... 	int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... //	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u sbd.mo_sbdix_wait=%u\r\n",sbd.mo_state,sbd.mo_try,sbd.mo_sbdix_wait);
.................... #endif
.................... 
.................... 
.................... 	if ( 0 == sbd.mo_state ) {
*
1364:  MOVLB  6
1366:  MOVF   xC9,F
1368:  BNZ   136E
.................... 		/* nothing to do */
.................... 		return;
136A:  BRA    1746
.................... 
.................... 	} else if ( 1 == sbd.mo_state ) {
136C:  BRA    1740
136E:  DECFSZ xC9,W
1370:  BRA    1388
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
1372:  MOVLB  0
1374:  CALL   0ABC
.................... 		printf(uart_putc,"ATE0\r");
1378:  MOVLW  08
137A:  MOVWF  FF6
137C:  MOVLW  04
137E:  MOVWF  FF7
1380:  RCALL  0F24
.................... 		sbd.mo_state++;
1382:  MOVLB  6
1384:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mo_state ) {
1386:  BRA    1740
1388:  MOVF   xC9,W
138A:  SUBLW  02
138C:  BNZ   13B2
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
138E:  MOVLB  8
1390:  DECFSZ xE6,W
1392:  BRA    13AE
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1394:  MOVF   xE7,W
1396:  SUBLW  4F
1398:  BNZ   13A6
139A:  MOVF   xE8,W
139C:  SUBLW  4B
139E:  BNZ   13A6
.................... 				sbd.mo_state++;
13A0:  MOVLB  6
13A2:  INCF   xC9,F
13A4:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
13A6:  MOVLB  0
13A8:  CALL   0ABC
13AC:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mo_state ) {
13AE:  BRA    1742
13B0:  MOVLB  6
13B2:  MOVF   xC9,W
13B4:  SUBLW  03
13B6:  BNZ   13CE
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
13B8:  MOVLB  0
13BA:  CALL   0ABC
.................... 		printf(uart_putc,"AT&K0\r");
13BE:  MOVLW  0E
13C0:  MOVWF  FF6
13C2:  MOVLW  04
13C4:  MOVWF  FF7
13C6:  RCALL  0F24
.................... 		sbd.mo_state++;
13C8:  MOVLB  6
13CA:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mo_state ) {
13CC:  BRA    1740
13CE:  MOVF   xC9,W
13D0:  SUBLW  04
13D2:  BNZ   13F8
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
13D4:  MOVLB  8
13D6:  DECFSZ xE6,W
13D8:  BRA    13F4
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
13DA:  MOVF   xE7,W
13DC:  SUBLW  4F
13DE:  BNZ   13EC
13E0:  MOVF   xE8,W
13E2:  SUBLW  4B
13E4:  BNZ   13EC
.................... 				sbd.mo_state++;
13E6:  MOVLB  6
13E8:  INCF   xC9,F
13EA:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
13EC:  MOVLB  0
13EE:  CALL   0ABC
13F2:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mo_state ) {
13F4:  BRA    1742
13F6:  MOVLB  6
13F8:  MOVF   xC9,W
13FA:  SUBLW  05
13FC:  BNZ   1414
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
13FE:  MOVLB  0
1400:  CALL   0ABC
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
1404:  MOVLW  16
1406:  MOVWF  FF6
1408:  MOVLW  04
140A:  MOVWF  FF7
140C:  RCALL  0F24
.................... 		sbd.mo_state++;
140E:  MOVLB  6
1410:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mo_state ) {
1412:  BRA    1740
1414:  MOVF   xC9,W
1416:  SUBLW  06
1418:  BNZ   143E
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
141A:  MOVLB  8
141C:  DECFSZ xE6,W
141E:  BRA    143A
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1420:  MOVF   xE7,W
1422:  SUBLW  4F
1424:  BNZ   1432
1426:  MOVF   xE8,W
1428:  SUBLW  4B
142A:  BNZ   1432
.................... 				sbd.mo_state++;
142C:  MOVLB  6
142E:  INCF   xC9,F
1430:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1432:  MOVLB  0
1434:  CALL   0ABC
1438:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mo_state ) {
143A:  BRA    1742
143C:  MOVLB  6
143E:  MOVF   xC9,W
1440:  SUBLW  07
1442:  BNZ   147A
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDWB=[<SBD Message Length>]' to tell modem how long our MO */
.................... 		iridium_mr_clear();
1444:  MOVLB  0
1446:  CALL   0ABC
.................... 		printf(uart_putc,"AT+SBDWB=%lu\r",sbd.mo_length);
144A:  MOVLW  24
144C:  MOVWF  FF6
144E:  MOVLW  04
1450:  MOVWF  FF7
1452:  MOVLW  09
1454:  MOVLB  9
1456:  MOVWF  x7E
1458:  MOVLB  0
145A:  BRA    11B6
145C:  MOVLW  10
145E:  MOVWF  FE9
1460:  MOVFF  7DB,97F
1464:  MOVFF  7DA,97E
1468:  BRA    11E0
146A:  MOVLW  0D
146C:  MOVLB  9
146E:  MOVWF  x87
1470:  MOVLB  0
1472:  RCALL  0F14
.................... 		sbd.mo_state++;
1474:  MOVLB  6
1476:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mo_state ) {
1478:  BRA    1740
147A:  MOVF   xC9,W
147C:  SUBLW  08
147E:  BNZ   14B6
.................... 		/* receive response 'READY' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1480:  MOVLB  8
1482:  DECFSZ xE6,W
1484:  BRA    14B2
.................... 			if ( 'R'==sbd.mr_buff[0] 
....................                  && 'E'==sbd.mr_buff[1] 
....................                  && 'A'==sbd.mr_buff[2]
.................... 			     && 'D'==sbd.mr_buff[3]
.................... 			     && 'Y'==sbd.mr_buff[4]
1486:  MOVF   xE7,W
1488:  SUBLW  52
148A:  BNZ   14AA
148C:  MOVF   xE8,W
148E:  SUBLW  45
1490:  BNZ   14AA
1492:  MOVF   xE9,W
1494:  SUBLW  41
1496:  BNZ   14AA
1498:  MOVF   xEA,W
149A:  SUBLW  44
149C:  BNZ   14AA
149E:  MOVF   xEB,W
14A0:  SUBLW  59
14A2:  BNZ   14AA
.................... 			    ) {
.................... 				sbd.mo_state++;
14A4:  MOVLB  6
14A6:  INCF   xC9,F
14A8:  MOVLB  8
.................... 			}
.................... 		
.................... 			/* clear mr because either we got READY or we got a bad response */
.................... 			iridium_mr_clear();				
14AA:  MOVLB  0
14AC:  CALL   0ABC
14B0:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 9 == sbd.mo_state ) {
14B2:  BRA    1742
14B4:  MOVLB  6
14B6:  MOVF   xC9,W
14B8:  SUBLW  09
14BA:  BNZ   1544
.................... 		/* send binary message and 2 byte checksum */
.................... 		iridium_mr_clear();
14BC:  MOVLB  0
14BE:  CALL   0ABC
.................... 		checksum=0;
14C2:  MOVLB  9
14C4:  CLRF   x7D
14C6:  CLRF   x7C
.................... 		/* send data bytes and update checksum */
.................... 		for ( l=0 ; l<sbd.mo_length ; l++ ) {
14C8:  CLRF   x7B
14CA:  CLRF   x7A
14CC:  MOVF   x7B,W
14CE:  MOVLB  7
14D0:  SUBWF  xDB,W
14D2:  BNC   1530
14D4:  BNZ   14E6
14D6:  MOVF   xDA,W
14D8:  MOVLB  9
14DA:  SUBWF  x7A,W
14DC:  BTFSS  FD8.0
14DE:  BRA    14E4
14E0:  MOVLB  7
14E2:  BRA    1530
14E4:  MOVLB  7
.................... 			uart_putc(sbd.mo_buff[l]);
14E6:  MOVLW  CA
14E8:  MOVLB  9
14EA:  ADDWF  x7A,W
14EC:  MOVWF  FE9
14EE:  MOVLW  06
14F0:  ADDWFC x7B,W
14F2:  MOVWF  FEA
14F4:  MOVFF  FEF,987
14F8:  MOVLB  0
14FA:  RCALL  0F14
.................... 			delay_us(500);
14FC:  CLRWDT
14FE:  MOVLW  02
1500:  MOVLB  9
1502:  MOVWF  x7E
1504:  MOVLW  F7
1506:  MOVWF  x7F
1508:  MOVLB  0
150A:  BRA    12A8
150C:  MOVLB  9
150E:  DECFSZ x7E,F
1510:  BRA    1504
.................... 			checksum += sbd.mo_buff[l];
1512:  MOVLW  CA
1514:  ADDWF  x7A,W
1516:  MOVWF  FE9
1518:  MOVLW  06
151A:  ADDWFC x7B,W
151C:  MOVWF  FEA
151E:  MOVF   FEF,W
1520:  ADDWF  x7C,F
1522:  MOVLW  00
1524:  ADDWFC x7D,F
1526:  INCF   x7A,F
1528:  BTFSC  FD8.2
152A:  INCF   x7B,F
152C:  BRA    14CC
152E:  MOVLB  7
.................... 		}
.................... 
.................... 		/* send checksum bytes */
.................... 		uart_putc(make8(checksum,1));
1530:  MOVFF  97D,987
1534:  MOVLB  0
1536:  RCALL  0F14
.................... 		uart_putc(make8(checksum,0));
1538:  MOVFF  97C,987
153C:  RCALL  0F14
.................... 
.................... 		sbd.mo_state++;
153E:  MOVLB  6
1540:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		
.................... 	} else if ( 10 == sbd.mo_state ) {
1542:  BRA    1740
1544:  MOVF   xC9,W
1546:  SUBLW  0A
1548:  BNZ   156C
.................... 		/* 
.................... 		receive response <Status> which means 
.................... 		
.................... 		0 => SBD message successfully written to the ISU.
.................... 
.................... 		1 => SBD message write timeout. An insufficient number of bytes were transferred 
.................... 		to ISU during the transfer period of 60 seconds.
.................... 
.................... 		2 => SBD message checksum sent from DTE does not match the checksum calculated at 
.................... 		the ISU.
.................... 
.................... 		3 => SBD message size is not correct. The maximum mobile originated SBD message 
.................... 		length is 340 bytes. The minimum mobile originated SBD message length is 1 byte.
.................... 		*/
.................... 
.................... 		/* status must be 0 */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
154A:  MOVLB  8
154C:  DECFSZ xE6,W
154E:  BRA    1568
.................... 			if ( '0'==sbd.mr_buff[0] ) {
1550:  MOVF   xE7,W
1552:  SUBLW  30
1554:  BNZ   155E
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
1556:  MOVLB  6
1558:  INCF   xC9,F
.................... 			} else {
155A:  BRA    1566
155C:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
155E:  MOVLB  0
1560:  CALL   0ABC
1564:  MOVLB  6
1566:  MOVLB  8
.................... 			}
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mo_state ) {
1568:  BRA    1742
156A:  MOVLB  6
156C:  MOVF   xC9,W
156E:  SUBLW  0B
1570:  BNZ   1596
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1572:  MOVLB  8
1574:  DECFSZ xE6,W
1576:  BRA    1592
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1578:  MOVF   xE7,W
157A:  SUBLW  4F
157C:  BNZ   158A
157E:  MOVF   xE8,W
1580:  SUBLW  4B
1582:  BNZ   158A
.................... 				sbd.mo_state++;
1584:  MOVLB  6
1586:  INCF   xC9,F
1588:  MOVLB  8
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
158A:  MOVLB  0
158C:  CALL   0ABC
1590:  MOVLB  8
.................... 		}
.................... 
.................... 	} else if ( 12 == sbd.mo_state ) {
1592:  BRA    1742
1594:  MOVLB  6
1596:  MOVF   xC9,W
1598:  SUBLW  0C
159A:  BNZ   15C2
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		/* send 'AT+SBDIX' to initiate Extended SBD Session */
.................... 
.................... 		if ( sbd.mo_try > 0 && 0 != sbd.mo_sbdix_wait ) {
159C:  MOVLB  7
159E:  MOVF   xDC,F
15A0:  BZ    15AC
15A2:  MOVF   xDD,F
15A4:  BZ    15AC
.................... 			/* external function decrements sbd.mo_sbdix_wait once per second */
.................... 			return;
15A6:  MOVLB  6
15A8:  BRA    1746
15AA:  MOVLB  7
.................... 		}
.................... 
.................... 		iridium_mr_clear();
15AC:  MOVLB  0
15AE:  CALL   0ABC
.................... 		printf(uart_putc,"AT+SBDIX\r");
15B2:  MOVLW  32
15B4:  MOVWF  FF6
15B6:  MOVLW  04
15B8:  MOVWF  FF7
15BA:  RCALL  0F24
.................... 		sbd.mo_state++;
15BC:  MOVLB  6
15BE:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 13 == sbd.mo_state ) {
15C0:  BRA    1740
15C2:  MOVF   xC9,W
15C4:  SUBLW  0D
15C6:  BNZ   1654
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		/*
.................... 		receive response:
.................... 			 +SBDIX: <MO status>, <MOMSN>, <MT status>, <MTMSN>, <MT length>, <MT queued>
.................... 		which means
.................... 
.................... 		<MO status> - Any returned number with a value of 0 to 2 indicates your message 
.................... 		has been successfully transmitted. Any number above 2 indicates that the message 
.................... 		has not been successfully transmitted.
.................... 
.................... 		Per rock7 website (https://docs.rockblock.rock7.com/reference/sbdix):
.................... 		0	MO message, if any, transferred successfully.
.................... 		1	MO message, if any, transferred successfully, but the MT message in the queue was too big to be transferred.
.................... 		2	MO message, if any, transferred successfully, but the requested Location Update was not accepted.
.................... 		3 .. 4	Reserved, but indicate MO session success if used.
.................... 		5 .. 8	Reserved, but indicate MO session failure if used.
.................... 		10	GSS reported that the call did not complete in the allowed time.
.................... 		11	MO message queue at the GSS is full.
.................... 		12	MO message has too many segments.
.................... 		13	GSS reported that the session did not complete.
.................... 		14	Invalid segment size.
.................... 		15	Access is denied.
.................... 		16	ISU has been locked and may not make SBD calls (see +CULK command).
.................... 		17	Gateway not responding (local session timeout).
.................... 		18	Connection lost (RF drop).
.................... 		19	Link failure (A protocol error caused termination of the call).
.................... 		20 .. 31	Reserved, but indicate failure if used.
.................... 		32	No network service, unable to initiate call.
.................... 		33	Antenna fault, unable to initiate call.
.................... 		34	Radio is disabled, unable to initiate call (see *Rn command).
.................... 		35	ISU is busy, unable to initiate call.
.................... 		36	Try later, must wait 3 minutes since last registration.
.................... 		37	SBD service is temporarily disabled.
.................... 		38	Try later, traffic management period (see +SBDLOE command)
.................... 		39 .. 63	Reserved, but indicate failure if used.
.................... 		64	Band violation (attempt to transmit outside permitted frequency band).
.................... 		65	PLL lock failure; hardware error during attempted transmit.
.................... 
.................... 		<MOMSN> - This number denotes the MO message number and cycles between 0 and 65535.
.................... 
.................... 		<MT status>
.................... 			0 => No messages waiting to be received.
.................... 			1 => New message successfully received.
.................... 			2 => Error during mailbox check / message reception.
.................... 
.................... 		<MTMSN> - This number denotes the MT message number and cycles between 0 and 65535.
.................... 
.................... 		<MT length> - The size (in bytes) of the MT message.
.................... 
.................... 		<MT queued> - The number of MT messages in the queue waiting to be downloaded.
.................... 
.................... 		+SBDIX:32,22, 2, 0, 0, 0
....................         012345678901234567890123
....................         0         1         2
.................... 		*/
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
15C8:  MOVLB  8
15CA:  DECFSZ xE6,W
15CC:  BRA    1650
.................... 			if ( '+'==sbd.mr_buff[0] && 'S'==sbd.mr_buff[1] &&
.................... 			     'B'==sbd.mr_buff[2] && 'D'==sbd.mr_buff[3] &&
.................... 			     'I'==sbd.mr_buff[4] && 'X'==sbd.mr_buff[5] 
15CE:  MOVF   xE7,W
15D0:  SUBLW  2B
15D2:  BNZ   1648
15D4:  MOVF   xE8,W
15D6:  SUBLW  53
15D8:  BNZ   1648
15DA:  MOVF   xE9,W
15DC:  SUBLW  42
15DE:  BNZ   1648
15E0:  MOVF   xEA,W
15E2:  SUBLW  44
15E4:  BNZ   1648
15E6:  MOVF   xEB,W
15E8:  SUBLW  49
15EA:  BNZ   1648
15EC:  MOVF   xEC,W
15EE:  SUBLW  58
15F0:  BNZ   1648
.................... 			) {
.................... 				/* copy +SBDIX result to seperate buffer so it can be further processed for message downloading */
.................... 				if ( '\0' == sbd.sbdix_response[0] ) {
15F2:  MOVLB  6
15F4:  MOVF   x96,F
15F6:  BNZ   1618
.................... 					strncpy(sbd.sbdix_response,sbd.mr_buff,sizeof(sbd.sbdix_response)-1);
15F8:  MOVLW  06
15FA:  MOVLB  9
15FC:  MOVWF  x7F
15FE:  MOVLW  96
1600:  MOVWF  x7E
1602:  MOVLW  08
1604:  MOVWF  x81
1606:  MOVLW  E7
1608:  MOVWF  x80
160A:  CLRF   x83
160C:  MOVLW  29
160E:  MOVWF  x82
1610:  MOVLB  0
1612:  BRA    12CE
.................... 					sbd.sbdix_response[sizeof(sbd.sbdix_response)-1]='\0';
1614:  MOVLB  6
1616:  CLRF   xBF
.................... 				}
.................... 
.................... 
.................... 				/* so we got an +SBDIX response. If first byte ([8]) is '0', '1', '2' and second byte ([9]) is ',' 
.................... 				we are okay to proceed and clear buffer. If it is anything else, we need to wait and try again */
.................... 				/* TODO: white space location / pading may not be consistent. Use atoi style parsing to determine MO_STATUS reliably */
.................... 				if ( ' '==sbd.mr_buff[7] && ( sbd.mr_buff[8] >= '0' && sbd.mr_buff[8] <= '2'  && ',' == sbd.mr_buff[9]) ) {
1618:  MOVLB  8
161A:  MOVF   xEE,W
161C:  SUBLW  20
161E:  BNZ   163E
1620:  MOVF   xEF,W
1622:  SUBLW  2F
1624:  BC    163E
1626:  MOVF   xEF,W
1628:  SUBLW  32
162A:  BNC   163E
162C:  MOVF   xF0,W
162E:  SUBLW  2C
1630:  BNZ   163E
.................... 					sbd.mo_state++;
1632:  MOVLB  6
1634:  INCF   xC9,F
.................... 					sbd.mo_try=0;
1636:  MOVLB  7
1638:  CLRF   xDC
.................... 				} else {
163A:  BRA    1646
163C:  MOVLB  8
.................... 					/* didn't get a 0 or 1 or 2 ... but still go on to next state for OK */
.................... 					sbd.mo_state++;
163E:  MOVLB  6
1640:  INCF   xC9,F
.................... 					sbd.mo_try++;
1642:  MOVLB  7
1644:  INCF   xDC,F
1646:  MOVLB  8
.................... 				}
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
1648:  MOVLB  0
164A:  CALL   0ABC
164E:  MOVLB  8
.................... 		}
.................... 	} else if ( 14 == sbd.mo_state ) {
1650:  BRA    1742
1652:  MOVLB  6
1654:  MOVF   xC9,W
1656:  SUBLW  0E
1658:  BNZ   16C4
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u start\r\n",sbd.mo_state,sbd.mo_try);
.................... #endif
.................... 
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
165A:  MOVLB  8
165C:  DECFSZ xE6,W
165E:  BRA    167A
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1660:  MOVF   xE7,W
1662:  SUBLW  4F
1664:  BNZ   1672
1666:  MOVF   xE8,W
1668:  SUBLW  4B
166A:  BNZ   1672
.................... 				sbd.mo_state++;
166C:  MOVLB  6
166E:  INCF   xC9,F
1670:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
1672:  MOVLB  0
1674:  CALL   0ABC
1678:  MOVLB  8
.................... 		}
.................... 
.................... 		if ( 0 != sbd.mo_try ) {
167A:  MOVLB  7
167C:  MOVF   xDC,F
167E:  BZ    16C0
.................... 			/* need to try SBDIX again */
.................... 			sbd.mo_state=12;
1680:  MOVLW  0C
1682:  MOVLB  6
1684:  MOVWF  xC9
.................... 			/* back off */
.................... 			if ( 1 == sbd.mo_try || 2 == sbd.mo_try ) {
1686:  MOVLB  7
1688:  DECFSZ xDC,W
168A:  BRA    168E
168C:  BRA    1694
168E:  MOVF   xDC,W
1690:  SUBLW  02
1692:  BNZ   169A
.................... 				sbd.mo_sbdix_wait=3;
1694:  MOVLW  03
1696:  MOVWF  xDD
.................... 			} else if ( 3 == sbd.mo_try || 4 == sbd.mo_try ) {
1698:  BRA    16C0
169A:  MOVF   xDC,W
169C:  SUBLW  03
169E:  BZ    16A6
16A0:  MOVF   xDC,W
16A2:  SUBLW  04
16A4:  BNZ   16AC
.................... 				sbd.mo_sbdix_wait=21;
16A6:  MOVLW  15
16A8:  MOVWF  xDD
.................... 			} else if ( 5 == sbd.mo_try ) {
16AA:  BRA    16C0
16AC:  MOVF   xDC,W
16AE:  SUBLW  05
16B0:  BNZ   16B8
.................... 				sbd.mo_sbdix_wait=251;
16B2:  MOVLW  FB
16B4:  MOVWF  xDD
.................... 			} else {
16B6:  BRA    16C0
.................... 				/* give up and clear buffer */
.................... 				sbd.mo_state=15;
16B8:  MOVLW  0F
16BA:  MOVLB  6
16BC:  MOVWF  xC9
16BE:  MOVLB  7
.................... 			}
.................... 		}
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u finish\r\n",sbd.mo_state,sbd.mo_try);
.................... #endif
.................... 	} else if ( 15 == sbd.mo_state ) {
16C0:  BRA    1744
16C2:  MOVLB  6
16C4:  MOVF   xC9,W
16C6:  SUBLW  0F
16C8:  BNZ   16E0
.................... 
.................... 		/* send 'AT+SBDD=0' to clear MO buffer */
.................... 		iridium_mr_clear();
16CA:  MOVLB  0
16CC:  CALL   0ABC
.................... 		printf(uart_putc,"AT+SBDD0\r");
16D0:  MOVLW  3C
16D2:  MOVWF  FF6
16D4:  MOVLW  04
16D6:  MOVWF  FF7
16D8:  RCALL  0F24
.................... 		sbd.mo_state++;
16DA:  MOVLB  6
16DC:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		/* TODO ... be careful about starting over without buffer being cleared */
.................... 	} else if ( 16 == sbd.mo_state ) {
16DE:  BRA    1740
16E0:  MOVF   xC9,W
16E2:  SUBLW  10
16E4:  BNZ   1708
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		if ( 1 == sbd.mr_ready ) {
16E6:  MOVLB  8
16E8:  DECFSZ xE6,W
16EA:  BRA    1704
.................... 			if ( '0'==sbd.mr_buff[0] ) {
16EC:  MOVF   xE7,W
16EE:  SUBLW  30
16F0:  BNZ   16FA
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
16F2:  MOVLB  6
16F4:  INCF   xC9,F
.................... 			} else {
16F6:  BRA    1702
16F8:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
16FA:  MOVLB  0
16FC:  CALL   0ABC
1700:  MOVLB  6
1702:  MOVLB  8
.................... 			}
.................... 		}
.................... 	} else if ( 17 == sbd.mo_state ) {
1704:  BRA    1742
1706:  MOVLB  6
1708:  MOVF   xC9,W
170A:  SUBLW  11
170C:  BNZ   1732
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
170E:  MOVLB  8
1710:  DECFSZ xE6,W
1712:  BRA    172E
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1714:  MOVF   xE7,W
1716:  SUBLW  4F
1718:  BNZ   1726
171A:  MOVF   xE8,W
171C:  SUBLW  4B
171E:  BNZ   1726
.................... 				sbd.mo_state++;
1720:  MOVLB  6
1722:  INCF   xC9,F
1724:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
1726:  MOVLB  0
1728:  CALL   0ABC
172C:  MOVLB  8
.................... 		}
.................... 	} else if ( 18 == sbd.mo_state ) {
172E:  BRA    1742
1730:  MOVLB  6
1732:  MOVF   xC9,W
1734:  SUBLW  12
1736:  BNZ   1740
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 
.................... 		/* done sending */
.................... 		/* download MT if needed? */
.................... 		/* turn off modem */
.................... //		iridium_off();
.................... 
.................... 		/* go back to waiting */
.................... 		iridium_mr_clear();
1738:  MOVLB  0
173A:  CALL   0ABC
.................... 		iridium_mo_clear();	
173E:  RCALL  1356
1740:  MOVLB  8
1742:  MOVLB  7
1744:  MOVLB  6
.................... 	}
1746:  MOVLB  0
1748:  GOTO   37A4 (RETURN)
.................... }
.................... 
.................... void iridium_mt_receive(void) {
.................... 	int8 c;
.................... 	static int16 l;
.................... 	static int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mt_receive() sbd.mt_state=%u\r\n",sbd.mt_state);
.................... #endif
.................... 
.................... 
.................... 	if ( sbd.mt_state <= 1 ) {
*
0F44:  MOVLB  7
0F46:  MOVF   xDF,W
0F48:  SUBLW  01
0F4A:  BNC   0F62
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
0F4C:  MOVLB  0
0F4E:  RCALL  0ABC
.................... 		printf(uart_putc,"ATE0\r");
0F50:  MOVLW  46
0F52:  MOVWF  FF6
0F54:  MOVLW  04
0F56:  MOVWF  FF7
0F58:  RCALL  0F24
.................... 		sbd.mt_state = 2;
0F5A:  MOVLW  02
0F5C:  MOVLB  7
0F5E:  MOVWF  xDF
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mt_state ) {
0F60:  BRA    11AE
0F62:  MOVF   xDF,W
0F64:  SUBLW  02
0F66:  BNZ   0F8A
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
0F68:  MOVLB  8
0F6A:  DECFSZ xE6,W
0F6C:  BRA    0F86
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
0F6E:  MOVF   xE7,W
0F70:  SUBLW  4F
0F72:  BNZ   0F80
0F74:  MOVF   xE8,W
0F76:  SUBLW  4B
0F78:  BNZ   0F80
.................... 				sbd.mt_state++;
0F7A:  MOVLB  7
0F7C:  INCF   xDF,F
0F7E:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
0F80:  MOVLB  0
0F82:  RCALL  0ABC
0F84:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mt_state ) {
0F86:  BRA    11AE
0F88:  MOVLB  7
0F8A:  MOVF   xDF,W
0F8C:  SUBLW  03
0F8E:  BNZ   0FA4
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
0F90:  MOVLB  0
0F92:  RCALL  0ABC
.................... 		printf(uart_putc,"AT&K0\r");
0F94:  MOVLW  4C
0F96:  MOVWF  FF6
0F98:  MOVLW  04
0F9A:  MOVWF  FF7
0F9C:  RCALL  0F24
.................... 		sbd.mt_state++;
0F9E:  MOVLB  7
0FA0:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mt_state ) {
0FA2:  BRA    11AE
0FA4:  MOVF   xDF,W
0FA6:  SUBLW  04
0FA8:  BNZ   0FCC
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
0FAA:  MOVLB  8
0FAC:  DECFSZ xE6,W
0FAE:  BRA    0FC8
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
0FB0:  MOVF   xE7,W
0FB2:  SUBLW  4F
0FB4:  BNZ   0FC2
0FB6:  MOVF   xE8,W
0FB8:  SUBLW  4B
0FBA:  BNZ   0FC2
.................... 				sbd.mt_state++;
0FBC:  MOVLB  7
0FBE:  INCF   xDF,F
0FC0:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
0FC2:  MOVLB  0
0FC4:  RCALL  0ABC
0FC6:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mt_state ) {
0FC8:  BRA    11AE
0FCA:  MOVLB  7
0FCC:  MOVF   xDF,W
0FCE:  SUBLW  05
0FD0:  BNZ   0FE6
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
0FD2:  MOVLB  0
0FD4:  RCALL  0ABC
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
0FD6:  MOVLW  54
0FD8:  MOVWF  FF6
0FDA:  MOVLW  04
0FDC:  MOVWF  FF7
0FDE:  RCALL  0F24
.................... 		sbd.mt_state++;
0FE0:  MOVLB  7
0FE2:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mt_state ) {
0FE4:  BRA    11AE
0FE6:  MOVF   xDF,W
0FE8:  SUBLW  06
0FEA:  BNZ   100E
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
0FEC:  MOVLB  8
0FEE:  DECFSZ xE6,W
0FF0:  BRA    100A
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
0FF2:  MOVF   xE7,W
0FF4:  SUBLW  4F
0FF6:  BNZ   1004
0FF8:  MOVF   xE8,W
0FFA:  SUBLW  4B
0FFC:  BNZ   1004
.................... 				sbd.mt_state++;
0FFE:  MOVLB  7
1000:  INCF   xDF,F
1002:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1004:  MOVLB  0
1006:  RCALL  0ABC
1008:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mt_state ) {
100A:  BRA    11AE
100C:  MOVLB  7
100E:  MOVF   xDF,W
1010:  SUBLW  07
1012:  BNZ   1030
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDRB' to tell modem to send us our MT */
.................... 		iridium_mr_clear();
1014:  MOVLB  0
1016:  RCALL  0ABC
.................... 		sbd.mr_disable=1; /* switch iridum character receiver to binary */
1018:  MOVLW  01
101A:  MOVLB  9
101C:  MOVWF  x28
.................... 		printf(uart_putc,"AT+SBDRB\r");
101E:  MOVLW  62
1020:  MOVWF  FF6
1022:  MOVLW  04
1024:  MOVWF  FF7
1026:  MOVLB  0
1028:  RCALL  0F24
.................... 		sbd.mt_state++;
102A:  MOVLB  7
102C:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mt_state ) {
102E:  BRA    11AE
1030:  MOVF   xDF,W
1032:  SUBLW  08
1034:  BNZ   1058
.................... 		/* receive first byte of length */
.................... 		if ( ! uart_kbhit() ) {
1036:  MOVLB  0
1038:  RCALL  0E4E
103A:  MOVF   01,F
103C:  BNZ   1040
.................... 			/* no character available */
.................... 			return;
103E:  BRA    11B0
.................... 		}
.................... 	
.................... 		sbd.mt_length=make16(uart_getc(),0);
*
104A:  MOVFF  01,8E1
104E:  MOVLB  8
1050:  CLRF   xE0
.................... 		sbd.mt_state++;
1052:  MOVLB  7
1054:  INCF   xDF,F
.................... 	} else if ( 9 == sbd.mt_state ) {
1056:  BRA    11AE
1058:  MOVF   xDF,W
105A:  SUBLW  09
105C:  BNZ   108E
.................... 		/* receive second byte of length */
.................... 		if ( ! uart_kbhit() ) {
105E:  MOVLB  0
1060:  RCALL  0E4E
1062:  MOVF   01,F
1064:  BNZ   1068
.................... 			/* no character available */
.................... 			return;
1066:  BRA    11B0
.................... 		}
.................... 	
.................... 		sbd.mt_length += uart_getc();
*
1072:  MOVF   01,W
1074:  MOVLB  8
1076:  ADDWF  xE0,F
1078:  MOVLW  00
107A:  ADDWFC xE1,F
.................... 		sbd.mt_state++;
107C:  MOVLB  7
107E:  INCF   xDF,F
.................... 
.................... 		checksum=0;
1080:  MOVLB  9
1082:  CLRF   x2E
1084:  CLRF   x2D
.................... 		l=0;
1086:  CLRF   x2C
1088:  CLRF   x2B
.................... 	} else if ( 10 == sbd.mt_state ) {
108A:  BRA    11B0
108C:  MOVLB  7
108E:  MOVF   xDF,W
1090:  SUBLW  0A
1092:  BNZ   10FE
.................... 		/* receive MT length of characters and calculate checksum */
.................... 		if ( ! uart_kbhit() ) {
1094:  MOVLB  0
1096:  RCALL  0E4E
1098:  MOVF   01,F
109A:  BNZ   109E
.................... 			/* no character available */
.................... 			return;
109C:  BRA    11B0
.................... 		}
.................... 
.................... 		if ( 0 == sbd.mt_length ) {
109E:  MOVLB  8
10A0:  MOVF   xE0,F
10A2:  BNZ   10B2
10A4:  MOVF   xE1,F
10A6:  BNZ   10B2
.................... 			/* zero byte message skips this state */
.................... 			sbd.mt_state++;
10A8:  MOVLB  7
10AA:  INCF   xDF,F
.................... 			return;
10AC:  MOVLB  0
10AE:  BRA    11B0
10B0:  MOVLB  8
.................... 		}
.................... 
.................... 		c = uart_getc();
*
10BC:  MOVFF  01,97A
.................... 		sbd.mt_buff[l]=c;
10C0:  MOVLW  E0
10C2:  MOVLB  9
10C4:  ADDWF  x2B,W
10C6:  MOVWF  FE9
10C8:  MOVLW  07
10CA:  ADDWFC x2C,W
10CC:  MOVWF  FEA
10CE:  MOVFF  97A,FEF
.................... 		checksum += c;
10D2:  MOVF   x7A,W
10D4:  ADDWF  x2D,F
10D6:  MOVLW  00
10D8:  ADDWFC x2E,F
.................... 		l++;
10DA:  INCF   x2B,F
10DC:  BTFSC  FD8.2
10DE:  INCF   x2C,F
.................... 
.................... 		if ( l == sbd.mt_length ) {
10E0:  MOVLB  8
10E2:  MOVF   xE0,W
10E4:  MOVLB  9
10E6:  SUBWF  x2B,W
10E8:  BNZ   10FA
10EA:  MOVLB  8
10EC:  MOVF   xE1,W
10EE:  MOVLB  9
10F0:  SUBWF  x2C,W
10F2:  BNZ   10FA
.................... 			/* received right number of characters */
.................... 			sbd.mt_state++;
10F4:  MOVLB  7
10F6:  INCF   xDF,F
10F8:  MOVLB  9
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mt_state ) {
10FA:  BRA    11B0
10FC:  MOVLB  7
10FE:  MOVF   xDF,W
1100:  SUBLW  0B
1102:  BNZ   1126
.................... 		if ( ! uart_kbhit() ) {
1104:  MOVLB  0
1106:  RCALL  0E4E
1108:  MOVF   01,F
110A:  BNZ   110E
.................... 			/* no character available */
.................... 			return;
110C:  BRA    11B0
.................... 		}
.................... 
.................... 		/* high byte of checksum */
.................... 		l=make16(uart_getc(),0);
*
1118:  MOVFF  01,92C
111C:  MOVLB  9
111E:  CLRF   x2B
.................... 		sbd.mt_state++;
1120:  MOVLB  7
1122:  INCF   xDF,F
.................... 	} else if ( 12 == sbd.mt_state ) {
1124:  BRA    11AE
1126:  MOVF   xDF,W
1128:  SUBLW  0C
112A:  BNZ   1156
.................... 		if ( ! uart_kbhit() ) {
112C:  MOVLB  0
112E:  RCALL  0E4E
1130:  MOVF   01,F
1132:  BNZ   1136
.................... 			/* no character available */
.................... 			return;
1134:  BRA    11B0
.................... 		}
.................... 
.................... 		/* low byte of checksum */
.................... 		l += uart_getc();
*
1140:  MOVF   01,W
1142:  MOVLB  9
1144:  ADDWF  x2B,F
1146:  MOVLW  00
1148:  ADDWFC x2C,F
.................... 		sbd.mt_state++;
114A:  MOVLB  7
114C:  INCF   xDF,F
.................... 
.................... 		sbd.mr_disable=0;
114E:  MOVLB  9
1150:  CLRF   x28
.................... 	} else if ( 13 == sbd.mt_state ) {
1152:  BRA    11B0
1154:  MOVLB  7
1156:  MOVF   xDF,W
1158:  SUBLW  0D
115A:  BNZ   1178
.................... 		/* compare local and remote checksum */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mt_receive() checksum l=%lu r=%lu\r\n",checksum,l);
.................... #endif
.................... 
.................... 		if ( checksum == l ) {
115C:  MOVLB  9
115E:  MOVF   x2B,W
1160:  SUBWF  x2D,W
1162:  BNZ   1172
1164:  MOVF   x2C,W
1166:  SUBWF  x2E,W
1168:  BNZ   1172
.................... 			/* checksums matched, we have a good message! */
.................... 			sbd.mt_ready=1;
116A:  MOVLW  01
116C:  MOVLB  7
116E:  MOVWF  xDE
1170:  MOVLB  9
.................... 
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# iridium_mt_receive() mt_ready=1, here is our message:\r\n");
.................... 			for ( l=0 ; l<sbd.mt_length ; l++ ) {
.................... 				fprintf(STREAM_WORLD,"# mt_buff[%lu]=%c\r\n",l,sbd.mt_buff[l]);
.................... 			}
.................... #endif
.................... 		}
.................... 
.................... 		/* even if we have a bad checksum, we advance to next state and watch for OK */
.................... 		sbd.mt_state++;
1172:  MOVLB  7
1174:  INCF   xDF,F
.................... 
.................... 	} else if ( 14 == sbd.mt_state ) {
1176:  BRA    11AE
1178:  MOVF   xDF,W
117A:  SUBLW  0E
117C:  BNZ   11A0
.................... 		/* 
.................... 		Iridium reference manual says:
.................... 		"There are no response codes generated by the ISU for this command".
.................... 		But it does, in fact, give an "OK" (0x0D 0x0A 0x4F 0x4B 0x0D 0x0A) 
.................... 		about 2.7ms after finishing send the SBD data 
.................... 		*/
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
117E:  MOVLB  8
1180:  DECFSZ xE6,W
1182:  BRA    119C
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1184:  MOVF   xE7,W
1186:  SUBLW  4F
1188:  BNZ   1196
118A:  MOVF   xE8,W
118C:  SUBLW  4B
118E:  BNZ   1196
.................... 				sbd.mt_state++;
1190:  MOVLB  7
1192:  INCF   xDF,F
1194:  MOVLB  8
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# iridium_mt_receive() got final OK\r\n");
.................... #endif
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1196:  MOVLB  0
1198:  RCALL  0ABC
119A:  MOVLB  8
.................... 		}	
.................... 	} else if ( 15 == sbd.mt_state ) {
119C:  BRA    11AE
119E:  MOVLB  7
11A0:  MOVF   xDF,W
11A2:  SUBLW  0F
11A4:  BNZ   11AE
.................... 		/* message has processed */
.................... 		sbd.sbdix_mt_status=0;
11A6:  MOVLB  6
11A8:  CLRF   xC3
.................... 		sbd.mt_state=0;
11AA:  MOVLB  7
11AC:  CLRF   xDF
11AE:  MOVLB  9
11B0:  MOVLB  0
.................... 	}
11B2:  GOTO   378C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #if 0
.................... 			/* if not using RING ALERT through the UART, we can do this */
.................... 			/* check if RING ALERT is active via the !CTS pin connected to RING ALERT line on the SBD modem */
.................... 			if ( bit_test(uart_read(UART_MSR),4) ) {
.................... 				sbd.ring_flag=1;
.................... 			}
.................... #endif
.................... 
.................... #include "interrupt_rdTap.c"
.................... /* int_timer2 in modbus_int_uart.c */
.................... 
.................... #int_timer4
.................... void isr_10ms(void) {
.................... 	static int8 sc=0;
.................... 	static int16 li=0;
.................... 
.................... 	/* once per second */
.................... 	sc++;
*
046C:  MOVLB  9
046E:  INCF   x2F,F
.................... 	if ( 100==sc ) {
0470:  MOVF   x2F,W
0472:  SUBLW  64
0474:  BNZ   04AA
.................... 		sc=0;
0476:  CLRF   x2F
.................... 
.................... 		li++;
0478:  INCF   x30,F
047A:  BTFSC  FD8.2
047C:  INCF   x31,F
.................... 		if ( li >= config.live_interval ) {
047E:  MOVLB  5
0480:  MOVF   x87,W
0482:  MOVLB  9
0484:  SUBWF  x31,W
0486:  BNC   04A0
0488:  BNZ   0494
048A:  MOVLB  5
048C:  MOVF   x86,W
048E:  MOVLB  9
0490:  SUBWF  x30,W
0492:  BNC   04A0
.................... 			li=0;
0494:  CLRF   x31
0496:  CLRF   x30
.................... 			timers.now_poll=1;
0498:  MOVLW  01
049A:  MOVLB  3
049C:  MOVWF  x61
049E:  MOVLB  9
.................... 		}
.................... 
.................... 
.................... 		if ( sbd.mo_sbdix_wait > 0 ) {
04A0:  MOVLB  7
04A2:  MOVF   xDD,F
04A4:  BZ    04A8
.................... 			sbd.mo_sbdix_wait--;
04A6:  DECF   xDD,F
04A8:  MOVLB  9
.................... 		}
.................... 	}
.................... 
.................... 	if ( timers.world_timeout < 255 ) {
04AA:  MOVLB  3
04AC:  INCFSZ x62,W
04AE:  BRA    04B2
04B0:  BRA    04B4
.................... 		timers.world_timeout++;
04B2:  INCF   x62,F
.................... 	}
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
04B4:  MOVF   x64,F
04B6:  BNZ   04BE
.................... 		output_low(LED_GREEN);
04B8:  BCF    F93.5
04BA:  BCF    F8A.5
.................... 	} else {
04BC:  BRA    04C4
.................... 		output_high(LED_GREEN);
04BE:  BCF    F93.5
04C0:  BSF    F8A.5
.................... 		timers.led_on_green--;
04C2:  DECF   x64,F
.................... 	}
.................... 
.................... }
.................... 
.................... 
.................... /* int_rda in modbus_int_uart.c */
.................... 
04C4:  BCF    FB7.7
04C6:  MOVLB  0
04C8:  GOTO   0084
.................... #int_rda2
.................... void isr_world(void) {
.................... 	static int8 pre[5];
.................... 
.................... 
.................... 
.................... 	if ( query.buff_ready ) {
*
04E2:  MOVLB  5
04E4:  MOVF   x6D,F
04E6:  BZ    04EE
.................... 		/* throw out data received while processing previous query */
.................... 		fgetc(STREAM_WORLD);
04E8:  MOVLB  0
04EA:  RCALL  04CC
04EC:  MOVLB  5
.................... 	}
.................... 
.................... 	/* timeout after 100 milliseconds */
.................... 	if ( timers.world_timeout > 10 ) {
04EE:  MOVLB  3
04F0:  MOVF   x62,W
04F2:  SUBLW  0A
04F4:  BC    04FC
.................... 		query.buff_pos=0;
04F6:  MOVLB  5
04F8:  CLRF   x6C
04FA:  MOVLB  3
.................... //		output_toggle(LED_RED);
.................... 	}
.................... 	timers.world_timeout=0;
04FC:  CLRF   x62
.................... 
.................... 	if ( 0 == query.buff_pos ) {
04FE:  MOVLB  5
0500:  MOVF   x6C,F
0502:  BNZ   0574
.................... 		pre[0]=pre[1];
0504:  MOVFF  933,932
.................... 		pre[1]=pre[2];
0508:  MOVFF  934,933
.................... 		pre[2]=pre[3];
050C:  MOVFF  935,934
.................... 		pre[3]=pre[4];
0510:  MOVFF  936,935
.................... 		pre[4]=fgetc(STREAM_WORLD);
0514:  MOVLB  0
0516:  RCALL  04CC
0518:  MOVFF  01,936
.................... 
.................... 		/* packet addressed to us */
.................... 		if ( '#'==pre[0] && config.serial_prefix==pre[1] && config.serial_number==make16(pre[2],pre[3]) ) {
051C:  MOVLB  9
051E:  MOVF   x32,W
0520:  SUBLW  23
0522:  BNZ   0570
0524:  MOVF   x33,W
0526:  MOVLB  5
0528:  SUBWF  x83,W
052A:  BTFSC  FD8.2
052C:  BRA    0532
052E:  MOVLB  9
0530:  BRA    0570
0532:  MOVFF  934,03
0536:  MOVLB  9
0538:  MOVF   x35,W
053A:  MOVLB  5
053C:  SUBWF  x84,W
053E:  BTFSC  FD8.2
0540:  BRA    0546
0542:  MOVLB  9
0544:  BRA    0570
0546:  MOVF   03,W
0548:  SUBWF  x85,W
054A:  BTFSC  FD8.2
054C:  BRA    0552
054E:  MOVLB  9
0550:  BRA    0570
.................... 			output_high(CTRL_1);
0552:  BCF    F92.1
0554:  BSF    F89.1
.................... 			query.buff[0]=pre[0];
0556:  MOVFF  932,46C
.................... 			query.buff[1]=pre[1];
055A:  MOVFF  933,46D
.................... 			query.buff[2]=pre[2];
055E:  MOVFF  934,46E
.................... 			query.buff[3]=pre[3];
0562:  MOVFF  935,46F
.................... 			query.buff[4]=pre[4];
0566:  MOVFF  936,470
.................... 			query.buff_pos=5;
056A:  MOVLW  05
056C:  MOVWF  x6C
056E:  MOVLB  9
.................... 		}
.................... 	} else {
0570:  BRA    05B0
0572:  MOVLB  5
.................... 		query.buff[query.buff_pos++]=fgetc(STREAM_WORLD);
0574:  MOVF   x6C,W
0576:  INCF   x6C,F
0578:  ADDLW  6C
057A:  MOVWF  FE9
057C:  MOVLW  04
057E:  MOVWF  FEA
0580:  BTFSC  FD8.0
0582:  INCF   FEA,F
0584:  MOVFF  FEA,99E
0588:  MOVFF  FE9,99D
058C:  MOVLB  0
058E:  RCALL  04CC
0590:  MOVFF  99E,FEA
0594:  MOVFF  99D,FE9
0598:  MOVFF  01,FEF
.................... 
.................... 		if ( query.buff_pos == query.buff[4] ) {
059C:  MOVLB  4
059E:  MOVF   x70,W
05A0:  MOVLB  5
05A2:  SUBWF  x6C,W
05A4:  BNZ   05AE
.................... 			output_toggle(CTRL_1);
05A6:  BCF    F92.1
05A8:  BTG    F89.1
.................... 			query.buff_ready=1;
05AA:  MOVLW  01
05AC:  MOVWF  x6D
05AE:  MOVLB  9
.................... 		}
.................... 	}
.................... }
.................... 
05B0:  BCF    FA4.5
05B2:  MOVLB  0
05B4:  GOTO   0084
.................... #include "live_rdTap.c"
.................... /* pass reg_crc value of 0xFFFF to reset */
.................... int16 crc_chk_pass(int16 reg_crc, int8 *data, int8 length) {
.................... 	int8 j;
.................... 	
.................... 	while ( length-- ) {
*
1930:  MOVLB  9
1932:  MOVF   x97,W
1934:  DECF   x97,F
1936:  XORLW  00
1938:  BZ    1982
.................... 		reg_crc ^= *data++;
193A:  MOVFF  996,FEA
193E:  MOVF   x95,W
1940:  INCF   x95,F
1942:  BTFSC  FD8.2
1944:  INCF   x96,F
1946:  MOVWF  FE9
1948:  MOVF   FEF,W
194A:  XORWF  x93,F
.................... 
.................... 		for ( j=0 ; j<8 ; j++ ) {
194C:  CLRF   x98
194E:  MOVF   x98,W
1950:  SUBLW  07
1952:  BNC   1980
.................... 			if ( reg_crc & 0x01 ) {
1954:  MOVF   x93,W
1956:  ANDLW  01
1958:  MOVWF  00
195A:  CLRF   03
195C:  MOVF   00,W
195E:  IORWF  03,W
1960:  BZ    1976
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001;
1962:  BCF    FD8.0
1964:  RRCF   x94,W
1966:  MOVWF  x9A
1968:  RRCF   x93,W
196A:  XORLW  01
196C:  MOVWF  x93
196E:  MOVF   x9A,W
1970:  XORLW  A0
1972:  MOVWF  x94
.................... 			} else {
1974:  BRA    197C
.................... 				reg_crc=reg_crc>>1;
1976:  BCF    FD8.0
1978:  RRCF   x94,F
197A:  RRCF   x93,F
.................... 			}
197C:  INCF   x98,F
197E:  BRA    194E
.................... 		}	
1980:  BRA    1932
.................... 	}
.................... 	
.................... 	return reg_crc;
1982:  MOVFF  993,01
1986:  MOVFF  994,02
198A:  MOVLB  0
198C:  RETURN 0
.................... }
.................... 
.................... void live_send(void) {
.................... 	int16 lCRC;
.................... 	int8 i;
.................... 	int8 buff[17];
.................... 	int16 completeLength;
.................... 
.................... 	completeLength=sizeof(buff) + qbuff.rResultLength + 2;
*
1996:  MOVLW  11
1998:  MOVLB  4
199A:  ADDWF  x68,W
199C:  ADDLW  02
199E:  MOVLB  9
19A0:  MOVWF  x91
19A2:  CLRF   x92
19A4:  BTFSC  FD8.0
19A6:  INCF   x92,F
.................... 
.................... 	buff[0]='#';
19A8:  MOVLW  23
19AA:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
19AC:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
19B0:  MOVFF  585,982
19B4:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0); 
19B6:  MOVFF  584,983
19BA:  MOVLB  9
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */
19BC:  SETF   x84
.................... 	buff[5]=18; /* packet type */
19BE:  MOVLW  12
19C0:  MOVWF  x85
.................... 	buff[6]=make8(completeLength,1);
19C2:  MOVFF  992,986
.................... 	buff[7]=make8(completeLength,0);
19C6:  MOVFF  991,987
.................... 
.................... 	buff[8]=make8(qbuff.measurementNumber,1);
19CA:  MOVFF  46B,988
19CE:  MOVLB  9
.................... 	buff[9]=make8(qbuff.measurementNumber,0);
19D0:  MOVFF  46A,989
19D4:  MOVLB  9
.................... 
.................... 	/* device info */
.................... 	/* WorldData device type identifier (16-bit) */
.................... 	i=qbuff.deviceNumber;
19D6:  MOVFF  469,97F
.................... 	buff[10]=make8(device[i].typeWorld,1);
19DA:  CLRF   x95
19DC:  MOVFF  97F,994
19E0:  CLRF   x97
19E2:  MOVLW  0D
19E4:  MOVWF  x96
19E6:  MOVLB  0
19E8:  CALL   084C
19EC:  MOVFF  01,993
19F0:  MOVLW  01
19F2:  MOVLB  9
19F4:  ADDWF  01,W
19F6:  MOVWF  01
19F8:  MOVLW  00
19FA:  ADDWFC 02,W
19FC:  MOVWF  03
19FE:  MOVF   01,W
1A00:  ADDLW  21
1A02:  MOVWF  FE9
1A04:  MOVLW  00
1A06:  ADDWFC 03,W
1A08:  MOVWF  FEA
1A0A:  MOVFF  FEC,98A
1A0E:  MOVF   FED,F
1A10:  MOVFF  FEF,993
.................... 	buff[11]=make8(device[i].typeWorld,0);
1A14:  CLRF   x95
1A16:  MOVFF  97F,994
1A1A:  CLRF   x97
1A1C:  MOVLW  0D
1A1E:  MOVWF  x96
1A20:  MOVLB  0
1A22:  CALL   084C
1A26:  MOVFF  01,993
1A2A:  MOVLW  01
1A2C:  MOVLB  9
1A2E:  ADDWF  01,W
1A30:  MOVWF  01
1A32:  MOVLW  00
1A34:  ADDWFC 02,W
1A36:  MOVWF  03
1A38:  MOVF   01,W
1A3A:  ADDLW  21
1A3C:  MOVWF  FE9
1A3E:  MOVLW  00
1A40:  ADDWFC 03,W
1A42:  MOVWF  FEA
1A44:  MOVFF  FEC,994
1A48:  MOVF   FED,F
1A4A:  MOVFF  FEF,98B
.................... 	/* manufacturers serial number */
.................... 	buff[12]=make8(device[i].serialNumber,3);
1A4E:  CLRF   x95
1A50:  MOVFF  97F,994
1A54:  CLRF   x97
1A56:  MOVLW  0D
1A58:  MOVWF  x96
1A5A:  MOVLB  0
1A5C:  CALL   084C
1A60:  MOVFF  01,993
1A64:  MOVLW  05
1A66:  MOVLB  9
1A68:  ADDWF  01,W
1A6A:  MOVWF  01
1A6C:  MOVLW  00
1A6E:  ADDWFC 02,W
1A70:  MOVWF  03
1A72:  MOVF   01,W
1A74:  ADDLW  21
1A76:  MOVWF  FE9
1A78:  MOVLW  00
1A7A:  ADDWFC 03,W
1A7C:  MOVWF  FEA
1A7E:  MOVFF  FEF,993
1A82:  MOVFF  FEC,994
1A86:  MOVFF  FEC,995
1A8A:  MOVFF  FEC,98C
.................... 	buff[13]=make8(device[i].serialNumber,2);
1A8E:  CLRF   x95
1A90:  MOVFF  97F,994
1A94:  CLRF   x97
1A96:  MOVLW  0D
1A98:  MOVWF  x96
1A9A:  MOVLB  0
1A9C:  CALL   084C
1AA0:  MOVFF  01,993
1AA4:  MOVLW  05
1AA6:  MOVLB  9
1AA8:  ADDWF  01,W
1AAA:  MOVWF  01
1AAC:  MOVLW  00
1AAE:  ADDWFC 02,W
1AB0:  MOVWF  03
1AB2:  MOVF   01,W
1AB4:  ADDLW  21
1AB6:  MOVWF  FE9
1AB8:  MOVLW  00
1ABA:  ADDWFC 03,W
1ABC:  MOVWF  FEA
1ABE:  MOVFF  FEF,993
1AC2:  MOVFF  FEC,994
1AC6:  MOVFF  FEC,98D
1ACA:  MOVFF  FEC,996
.................... 	buff[14]=make8(device[i].serialNumber,1);
1ACE:  CLRF   x95
1AD0:  MOVFF  97F,994
1AD4:  CLRF   x97
1AD6:  MOVLW  0D
1AD8:  MOVWF  x96
1ADA:  MOVLB  0
1ADC:  CALL   084C
1AE0:  MOVFF  01,993
1AE4:  MOVLW  05
1AE6:  MOVLB  9
1AE8:  ADDWF  01,W
1AEA:  MOVWF  01
1AEC:  MOVLW  00
1AEE:  ADDWFC 02,W
1AF0:  MOVWF  03
1AF2:  MOVF   01,W
1AF4:  ADDLW  21
1AF6:  MOVWF  FE9
1AF8:  MOVLW  00
1AFA:  ADDWFC 03,W
1AFC:  MOVWF  FEA
1AFE:  MOVFF  FEF,993
1B02:  MOVFF  FEC,98E
1B06:  MOVFF  FEC,995
1B0A:  MOVFF  FEC,996
.................... 	buff[15]=make8(device[i].serialNumber,0);
1B0E:  CLRF   x95
1B10:  MOVFF  97F,994
1B14:  CLRF   x97
1B16:  MOVLW  0D
1B18:  MOVWF  x96
1B1A:  MOVLB  0
1B1C:  CALL   084C
1B20:  MOVFF  01,993
1B24:  MOVLW  05
1B26:  MOVLB  9
1B28:  ADDWF  01,W
1B2A:  MOVWF  01
1B2C:  MOVLW  00
1B2E:  ADDWFC 02,W
1B30:  MOVWF  03
1B32:  MOVF   01,W
1B34:  ADDLW  21
1B36:  MOVWF  FE9
1B38:  MOVLW  00
1B3A:  ADDWFC 03,W
1B3C:  MOVWF  FEA
1B3E:  MOVFF  FEF,98F
1B42:  MOVFF  FEC,994
1B46:  MOVFF  FEC,995
1B4A:  MOVFF  FEC,996
.................... 	/* status of the data read */
.................... 	buff[16]=qbuff.rException;
1B4E:  MOVFF  367,990
.................... 
.................... 	/* compute CRC on header and result data */
.................... 	lCRC=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
1B52:  SETF   x94
1B54:  SETF   x93
1B56:  MOVLW  09
1B58:  MOVWF  x96
1B5A:  MOVLW  81
1B5C:  MOVWF  x95
1B5E:  MOVLW  10
1B60:  MOVWF  x97
1B62:  MOVLB  0
1B64:  RCALL  1930
1B66:  MOVFF  02,97E
1B6A:  MOVFF  01,97D
.................... 	lCRC=crc_chk_pass(lCRC,qbuff.rResult,qbuff.rResultLength);
1B6E:  MOVFF  97E,994
1B72:  MOVFF  97D,993
1B76:  MOVLW  03
1B78:  MOVLB  9
1B7A:  MOVWF  x96
1B7C:  MOVLW  68
1B7E:  MOVWF  x95
1B80:  MOVFF  468,997
1B84:  MOVLB  0
1B86:  RCALL  1930
1B88:  MOVFF  02,97E
1B8C:  MOVFF  01,97D
.................... 
.................... 	/* send buff, qbuff.rResult, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
1B90:  MOVLB  9
1B92:  CLRF   x7F
1B94:  MOVF   x7F,W
1B96:  SUBLW  10
1B98:  BNC   1BB8
.................... 		fputc(buff[i],STREAM_WORLD);
1B9A:  CLRF   03
1B9C:  MOVF   x7F,W
1B9E:  ADDLW  80
1BA0:  MOVWF  FE9
1BA2:  MOVLW  09
1BA4:  ADDWFC 03,W
1BA6:  MOVWF  FEA
1BA8:  MOVFF  FEF,993
1BAC:  MOVF   x93,W
1BAE:  MOVLB  0
1BB0:  RCALL  198E
1BB2:  MOVLB  9
1BB4:  INCF   x7F,F
1BB6:  BRA    1B94
.................... 	}	
.................... 	for ( i=0 ; i<qbuff.rResultLength ; i++ ) {
1BB8:  CLRF   x7F
1BBA:  MOVLB  4
1BBC:  MOVF   x68,W
1BBE:  MOVLB  9
1BC0:  SUBWF  x7F,W
1BC2:  BC    1BE2
.................... 		fputc(qbuff.rResult[i],STREAM_WORLD);
1BC4:  MOVLW  68
1BC6:  ADDWF  x7F,W
1BC8:  MOVWF  FE9
1BCA:  MOVLW  03
1BCC:  MOVWF  FEA
1BCE:  BTFSC  FD8.0
1BD0:  INCF   FEA,F
1BD2:  MOVFF  FEF,993
1BD6:  MOVF   x93,W
1BD8:  MOVLB  0
1BDA:  RCALL  198E
1BDC:  MOVLB  9
1BDE:  INCF   x7F,F
1BE0:  BRA    1BBA
.................... 	}
.................... 	fputc(make8(lCRC,1),STREAM_WORLD);
1BE2:  MOVFF  97E,993
1BE6:  MOVF   x93,W
1BE8:  MOVLB  0
1BEA:  RCALL  198E
.................... 	fputc(make8(lCRC,0),STREAM_WORLD);
1BEC:  MOVFF  97D,993
1BF0:  MOVLB  9
1BF2:  MOVF   x93,W
1BF4:  MOVLB  0
1BF6:  RCALL  198E
1BF8:  RETURN 0
.................... }
.................... 
.................... 
.................... #include "queryHandler_rdTap.c"
.................... /* this will do an arbitrary query to some other device on the network */
.................... void query_other(void) {
.................... 	int8 parseType;
.................... 	int8 i;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_other()\r\n");
.................... 	fprintf(STREAM_WORLD,"# query function=%lu\r\n",query.function);
.................... #endif
.................... 
.................... 	if ( query.function <= DEV_TYPE_MODBUS_MAX ) {
*
30B4:  MOVLB  5
30B6:  MOVF   x7A,F
30B8:  BTFSS  FD8.2
30BA:  BRA    330C
30BC:  MOVF   x79,W
30BE:  SUBLW  07
30C0:  BTFSS  FD8.0
30C2:  BRA    330C
.................... 		/* modbus device type */
.................... 		switch ( query.function ) {
30C4:  MOVF   x79,W
30C6:  MOVWF  00
30C8:  MOVF   x7A,W
30CA:  MOVWF  03
30CC:  MOVF   03,W
30CE:  BNZ   30D8
30D0:  MOVF   00,F
30D2:  MOVLB  0
30D4:  BZ    3140
30D6:  MOVLB  5
30D8:  MOVF   03,W
30DA:  BNZ   30E6
30DC:  MOVLW  01
30DE:  SUBWF  00,W
30E0:  MOVLB  0
30E2:  BZ    3142
30E4:  MOVLB  5
30E6:  MOVF   03,W
30E8:  BNZ   30F4
30EA:  MOVLW  02
30EC:  SUBWF  00,W
30EE:  MOVLB  0
30F0:  BZ    316A
30F2:  MOVLB  5
30F4:  MOVF   03,W
30F6:  BNZ   3102
30F8:  MOVLW  03
30FA:  SUBWF  00,W
30FC:  MOVLB  0
30FE:  BZ    3190
3100:  MOVLB  5
3102:  MOVF   03,W
3104:  BNZ   3110
3106:  MOVLW  04
3108:  SUBWF  00,W
310A:  MOVLB  0
310C:  BZ    31B8
310E:  MOVLB  5
3110:  MOVF   03,W
3112:  BNZ   311E
3114:  MOVLW  05
3116:  SUBWF  00,W
3118:  MOVLB  0
311A:  BZ    31E0
311C:  MOVLB  5
311E:  MOVF   03,W
3120:  BNZ   312E
3122:  MOVLW  06
3124:  SUBWF  00,W
3126:  MOVLB  0
3128:  BTFSC  FD8.2
312A:  BRA    3212
312C:  MOVLB  5
312E:  MOVF   03,W
3130:  BNZ   313E
3132:  MOVLW  07
3134:  SUBWF  00,W
3136:  MOVLB  0
3138:  BTFSC  FD8.2
313A:  BRA    3268
313C:  MOVLB  5
313E:  BRA    32A8
.................... 			case DEV_TYPE_DISABLED:
.................... 				return;
3140:  BRA    33D2
.................... 			case DEV_TYPE_MODBUS_1: /* not very well tested */
.................... 				query.resultException=modbus_read_coils(query.network_address, query.start_address, query.n_words);
3142:  MOVFF  577,982
3146:  MOVFF  57C,984
314A:  MOVFF  57B,983
314E:  MOVLB  9
3150:  CLRF   x86
3152:  MOVFF  57D,985
3156:  MOVLB  0
3158:  CALL   1BFA
315C:  MOVFF  01,581
.................... 				parseType=1;
3160:  MOVLW  01
3162:  MOVLB  9
3164:  MOVWF  x80
.................... 				break;
3166:  MOVLB  5
3168:  BRA    32A8
.................... 			case DEV_TYPE_MODBUS_2: /* not very well tested */
.................... 				query.resultException=modbus_read_discrete_input(query.network_address, query.start_address, query.n_words);
316A:  MOVFF  577,982
316E:  MOVFF  57C,984
3172:  MOVFF  57B,983
3176:  MOVLB  9
3178:  CLRF   x86
317A:  MOVFF  57D,985
317E:  MOVLB  0
3180:  BRA    2D48
3182:  MOVFF  01,581
.................... 				parseType=1;
3186:  MOVLW  01
3188:  MOVLB  9
318A:  MOVWF  x80
.................... 				break;
318C:  MOVLB  5
318E:  BRA    32A8
.................... 			case DEV_TYPE_MODBUS_3: /* tested */
.................... 				query.resultException=modbus_read_holding_registers(query.network_address, query.start_address, query.n_words);
3190:  MOVFF  577,982
3194:  MOVFF  57C,984
3198:  MOVFF  57B,983
319C:  MOVLB  9
319E:  CLRF   x86
31A0:  MOVFF  57D,985
31A4:  MOVLB  0
31A6:  CALL   1898
31AA:  MOVFF  01,581
.................... 				parseType=1;
31AE:  MOVLW  01
31B0:  MOVLB  9
31B2:  MOVWF  x80
.................... 				break;
31B4:  MOVLB  5
31B6:  BRA    32A8
.................... 			case DEV_TYPE_MODBUS_4: /* tested */
.................... 				query.resultException=modbus_read_input_registers(query.network_address, query.start_address, query.n_words);
31B8:  MOVFF  577,982
31BC:  MOVFF  57C,984
31C0:  MOVFF  57B,983
31C4:  MOVLB  9
31C6:  CLRF   x86
31C8:  MOVFF  57D,985
31CC:  MOVLB  0
31CE:  CALL   1800
31D2:  MOVFF  01,581
.................... 				parseType=1;
31D6:  MOVLW  01
31D8:  MOVLB  9
31DA:  MOVWF  x80
.................... 				break;
31DC:  MOVLB  5
31DE:  BRA    32A8
.................... 			case DEV_TYPE_MODBUS_5: /* tested */
.................... 				query.resultException=modbus_write_single_coil(query.network_address, query.start_address, query.buff[query.data_start_offset]);
31E0:  MOVLW  6C
31E2:  MOVLB  5
31E4:  ADDWF  x7E,W
31E6:  MOVWF  FE9
31E8:  MOVLW  04
31EA:  MOVWF  FEA
31EC:  BTFSC  FD8.0
31EE:  INCF   FEA,F
31F0:  MOVFF  FEF,986
31F4:  MOVFF  577,983
31F8:  MOVFF  57C,985
31FC:  MOVFF  57B,984
3200:  MOVLB  0
3202:  BRA    2DF0
3204:  MOVFF  01,581
.................... 				parseType=2;
3208:  MOVLW  02
320A:  MOVLB  9
320C:  MOVWF  x80
.................... 				break;
320E:  MOVLB  5
3210:  BRA    32A8
.................... 			case DEV_TYPE_MODBUS_6: /* tested */
.................... 				query.resultException=modbus_write_single_register(query.network_address, query.start_address, 
.................... 					make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
3212:  MOVLW  6C
3214:  MOVLB  5
3216:  ADDWF  x7E,W
3218:  MOVWF  FE9
321A:  MOVLW  04
321C:  MOVWF  FEA
321E:  BTFSC  FD8.0
3220:  INCF   FEA,F
3222:  MOVFF  FEF,982
3226:  MOVLW  01
3228:  ADDWF  x7E,W
322A:  ADDLW  6C
322C:  MOVWF  FE9
322E:  MOVLW  04
3230:  MOVWF  FEA
3232:  BTFSC  FD8.0
3234:  INCF   FEA,F
3236:  MOVFF  FEF,983
323A:  MOVFF  982,985
323E:  MOVFF  983,984
3242:  MOVFF  577,986
3246:  MOVFF  57C,988
324A:  MOVFF  57B,987
324E:  MOVFF  982,98A
3252:  MOVFF  983,989
3256:  MOVLB  0
3258:  BRA    2EAC
325A:  MOVFF  01,581
.................... 				parseType=2;
325E:  MOVLW  02
3260:  MOVLB  9
3262:  MOVWF  x80
.................... 				return;
3264:  MOVLB  0
3266:  BRA    33D2
.................... 			case DEV_TYPE_MODBUS_16: /* tested ... endian issues lead to having to send data in a (backwards?) order */
.................... 				query.resultException=modbus_write_multiple_registers_flip(query.network_address, query.start_address, 
.................... 					query.n_words,&query.buff+query.data_start_offset
.................... 				);
3268:  MOVLW  6C
326A:  MOVLB  5
326C:  ADDWF  x7E,W
326E:  MOVLB  9
3270:  MOVWF  x82
3272:  MOVLW  04
3274:  MOVWF  x83
3276:  BTFSC  FD8.0
3278:  INCF   x83,F
327A:  MOVFF  577,984
327E:  MOVFF  57C,986
3282:  MOVFF  57B,985
3286:  CLRF   x88
3288:  MOVFF  57D,987
328C:  MOVFF  983,98A
3290:  MOVFF  982,989
3294:  MOVLB  0
3296:  BRA    2F54
3298:  MOVFF  01,581
.................... 				parseType=2;
329C:  MOVLW  02
329E:  MOVLB  9
32A0:  MOVWF  x80
.................... 				return;
32A2:  MOVLB  0
32A4:  BRA    33D2
32A6:  MOVLB  5
.................... 		}	
.................... 
.................... 		/* Modbus query performed above. */
.................... 		/* no error, copy data to buffer to send response */
.................... 		if ( 1==parseType && 0==query.resultException ) {
32A8:  MOVLB  9
32AA:  DECFSZ x80,W
32AC:  BRA    32E8
32AE:  MOVLB  5
32B0:  MOVF   x81,F
32B2:  BTFSC  FD8.2
32B4:  BRA    32BA
32B6:  MOVLB  9
32B8:  BRA    32E8
.................... 			query.resultLength=modbus_rx.len-1;
32BA:  MOVLW  01
32BC:  SUBWF  x94,W
32BE:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[1],modbus_rx.len-1); 
32C0:  MOVLW  01
32C2:  SUBWF  x94,W
32C4:  MOVLB  9
32C6:  MOVWF  x82
32C8:  MOVLW  04
32CA:  MOVWF  FEA
32CC:  MOVLW  6C
32CE:  MOVWF  FE9
32D0:  MOVLW  05
32D2:  MOVWF  FE2
32D4:  MOVLW  98
32D6:  MOVWF  FE1
32D8:  MOVF   x82,W
32DA:  MOVWF  01
32DC:  BZ    32E6
32DE:  MOVFF  FE6,FEE
32E2:  DECFSZ 01,F
32E4:  BRA    32DE
.................... 		} else if ( 2==parseType && 0==query.resultException ) {
32E6:  BRA    3308
32E8:  MOVF   x80,W
32EA:  SUBLW  02
32EC:  BNZ   3308
32EE:  MOVLB  5
32F0:  MOVF   x81,F
32F2:  BTFSC  FD8.2
32F4:  BRA    32FA
32F6:  MOVLB  9
32F8:  BRA    3308
.................... 			/* return the value of the coil we wrote */
.................... 			query.resultLength=2;
32FA:  MOVLW  02
32FC:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[3],2); 
32FE:  MOVFF  59A,46C
3302:  MOVFF  59B,46D
3306:  MOVLB  9
.................... 		}
.................... 	} else if ( query.function <= DEV_TYPE_I2C_MAX ) {
3308:  BRA    33D0
330A:  MOVLB  5
330C:  MOVF   x7A,F
330E:  BNZ   33D2
3310:  MOVF   x79,W
3312:  SUBLW  17
3314:  BNC   33D2
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# query_other for I2C network_adress=%lu, start_address=%lu n_words=%u\r\n",
.................... 			query.network_address,
.................... 			query.start_address,
.................... 			query.n_words
.................... 		);
.................... #endif
.................... 
.................... 		if ( DEV_TYPE_I2C_READ_8 == query.function ) {
3316:  MOVF   x79,W
3318:  SUBLW  10
331A:  BNZ   3346
331C:  MOVF   x7A,F
331E:  BNZ   3346
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_READ_8\r\n");
.................... #endif
.................... 
.................... 			/* start a read at start address then just read a byte at a time. n_words is actually bytes */
.................... 			i2c_buff_read(query.network_address, query.start_address, query.buff, query.n_words);
3320:  MOVFF  577,982
3324:  MOVFF  57B,983
3328:  MOVLW  04
332A:  MOVLB  9
332C:  MOVWF  x85
332E:  MOVLW  6C
3330:  MOVWF  x84
3332:  MOVFF  57D,986
3336:  MOVLB  0
3338:  CALL   1C92
.................... 			query.resultLength = query.n_words; /* in bytes */
333C:  MOVFF  57D,582
.................... 			query.resultException=0;
3340:  MOVLB  5
3342:  CLRF   x81
.................... 		} else if ( DEV_TYPE_I2C_WRITE_16 == query.function ) {
3344:  BRA    33D2
3346:  MOVF   x79,W
3348:  SUBLW  15
334A:  BNZ   33D2
334C:  MOVF   x7A,F
334E:  BNZ   33D2
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_WRITE_16\r\n");
.................... #endif
.................... 
.................... 			for ( i=0 ; i<query.n_words ; i++ ) {
3350:  MOVLB  9
3352:  CLRF   x81
3354:  MOVLB  5
3356:  MOVF   x7D,W
3358:  MOVLB  9
335A:  SUBWF  x81,W
335C:  BC    33D0
.................... #if DEBUG_ASCII
.................... 				fprintf(STREAM_WORLD,"# writing 0x%04lx to I2C device 0x%02x at address %lu\r\n",
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1]),
.................... 					query.network_address,
.................... 					(query.start_address+i*2)
.................... 				);
.................... #endif
.................... 
.................... 				i2c_register_write16(
.................... 					query.network_address,
.................... 					(query.start_address+i*2),
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1])
.................... 				);
335E:  BCF    FD8.0
3360:  RLCF   x81,W
3362:  MOVLB  5
3364:  ADDWF  x7B,W
3366:  MOVLB  9
3368:  MOVWF  x82
336A:  MOVLW  00
336C:  MOVLB  5
336E:  ADDWFC x7C,W
3370:  MOVLB  9
3372:  MOVWF  x83
3374:  BCF    FD8.0
3376:  RLCF   x81,W
3378:  MOVLB  5
337A:  ADDWF  x7E,W
337C:  ADDLW  6C
337E:  MOVWF  FE9
3380:  MOVLW  04
3382:  MOVWF  FEA
3384:  BTFSC  FD8.0
3386:  INCF   FEA,F
3388:  MOVFF  FEF,984
338C:  BCF    FD8.0
338E:  MOVLB  9
3390:  RLCF   x81,W
3392:  MOVLB  5
3394:  ADDWF  x7E,W
3396:  ADDLW  01
3398:  ADDLW  6C
339A:  MOVWF  FE9
339C:  MOVLW  04
339E:  MOVWF  FEA
33A0:  BTFSC  FD8.0
33A2:  INCF   FEA,F
33A4:  MOVFF  FEF,985
33A8:  MOVFF  984,987
33AC:  MOVFF  985,986
33B0:  MOVFF  577,988
33B4:  MOVFF  982,989
33B8:  MOVFF  984,98B
33BC:  MOVFF  985,98A
33C0:  MOVLB  0
33C2:  BRA    3078
.................... 
.................... 				query.resultLength = 0; /* in bytes */
33C4:  MOVLB  5
33C6:  CLRF   x82
.................... 				query.resultException=0;
33C8:  CLRF   x81
33CA:  MOVLB  9
33CC:  INCF   x81,F
33CE:  BRA    3354
.................... 
.................... 			}
.................... 
.................... 		} else {
33D0:  MOVLB  5
33D2:  MOVLB  0
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# un-implemented I2C query function\r\n");
.................... #endif
.................... 		}
.................... 
.................... 	}
33D4:  GOTO   35F6 (RETURN)
.................... }
.................... 
.................... 
.................... /* 
.................... try to write the specified register
.................... if successful, return 0, otherwise return a modbus exception
.................... */
.................... exception query_self_write_register(int16 address, int16 value) {
.................... 	int8 dev, offset;
.................... 	int16 last;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_write_register address=%lu value=%lu\r\n",address,value);
.................... #endif
.................... 
.................... 	/* if we have been unlocked, then we can modify serial number */
.................... 	if ( timers.factory_unlocked ) {
*
293A:  MOVLB  3
293C:  MOVF   x63,F
293E:  BZ    2976
.................... 		if ( 1000 == address ) {
2940:  MOVLB  9
2942:  MOVF   x84,W
2944:  SUBLW  E8
2946:  BNZ   295A
2948:  MOVF   x85,W
294A:  SUBLW  03
294C:  BNZ   295A
.................... 			config.serial_prefix=value;
294E:  MOVFF  986,583
.................... 			return 0;
2952:  MOVLW  00
2954:  MOVWF  01
2956:  BRA    2C64
.................... 		} else if ( 1001 == address ) {
2958:  BRA    2974
295A:  MOVF   x84,W
295C:  SUBLW  E9
295E:  BNZ   2974
2960:  MOVF   x85,W
2962:  SUBLW  03
2964:  BNZ   2974
.................... 			config.serial_number=value;
2966:  MOVFF  987,585
296A:  MOVFF  986,584
.................... 			return 0;
296E:  MOVLW  00
2970:  MOVWF  01
2972:  BRA    2C64
2974:  MOVLB  3
.................... 		}
.................... 	}
.................... 
.................... 	if ( address < 1000 ) {
2976:  MOVLB  9
2978:  MOVF   x85,W
297A:  SUBLW  03
297C:  BTFSS  FD8.0
297E:  BRA    2B88
2980:  BNZ   298A
2982:  MOVF   x84,W
2984:  SUBLW  E7
2986:  BTFSS  FD8.0
2988:  BRA    2B88
.................... 		dev=address>>3;
298A:  RRCF   x85,W
298C:  MOVWF  03
298E:  RRCF   x84,W
2990:  MOVWF  02
2992:  RRCF   03,F
2994:  RRCF   02,F
2996:  RRCF   03,F
2998:  RRCF   02,F
299A:  MOVFF  02,988
.................... 		offset=address&0b111;
299E:  MOVF   x84,W
29A0:  ANDLW  07
29A2:  MOVWF  x89
.................... 
.................... 		if ( dev > DEV_MAX_N )
29A4:  MOVF   x88,W
29A6:  SUBLW  40
29A8:  BC    29B0
.................... 			return ILLEGAL_DATA_ADDRESS;
29AA:  MOVLW  02
29AC:  MOVWF  01
29AE:  BRA    2C64
.................... 
.................... 		switch ( offset ) {
29B0:  MOVF   x89,W
29B2:  ADDLW  F8
29B4:  BTFSC  FD8.0
29B6:  BRA    2B86
29B8:  ADDLW  08
29BA:  MOVLB  0
29BC:  GOTO   2C6A
.................... 			case 0: device[dev].type=make8(value,0); break;
29C0:  MOVLB  9
29C2:  CLRF   x95
29C4:  MOVFF  988,994
29C8:  CLRF   x97
29CA:  MOVLW  0D
29CC:  MOVWF  x96
29CE:  MOVLB  0
29D0:  CALL   084C
29D4:  MOVFF  02,98D
29D8:  MOVFF  01,98C
29DC:  MOVLW  21
29DE:  MOVLB  9
29E0:  ADDWF  01,W
29E2:  MOVWF  FE9
29E4:  MOVLW  00
29E6:  ADDWFC 02,W
29E8:  MOVWF  FEA
29EA:  MOVFF  986,FEF
29EE:  BRA    2B86
.................... 			case 1: device[dev].typeWorld=value; break;
29F0:  MOVLB  9
29F2:  CLRF   x95
29F4:  MOVFF  988,994
29F8:  CLRF   x97
29FA:  MOVLW  0D
29FC:  MOVWF  x96
29FE:  MOVLB  0
2A00:  CALL   084C
2A04:  MOVFF  02,98D
2A08:  MOVFF  01,98C
2A0C:  MOVLW  01
2A0E:  MOVLB  9
2A10:  ADDWF  01,W
2A12:  MOVWF  01
2A14:  MOVLW  00
2A16:  ADDWFC 02,W
2A18:  MOVWF  03
2A1A:  MOVF   01,W
2A1C:  ADDLW  21
2A1E:  MOVWF  FE9
2A20:  MOVLW  00
2A22:  ADDWFC 03,W
2A24:  MOVWF  FEA
2A26:  MOVFF  987,FEC
2A2A:  MOVF   FED,F
2A2C:  MOVFF  986,FEF
2A30:  BRA    2B86
.................... 			case 2: device[dev].transmitEvery=make8(value,0); break;
2A32:  MOVLB  9
2A34:  CLRF   x95
2A36:  MOVFF  988,994
2A3A:  CLRF   x97
2A3C:  MOVLW  0D
2A3E:  MOVWF  x96
2A40:  MOVLB  0
2A42:  CALL   084C
2A46:  MOVFF  02,98D
2A4A:  MOVFF  01,98C
2A4E:  MOVLW  03
2A50:  MOVLB  9
2A52:  ADDWF  01,W
2A54:  MOVWF  01
2A56:  MOVLW  00
2A58:  ADDWFC 02,W
2A5A:  MOVWF  03
2A5C:  MOVF   01,W
2A5E:  ADDLW  21
2A60:  MOVWF  FE9
2A62:  MOVLW  00
2A64:  ADDWFC 03,W
2A66:  MOVWF  FEA
2A68:  MOVFF  986,FEF
2A6C:  BRA    2B86
.................... 			case 3: device[dev].networkAddress=make8(value,0); break;
2A6E:  MOVLB  9
2A70:  CLRF   x95
2A72:  MOVFF  988,994
2A76:  CLRF   x97
2A78:  MOVLW  0D
2A7A:  MOVWF  x96
2A7C:  MOVLB  0
2A7E:  CALL   084C
2A82:  MOVFF  02,98D
2A86:  MOVFF  01,98C
2A8A:  MOVLW  04
2A8C:  MOVLB  9
2A8E:  ADDWF  01,W
2A90:  MOVWF  01
2A92:  MOVLW  00
2A94:  ADDWFC 02,W
2A96:  MOVWF  03
2A98:  MOVF   01,W
2A9A:  ADDLW  21
2A9C:  MOVWF  FE9
2A9E:  MOVLW  00
2AA0:  ADDWFC 03,W
2AA2:  MOVWF  FEA
2AA4:  MOVFF  986,FEF
2AA8:  BRA    2B86
.................... 			/* first pass get the high word of serial number */
.................... 			case 4: last=value; break;
2AAA:  MOVFF  987,98B
2AAE:  MOVFF  986,98A
2AB2:  MOVLB  9
2AB4:  BRA    2B86
.................... 			/* second pass, combine last value and current value */
.................... 			case 5: device[dev].serialNumber=make32(last,value); break; /* was missing a break prior to 2024-04-03 */
2AB6:  MOVLB  9
2AB8:  CLRF   x95
2ABA:  MOVFF  988,994
2ABE:  CLRF   x97
2AC0:  MOVLW  0D
2AC2:  MOVWF  x96
2AC4:  MOVLB  0
2AC6:  CALL   084C
2ACA:  MOVFF  02,98D
2ACE:  MOVFF  01,98C
2AD2:  MOVLW  05
2AD4:  MOVLB  9
2AD6:  ADDWF  01,W
2AD8:  MOVWF  01
2ADA:  MOVLW  00
2ADC:  ADDWFC 02,W
2ADE:  MOVWF  03
2AE0:  MOVF   01,W
2AE2:  ADDLW  21
2AE4:  MOVWF  FE9
2AE6:  MOVLW  00
2AE8:  ADDWFC 03,W
2AEA:  MOVWF  FEA
2AEC:  MOVF   FEE,F
2AEE:  MOVFF  98A,FEC
2AF2:  MOVFF  98B,FEC
2AF6:  MOVF   FED,F
2AF8:  MOVF   FED,F
2AFA:  MOVF   FED,F
2AFC:  MOVFF  986,FEF
2B00:  MOVFF  987,FEC
2B04:  BRA    2B86
.................... 			case 6: device[dev].startRegister=value; break;
2B06:  MOVLB  9
2B08:  CLRF   x95
2B0A:  MOVFF  988,994
2B0E:  CLRF   x97
2B10:  MOVLW  0D
2B12:  MOVWF  x96
2B14:  MOVLB  0
2B16:  CALL   084C
2B1A:  MOVFF  02,98D
2B1E:  MOVFF  01,98C
2B22:  MOVLW  09
2B24:  MOVLB  9
2B26:  ADDWF  01,W
2B28:  MOVWF  01
2B2A:  MOVLW  00
2B2C:  ADDWFC 02,W
2B2E:  MOVWF  03
2B30:  MOVF   01,W
2B32:  ADDLW  21
2B34:  MOVWF  FE9
2B36:  MOVLW  00
2B38:  ADDWFC 03,W
2B3A:  MOVWF  FEA
2B3C:  MOVFF  987,FEC
2B40:  MOVF   FED,F
2B42:  MOVFF  986,FEF
2B46:  BRA    2B86
.................... 			case 7: device[dev].nRegisters=make8(value,0); break;
2B48:  MOVLB  9
2B4A:  CLRF   x95
2B4C:  MOVFF  988,994
2B50:  CLRF   x97
2B52:  MOVLW  0D
2B54:  MOVWF  x96
2B56:  MOVLB  0
2B58:  CALL   084C
2B5C:  MOVFF  02,98D
2B60:  MOVFF  01,98C
2B64:  MOVLW  0B
2B66:  MOVLB  9
2B68:  ADDWF  01,W
2B6A:  MOVWF  01
2B6C:  MOVLW  00
2B6E:  ADDWFC 02,W
2B70:  MOVWF  03
2B72:  MOVF   01,W
2B74:  ADDLW  21
2B76:  MOVWF  FE9
2B78:  MOVLW  00
2B7A:  ADDWFC 03,W
2B7C:  MOVWF  FEA
2B7E:  MOVFF  986,FEF
2B82:  BRA    2B86
2B84:  MOVLB  9
.................... 		}
.................... 	} else {
2B86:  BRA    2C5C
.................... 		/* publicly writeable addresses */
.................... 
.................... 		switch ( address ) {
2B88:  MOVF   x84,W
2B8A:  MOVWF  00
2B8C:  MOVF   x85,W
2B8E:  MOVWF  03
2B90:  MOVLW  04
2B92:  SUBWF  03,W
2B94:  BNZ   2BA0
2B96:  MOVLW  4C
2B98:  SUBWF  00,W
2B9A:  MOVLB  0
2B9C:  BZ    2BE2
2B9E:  MOVLB  9
2BA0:  MOVLW  07
2BA2:  SUBWF  03,W
2BA4:  BNZ   2BB0
2BA6:  MOVLW  CD
2BA8:  SUBWF  00,W
2BAA:  MOVLB  0
2BAC:  BZ    2BEC
2BAE:  MOVLB  9
2BB0:  MOVLW  07
2BB2:  SUBWF  03,W
2BB4:  BNZ   2BC0
2BB6:  MOVLW  CE
2BB8:  SUBWF  00,W
2BBA:  MOVLB  0
2BBC:  BZ    2BF0
2BBE:  MOVLB  9
2BC0:  MOVLW  07
2BC2:  SUBWF  03,W
2BC4:  BNZ   2BD0
2BC6:  MOVLW  CF
2BC8:  SUBWF  00,W
2BCA:  MOVLB  0
2BCC:  BZ    2C10
2BCE:  MOVLB  9
2BD0:  MOVLW  4E
2BD2:  SUBWF  03,W
2BD4:  BNZ   2BE0
2BD6:  MOVLW  1F
2BD8:  SUBWF  00,W
2BDA:  MOVLB  0
2BDC:  BZ    2C2C
2BDE:  MOVLB  9
2BE0:  BRA    2C56
.................... 			case 1100: config.live_interval=value; break;
2BE2:  MOVFF  987,587
2BE6:  MOVFF  986,586
2BEA:  BRA    2C5E
.................... 
.................... 			case 1997:
.................... 				reset_cpu(); break; /* break doesn't do anything, but makes the compiler complain less */
2BEC:  RESET
2BEE:  BRA    2C5E
.................... 			case 1998:
.................... 				if ( 1998 != value ) return ILLEGAL_DATA_VALUE;
2BF0:  MOVLB  9
2BF2:  MOVF   x86,W
2BF4:  SUBLW  CE
2BF6:  BNZ   2BFE
2BF8:  MOVF   x87,W
2BFA:  SUBLW  07
2BFC:  BZ    2C04
2BFE:  MOVLW  03
2C00:  MOVWF  01
2C02:  BRA    2C64
.................... 				write_default_param_file();
2C04:  MOVLB  0
2C06:  CALL   0822
.................... 				write_default_device_file();
2C0A:  CALL   08C0
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# writing default files\r\n");
.................... #endif
.................... 				break;
2C0E:  BRA    2C5E
.................... 			case 1999:
.................... 				/* write config to EEPROM */
.................... 				if ( 1 != value ) return ILLEGAL_DATA_VALUE;
2C10:  MOVLB  9
2C12:  DECFSZ x86,W
2C14:  BRA    2C1A
2C16:  MOVF   x87,F
2C18:  BZ    2C20
2C1A:  MOVLW  03
2C1C:  MOVWF  01
2C1E:  BRA    2C64
.................... 				write_param_file();
2C20:  MOVLB  0
2C22:  CALL   07CE
.................... 				write_device_file();
2C26:  CALL   086E
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# config.live_interval=%lu\r\n",config.live_interval);
.................... #endif
.................... 
.................... 				break;
2C2A:  BRA    2C5E
.................... 
.................... 			case 19999:
.................... 				/* unlock factory programming registers when we get 1802 in passcode register */
.................... 				if ( 1802 != value ) {
2C2C:  MOVLB  9
2C2E:  MOVF   x86,W
2C30:  SUBLW  0A
2C32:  BNZ   2C3A
2C34:  MOVF   x87,W
2C36:  SUBLW  07
2C38:  BZ    2C46
.................... 					timers.factory_unlocked=0;
2C3A:  MOVLB  3
2C3C:  CLRF   x63
.................... 					return ILLEGAL_DATA_VALUE;
2C3E:  MOVLW  03
2C40:  MOVWF  01
2C42:  MOVLB  9
2C44:  BRA    2C64
.................... 				}
.................... 				timers.factory_unlocked=1;
2C46:  MOVLW  01
2C48:  MOVLB  3
2C4A:  MOVWF  x63
.................... 				/* green LED for 2 seconds */
.................... 				timers.led_on_green=200;
2C4C:  MOVLW  C8
2C4E:  MOVWF  x64
.................... 				break;
2C50:  MOVLB  0
2C52:  BRA    2C5E
2C54:  MOVLB  9
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# factory unlocked\r\n");
.................... #endif
.................... 
.................... 			default:
.................... 				return ILLEGAL_DATA_ADDRESS;
2C56:  MOVLW  02
2C58:  MOVWF  01
2C5A:  BRA    2C64
2C5C:  MOVLB  0
.................... 		}
.................... 	}
.................... 
.................... 	/* must not have triggered an exception */
.................... 	return 0;
2C5E:  MOVLW  00
2C60:  MOVWF  01
2C62:  MOVLB  9
2C64:  MOVLB  0
2C66:  GOTO   2D32 (RETURN)
.................... }
.................... 
.................... 
.................... /* address to read, put 16-bit results in query.buff[n] and query.buff[n+1] */
.................... exception query_self_read_register(int16 address, int8 n) {
.................... 	int16 result;
.................... 	int8 dev;
.................... 	int8 offset;
.................... 
.................... 
.................... 	if ( address < 1000 ) {
*
24E8:  MOVLB  9
24EA:  MOVF   x89,W
24EC:  SUBLW  03
24EE:  BTFSS  FD8.0
24F0:  BRA    27CE
24F2:  BNZ   24FC
24F4:  MOVF   x88,W
24F6:  SUBLW  E7
24F8:  BTFSS  FD8.0
24FA:  BRA    27CE
.................... 		dev=address>>3;
24FC:  RRCF   x89,W
24FE:  MOVWF  03
2500:  RRCF   x88,W
2502:  MOVWF  02
2504:  RRCF   03,F
2506:  RRCF   02,F
2508:  RRCF   03,F
250A:  RRCF   02,F
250C:  MOVFF  02,98D
.................... 		offset=address&0b111;
2510:  MOVF   x88,W
2512:  ANDLW  07
2514:  MOVWF  x8E
.................... 
.................... 		if ( dev > DEV_MAX_N )
2516:  MOVF   x8D,W
2518:  SUBLW  40
251A:  BC    2522
.................... 			return ILLEGAL_DATA_ADDRESS;
251C:  MOVLW  02
251E:  MOVWF  01
2520:  BRA    28C6
.................... 
.................... 		switch ( offset ) {
2522:  MOVF   x8E,W
2524:  ADDLW  F8
2526:  BTFSC  FD8.0
2528:  BRA    27CC
252A:  ADDLW  08
252C:  MOVLB  0
252E:  GOTO   28CC
.................... 			case 0: result=device[dev].type; break;
2532:  MOVLB  9
2534:  CLRF   x95
2536:  MOVFF  98D,994
253A:  CLRF   x97
253C:  MOVLW  0D
253E:  MOVWF  x96
2540:  MOVLB  0
2542:  CALL   084C
2546:  MOVFF  02,990
254A:  MOVFF  01,98F
254E:  MOVLW  21
2550:  MOVLB  9
2552:  ADDWF  01,W
2554:  MOVWF  FE9
2556:  MOVLW  00
2558:  ADDWFC 02,W
255A:  MOVWF  FEA
255C:  CLRF   x8C
255E:  MOVFF  FEF,98B
2562:  BRA    27CC
.................... 			case 1: result=device[dev].typeWorld; break;
2564:  MOVLB  9
2566:  CLRF   x95
2568:  MOVFF  98D,994
256C:  CLRF   x97
256E:  MOVLW  0D
2570:  MOVWF  x96
2572:  MOVLB  0
2574:  CALL   084C
2578:  MOVFF  02,990
257C:  MOVFF  01,98F
2580:  MOVLW  01
2582:  MOVLB  9
2584:  ADDWF  01,W
2586:  MOVWF  01
2588:  MOVLW  00
258A:  ADDWFC 02,W
258C:  MOVWF  03
258E:  MOVF   01,W
2590:  ADDLW  21
2592:  MOVWF  FE9
2594:  MOVLW  00
2596:  ADDWFC 03,W
2598:  MOVWF  FEA
259A:  MOVFF  FEC,98C
259E:  MOVF   FED,F
25A0:  MOVFF  FEF,98B
25A4:  BRA    27CC
.................... 			case 2: result=device[dev].transmitEvery; break;
25A6:  MOVLB  9
25A8:  CLRF   x95
25AA:  MOVFF  98D,994
25AE:  CLRF   x97
25B0:  MOVLW  0D
25B2:  MOVWF  x96
25B4:  MOVLB  0
25B6:  CALL   084C
25BA:  MOVFF  02,990
25BE:  MOVFF  01,98F
25C2:  MOVLW  03
25C4:  MOVLB  9
25C6:  ADDWF  01,W
25C8:  MOVWF  01
25CA:  MOVLW  00
25CC:  ADDWFC 02,W
25CE:  MOVWF  03
25D0:  MOVF   01,W
25D2:  ADDLW  21
25D4:  MOVWF  FE9
25D6:  MOVLW  00
25D8:  ADDWFC 03,W
25DA:  MOVWF  FEA
25DC:  CLRF   x8C
25DE:  MOVFF  FEF,98B
25E2:  BRA    27CC
.................... 			case 3: result=device[dev].networkAddress; break;
25E4:  MOVLB  9
25E6:  CLRF   x95
25E8:  MOVFF  98D,994
25EC:  CLRF   x97
25EE:  MOVLW  0D
25F0:  MOVWF  x96
25F2:  MOVLB  0
25F4:  CALL   084C
25F8:  MOVFF  02,990
25FC:  MOVFF  01,98F
2600:  MOVLW  04
2602:  MOVLB  9
2604:  ADDWF  01,W
2606:  MOVWF  01
2608:  MOVLW  00
260A:  ADDWFC 02,W
260C:  MOVWF  03
260E:  MOVF   01,W
2610:  ADDLW  21
2612:  MOVWF  FE9
2614:  MOVLW  00
2616:  ADDWFC 03,W
2618:  MOVWF  FEA
261A:  CLRF   x8C
261C:  MOVFF  FEF,98B
2620:  BRA    27CC
.................... 			case 4: result=make16(make8(device[dev].serialNumber,3),make8(device[dev].serialNumber,2)); break;
2622:  MOVLB  9
2624:  CLRF   x95
2626:  MOVFF  98D,994
262A:  CLRF   x97
262C:  MOVLW  0D
262E:  MOVWF  x96
2630:  MOVLB  0
2632:  CALL   084C
2636:  MOVFF  01,98F
263A:  MOVLW  05
263C:  MOVLB  9
263E:  ADDWF  01,W
2640:  MOVWF  01
2642:  MOVLW  00
2644:  ADDWFC 02,W
2646:  MOVWF  03
2648:  MOVF   01,W
264A:  ADDLW  21
264C:  MOVWF  FE9
264E:  MOVLW  00
2650:  ADDWFC 03,W
2652:  MOVWF  FEA
2654:  MOVFF  FEF,98F
2658:  MOVFF  FEC,990
265C:  MOVFF  FEC,991
2660:  MOVFF  FEC,992
2664:  MOVFF  992,993
2668:  CLRF   x95
266A:  MOVFF  98D,994
266E:  CLRF   x97
2670:  MOVLW  0D
2672:  MOVWF  x96
2674:  MOVLB  0
2676:  CALL   084C
267A:  MOVFF  01,994
267E:  MOVLW  05
2680:  MOVLB  9
2682:  ADDWF  01,W
2684:  MOVWF  01
2686:  MOVLW  00
2688:  ADDWFC 02,W
268A:  MOVWF  03
268C:  MOVF   01,W
268E:  ADDLW  21
2690:  MOVWF  FE9
2692:  MOVLW  00
2694:  ADDWFC 03,W
2696:  MOVWF  FEA
2698:  MOVFF  FEF,994
269C:  MOVFF  FEC,995
26A0:  MOVFF  FEC,996
26A4:  MOVFF  FEC,997
26A8:  MOVFF  996,998
26AC:  MOVFF  992,98C
26B0:  MOVFF  996,98B
26B4:  BRA    27CC
.................... 			case 5: result=make16(make8(device[dev].serialNumber,1),make8(device[dev].serialNumber,0)); break;
26B6:  MOVLB  9
26B8:  CLRF   x95
26BA:  MOVFF  98D,994
26BE:  CLRF   x97
26C0:  MOVLW  0D
26C2:  MOVWF  x96
26C4:  MOVLB  0
26C6:  CALL   084C
26CA:  MOVFF  01,98F
26CE:  MOVLW  05
26D0:  MOVLB  9
26D2:  ADDWF  01,W
26D4:  MOVWF  01
26D6:  MOVLW  00
26D8:  ADDWFC 02,W
26DA:  MOVWF  03
26DC:  MOVF   01,W
26DE:  ADDLW  21
26E0:  MOVWF  FE9
26E2:  MOVLW  00
26E4:  ADDWFC 03,W
26E6:  MOVWF  FEA
26E8:  MOVFF  FEF,98F
26EC:  MOVFF  FEC,990
26F0:  MOVFF  FEC,991
26F4:  MOVFF  FEC,992
26F8:  MOVFF  990,993
26FC:  CLRF   x95
26FE:  MOVFF  98D,994
2702:  CLRF   x97
2704:  MOVLW  0D
2706:  MOVWF  x96
2708:  MOVLB  0
270A:  CALL   084C
270E:  MOVFF  01,994
2712:  MOVLW  05
2714:  MOVLB  9
2716:  ADDWF  01,W
2718:  MOVWF  01
271A:  MOVLW  00
271C:  ADDWFC 02,W
271E:  MOVWF  03
2720:  MOVF   01,W
2722:  ADDLW  21
2724:  MOVWF  FE9
2726:  MOVLW  00
2728:  ADDWFC 03,W
272A:  MOVWF  FEA
272C:  MOVFF  FEF,994
2730:  MOVFF  FEC,995
2734:  MOVFF  FEC,996
2738:  MOVFF  FEC,997
273C:  MOVFF  994,998
2740:  MOVFF  990,98C
2744:  MOVFF  994,98B
2748:  BRA    27CC
.................... 			case 6: result=device[dev].startRegister; break;
274A:  MOVLB  9
274C:  CLRF   x95
274E:  MOVFF  98D,994
2752:  CLRF   x97
2754:  MOVLW  0D
2756:  MOVWF  x96
2758:  MOVLB  0
275A:  CALL   084C
275E:  MOVFF  02,990
2762:  MOVFF  01,98F
2766:  MOVLW  09
2768:  MOVLB  9
276A:  ADDWF  01,W
276C:  MOVWF  01
276E:  MOVLW  00
2770:  ADDWFC 02,W
2772:  MOVWF  03
2774:  MOVF   01,W
2776:  ADDLW  21
2778:  MOVWF  FE9
277A:  MOVLW  00
277C:  ADDWFC 03,W
277E:  MOVWF  FEA
2780:  MOVFF  FEC,98C
2784:  MOVF   FED,F
2786:  MOVFF  FEF,98B
278A:  BRA    27CC
.................... 			case 7: result=device[dev].nRegisters; break;
278C:  MOVLB  9
278E:  CLRF   x95
2790:  MOVFF  98D,994
2794:  CLRF   x97
2796:  MOVLW  0D
2798:  MOVWF  x96
279A:  MOVLB  0
279C:  CALL   084C
27A0:  MOVFF  02,990
27A4:  MOVFF  01,98F
27A8:  MOVLW  0B
27AA:  MOVLB  9
27AC:  ADDWF  01,W
27AE:  MOVWF  01
27B0:  MOVLW  00
27B2:  ADDWFC 02,W
27B4:  MOVWF  03
27B6:  MOVF   01,W
27B8:  ADDLW  21
27BA:  MOVWF  FE9
27BC:  MOVLW  00
27BE:  ADDWFC 03,W
27C0:  MOVWF  FEA
27C2:  CLRF   x8C
27C4:  MOVFF  FEF,98B
27C8:  BRA    27CC
27CA:  MOVLB  9
.................... 		}
.................... 	} else {
27CC:  BRA    2894
.................... 		switch ( address ) {
27CE:  MOVF   x88,W
27D0:  MOVWF  00
27D2:  MOVF   x89,W
27D4:  MOVWF  03
27D6:  MOVLW  03
27D8:  SUBWF  03,W
27DA:  BNZ   27E6
27DC:  MOVLW  E8
27DE:  SUBWF  00,W
27E0:  MOVLB  0
27E2:  BZ    2848
27E4:  MOVLB  9
27E6:  MOVLW  03
27E8:  SUBWF  03,W
27EA:  BNZ   27F6
27EC:  MOVLW  E9
27EE:  SUBWF  00,W
27F0:  MOVLB  0
27F2:  BZ    2852
27F4:  MOVLB  9
27F6:  MOVLW  03
27F8:  SUBWF  03,W
27FA:  BNZ   2806
27FC:  MOVLW  EA
27FE:  SUBWF  00,W
2800:  MOVLB  0
2802:  BZ    285E
2804:  MOVLB  9
2806:  MOVLW  03
2808:  SUBWF  03,W
280A:  BNZ   2816
280C:  MOVLW  EB
280E:  SUBWF  00,W
2810:  MOVLB  0
2812:  BZ    2868
2814:  MOVLB  9
2816:  MOVLW  03
2818:  SUBWF  03,W
281A:  BNZ   2826
281C:  MOVLW  EC
281E:  SUBWF  00,W
2820:  MOVLB  0
2822:  BZ    2870
2824:  MOVLB  9
2826:  MOVLW  03
2828:  SUBWF  03,W
282A:  BNZ   2836
282C:  MOVLW  ED
282E:  SUBWF  00,W
2830:  MOVLB  0
2832:  BZ    287A
2834:  MOVLB  9
2836:  MOVLW  04
2838:  SUBWF  03,W
283A:  BNZ   2846
283C:  MOVLW  4C
283E:  SUBWF  00,W
2840:  MOVLB  0
2842:  BZ    2882
2844:  MOVLB  9
2846:  BRA    288E
.................... 			case 1000: result=config.serial_prefix; break;
2848:  MOVLB  9
284A:  CLRF   x8C
284C:  MOVFF  583,98B
2850:  BRA    2894
.................... 			case 1001: result=config.serial_number; break;
2852:  MOVFF  585,98C
2856:  MOVFF  584,98B
285A:  MOVLB  9
285C:  BRA    2894
.................... 			case 1002: result='R'; break;
285E:  MOVLB  9
2860:  CLRF   x8C
2862:  MOVLW  52
2864:  MOVWF  x8B
2866:  BRA    2894
.................... 			case 1003: result=0; break;
2868:  MOVLB  9
286A:  CLRF   x8C
286C:  CLRF   x8B
286E:  BRA    2894
.................... 			case 1004: result='4'; break;
2870:  MOVLB  9
2872:  CLRF   x8C
2874:  MOVLW  34
2876:  MOVWF  x8B
2878:  BRA    2894
.................... 			case 1005: result=0; break;
287A:  MOVLB  9
287C:  CLRF   x8C
287E:  CLRF   x8B
2880:  BRA    2894
.................... 	
.................... 			case 1100: result=config.live_interval; break;
2882:  MOVFF  587,98C
2886:  MOVFF  586,98B
288A:  MOVLB  9
288C:  BRA    2894
.................... 	
.................... 			default: return ILLEGAL_DATA_ADDRESS;
288E:  MOVLW  02
2890:  MOVWF  01
2892:  BRA    28C6
.................... 		}
.................... 	}
.................... 
.................... //	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u) result=%lu\r\n",address,n,result);
.................... 
.................... 	query.buff[n]  =make8(result,1);
2894:  MOVLW  6C
2896:  ADDWF  x8A,W
2898:  MOVWF  FE9
289A:  MOVLW  04
289C:  MOVWF  FEA
289E:  BTFSC  FD8.0
28A0:  INCF   FEA,F
28A2:  MOVFF  98C,FEF
.................... 	query.buff[n+1]=make8(result,0);
28A6:  MOVLW  01
28A8:  ADDWF  x8A,W
28AA:  ADDLW  6C
28AC:  MOVWF  FE9
28AE:  MOVLW  04
28B0:  MOVWF  FEA
28B2:  BTFSC  FD8.0
28B4:  INCF   FEA,F
28B6:  MOVFF  98B,FEF
.................... 	query.resultLength += 2;
28BA:  MOVLW  02
28BC:  MOVLB  5
28BE:  ADDWF  x82,F
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u, result=%lu, query.resultLength=%u)\r\n",
.................... 		address,
.................... 		n,
.................... 		result,
.................... 		query.resultLength
.................... 	);
.................... #endif
.................... 
.................... 
.................... 	return 0;
28C0:  MOVLW  00
28C2:  MOVWF  01
28C4:  MOVLB  9
28C6:  MOVLB  0
28C8:  GOTO   2926 (RETURN)
.................... }
.................... 
.................... exception query_self_read_registers(int16 address, int8 nRegisters) {
*
28F6:  MOVLB  9
28F8:  CLRF   x84
.................... 	int8 i;
.................... 	exception e=0;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers (address=%lu, nRegisters=%u)\r\n",address,nRegisters);
.................... #endif
.................... 
.................... 	for ( i=0 ; i<nRegisters && 0==e ; i++ ) {
28FA:  CLRF   x83
28FC:  MOVF   x82,W
28FE:  SUBWF  x83,W
2900:  BC    2930
2902:  MOVF   x84,F
2904:  BNZ   2930
.................... 		e=query_self_read_register(address+i,i*2);
2906:  MOVF   x83,W
2908:  ADDWF  x80,W
290A:  MOVWF  x85
290C:  MOVLW  00
290E:  ADDWFC x81,W
2910:  MOVWF  x86
2912:  BCF    FD8.0
2914:  RLCF   x83,W
2916:  MOVWF  x87
2918:  MOVFF  986,989
291C:  MOVFF  985,988
2920:  MOVWF  x8A
2922:  MOVLB  0
2924:  BRA    24E8
2926:  MOVFF  01,984
.................... 	}
.................... 
.................... 
.................... #if DEBUG_ASCII
292A:  MOVLB  9
292C:  INCF   x83,F
292E:  BRA    28FC
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers returning e=%u\r\n",e);
.................... #endif
.................... 
.................... 
.................... 	return e;
2930:  MOVFF  984,01
2934:  MOVLB  0
2936:  GOTO   2CE8 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void query_self(void) {
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self( query.function=%lu, query.start_address=%lu, query.n_words=%u)\r\n",
.................... 		query.function,
.................... 		query.start_address,
.................... 		query.n_words
.................... 	);
.................... #endif
.................... 
.................... 	query.resultLength=0;
*
2C94:  MOVLB  5
2C96:  CLRF   x82
.................... 
.................... 	switch ( query.function ) {
2C98:  MOVF   x79,W
2C9A:  MOVWF  00
2C9C:  MOVF   x7A,W
2C9E:  MOVWF  03
2CA0:  MOVF   03,W
2CA2:  BNZ   2CAE
2CA4:  MOVLW  03
2CA6:  SUBWF  00,W
2CA8:  MOVLB  0
2CAA:  BZ    2CDA
2CAC:  MOVLB  5
2CAE:  MOVF   03,W
2CB0:  BNZ   2CBC
2CB2:  MOVLW  04
2CB4:  SUBWF  00,W
2CB6:  MOVLB  0
2CB8:  BZ    2CDA
2CBA:  MOVLB  5
2CBC:  MOVF   03,W
2CBE:  BNZ   2CCA
2CC0:  MOVLW  06
2CC2:  SUBWF  00,W
2CC4:  MOVLB  0
2CC6:  BZ    2CEE
2CC8:  MOVLB  5
2CCA:  MOVF   03,W
2CCC:  BNZ   2CD8
2CCE:  MOVLW  07
2CD0:  SUBWF  00,W
2CD2:  MOVLB  0
2CD4:  BZ    2D38
2CD6:  MOVLB  5
2CD8:  BRA    2D3C
.................... 		case DEV_TYPE_MODBUS_3:
.................... 		case DEV_TYPE_MODBUS_4:
.................... 			/* read registers */
.................... 			query.resultException=query_self_read_registers(query.start_address, query.n_words);
2CDA:  MOVFF  57C,981
2CDE:  MOVFF  57B,980
2CE2:  MOVFF  57D,982
2CE6:  BRA    28F6
2CE8:  MOVFF  01,581
.................... 			break;
2CEC:  BRA    2D42
.................... 		case DEV_TYPE_MODBUS_6:
.................... 			/* write single register */
.................... 			query.resultException=query_self_write_register(query.start_address, 
.................... 				make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
2CEE:  MOVLW  6C
2CF0:  MOVLB  5
2CF2:  ADDWF  x7E,W
2CF4:  MOVWF  FE9
2CF6:  MOVLW  04
2CF8:  MOVWF  FEA
2CFA:  BTFSC  FD8.0
2CFC:  INCF   FEA,F
2CFE:  MOVFF  FEF,980
2D02:  MOVLW  01
2D04:  ADDWF  x7E,W
2D06:  ADDLW  6C
2D08:  MOVWF  FE9
2D0A:  MOVLW  04
2D0C:  MOVWF  FEA
2D0E:  BTFSC  FD8.0
2D10:  INCF   FEA,F
2D12:  MOVFF  FEF,981
2D16:  MOVFF  980,983
2D1A:  MOVFF  981,982
2D1E:  MOVFF  57C,985
2D22:  MOVFF  57B,984
2D26:  MOVFF  980,987
2D2A:  MOVFF  981,986
2D2E:  MOVLB  0
2D30:  BRA    293A
2D32:  MOVFF  01,581
.................... 			break;
2D36:  BRA    2D42
.................... 		case DEV_TYPE_MODBUS_16:
.................... 			/* write multiple registers */
.................... 			break;
2D38:  BRA    2D42
2D3A:  MOVLB  5
.................... 		default:
.................... 			query.resultException=ILLEGAL_FUNCTION;
2D3C:  MOVLW  01
2D3E:  MOVWF  x81
.................... 			query.resultLength=0;
2D40:  CLRF   x82
2D42:  MOVLB  0
.................... 	}
2D44:  GOTO   35EE (RETURN)
.................... }
.................... 
.................... /*
.................... Remote query (from WorldData to us) syntax
.................... '#'                 0  STX
.................... RECV'R ID PREFIX    1  First character (A-Z) for gateway serial number
.................... RECV'R ID MSB       2  gateway serial number
.................... RECV'R ID LSB       3  
.................... PACKET LENGTH       4  
.................... PACKET TYPE         5  type of packet we are receiving (19)
.................... QUERY ID MSB        6  32 bit query id that we must answer with
.................... QUERY ID            7
.................... QUERY ID            8
.................... QUERY ID LSB        9
.................... QUERY DEV SN MSB    10 32 bit serial number of device to query
.................... QUERY DEV SN        11
.................... QUERY DEV SN        12
.................... QUERY DEV SN LSB    13
.................... Q NETWORK ADDR MSB  14 Network address of device to query, if SN not specified
.................... Q NETWORK ADDR LSB  15
.................... QUERY FUNCTION MSB  16 type of query to perform
.................... QUERY FUNCTION LSB  17
.................... QUERY ADDRESS MSB   18 start address for query
.................... QUERY ADDRESS LSB   19
.................... QUERY N WORDS       20 number of 16-bit words in query data
.................... QUERY DATA[0] MSB   [] first word of query data
.................... QUERY DATA[0] LSB   [+1]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... 
.................... Parse first four bytes for match to our serial number. If matched, receive rest 
.................... of packet and do checksum.
.................... 
.................... Send query to network one of two ways:
.................... if ( 0 != query_dev_sn ) then scan device table to determine network id
.................... else use network id
.................... 
.................... if ( 0==network id || our_serial_number==query_dev_sn ) then use local registers
.................... else perform network query
.................... */
.................... 
.................... void query_reset(void) {
.................... 	query.buff_pos=0;
*
05B8:  MOVLB  5
05BA:  CLRF   x6C
.................... 	
.................... 	/* !buff_ready causes serial receive interrupt to throw out data ... so clear last */
.................... 	query.buff_ready=0;
05BC:  CLRF   x6D
05BE:  MOVLB  0
05C0:  RETURN 0
.................... }
.................... 
.................... /* 
.................... response to remote query (from us to WorldData)
.................... '#'                 0  STX
.................... SERIAL PREFIX       1  First character (A-Z) for serial number
.................... SERIAL MSB          2  high byte of sending station ID
.................... SERIAL LSB          3  low byte of sending station ID
.................... PACKET LENGTH       4  always 0xff
.................... PACKET TYPE         5  type of packet we are sending (20)
.................... PACKET LENGTH MSB   6  number of byte for packet including STX through CRC
.................... PACKET LENGTH LSB   7
.................... QUERY ID MSB        8  32 bit query id that we are answering
.................... QUERY ID            9
.................... QUERY ID            10
.................... QUERY ID LSB        11
.................... QUERY EXCEPTION     12 exception encountered in performing query
.................... QUERY DATA[0] MSB [13] first word of query data
.................... QUERY DATA[0] LSB [14]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... */
.................... void query_response(void) {
.................... 	int8 buff[13];
.................... 	int16 l;
.................... 	int8 i;
.................... 
.................... 	buff[0]='#';
*
33D8:  MOVLW  23
33DA:  MOVLB  9
33DC:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
33DE:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
33E2:  MOVFF  585,982
33E6:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0);
33E8:  MOVFF  584,983
33EC:  MOVLB  9
.................... 	buff[4]=0xff;
33EE:  SETF   x84
.................... 	buff[5]=20;
33F0:  MOVLW  14
33F2:  MOVWF  x85
.................... 	/* packet length */
.................... 	l=sizeof(buff)+query.resultLength+2;
33F4:  MOVLW  0D
33F6:  MOVLB  5
33F8:  ADDWF  x82,W
33FA:  ADDLW  02
33FC:  MOVLB  9
33FE:  MOVWF  x8D
3400:  CLRF   x8E
3402:  BTFSC  FD8.0
3404:  INCF   x8E,F
.................... 	buff[6]=make8(l,1);
3406:  MOVFF  98E,986
.................... 	buff[7]=make8(l,0);
340A:  MOVFF  98D,987
.................... 
.................... 	buff[8]=make8(query.query_id,3);
340E:  MOVFF  572,988
3412:  MOVLB  9
.................... 	buff[9]=make8(query.query_id,2);
3414:  MOVFF  571,989
3418:  MOVLB  9
.................... 	buff[10]=make8(query.query_id,1);
341A:  MOVFF  570,98A
341E:  MOVLB  9
.................... 	buff[11]=make8(query.query_id,0);
3420:  MOVFF  56F,98B
3424:  MOVLB  9
.................... 	buff[12]=query.resultException;
3426:  MOVFF  581,98C
.................... 
.................... 	/* compute CRC on header (skip STX) and result data */
.................... 	l=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
342A:  SETF   x94
342C:  SETF   x93
342E:  MOVLW  09
3430:  MOVWF  x96
3432:  MOVLW  81
3434:  MOVWF  x95
3436:  MOVLW  0C
3438:  MOVWF  x97
343A:  MOVLB  0
343C:  CALL   1930
3440:  MOVFF  02,98E
3444:  MOVFF  01,98D
.................... 	l=crc_chk_pass(l,query.buff,query.resultLength);
3448:  MOVFF  98E,994
344C:  MOVFF  98D,993
3450:  MOVLW  04
3452:  MOVLB  9
3454:  MOVWF  x96
3456:  MOVLW  6C
3458:  MOVWF  x95
345A:  MOVFF  582,997
345E:  MOVLB  0
3460:  CALL   1930
3464:  MOVFF  02,98E
3468:  MOVFF  01,98D
.................... 
.................... 	output_high(CTRL_0);
346C:  BCF    F92.0
346E:  BSF    F89.0
.................... 	/* send buff, result, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
3470:  MOVLB  9
3472:  CLRF   x8F
3474:  MOVF   x8F,W
3476:  SUBLW  0C
3478:  BNC   349A
.................... 		fputc(buff[i],STREAM_WORLD);
347A:  CLRF   03
347C:  MOVF   x8F,W
347E:  ADDLW  80
3480:  MOVWF  FE9
3482:  MOVLW  09
3484:  ADDWFC 03,W
3486:  MOVWF  FEA
3488:  MOVFF  FEF,990
348C:  MOVF   x90,W
348E:  MOVLB  0
3490:  CALL   198E
3494:  MOVLB  9
3496:  INCF   x8F,F
3498:  BRA    3474
.................... 	}	
.................... 	for ( i=0 ; i<query.resultLength ; i++ ) {
349A:  CLRF   x8F
349C:  MOVLB  5
349E:  MOVF   x82,W
34A0:  MOVLB  9
34A2:  SUBWF  x8F,W
34A4:  BC    34C6
.................... 		fputc(query.buff[i],STREAM_WORLD);
34A6:  MOVLW  6C
34A8:  ADDWF  x8F,W
34AA:  MOVWF  FE9
34AC:  MOVLW  04
34AE:  MOVWF  FEA
34B0:  BTFSC  FD8.0
34B2:  INCF   FEA,F
34B4:  MOVFF  FEF,990
34B8:  MOVF   x90,W
34BA:  MOVLB  0
34BC:  CALL   198E
34C0:  MOVLB  9
34C2:  INCF   x8F,F
34C4:  BRA    349C
.................... 	}
.................... 	fputc(make8(l,1),STREAM_WORLD);
34C6:  MOVFF  98E,990
34CA:  MOVF   x90,W
34CC:  MOVLB  0
34CE:  CALL   198E
.................... 	fputc(make8(l,0),STREAM_WORLD);
34D2:  MOVFF  98D,990
34D6:  MOVLB  9
34D8:  MOVF   x90,W
34DA:  MOVLB  0
34DC:  CALL   198E
.................... 
.................... 
.................... 	delay_ms(10);
34E0:  MOVLW  0A
34E2:  MOVLB  9
34E4:  MOVWF  x90
34E6:  MOVLB  0
34E8:  CALL   068A
.................... 	output_low(CTRL_0);
34EC:  BCF    F92.0
34EE:  BCF    F89.0
.................... 
.................... #if 0
34F0:  GOTO   35F8 (RETURN)
.................... 	fprintf(STREAM_WORLD,"# query result (query.resultLength=%u query.resultException=%u):\r\n",query.resultLength,query.resultException);
.................... 	/* query.resultLength is in bytes  .... result is in 16-bit words */
.................... 	for ( i=0 ; i<query.resultLength ; i+=2 ) {
.................... 		fprintf(STREAM_WORLD,"# query.buff[%u]=%lu (0x%04lX)\r\n",
.................... 			i/2,
.................... 			make16(query.buff[i],query.buff[i+1]),
.................... 			make16(query.buff[i],query.buff[i+1])
.................... 		);
.................... 		query.buff[i]=0xff;
.................... 		query.buff[i+1]=0xff;
.................... 	}
.................... #endif
.................... }
.................... 
.................... /* we received a query addressed to us */
.................... void query_process(void) {
.................... 	int32 our_serial;
.................... //	int8 i;
.................... 	int16 lCRC;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# in query_process()\r\n");
.................... #endif
.................... 
.................... 	query.packet_length=query.buff[4];
34F4:  MOVFF  470,56E
.................... 	query.crc=make16(query.buff[query.packet_length-2],query.buff[query.packet_length-1]);	
34F8:  MOVLW  02
34FA:  MOVLB  5
34FC:  SUBWF  x6E,W
34FE:  ADDLW  6C
3500:  MOVWF  FE9
3502:  MOVLW  04
3504:  MOVWF  FEA
3506:  BTFSC  FD8.0
3508:  INCF   FEA,F
350A:  MOVFF  FEF,580
350E:  MOVLW  01
3510:  SUBWF  x6E,W
3512:  ADDLW  6C
3514:  MOVWF  FE9
3516:  MOVLW  04
3518:  MOVWF  FEA
351A:  BTFSC  FD8.0
351C:  INCF   FEA,F
351E:  MOVFF  FEF,57F
.................... 	lCRC = crc_chk_pass(0xFFFF,query.buff+1,query.packet_length-3);
3522:  MOVLW  03
3524:  SUBWF  x6E,W
3526:  MOVLB  9
3528:  MOVWF  x80
352A:  SETF   x94
352C:  SETF   x93
352E:  MOVLW  04
3530:  MOVWF  x96
3532:  MOVLW  6D
3534:  MOVWF  x95
3536:  MOVFF  980,997
353A:  MOVLB  0
353C:  CALL   1930
3540:  MOVFF  02,97F
3544:  MOVFF  01,97E
.................... 
.................... 	if ( lCRC != query.crc ) {
3548:  MOVLB  5
354A:  MOVF   x7F,W
354C:  MOVLB  9
354E:  SUBWF  x7E,W
3550:  BNZ   355C
3552:  MOVLB  5
3554:  MOVF   x80,W
3556:  MOVLB  9
3558:  SUBWF  x7F,W
355A:  BZ    355E
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# CRC 0x%04lX != 0x%04lX (LOCAL)\r\n",query.crc,lCRC);
.................... #endif
.................... 		return;
355C:  BRA    35FA
.................... 	}
.................... 
.................... 
.................... 	if ( 19 != query.buff[5] ) {
355E:  MOVLB  4
3560:  MOVF   x71,W
3562:  SUBLW  13
3564:  BZ    356C
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# not query type 19 ... don't know how to handle!\r\n");
.................... #endif
.................... 		return;
3566:  MOVLB  9
3568:  BRA    35FA
356A:  MOVLB  4
.................... 	}
.................... 
.................... 	
.................... 	query.query_id=make32(query.buff[6],query.buff[7],query.buff[8],query.buff[9]);
356C:  MOVFF  472,572
3570:  MOVFF  473,571
3574:  MOVFF  474,570
3578:  MOVFF  475,56F
.................... 	query.device_serial=make32(query.buff[10],query.buff[11],query.buff[12],query.buff[13]);
357C:  MOVFF  476,576
3580:  MOVFF  477,575
3584:  MOVFF  478,574
3588:  MOVFF  479,573
.................... 	query.network_address=make16(query.buff[14],query.buff[15]);
358C:  MOVFF  47A,578
3590:  MOVFF  47B,577
.................... 	query.function=make16(query.buff[16],query.buff[17]);
3594:  MOVFF  47C,57A
3598:  MOVFF  47D,579
.................... 	query.start_address=make16(query.buff[18],query.buff[19]);
359C:  MOVFF  47E,57C
35A0:  MOVFF  47F,57B
.................... 	query.n_words=query.buff[20];
35A4:  MOVFF  480,57D
.................... 	query.data_start_offset=21;
35A8:  MOVLW  15
35AA:  MOVLB  5
35AC:  MOVWF  x7E
.................... 	
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# length=%u (query.buff_pos=%u)\r\n",query.packet_length,query.buff_pos);
.................... 	fprintf(STREAM_WORLD,"# query_id=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.query_id,3),
.................... 		make8(query.query_id,2),
.................... 		make8(query.query_id,1),
.................... 		make8(query.query_id,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# device serial=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.device_serial,3),
.................... 		make8(query.device_serial,2),
.................... 		make8(query.device_serial,1),
.................... 		make8(query.device_serial,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# network address=%lu\r\n",query.network_address);
.................... 	fprintf(STREAM_WORLD,"# function=%lu\r\n",query.function);
.................... 	fprintf(STREAM_WORLD,"# start address=%lu\r\n",query.start_address);
.................... 	fprintf(STREAM_WORLD,"# n_words=%u\r\n",query.n_words);
.................... 
.................... 	/* n words can be the number of query words, in which case we won't have any data besides the CRC */
.................... 	for ( i=0 ; i<query.n_words && i<query.packet_length-2 ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# word[%u]=%lu\r\n",i,make16(query.buff[21+i*2],query.buff[22+i*2]));
.................... 	}
.................... 
.................... 	fprintf(STREAM_WORLD,"# rCRC=%lu\r\n",query.crc);
.................... #endif
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# dump whole packet:\r\n");
.................... 	for ( i=0 ; i<query.packet_length ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# buff[%u]=0x%02X",i,query.buff[i]);
.................... 		if ( i==query.data_start_offset )
.................... 			fprintf(STREAM_WORLD," (start)");
.................... 		fprintf(STREAM_WORLD,"\r\n");
.................... 	}
.................... #endif
.................... 
.................... 	query.resultLength=0;
35AE:  CLRF   x82
.................... 	/* check to see who handles this query */
.................... 	our_serial=make32(0,config.serial_prefix,config.serial_number);
35B0:  MOVLB  9
35B2:  CLRF   x7D
35B4:  MOVFF  583,97C
35B8:  MOVFF  584,97A
35BC:  MOVFF  585,97B
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"#   our serial=%c%lu\r\n",config.serial_prefix,config.serial_number);
.................... 	fprintf(STREAM_WORLD,"# query serial=%c%lu\r\n",make8(query.device_serial,2),(int16) query.device_serial);
.................... #endif
.................... 
.................... 	if ( our_serial == query.device_serial ) {
35C0:  MOVLB  5
35C2:  MOVF   x73,W
35C4:  MOVLB  9
35C6:  SUBWF  x7A,W
35C8:  BNZ   35F2
35CA:  MOVLB  5
35CC:  MOVF   x74,W
35CE:  MOVLB  9
35D0:  SUBWF  x7B,W
35D2:  BNZ   35F2
35D4:  MOVLB  5
35D6:  MOVF   x75,W
35D8:  MOVLB  9
35DA:  SUBWF  x7C,W
35DC:  BNZ   35F2
35DE:  MOVLB  5
35E0:  MOVF   x76,W
35E2:  MOVLB  9
35E4:  SUBWF  x7D,W
35E6:  BNZ   35F2
.................... 		query_self();
35E8:  MOVLB  0
35EA:  GOTO   2C94
.................... 	} else {
35EE:  BRA    35F6
35F0:  MOVLB  9
.................... 		query_other();
35F2:  MOVLB  0
35F4:  BRA    30B4
.................... 		
.................... 	}	
.................... 
.................... 	query_response();
35F6:  BRA    33D8
35F8:  MOVLB  9
35FA:  MOVLB  0
35FC:  GOTO   37E0 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void deviceQuery(void) {
.................... 	static int16 measurementNumber=0;
.................... 	static int8  nCycles[DEV_MAX_N];
.................... 	int8 n;
.................... 	int16 l;
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... #endif
.................... 
.................... 	/* check if next cycle will be an SBD transmission. */
.................... 	if ( 1 == timers.sbd_cycle ) {
*
1D1C:  MOVLB  3
1D1E:  DECFSZ x65,W
1D20:  BRA    1D2E
1D22:  MOVF   x66,F
1D24:  BNZ   1D2E
.................... 		/* next cycle will be an Iridium transmit cycle, so turn on modem and clear outgoing buffer */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() next cycle will be SBD transmit cycle.\r\n");
.................... #endif
.................... //		iridium_on();
.................... 		iridium_mo_clear();
1D26:  MOVLB  0
1D28:  CALL   1356
1D2C:  MOVLB  3
.................... 	}
.................... 
.................... 	/* check if we are going to be doing a SBD transmision */
.................... 	if ( 0 == timers.sbd_cycle ) {
1D2E:  MOVF   x65,F
1D30:  BNZ   1D82
1D32:  MOVF   x66,F
1D34:  BNZ   1D82
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() this cycle is an SBD transmit cycle.\r\n");
.................... #endif
.................... 		/* turn on modem in case it isn't already on */
.................... //		iridium_on();
.................... 		/* clear MO buffer */
.................... 		iridium_mo_clear();
1D36:  MOVLB  0
1D38:  CALL   1356
.................... 
.................... 		/* build header */
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,1);
1D3C:  MOVLB  7
1D3E:  MOVFF  7DB,03
1D42:  MOVF   xDA,W
1D44:  INCF   xDA,F
1D46:  BTFSC  FD8.2
1D48:  INCF   xDB,F
1D4A:  MOVLB  9
1D4C:  MOVWF  x7D
1D4E:  MOVLW  CA
1D50:  ADDWF  x7D,W
1D52:  MOVWF  FE9
1D54:  MOVLW  06
1D56:  ADDWFC 03,W
1D58:  MOVWF  FEA
1D5A:  MOVFF  938,FEF
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,0);
1D5E:  MOVLB  7
1D60:  MOVFF  7DB,03
1D64:  MOVF   xDA,W
1D66:  INCF   xDA,F
1D68:  BTFSC  FD8.2
1D6A:  INCF   xDB,F
1D6C:  MOVLB  9
1D6E:  MOVWF  x7D
1D70:  MOVLW  CA
1D72:  ADDWF  x7D,W
1D74:  MOVWF  FE9
1D76:  MOVLW  06
1D78:  ADDWFC 03,W
1D7A:  MOVWF  FEA
1D7C:  MOVFF  937,FEF
1D80:  MOVLB  3
.................... 	}
.................... 
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() querying all enabled devices:\r\n");
.................... #endif
.................... 
.................... 	for ( n=0 ; n<DEV_MAX_N ; n++ ) {
1D82:  MOVLB  9
1D84:  CLRF   x7A
1D86:  MOVF   x7A,W
1D88:  SUBLW  3F
1D8A:  BTFSS  FD8.0
1D8C:  BRA    2490
.................... 		restart_wdt();
1D8E:  CLRWDT
.................... 		timers.led_on_green=100;
1D90:  MOVLW  64
1D92:  MOVLB  3
1D94:  MOVWF  x64
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[n].type ) 
1D96:  MOVLB  9
1D98:  CLRF   x95
1D9A:  MOVFF  97A,994
1D9E:  CLRF   x97
1DA0:  MOVLW  0D
1DA2:  MOVWF  x96
1DA4:  MOVLB  0
1DA6:  CALL   084C
1DAA:  MOVFF  02,97E
1DAE:  MOVFF  01,97D
1DB2:  MOVLW  21
1DB4:  MOVLB  9
1DB6:  ADDWF  01,W
1DB8:  MOVWF  FE9
1DBA:  MOVLW  00
1DBC:  ADDWFC 02,W
1DBE:  MOVWF  FEA
1DC0:  MOVF   FEF,W
1DC2:  BNZ   1DC6
.................... 			continue;
1DC4:  BRA    2488
.................... 
.................... 		nCycles[n]++;
1DC6:  CLRF   03
1DC8:  MOVF   x7A,W
1DCA:  ADDLW  39
1DCC:  MOVWF  FE9
1DCE:  MOVLW  09
1DD0:  ADDWFC 03,W
1DD2:  MOVWF  FEA
1DD4:  INCF   FEF,F
.................... 		if ( nCycles[n] < device[n].transmitEvery ) {
1DD6:  CLRF   03
1DD8:  MOVF   x7A,W
1DDA:  ADDLW  39
1DDC:  MOVWF  FE9
1DDE:  MOVLW  09
1DE0:  ADDWFC 03,W
1DE2:  MOVWF  FEA
1DE4:  MOVFF  FEF,97D
1DE8:  CLRF   x95
1DEA:  MOVFF  97A,994
1DEE:  CLRF   x97
1DF0:  MOVLW  0D
1DF2:  MOVWF  x96
1DF4:  MOVLB  0
1DF6:  CALL   084C
1DFA:  MOVFF  02,97F
1DFE:  MOVFF  01,97E
1E02:  MOVLW  03
1E04:  MOVLB  9
1E06:  ADDWF  01,W
1E08:  MOVWF  01
1E0A:  MOVLW  00
1E0C:  ADDWFC 02,W
1E0E:  MOVWF  03
1E10:  MOVF   01,W
1E12:  ADDLW  21
1E14:  MOVWF  FE9
1E16:  MOVLW  00
1E18:  ADDWFC 03,W
1E1A:  MOVWF  FEA
1E1C:  MOVF   FEF,W
1E1E:  SUBWF  x7D,W
1E20:  BC    1E26
.................... 			continue;
1E22:  BRA    2488
.................... 		} else {
1E24:  BRA    1E36
.................... 			nCycles[n]=0;
1E26:  CLRF   03
1E28:  MOVF   x7A,W
1E2A:  ADDLW  39
1E2C:  MOVWF  FE9
1E2E:  MOVLW  09
1E30:  ADDWFC 03,W
1E32:  MOVWF  FEA
1E34:  CLRF   FEF
.................... 		}
.................... 
.................... 
.................... 
.................... 		qbuff.deviceNumber=n;
1E36:  MOVFF  97A,469
.................... 		qbuff.measurementNumber=measurementNumber;
1E3A:  MOVFF  938,46B
1E3E:  MOVFF  937,46A
.................... 
.................... 
.................... 		if ( device[n].type <= DEV_TYPE_MODBUS_MAX ) {
1E42:  CLRF   x95
1E44:  MOVFF  97A,994
1E48:  CLRF   x97
1E4A:  MOVLW  0D
1E4C:  MOVWF  x96
1E4E:  MOVLB  0
1E50:  CALL   084C
1E54:  MOVFF  02,97E
1E58:  MOVFF  01,97D
1E5C:  MOVLW  21
1E5E:  MOVLB  9
1E60:  ADDWF  01,W
1E62:  MOVWF  FE9
1E64:  MOVLW  00
1E66:  ADDWFC 02,W
1E68:  MOVWF  FEA
1E6A:  MOVF   FEF,W
1E6C:  SUBLW  07
1E6E:  BTFSS  FD8.0
1E70:  BRA    2282
.................... 			/* modbus device type */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() MODBUS device\r\n");
.................... #endif
.................... 			/* set serial port speed */
.................... 			if ( DEV_SERIAL_19200 == device[n].serialSpeed ) {
1E72:  CLRF   x95
1E74:  MOVFF  97A,994
1E78:  CLRF   x97
1E7A:  MOVLW  0D
1E7C:  MOVWF  x96
1E7E:  MOVLB  0
1E80:  CALL   084C
1E84:  MOVFF  02,97E
1E88:  MOVFF  01,97D
1E8C:  MOVLW  0C
1E8E:  MOVLB  9
1E90:  ADDWF  01,W
1E92:  MOVWF  01
1E94:  MOVLW  00
1E96:  ADDWFC 02,W
1E98:  MOVWF  03
1E9A:  MOVF   01,W
1E9C:  ADDLW  21
1E9E:  MOVWF  FE9
1EA0:  MOVLW  00
1EA2:  ADDWFC 03,W
1EA4:  MOVWF  FEA
1EA6:  MOVF   FEF,W
1EA8:  SUBLW  01
1EAA:  BNZ   1EBC
.................... 				set_uart_speed(19200,MODBUS_SERIAL);
1EAC:  BCF    FA7.3
1EAE:  MOVLW  19
1EB0:  MOVWF  FAF
1EB2:  MOVLW  A6
1EB4:  MOVWF  FAC
1EB6:  MOVLW  90
1EB8:  MOVWF  FAB
.................... 			} else {
1EBA:  BRA    1ECA
.................... 				set_uart_speed(9600,MODBUS_SERIAL);
1EBC:  BCF    FA7.3
1EBE:  MOVLW  0C
1EC0:  MOVWF  FAF
1EC2:  MOVLW  A2
1EC4:  MOVWF  FAC
1EC6:  MOVLW  90
1EC8:  MOVWF  FAB
.................... 			}
.................... 
.................... 			if ( DEV_TYPE_MODBUS_3 == device[n].type || DEV_TYPE_MODBUS_4 == device[n].type ) {
1ECA:  CLRF   x95
1ECC:  MOVFF  97A,994
1ED0:  CLRF   x97
1ED2:  MOVLW  0D
1ED4:  MOVWF  x96
1ED6:  MOVLB  0
1ED8:  CALL   084C
1EDC:  MOVFF  02,97E
1EE0:  MOVFF  01,97D
1EE4:  MOVLW  21
1EE6:  MOVLB  9
1EE8:  ADDWF  01,W
1EEA:  MOVWF  FE9
1EEC:  MOVLW  00
1EEE:  ADDWFC 02,W
1EF0:  MOVWF  FEA
1EF2:  MOVF   FEF,W
1EF4:  SUBLW  03
1EF6:  BZ    1F28
1EF8:  CLRF   x95
1EFA:  MOVFF  97A,994
1EFE:  CLRF   x97
1F00:  MOVLW  0D
1F02:  MOVWF  x96
1F04:  MOVLB  0
1F06:  CALL   084C
1F0A:  MOVFF  02,980
1F0E:  MOVFF  01,97F
1F12:  MOVLW  21
1F14:  MOVLB  9
1F16:  ADDWF  01,W
1F18:  MOVWF  FE9
1F1A:  MOVLW  00
1F1C:  ADDWFC 02,W
1F1E:  MOVWF  FEA
1F20:  MOVF   FEF,W
1F22:  SUBLW  04
1F24:  BTFSS  FD8.2
1F26:  BRA    2120
.................... 				/* Modbus read input or holding registers */
.................... 				if ( DEV_TYPE_MODBUS_4 == device[n].type ) {
1F28:  CLRF   x95
1F2A:  MOVFF  97A,994
1F2E:  CLRF   x97
1F30:  MOVLW  0D
1F32:  MOVWF  x96
1F34:  MOVLB  0
1F36:  CALL   084C
1F3A:  MOVFF  02,97E
1F3E:  MOVFF  01,97D
1F42:  MOVLW  21
1F44:  MOVLB  9
1F46:  ADDWF  01,W
1F48:  MOVWF  FE9
1F4A:  MOVLW  00
1F4C:  ADDWFC 02,W
1F4E:  MOVWF  FEA
1F50:  MOVF   FEF,W
1F52:  SUBLW  04
1F54:  BNZ   201C
.................... 					qbuff.rException=modbus_read_input_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
1F56:  CLRF   x95
1F58:  MOVFF  97A,994
1F5C:  CLRF   x97
1F5E:  MOVLW  0D
1F60:  MOVWF  x96
1F62:  MOVLB  0
1F64:  CALL   084C
1F68:  MOVFF  02,97E
1F6C:  MOVFF  01,97D
1F70:  MOVLW  04
1F72:  MOVLB  9
1F74:  ADDWF  01,W
1F76:  MOVWF  01
1F78:  MOVLW  00
1F7A:  ADDWFC 02,W
1F7C:  MOVWF  03
1F7E:  MOVF   01,W
1F80:  ADDLW  21
1F82:  MOVWF  FE9
1F84:  MOVLW  00
1F86:  ADDWFC 03,W
1F88:  MOVWF  FEA
1F8A:  MOVFF  FEF,97D
1F8E:  CLRF   x95
1F90:  MOVFF  97A,994
1F94:  CLRF   x97
1F96:  MOVLW  0D
1F98:  MOVWF  x96
1F9A:  MOVLB  0
1F9C:  CALL   084C
1FA0:  MOVFF  01,97E
1FA4:  MOVLW  09
1FA6:  MOVLB  9
1FA8:  ADDWF  01,W
1FAA:  MOVWF  01
1FAC:  MOVLW  00
1FAE:  ADDWFC 02,W
1FB0:  MOVWF  03
1FB2:  MOVF   01,W
1FB4:  ADDLW  21
1FB6:  MOVWF  FE9
1FB8:  MOVLW  00
1FBA:  ADDWFC 03,W
1FBC:  MOVWF  FEA
1FBE:  MOVFF  FEC,97F
1FC2:  MOVF   FED,F
1FC4:  MOVFF  FEF,97E
1FC8:  CLRF   x95
1FCA:  MOVFF  97A,994
1FCE:  CLRF   x97
1FD0:  MOVLW  0D
1FD2:  MOVWF  x96
1FD4:  MOVLB  0
1FD6:  CALL   084C
1FDA:  MOVFF  02,981
1FDE:  MOVFF  01,980
1FE2:  MOVLW  0B
1FE4:  MOVLB  9
1FE6:  ADDWF  01,W
1FE8:  MOVWF  01
1FEA:  MOVLW  00
1FEC:  ADDWFC 02,W
1FEE:  MOVWF  03
1FF0:  MOVF   01,W
1FF2:  ADDLW  21
1FF4:  MOVWF  FE9
1FF6:  MOVLW  00
1FF8:  ADDWFC 03,W
1FFA:  MOVWF  FEA
1FFC:  MOVFF  FEF,985
2000:  MOVFF  97D,982
2004:  MOVFF  97F,984
2008:  MOVFF  97E,983
200C:  CLRF   x86
200E:  MOVLB  0
2010:  CALL   1800
2014:  MOVFF  01,367
.................... 				} else {
2018:  BRA    20DE
201A:  MOVLB  9
.................... 					qbuff.rException=modbus_read_holding_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
201C:  CLRF   x95
201E:  MOVFF  97A,994
2022:  CLRF   x97
2024:  MOVLW  0D
2026:  MOVWF  x96
2028:  MOVLB  0
202A:  CALL   084C
202E:  MOVFF  02,97E
2032:  MOVFF  01,97D
2036:  MOVLW  04
2038:  MOVLB  9
203A:  ADDWF  01,W
203C:  MOVWF  01
203E:  MOVLW  00
2040:  ADDWFC 02,W
2042:  MOVWF  03
2044:  MOVF   01,W
2046:  ADDLW  21
2048:  MOVWF  FE9
204A:  MOVLW  00
204C:  ADDWFC 03,W
204E:  MOVWF  FEA
2050:  MOVFF  FEF,97D
2054:  CLRF   x95
2056:  MOVFF  97A,994
205A:  CLRF   x97
205C:  MOVLW  0D
205E:  MOVWF  x96
2060:  MOVLB  0
2062:  CALL   084C
2066:  MOVFF  01,97E
206A:  MOVLW  09
206C:  MOVLB  9
206E:  ADDWF  01,W
2070:  MOVWF  01
2072:  MOVLW  00
2074:  ADDWFC 02,W
2076:  MOVWF  03
2078:  MOVF   01,W
207A:  ADDLW  21
207C:  MOVWF  FE9
207E:  MOVLW  00
2080:  ADDWFC 03,W
2082:  MOVWF  FEA
2084:  MOVFF  FEC,97F
2088:  MOVF   FED,F
208A:  MOVFF  FEF,97E
208E:  CLRF   x95
2090:  MOVFF  97A,994
2094:  CLRF   x97
2096:  MOVLW  0D
2098:  MOVWF  x96
209A:  MOVLB  0
209C:  CALL   084C
20A0:  MOVFF  02,981
20A4:  MOVFF  01,980
20A8:  MOVLW  0B
20AA:  MOVLB  9
20AC:  ADDWF  01,W
20AE:  MOVWF  01
20B0:  MOVLW  00
20B2:  ADDWFC 02,W
20B4:  MOVWF  03
20B6:  MOVF   01,W
20B8:  ADDLW  21
20BA:  MOVWF  FE9
20BC:  MOVLW  00
20BE:  ADDWFC 03,W
20C0:  MOVWF  FEA
20C2:  MOVFF  FEF,985
20C6:  MOVFF  97D,982
20CA:  MOVFF  97F,984
20CE:  MOVFF  97E,983
20D2:  CLRF   x86
20D4:  MOVLB  0
20D6:  CALL   1898
20DA:  MOVFF  01,367
.................... 				}
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
20DE:  MOVLB  3
20E0:  MOVF   x67,F
20E2:  BNZ   211C
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
20E4:  MOVLW  01
20E6:  MOVLB  5
20E8:  SUBWF  x94,W
20EA:  MOVLB  4
20EC:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
20EE:  MOVLW  01
20F0:  MOVLB  5
20F2:  SUBWF  x94,W
20F4:  MOVLB  9
20F6:  MOVWF  x7D
20F8:  MOVLW  03
20FA:  MOVWF  FEA
20FC:  MOVLW  68
20FE:  MOVWF  FE9
2100:  MOVLW  05
2102:  MOVWF  FE2
2104:  MOVLW  98
2106:  MOVWF  FE1
2108:  MOVF   x7D,W
210A:  MOVWF  01
210C:  BZ    2116
210E:  MOVFF  FE6,FEE
2112:  DECFSZ 01,F
2114:  BRA    210E
.................... 
.................... 					live_send();
2116:  MOVLB  0
2118:  RCALL  1996
211A:  MOVLB  3
.................... 				}
.................... 			} else if ( DEV_TYPE_MODBUS_1==device[n].type || DEV_TYPE_MODBUS_2==device[n].type ) {
211C:  BRA    227E
211E:  MOVLB  9
2120:  CLRF   x95
2122:  MOVFF  97A,994
2126:  CLRF   x97
2128:  MOVLW  0D
212A:  MOVWF  x96
212C:  MOVLB  0
212E:  CALL   084C
2132:  MOVFF  02,97E
2136:  MOVFF  01,97D
213A:  MOVLW  21
213C:  MOVLB  9
213E:  ADDWF  01,W
2140:  MOVWF  FE9
2142:  MOVLW  00
2144:  ADDWFC 02,W
2146:  MOVWF  FEA
2148:  MOVF   FEF,W
214A:  SUBLW  01
214C:  BZ    217E
214E:  CLRF   x95
2150:  MOVFF  97A,994
2154:  CLRF   x97
2156:  MOVLW  0D
2158:  MOVWF  x96
215A:  MOVLB  0
215C:  CALL   084C
2160:  MOVFF  02,980
2164:  MOVFF  01,97F
2168:  MOVLW  21
216A:  MOVLB  9
216C:  ADDWF  01,W
216E:  MOVWF  FE9
2170:  MOVLW  00
2172:  ADDWFC 02,W
2174:  MOVWF  FEA
2176:  MOVF   FEF,W
2178:  SUBLW  02
217A:  BTFSS  FD8.2
217C:  BRA    2280
.................... 				/* Modbus read coil or discrete input */
.................... 				qbuff.rException=modbus_read_coils(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
217E:  CLRF   x95
2180:  MOVFF  97A,994
2184:  CLRF   x97
2186:  MOVLW  0D
2188:  MOVWF  x96
218A:  MOVLB  0
218C:  CALL   084C
2190:  MOVFF  02,97E
2194:  MOVFF  01,97D
2198:  MOVLW  04
219A:  MOVLB  9
219C:  ADDWF  01,W
219E:  MOVWF  01
21A0:  MOVLW  00
21A2:  ADDWFC 02,W
21A4:  MOVWF  03
21A6:  MOVF   01,W
21A8:  ADDLW  21
21AA:  MOVWF  FE9
21AC:  MOVLW  00
21AE:  ADDWFC 03,W
21B0:  MOVWF  FEA
21B2:  MOVFF  FEF,97D
21B6:  CLRF   x95
21B8:  MOVFF  97A,994
21BC:  CLRF   x97
21BE:  MOVLW  0D
21C0:  MOVWF  x96
21C2:  MOVLB  0
21C4:  CALL   084C
21C8:  MOVFF  01,97E
21CC:  MOVLW  09
21CE:  MOVLB  9
21D0:  ADDWF  01,W
21D2:  MOVWF  01
21D4:  MOVLW  00
21D6:  ADDWFC 02,W
21D8:  MOVWF  03
21DA:  MOVF   01,W
21DC:  ADDLW  21
21DE:  MOVWF  FE9
21E0:  MOVLW  00
21E2:  ADDWFC 03,W
21E4:  MOVWF  FEA
21E6:  MOVFF  FEC,97F
21EA:  MOVF   FED,F
21EC:  MOVFF  FEF,97E
21F0:  CLRF   x95
21F2:  MOVFF  97A,994
21F6:  CLRF   x97
21F8:  MOVLW  0D
21FA:  MOVWF  x96
21FC:  MOVLB  0
21FE:  CALL   084C
2202:  MOVFF  02,981
2206:  MOVFF  01,980
220A:  MOVLW  0B
220C:  MOVLB  9
220E:  ADDWF  01,W
2210:  MOVWF  01
2212:  MOVLW  00
2214:  ADDWFC 02,W
2216:  MOVWF  03
2218:  MOVF   01,W
221A:  ADDLW  21
221C:  MOVWF  FE9
221E:  MOVLW  00
2220:  ADDWFC 03,W
2222:  MOVWF  FEA
2224:  MOVFF  FEF,985
2228:  MOVFF  97D,982
222C:  MOVFF  97F,984
2230:  MOVFF  97E,983
2234:  CLRF   x86
2236:  MOVLB  0
2238:  RCALL  1BFA
223A:  MOVFF  01,367
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
223E:  MOVLB  3
2240:  MOVF   x67,F
2242:  BNZ   227E
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
2244:  MOVLW  01
2246:  MOVLB  5
2248:  SUBWF  x94,W
224A:  MOVLB  4
224C:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
224E:  MOVLW  01
2250:  MOVLB  5
2252:  SUBWF  x94,W
2254:  MOVLB  9
2256:  MOVWF  x7D
2258:  MOVLW  03
225A:  MOVWF  FEA
225C:  MOVLW  68
225E:  MOVWF  FE9
2260:  MOVLW  05
2262:  MOVWF  FE2
2264:  MOVLW  98
2266:  MOVWF  FE1
2268:  MOVF   x7D,W
226A:  MOVWF  01
226C:  BZ    2276
226E:  MOVFF  FE6,FEE
2272:  DECFSZ 01,F
2274:  BRA    226E
.................... 
.................... 					live_send();
2276:  MOVLB  0
2278:  CALL   1996
227C:  MOVLB  3
227E:  MOVLB  9
.................... 				}
.................... 			}
.................... 		} else if ( device[n].type <= DEV_TYPE_I2C_MAX ) {
2280:  BRA    23E2
2282:  CLRF   x95
2284:  MOVFF  97A,994
2288:  CLRF   x97
228A:  MOVLW  0D
228C:  MOVWF  x96
228E:  MOVLB  0
2290:  CALL   084C
2294:  MOVFF  02,97E
2298:  MOVFF  01,97D
229C:  MOVLW  21
229E:  MOVLB  9
22A0:  ADDWF  01,W
22A2:  MOVWF  FE9
22A4:  MOVLW  00
22A6:  ADDWFC 02,W
22A8:  MOVWF  FEA
22AA:  MOVF   FEF,W
22AC:  SUBLW  17
22AE:  BTFSS  FD8.0
22B0:  BRA    23E2
.................... 			/* I2C device */
.................... 
.................... #if DEBUG_ASCII
.................... 			restart_wdt();
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() I2C device\r\n");
.................... 			fprintf(STREAM_WORLD,"device[%u]\r\n",n);
.................... 			fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[n].type);
.................... 			fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[n].transmitEvery);
.................... 			fprintf(STREAM_WORLD,"\tnetworkAddress=0x%02x\r\n",device[n].networkAddress);
.................... 			fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 				make8(device[n].serialNumber,3),
.................... 				make8(device[n].serialNumber,2),
.................... 				make8(device[n].serialNumber,1),
.................... 				make8(device[n].serialNumber,0)
.................... 			);
.................... 			fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[n].startRegister);
.................... 			fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[n].nRegisters);
.................... #endif
.................... 
.................... 			if ( DEV_TYPE_I2C_READ_8 == device[n].type ) {
22B2:  CLRF   x95
22B4:  MOVFF  97A,994
22B8:  CLRF   x97
22BA:  MOVLW  0D
22BC:  MOVWF  x96
22BE:  MOVLB  0
22C0:  CALL   084C
22C4:  MOVFF  02,97E
22C8:  MOVFF  01,97D
22CC:  MOVLW  21
22CE:  MOVLB  9
22D0:  ADDWF  01,W
22D2:  MOVWF  FE9
22D4:  MOVLW  00
22D6:  ADDWFC 02,W
22D8:  MOVWF  FEA
22DA:  MOVF   FEF,W
22DC:  SUBLW  10
22DE:  BTFSS  FD8.2
22E0:  BRA    23E2
.................... 				/* start a read at start address then just read a byte at a time. nRegisters is bytes */
.................... //fprintf(STREAM_WORLD,"z");
.................... 				i2c_buff_read(device[n].networkAddress, device[n].startRegister, qbuff.rResult, device[n].nRegisters);
22E2:  CLRF   x95
22E4:  MOVFF  97A,994
22E8:  CLRF   x97
22EA:  MOVLW  0D
22EC:  MOVWF  x96
22EE:  MOVLB  0
22F0:  CALL   084C
22F4:  MOVFF  02,97E
22F8:  MOVFF  01,97D
22FC:  MOVLW  04
22FE:  MOVLB  9
2300:  ADDWF  01,W
2302:  MOVWF  01
2304:  MOVLW  00
2306:  ADDWFC 02,W
2308:  MOVWF  03
230A:  MOVF   01,W
230C:  ADDLW  21
230E:  MOVWF  FE9
2310:  MOVLW  00
2312:  ADDWFC 03,W
2314:  MOVWF  FEA
2316:  MOVFF  FEF,97D
231A:  CLRF   x95
231C:  MOVFF  97A,994
2320:  CLRF   x97
2322:  MOVLW  0D
2324:  MOVWF  x96
2326:  MOVLB  0
2328:  CALL   084C
232C:  MOVFF  01,97E
2330:  MOVLW  09
2332:  MOVLB  9
2334:  ADDWF  01,W
2336:  MOVWF  01
2338:  MOVLW  00
233A:  ADDWFC 02,W
233C:  MOVWF  03
233E:  MOVF   01,W
2340:  ADDLW  21
2342:  MOVWF  FE9
2344:  MOVLW  00
2346:  ADDWFC 03,W
2348:  MOVWF  FEA
234A:  MOVFF  FEC,97F
234E:  MOVF   FED,F
2350:  MOVFF  FEF,97E
2354:  CLRF   x95
2356:  MOVFF  97A,994
235A:  CLRF   x97
235C:  MOVLW  0D
235E:  MOVWF  x96
2360:  MOVLB  0
2362:  CALL   084C
2366:  MOVFF  02,981
236A:  MOVFF  01,980
236E:  MOVLW  0B
2370:  MOVLB  9
2372:  ADDWF  01,W
2374:  MOVWF  01
2376:  MOVLW  00
2378:  ADDWFC 02,W
237A:  MOVWF  03
237C:  MOVF   01,W
237E:  ADDLW  21
2380:  MOVWF  FE9
2382:  MOVLW  00
2384:  ADDWFC 03,W
2386:  MOVWF  FEA
2388:  MOVFF  FEF,986
238C:  MOVFF  97D,982
2390:  MOVFF  97E,983
2394:  MOVLW  03
2396:  MOVWF  x85
2398:  MOVLW  68
239A:  MOVWF  x84
239C:  MOVLB  0
239E:  RCALL  1C92
.................... 
.................... 				qbuff.rException=0;
23A0:  MOVLB  3
23A2:  CLRF   x67
.................... 				qbuff.rResultLength=device[n].nRegisters;
23A4:  MOVLB  9
23A6:  CLRF   x95
23A8:  MOVFF  97A,994
23AC:  CLRF   x97
23AE:  MOVLW  0D
23B0:  MOVWF  x96
23B2:  MOVLB  0
23B4:  CALL   084C
23B8:  MOVFF  01,97D
23BC:  MOVLW  0B
23BE:  MOVLB  9
23C0:  ADDWF  01,W
23C2:  MOVWF  01
23C4:  MOVLW  00
23C6:  ADDWFC 02,W
23C8:  MOVWF  03
23CA:  MOVF   01,W
23CC:  ADDLW  21
23CE:  MOVWF  FE9
23D0:  MOVLW  00
23D2:  ADDWFC 03,W
23D4:  MOVWF  FEA
23D6:  MOVFF  FEF,468
.................... //fprintf(STREAM_WORLD,"Z");
.................... #if DEBUG_ASCII
.................... 				/* debug dump */
.................... 				restart_wdt();
.................... 				for ( i=0 ; i<device[n].nRegisters ; i++ ) {
.................... 					fprintf(STREAM_WORLD,"# reg addr[0x%02x]=0x%02x (%u)\r\n",i+device[n].startRegister,qbuff.rResult[i],qbuff.rResult[i]);
.................... 				}
.................... #endif
.................... 
.................... 				live_send();
23DA:  MOVLB  0
23DC:  CALL   1996
23E0:  MOVLB  9
.................... 
.................... 			}
.................... 
.................... 		} else {
.................... 			/* local */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() local (not implemented) device\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* Add data to SBD if this is an SBD cycle and we have valid data */
.................... 		if ( 0 == timers.sbd_cycle && 0 == qbuff.rException ) {
23E2:  MOVLB  3
23E4:  MOVF   x65,F
23E6:  BNZ   248A
23E8:  MOVF   x66,F
23EA:  BNZ   248A
23EC:  MOVF   x67,F
23EE:  BNZ   248A
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() adding to sbd.mo_buff since qbuff.rException=0\r\n");
.................... #endif
.................... 			/* sub-header, 2 bytes, device number, and data length */
.................... 			sbd.mo_buff[sbd.mo_length++]=n;
23F0:  MOVLB  7
23F2:  MOVFF  7DB,03
23F6:  MOVF   xDA,W
23F8:  INCF   xDA,F
23FA:  BTFSC  FD8.2
23FC:  INCF   xDB,F
23FE:  MOVLB  9
2400:  MOVWF  x7D
2402:  MOVLW  CA
2404:  ADDWF  x7D,W
2406:  MOVWF  FE9
2408:  MOVLW  06
240A:  ADDWFC 03,W
240C:  MOVWF  FEA
240E:  MOVFF  97A,FEF
.................... 			sbd.mo_buff[sbd.mo_length++]=qbuff.rResultLength;
2412:  MOVLB  7
2414:  MOVFF  7DB,03
2418:  MOVF   xDA,W
241A:  INCF   xDA,F
241C:  BTFSC  FD8.2
241E:  INCF   xDB,F
2420:  MOVLB  9
2422:  MOVWF  x7D
2424:  MOVLW  CA
2426:  ADDWF  x7D,W
2428:  MOVWF  FE9
242A:  MOVLW  06
242C:  ADDWFC 03,W
242E:  MOVWF  FEA
2430:  MOVFF  468,FEF
.................... 		
.................... 			/* sub-message */
.................... 			for ( l=0 ; l<qbuff.rResultLength ; l++ ) {
2434:  CLRF   x7C
2436:  CLRF   x7B
2438:  MOVF   x7C,F
243A:  BNZ   2488
243C:  MOVLB  4
243E:  MOVF   x68,W
2440:  MOVLB  9
2442:  SUBWF  x7B,W
2444:  BC    2488
.................... 				sbd.mo_buff[sbd.mo_length++]=qBuff.rResult[l];
2446:  MOVLB  7
2448:  MOVFF  7DB,97E
244C:  MOVF   xDA,W
244E:  INCF   xDA,F
2450:  BTFSC  FD8.2
2452:  INCF   xDB,F
2454:  MOVLB  9
2456:  MOVWF  x7D
2458:  MOVLW  CA
245A:  ADDWF  x7D,W
245C:  MOVWF  01
245E:  MOVLW  06
2460:  ADDWFC x7E,W
2462:  MOVWF  03
2464:  MOVLW  68
2466:  ADDWF  x7B,W
2468:  MOVWF  FE9
246A:  MOVLW  03
246C:  ADDWFC x7C,W
246E:  MOVWF  FEA
2470:  MOVFF  FEF,981
2474:  MOVFF  03,FEA
2478:  MOVFF  01,FE9
247C:  MOVFF  981,FEF
2480:  INCF   x7B,F
2482:  BTFSC  FD8.2
2484:  INCF   x7C,F
2486:  BRA    2438
2488:  MOVLB  3
.................... 			}
.................... 		}
248A:  MOVLB  9
248C:  INCF   x7A,F
248E:  BRA    1D86
.................... 
.................... 	}
.................... 
.................... 	/* if we have data to send, then we sent it */
.................... 	if ( 0 == timers.sbd_cycle && sbd.mo_length > 0 ) {
2490:  MOVLB  3
2492:  MOVF   x65,F
2494:  BNZ   24B2
2496:  MOVF   x66,F
2498:  BNZ   24B2
249A:  MOVLB  7
249C:  MOVF   xDA,F
249E:  BNZ   24AA
24A0:  MOVF   xDB,F
24A2:  BTFSS  FD8.2
24A4:  BRA    24AA
24A6:  MOVLB  3
24A8:  BRA    24B2
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() setting sbd.mo_state=1\r\n");
.................... #endif
.................... 		sbd.mo_state=1;
24AA:  MOVLW  01
24AC:  MOVLB  6
24AE:  MOVWF  xC9
24B0:  MOVLB  3
.................... 	}
.................... 
.................... 	measurementNumber++;
24B2:  MOVLB  9
24B4:  INCF   x37,F
24B6:  BTFSC  FD8.2
24B8:  INCF   x38,F
.................... 
.................... 	if ( 0 == timers.sbd_cycle ) {
24BA:  MOVLB  3
24BC:  MOVF   x65,F
24BE:  BNZ   24DA
24C0:  MOVF   x66,F
24C2:  BNZ   24DA
.................... 		timers.sbd_cycle=(config.sbd_every-1);
24C4:  MOVLW  01
24C6:  MOVLB  5
24C8:  SUBWF  x89,W
24CA:  MOVLB  3
24CC:  MOVWF  x65
24CE:  MOVLW  00
24D0:  MOVLB  5
24D2:  SUBWFB x8A,W
24D4:  MOVLB  3
24D6:  MOVWF  x66
.................... 	} else {
24D8:  BRA    24E2
.................... 		timers.sbd_cycle--;
24DA:  MOVF   x65,W
24DC:  BTFSC  FD8.2
24DE:  DECF   x66,F
24E0:  DECF   x65,F
.................... 	}
24E2:  MOVLB  0
24E4:  GOTO   37D4 (RETURN)
.................... }
.................... 
.................... void init() {
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
06BA:  MOVLW  62
06BC:  MOVWF  FD3
06BE:  CLRF   F9B
06C0:  CLRF   F64
.................... 	setup_adc_ports(NO_ANALOGS);
06C2:  MOVLB  F
06C4:  MOVF   x5C,W
06C6:  ANDLW  80
06C8:  MOVWF  x5C
06CA:  MOVLW  00
06CC:  MOVWF  x5D
06CE:  BCF    FC1.3
06D0:  BCF    FC1.4
06D2:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
06D4:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
06D6:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
06D8:  MOVLW  1F
06DA:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
06DC:  MOVLW  F0
06DE:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
06E0:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
06E2:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
06E4:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
06E6:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
06E8:  BCF    F94.5
06EA:  BCF    F8B.5
.................... 
.................... 	setup_timer_4(T4_DIV_BY_16,77,16); 
06EC:  MOVLW  78
06EE:  IORLW  06
06F0:  MOVWF  F88
06F2:  MOVLW  4D
06F4:  MOVWF  FA9
.................... 	enable_interrupts(INT_TIMER4);	
06F6:  BSF    FB6.7
.................... 
.................... 	/* global structures initialized to 0, set something else below if needed */
.................... 	timers.now_poll=1;
06F8:  MOVLW  01
06FA:  MOVLB  3
06FC:  MOVWF  x61
.................... 	timers.sbd_cycle=1; /* next packet will be an SBD packet */
06FE:  CLRF   x66
0700:  MOVWF  x65
.................... 	timers.world_timeout=255;
0702:  SETF   x62
.................... 	timers.factory_unlocked=0;
0704:  CLRF   x63
.................... 	timers.led_on_green=0;
0706:  CLRF   x64
.................... 
.................... 	query_reset();
0708:  MOVLB  0
070A:  RCALL  05B8
.................... 
.................... 	/* receive data from serial ports */
.................... 	enable_interrupts(INT_RDA2);
070C:  BSF    FA3.5
.................... 
.................... #if MCP3208_ENABLED
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
.................... #endif
.................... 
.................... 
.................... 	if ( config.sbd_config ) {
070E:  MOVLB  5
0710:  MOVF   x88,F
0712:  BZ    0720
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# init() initializing I2C Uart for SBD @ 19200\r\n");
.................... #endif
.................... 		/* initialize I2C UART for Iridium @ 19200 */
.................... 		uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
0714:  MOVLW  06
0716:  MOVLB  9
0718:  MOVWF  x7A
071A:  MOVLB  0
071C:  BRA    061E
071E:  MOVLB  5
.................... 	}
.................... 
.................... 	delay_ms(14);
0720:  MOVLW  0E
0722:  MOVLB  9
0724:  MOVWF  x90
0726:  MOVLB  0
0728:  RCALL  068A
072A:  GOTO   36CA (RETURN)
.................... }
.................... 
.................... void main(void) {
*
3600:  CLRF   FF8
3602:  BCF    FD0.7
3604:  BSF    07.7
3606:  MOVLW  62
3608:  MOVWF  FD3
360A:  CLRF   F9B
360C:  CLRF   F64
360E:  CLRF   20
3610:  BSF    FB9.3
3612:  MOVLW  22
3614:  MOVWF  F7B
3616:  MOVLW  00
3618:  MOVWF  F7C
361A:  MOVLW  A6
361C:  MOVWF  FBA
361E:  MOVLW  90
3620:  MOVWF  FA6
3622:  BSF    F94.3
3624:  BSF    F94.4
3626:  MOVLW  04
3628:  MOVWF  FC8
362A:  MOVLW  28
362C:  MOVWF  FC6
362E:  BCF    FC7.7
3630:  BCF    FC7.6
3632:  BCF    FA7.3
3634:  MOVLW  0C
3636:  MOVWF  FAF
3638:  MOVLW  A2
363A:  MOVWF  FAC
363C:  MOVLW  90
363E:  MOVWF  FAB
3640:  MOVLB  5
3642:  CLRF   x8E
3644:  MOVLW  01
3646:  MOVWF  x8D
3648:  MOVLW  86
364A:  MOVWF  x8C
364C:  MOVLW  A0
364E:  MOVWF  x8B
3650:  BCF    x8F.0
3652:  CLRF   x90
3654:  MOVLB  9
3656:  CLRF   x2A
3658:  CLRF   x29
365A:  MOVLB  F
365C:  MOVF   x5C,W
365E:  ANDLW  80
3660:  MOVWF  x5C
3662:  MOVLW  00
3664:  MOVWF  x5D
3666:  BCF    FC1.3
3668:  BCF    FC1.4
366A:  BCF    FC1.5
366C:  CLRF   x5E
366E:  CLRF   x5F
3670:  BRA    3686
3672:  DATA 02,00
3674:  DATA 1A,00
3676:  DATA 00,FF
3678:  DATA 46,96
367A:  DATA 00,FF
367C:  DATA C0,00
367E:  DATA 95,C0
3680:  DATA 00,4E
3682:  DATA 49,2B
3684:  DATA 00,00
3686:  MOVLW  00
3688:  MOVWF  FF8
368A:  MOVLW  36
368C:  MOVWF  FF7
368E:  MOVLW  72
3690:  MOVWF  FF6
3692:  TBLRD*+
3694:  MOVF   FF5,W
3696:  MOVWF  00
3698:  XORLW  00
369A:  BZ    36C2
369C:  TBLRD*+
369E:  MOVF   FF5,W
36A0:  MOVWF  01
36A2:  BTFSC  FE8.7
36A4:  BRA    36B0
36A6:  ANDLW  3F
36A8:  MOVWF  FEA
36AA:  TBLRD*+
36AC:  MOVFF  FF5,FE9
36B0:  BTFSC  01.6
36B2:  TBLRD*+
36B4:  BTFSS  01.6
36B6:  TBLRD*+
36B8:  MOVFF  FF5,FEE
36BC:  DCFSNZ 00,F
36BE:  BRA    3692
36C0:  BRA    36B4
36C2:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	/* normal device startup */
.................... 	init();
36C4:  MOVLB  0
36C6:  GOTO   06BA
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking wait\r\n");
.................... #endif
.................... 	for ( i=0 ; i<STARTUP_BLINKS ; i++ ) {
36CA:  MOVLB  9
36CC:  CLRF   x79
36CE:  MOVF   x79,W
36D0:  SUBLW  95
36D2:  BNC   36FA
.................... 		restart_wdt();
36D4:  CLRWDT
.................... 
.................... 		output_high(LED_GREEN);
36D6:  BCF    F93.5
36D8:  BSF    F8A.5
.................... 		delay_ms(100);
36DA:  MOVLW  64
36DC:  MOVWF  x90
36DE:  MOVLB  0
36E0:  CALL   068A
.................... 		output_low(LED_GREEN);
36E4:  BCF    F93.5
36E6:  BCF    F8A.5
.................... 		delay_ms(100);
36E8:  MOVLW  64
36EA:  MOVLB  9
36EC:  MOVWF  x90
36EE:  MOVLB  0
36F0:  CALL   068A
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# main() blink=%u\r\n",i);
.................... #endif
.................... 	}
.................... 
.................... #if DEBUG_ASCII
36F4:  MOVLB  9
36F6:  INCF   x79,F
36F8:  BRA    36CE
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking done\r\n");
.................... 
.................... 	fprintf(STREAM_WORLD,"# rdTap %s %s\r\n",__DATE__,__TIME__);
.................... 
.................... 	fprintf(STREAM_WORLD,"# restart cause: ");
.................... 	switch ( restart_cause ) {
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_WORLD,"WDT TIMEOUT"); break;
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_WORLD,"MCLR FROM SLEEP"); break;
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_WORLD,"MCLR FROM RUN"); break;
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_WORLD,"NORMAL POWER UP"); break;
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_WORLD,"BROWNOUT RESTART"); break;
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_WORLD,"WDT FROM SLEEP"); break;
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_WORLD,"RESET INSTRUCTION"); break;
.................... 		default:                fprintf(STREAM_WORLD,"UNKNOWN!");
.................... 	}
.................... 	fprintf(STREAM_WORLD,"\r\n");
.................... #endif
.................... 
.................... 	restart_wdt();
36FA:  CLRWDT
.................... 	enable_interrupts(GLOBAL);
36FC:  MOVLW  C0
36FE:  IORWF  FF2,F
.................... 
.................... 	write_default_param_file();
3700:  MOVLB  0
3702:  CALL   0822
.................... 	write_default_device_file();
3706:  CALL   08C0
.................... 
.................... 	read_param_file();
370A:  GOTO   09F8
.................... 	read_device_file();
370E:  GOTO   0A46
.................... 
.................... 	restart_wdt();
3712:  CLRWDT
.................... 	modbus_init();
3714:  GOTO   0AA4
.................... 
.................... #if DEBUG_ASCII
.................... 	devicesDump();
.................... #endif
.................... 
.................... 	iridium_mr_clear();
3718:  CALL   0ABC
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() starting for ( ; ; ) loop\r\n");
.................... #endif
.................... 
.................... 
.................... 	/* main loop */
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
371C:  CLRWDT
.................... 
.................... 		if ( config.sbd_config ) {
371E:  MOVLB  5
3720:  MOVF   x88,F
3722:  BZ    37C2
.................... 			/* iridium enabled */
.................... 
.................... 			/* act on flag set by SBDRING in UART character processor or RING ALERT line */
.................... 			if ( sbd.ring_flag ) {
3724:  MOVLB  8
3726:  MOVF   xE4,F
3728:  BZ    3736
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# main() sbd.ring_flag=1\r\n");
.................... #endif
.................... 				/* our easiest way to get the ringing message is to send another message. This also
.................... 				would help capture the results from a query */
.................... 				timers.sbd_cycle=1; /* next packet will be an SBD packet */
372A:  MOVLB  3
372C:  CLRF   x66
372E:  MOVLW  01
3730:  MOVWF  x65
.................... 
.................... 				sbd.ring_flag=0;
3732:  MOVLB  8
3734:  CLRF   xE4
.................... 			}
.................... 
.................... 			if ( '\0' != sbd.sbdix_response[0] && 0 == sbd.mo_state ) {
3736:  MOVLB  6
3738:  MOVF   x96,F
373A:  BZ    3758
373C:  MOVF   xC9,F
373E:  BNZ   3758
.................... 				/* 
.................... 				if there is something in our +SBDIX response we should check if we have a message or need to 
.................... 				get a message. But wait until MO sending is done (state machine idle).
.................... 				*/
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_response='%s'\r\n",sbd.sbdix_response);
.................... #endif
.................... 
....................  				iridium_sbdix_parse();
3740:  MOVLB  0
3742:  GOTO   0C10
.................... 
.................... 				/* clear the unparsed buffer so we don't get back here */
.................... 				sbd.sbdix_response[0]='\0';
3746:  MOVLB  6
3748:  CLRF   x96
.................... 
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
374A:  MOVF   xC8,F
374C:  BZ    3758
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
374E:  MOVLB  3
3750:  CLRF   x66
3752:  MOVLW  01
3754:  MOVWF  x65
3756:  MOVLB  6
.................... 					
.................... #if DEBUG_SBD
.................... 					fprintf(STREAM_WORLD,"# sbd.sbdix_mt_queued > 0 (is %u)\r\n",sbd.sbdix_mt_queued);
.................... #endif
.................... 				}
.................... 			}
.................... 
.................... 			/* read character into MR if we don't have an unprocessed message and there is a character available */
.................... 			if ( 0==sbd.mr_ready && ! sbd.mr_disable && uart_kbhit() ) {
3758:  MOVLB  8
375A:  MOVF   xE6,F
375C:  BNZ   3780
375E:  MOVLB  9
3760:  MOVF   x28,F
3762:  BTFSC  FD8.2
3764:  BRA    376A
3766:  MOVLB  8
3768:  BRA    3780
376A:  MOVLB  0
376C:  CALL   0E4E
3770:  MOVF   01,F
3772:  BTFSS  FD8.2
3774:  BRA    377A
3776:  MOVLB  8
3778:  BRA    3780
.................... 				iridium_getc();
377A:  GOTO   0E60
377E:  MOVLB  8
.................... 			}
.................... 
.................... 			/* download message from SBD modem */
.................... 			if ( 1 == sbd.sbdix_mt_status ) {
3780:  MOVLB  6
3782:  DECFSZ xC3,W
3784:  BRA    378E
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_mt_status=1\r\n");
.................... #endif
.................... 				iridium_mt_receive();
3786:  MOVLB  0
3788:  GOTO   0F44
378C:  MOVLB  6
.................... 			}
.................... 
.................... 			/* send messages to SBD modem */
.................... 			if ( 0 != sbd.mo_state && 0 == sbd.mt_state ) {
378E:  MOVF   xC9,F
3790:  BZ    37A6
3792:  MOVLB  7
3794:  MOVF   xDF,F
3796:  BTFSC  FD8.2
3798:  BRA    379E
379A:  MOVLB  6
379C:  BRA    37A6
.................... 				iridium_mo_send();
379E:  MOVLB  0
37A0:  GOTO   1364
37A4:  MOVLB  6
.................... 			}
.................... 
.................... 			if ( 1 == sbd.mt_ready ) {
37A6:  MOVLB  7
37A8:  DECFSZ xDE,W
37AA:  BRA    37C0
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.mt_ready=1\r\n");
.................... #endif
.................... 				/* TODO: send to message parser */
.................... 				sbd.mt_ready=0;
37AC:  CLRF   xDE
.................... 
.................... 				/* do another SBDIX if we have sbd.mt_queued > 0 */
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
37AE:  MOVLB  6
37B0:  MOVF   xC8,F
37B2:  BZ    37BE
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
37B4:  MOVLB  3
37B6:  CLRF   x66
37B8:  MOVLW  01
37BA:  MOVWF  x65
37BC:  MOVLB  6
37BE:  MOVLB  7
37C0:  MOVLB  5
.................... 				}
.................... 			} 
.................... 		}
.................... 
.................... 
.................... 		if ( timers.now_poll ) {
37C2:  MOVLB  3
37C4:  MOVF   x61,F
37C6:  BZ    37D6
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll\r\n");
.................... #endif
.................... 			timers.now_poll=0;
37C8:  CLRF   x61
.................... 			timers.led_on_green=200;
37CA:  MOVLW  C8
37CC:  MOVWF  x64
.................... 			deviceQuery();
37CE:  MOVLB  0
37D0:  GOTO   1D1C
37D4:  MOVLB  3
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll done\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* queries are messages send to us that we respond to */
.................... 		if ( query.buff_ready ) {
37D6:  MOVLB  5
37D8:  MOVF   x6D,F
37DA:  BZ    37E6
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_process()\r\n");
.................... #endif
.................... 
.................... 			query_process();
37DC:  MOVLB  0
37DE:  BRA    34F4
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_reset()\r\n");
.................... #endif
.................... 	
.................... 			query_reset();
37E0:  CALL   05B8
37E4:  MOVLB  5
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() done with query.buff_ready()\r\n");
.................... #endif
.................... 		}
37E6:  MOVLB  0
37E8:  BRA    371C
.................... 	}
.................... }
.................... 
37EA:  SLEEP 

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 2B67   NOPUT BROWNOUT BORV30 ZPBORM WDT WDT1024
   Word  3: 0900   CANB MSSPMSK7 NOMCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
