CCS PCH C Compiler, Version 5.117, 2295               11-Apr-24 11:17

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\rdTap\rdTap.lst

               ROM used:   14352 bytes (44%)
                           Largest free fragment is 18412
               RAM used:   2426 (67%) at main() level
                           2463 (68%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   3628
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   0304
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0378
006C:  BTFSS  FA3.5
006E:  GOTO   0078
0072:  BTFSC  FA4.5
0074:  GOTO   04E2
0078:  BTFSS  FB6.7
007A:  GOTO   0084
007E:  BTFSC  FB7.7
0080:  GOTO   046C
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #define DEBUG_ASCII     0
.................... #define DEBUG_SBD       0
.................... #define MCP3208_ENABLED 0
.................... #define STARTUP_BLINKS  150
.................... 
.................... 
.................... #include "rdTap.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 01,C0
00F4:  DATA 80,41
00F6:  DATA 00,C1
00F8:  DATA 81,40
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 00,C1
010C:  DATA 81,40
010E:  DATA 01,C0
0110:  DATA 80,41
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 01,C0
011C:  DATA 80,41
011E:  DATA 00,C1
0120:  DATA 81,40
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 00,C1
0134:  DATA 81,40
0136:  DATA 01,C0
0138:  DATA 80,41
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 01,C0
0154:  DATA 80,41
0156:  DATA 00,C1
0158:  DATA 81,40
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 00,C1
0174:  DATA 81,40
0176:  DATA 01,C0
0178:  DATA 80,41
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 01,C0
018C:  DATA 80,41
018E:  DATA 00,C1
0190:  DATA 81,40
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 00,C1
019C:  DATA 81,40
019E:  DATA 01,C0
01A0:  DATA 80,41
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 01,C0
01B4:  DATA 80,41
01B6:  DATA 00,C1
01B8:  DATA 81,40
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  DATA 00,C1
01CC:  DATA 81,40
01CE:  DATA 01,C0
01D0:  DATA 80,41
01D2:  DATA 00,C1
01D4:  DATA 81,40
01D6:  DATA 01,C0
01D8:  DATA 80,41
01DA:  DATA 01,C0
01DC:  DATA 80,41
01DE:  DATA 00,C1
01E0:  DATA 81,40
01E2:  CLRF   FF7
01E4:  ADDLW  F2
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  RETURN 0
01F2:  DATA 00,C0
01F4:  DATA C1,01
01F6:  DATA C3,03
01F8:  DATA 02,C2
01FA:  DATA C6,06
01FC:  DATA 07,C7
01FE:  DATA 05,C5
0200:  DATA C4,04
0202:  DATA CC,0C
0204:  DATA 0D,CD
0206:  DATA 0F,CF
0208:  DATA CE,0E
020A:  DATA 0A,CA
020C:  DATA CB,0B
020E:  DATA C9,09
0210:  DATA 08,C8
0212:  DATA D8,18
0214:  DATA 19,D9
0216:  DATA 1B,DB
0218:  DATA DA,1A
021A:  DATA 1E,DE
021C:  DATA DF,1F
021E:  DATA DD,1D
0220:  DATA 1C,DC
0222:  DATA 14,D4
0224:  DATA D5,15
0226:  DATA D7,17
0228:  DATA 16,D6
022A:  DATA D2,12
022C:  DATA 13,D3
022E:  DATA 11,D1
0230:  DATA D0,10
0232:  DATA F0,30
0234:  DATA 31,F1
0236:  DATA 33,F3
0238:  DATA F2,32
023A:  DATA 36,F6
023C:  DATA F7,37
023E:  DATA F5,35
0240:  DATA 34,F4
0242:  DATA 3C,FC
0244:  DATA FD,3D
0246:  DATA FF,3F
0248:  DATA 3E,FE
024A:  DATA FA,3A
024C:  DATA 3B,FB
024E:  DATA 39,F9
0250:  DATA F8,38
0252:  DATA 28,E8
0254:  DATA E9,29
0256:  DATA EB,2B
0258:  DATA 2A,EA
025A:  DATA EE,2E
025C:  DATA 2F,EF
025E:  DATA 2D,ED
0260:  DATA EC,2C
0262:  DATA E4,24
0264:  DATA 25,E5
0266:  DATA 27,E7
0268:  DATA E6,26
026A:  DATA 22,E2
026C:  DATA E3,23
026E:  DATA E1,21
0270:  DATA 20,E0
0272:  DATA A0,60
0274:  DATA 61,A1
0276:  DATA 63,A3
0278:  DATA A2,62
027A:  DATA 66,A6
027C:  DATA A7,67
027E:  DATA A5,65
0280:  DATA 64,A4
0282:  DATA 6C,AC
0284:  DATA AD,6D
0286:  DATA AF,6F
0288:  DATA 6E,AE
028A:  DATA AA,6A
028C:  DATA 6B,AB
028E:  DATA 69,A9
0290:  DATA A8,68
0292:  DATA 78,B8
0294:  DATA B9,79
0296:  DATA BB,7B
0298:  DATA 7A,BA
029A:  DATA BE,7E
029C:  DATA 7F,BF
029E:  DATA 7D,BD
02A0:  DATA BC,7C
02A2:  DATA B4,74
02A4:  DATA 75,B5
02A6:  DATA 77,B7
02A8:  DATA B6,76
02AA:  DATA 72,B2
02AC:  DATA B3,73
02AE:  DATA B1,71
02B0:  DATA 70,B0
02B2:  DATA 50,90
02B4:  DATA 91,51
02B6:  DATA 93,53
02B8:  DATA 52,92
02BA:  DATA 96,56
02BC:  DATA 57,97
02BE:  DATA 55,95
02C0:  DATA 94,54
02C2:  DATA 9C,5C
02C4:  DATA 5D,9D
02C6:  DATA 5F,9F
02C8:  DATA 9E,5E
02CA:  DATA 5A,9A
02CC:  DATA 9B,5B
02CE:  DATA 99,59
02D0:  DATA 58,98
02D2:  DATA 88,48
02D4:  DATA 49,89
02D6:  DATA 4B,8B
02D8:  DATA 8A,4A
02DA:  DATA 4E,8E
02DC:  DATA 8F,4F
02DE:  DATA 8D,4D
02E0:  DATA 4C,8C
02E2:  DATA 44,84
02E4:  DATA 85,45
02E6:  DATA 87,47
02E8:  DATA 46,86
02EA:  DATA 82,42
02EC:  DATA 43,83
02EE:  DATA 41,81
02F0:  DATA 80,40
*
03E2:  DATA 41,54
03E4:  DATA 45,30
03E6:  DATA 0D,00
03E8:  DATA 41,54
03EA:  DATA 26,4B
03EC:  DATA 30,0D
03EE:  DATA 00,00
03F0:  DATA 41,54
03F2:  DATA 2B,53
03F4:  DATA 42,44
03F6:  DATA 4D,54
03F8:  DATA 41,3D
03FA:  DATA 31,0D
03FC:  DATA 00,00
03FE:  DATA 41,54
0400:  DATA 2B,43
0402:  DATA 52,49
0404:  DATA 53,0D
0406:  DATA 00,00
0408:  DATA 41,54
040A:  DATA 45,30
040C:  DATA 0D,00
040E:  DATA 41,54
0410:  DATA 26,4B
0412:  DATA 30,0D
0414:  DATA 00,00
0416:  DATA 41,54
0418:  DATA 2B,53
041A:  DATA 42,44
041C:  DATA 4D,54
041E:  DATA 41,3D
0420:  DATA 31,0D
0422:  DATA 00,00
0424:  DATA 41,54
0426:  DATA 2B,53
0428:  DATA 42,44
042A:  DATA 57,42
042C:  DATA 3D,25
042E:  DATA 6C,75
0430:  DATA 0D,00
0432:  DATA 41,54
0434:  DATA 2B,53
0436:  DATA 42,44
0438:  DATA 49,58
043A:  DATA 0D,00
043C:  DATA 41,54
043E:  DATA 2B,53
0440:  DATA 42,44
0442:  DATA 44,30
0444:  DATA 0D,00
0446:  DATA 41,54
0448:  DATA 45,30
044A:  DATA 0D,00
044C:  DATA 41,54
044E:  DATA 26,4B
0450:  DATA 30,0D
0452:  DATA 00,00
0454:  DATA 41,54
0456:  DATA 2B,53
0458:  DATA 42,44
045A:  DATA 4D,54
045C:  DATA 41,3D
045E:  DATA 31,0D
0460:  DATA 00,00
0462:  DATA 41,54
0464:  DATA 2B,53
0466:  DATA 42,44
0468:  DATA 52,42
046A:  DATA 0D,00
*
084C:  MOVLB  9
084E:  MOVF   x94,W
0850:  MULWF  x96
0852:  MOVFF  FF3,01
0856:  MOVFF  FF4,00
085A:  MULWF  x97
085C:  MOVF   FF3,W
085E:  ADDWF  00,F
0860:  MOVF   x95,W
0862:  MULWF  x96
0864:  MOVF   FF3,W
0866:  ADDWFC 00,W
0868:  MOVWF  02
086A:  MOVLB  0
086C:  RETURN 0
*
0F4C:  TBLRD*+
0F4E:  MOVF   FF5,F
0F50:  BZ    0F6A
0F52:  MOVFF  FF6,97E
0F56:  MOVFF  FF7,97F
0F5A:  MOVFF  FF5,987
0F5E:  RCALL  0F3C
0F60:  MOVFF  97E,FF6
0F64:  MOVFF  97F,FF7
0F68:  BRA    0F4C
0F6A:  RETURN 0
*
11DE:  TBLRD*+
11E0:  MOVFF  FF6,97F
11E4:  MOVFF  FF7,980
11E8:  MOVFF  FF5,987
11EC:  RCALL  0F3C
11EE:  MOVFF  97F,FF6
11F2:  MOVFF  980,FF7
11F6:  MOVLB  9
11F8:  DECFSZ x7E,F
11FA:  BRA    11FE
11FC:  BRA    1202
11FE:  MOVLB  0
1200:  BRA    11DE
1202:  MOVLB  0
1204:  GOTO   1484 (RETURN)
1208:  MOVFF  FEA,986
120C:  MOVFF  FE9,985
1210:  MOVLB  9
1212:  SWAPF  x7F,W
1214:  IORLW  F0
1216:  MOVWF  x81
1218:  ADDWF  x81,F
121A:  ADDLW  E2
121C:  MOVWF  x82
121E:  ADDLW  32
1220:  MOVWF  x84
1222:  MOVF   x7F,W
1224:  ANDLW  0F
1226:  ADDWF  x82,F
1228:  ADDWF  x82,F
122A:  ADDWF  x84,F
122C:  ADDLW  E9
122E:  MOVWF  x83
1230:  ADDWF  x83,F
1232:  ADDWF  x83,F
1234:  SWAPF  x7E,W
1236:  ANDLW  0F
1238:  ADDWF  x83,F
123A:  ADDWF  x84,F
123C:  RLCF   x83,F
123E:  RLCF   x84,F
1240:  COMF   x84,F
1242:  RLCF   x84,F
1244:  MOVF   x7E,W
1246:  ANDLW  0F
1248:  ADDWF  x84,F
124A:  RLCF   x81,F
124C:  MOVLW  07
124E:  MOVWF  x80
1250:  MOVLW  0A
1252:  DECF   x83,F
1254:  ADDWF  x84,F
1256:  BNC   1252
1258:  DECF   x82,F
125A:  ADDWF  x83,F
125C:  BNC   1258
125E:  DECF   x81,F
1260:  ADDWF  x82,F
1262:  BNC   125E
1264:  DECF   x80,F
1266:  ADDWF  x81,F
1268:  BNC   1264
126A:  MOVLW  09
126C:  MOVWF  FEA
126E:  MOVLW  80
1270:  MOVWF  FE9
1272:  MOVLW  07
1274:  ANDWF  x85,W
1276:  BCF    x85.6
1278:  ADDWF  FE9,F
127A:  MOVLW  00
127C:  ADDWFC FEA,F
127E:  MOVF   FE9,W
1280:  SUBLW  84
1282:  BNZ   128C
1284:  MOVF   FEA,W
1286:  SUBLW  09
1288:  BNZ   128C
128A:  BSF    x85.6
128C:  MOVF   FEF,W
128E:  MOVWF  00
1290:  BNZ   12A2
1292:  BTFSC  x85.6
1294:  BRA    12A2
1296:  BTFSC  x85.4
1298:  BRA    12C4
129A:  BTFSC  x85.3
129C:  BRA    12A2
129E:  MOVLW  20
12A0:  BRA    12A8
12A2:  BSF    x85.3
12A4:  BCF    x85.4
12A6:  MOVLW  30
12A8:  ADDWF  00,F
12AA:  MOVFF  FEA,97F
12AE:  MOVFF  FE9,97E
12B2:  MOVFF  00,987
12B6:  MOVLB  0
12B8:  RCALL  0F3C
12BA:  MOVFF  97F,FEA
12BE:  MOVFF  97E,FE9
12C2:  MOVLB  9
12C4:  MOVF   FEE,W
12C6:  BTFSS  x85.6
12C8:  BRA    127E
12CA:  MOVLB  0
12CC:  GOTO   1492 (RETURN)
*
28F4:  ADDWF  FE8,W
28F6:  CLRF   FF7
28F8:  RLCF   FF7,F
28FA:  ADDLW  0F
28FC:  MOVWF  FF6
28FE:  MOVLW  29
2900:  ADDWFC FF7,F
2902:  TBLRD*-
2904:  MOVF   FF5,W
2906:  MOVWF  FFA
2908:  TBLRD*
290A:  MOVF   FF5,W
290C:  MOVWF  FF9
290E:  DATA 5A,25
2910:  DATA 8C,25
2912:  DATA CE,25
2914:  DATA 0C,26
2916:  DATA 4A,26
2918:  DATA DE,26
291A:  DATA 72,27
291C:  DATA B4,27
*
2C92:  ADDWF  FE8,W
2C94:  CLRF   FF7
2C96:  RLCF   FF7,F
2C98:  ADDLW  AD
2C9A:  MOVWF  FF6
2C9C:  MOVLW  2C
2C9E:  ADDWFC FF7,F
2CA0:  TBLRD*-
2CA2:  MOVF   FF5,W
2CA4:  MOVWF  FFA
2CA6:  TBLRD*
2CA8:  MOVF   FF5,W
2CAA:  MOVWF  FF9
2CAC:  DATA E8,29
2CAE:  DATA 18,2A
2CB0:  DATA 5A,2A
2CB2:  DATA 96,2A
2CB4:  DATA D2,2A
2CB6:  DATA DE,2A
2CB8:  DATA 2E,2B
2CBA:  DATA 70,2B
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses NOPUT
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... //#fuses WDT512
.................... #fuses WDT1024
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... 
.................... 
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
*
12F6:  MOVFF  97F,985
12FA:  MOVFF  97E,984
12FE:  MOVLB  9
1300:  MOVF   x82,F
1302:  BNZ   1308
1304:  MOVF   x83,F
1306:  BZ    134E
1308:  MOVFF  981,FEA
130C:  MOVFF  980,FE9
1310:  MOVF   FEF,F
1312:  BZ    134E
....................      *s++ = *s2++;
1314:  MOVFF  985,03
1318:  MOVF   x84,W
131A:  INCF   x84,F
131C:  BTFSC  FD8.2
131E:  INCF   x85,F
1320:  MOVWF  x86
1322:  MOVFF  03,987
1326:  MOVFF  981,FEA
132A:  MOVF   x80,W
132C:  INCF   x80,F
132E:  BTFSC  FD8.2
1330:  INCF   x81,F
1332:  MOVWF  FE9
1334:  MOVFF  FEF,988
1338:  MOVFF  03,FEA
133C:  MOVFF  986,FE9
1340:  MOVFF  988,FEF
1344:  MOVF   x82,W
1346:  BTFSC  FD8.2
1348:  DECF   x83,F
134A:  DECF   x82,F
134C:  BRA    1300
....................   for (; n > 0; n--)
134E:  MOVF   x82,F
1350:  BNZ   1356
1352:  MOVF   x83,F
1354:  BZ    1370
....................      *s++ = '\0';
1356:  MOVFF  985,FEA
135A:  MOVF   x84,W
135C:  INCF   x84,F
135E:  BTFSC  FD8.2
1360:  INCF   x85,F
1362:  MOVWF  FE9
1364:  CLRF   FEF
1366:  MOVF   x82,W
1368:  BTFSC  FD8.2
136A:  DECF   x83,F
136C:  DECF   x82,F
136E:  BRA    134E
.................... 
....................   return(s1);
1370:  MOVFF  97E,01
1374:  MOVFF  97F,02
1378:  MOVLB  0
137A:  GOTO   163C (RETURN)
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
*
0B82:  MOVFF  97F,FEA
0B86:  MOVLB  9
0B88:  MOVFF  97E,FE9
0B8C:  MOVF   x80,W
0B8E:  SUBWF  FEF,W
0B90:  BZ    0BB6
....................       if (*s == '\0')
0B92:  MOVFF  97F,03
0B96:  MOVFF  97E,FE9
0B9A:  MOVFF  03,FEA
0B9E:  MOVF   FEF,F
0BA0:  BNZ   0BAA
....................          return(0);
0BA2:  MOVLW  00
0BA4:  MOVWF  01
0BA6:  MOVWF  02
0BA8:  BRA    0BBE
0BAA:  INCF   x7E,F
0BAC:  BTFSC  FD8.2
0BAE:  INCF   x7F,F
0BB0:  MOVLB  0
0BB2:  BRA    0B82
0BB4:  MOVLB  9
....................    return(s);
0BB6:  MOVFF  97E,01
0BBA:  MOVFF  97F,02
0BBE:  MOVLB  0
0BC0:  RETURN 0
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0AF0:  MOVFF  97D,97F
0AF4:  MOVFF  97C,97E
0AF8:  MOVFF  97F,FEA
0AFC:  MOVLB  9
0AFE:  MOVFF  97E,FE9
0B02:  MOVF   FEF,F
0B04:  BZ    0B12
0B06:  INCF   x7E,F
0B08:  BTFSC  FD8.2
0B0A:  INCF   x7F,F
0B0C:  MOVLB  0
0B0E:  BRA    0AF8
0B10:  MOVLB  9
....................    return(sc - s);
0B12:  MOVF   x7C,W
0B14:  SUBWF  x7E,W
0B16:  MOVWF  00
0B18:  MOVF   x7D,W
0B1A:  SUBWFB x7F,W
0B1C:  MOVWF  03
0B1E:  MOVFF  00,01
0B22:  MOVWF  02
0B24:  MOVLB  0
0B26:  GOTO   0C46 (RETURN)
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
068A:  MOVLW  09
068C:  MOVWF  FEA
068E:  MOVLW  90
0690:  MOVWF  FE9
0692:  MOVF   FEF,W
0694:  BZ    06B8
0696:  MOVLW  02
0698:  MOVWF  01
069A:  MOVLW  BF
069C:  MOVWF  00
069E:  CLRWDT
06A0:  DECFSZ 00,F
06A2:  BRA    069E
06A4:  DECFSZ 01,F
06A6:  BRA    069A
06A8:  MOVLW  96
06AA:  MOVWF  00
06AC:  DECFSZ 00,F
06AE:  BRA    06AC
06B0:  BRA    06B2
06B2:  CLRWDT
06B4:  DECFSZ FEF,F
06B6:  BRA    0696
06B8:  RETURN 0
*
12D0:  MOVLW  09
12D2:  MOVLB  9
12D4:  SUBWF  x7F,F
12D6:  BNC   12F0
12D8:  MOVLW  09
12DA:  MOVWF  FEA
12DC:  MOVLW  7F
12DE:  MOVWF  FE9
12E0:  BCF    FD8.0
12E2:  RRCF   FEF,F
12E4:  MOVF   FEF,W
12E6:  BZ    12F0
12E8:  BRA    12EC
12EA:  CLRWDT
12EC:  DECFSZ FEF,F
12EE:  BRA    12EA
12F0:  MOVLB  0
12F2:  GOTO   1534 (RETURN)
.................... 
.................... /* 
.................... Parameters and devices are stored in 1024 byte EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x0000
.................... #define DEVICE_CRC_ADDRESS 0x0002
.................... 
.................... #define PARAM_ADDRESS      0x0004 /* parameters go from 4 to 127 ... 123 bytes max */ 
.................... #define DEVICE_ADDRESS     0x0080 /* devices go from 128 to 1024 ... 896 bytes max */
.................... 
.................... 
.................... /* uart1 is for modbus and set in modbus_int_uart */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600, errors)	
*
04CC:  BTFSS  FA4.5
04CE:  BRA    04CC
04D0:  MOVFF  FA6,20
04D4:  MOVFF  F7A,01
04D8:  BTFSS  20.1
04DA:  BRA    04E0
04DC:  BCF    FA6.4
04DE:  BSF    FA6.4
04E0:  RETURN 0
*
19B6:  BTFSS  FA4.4
19B8:  BRA    19B6
19BA:  MOVWF  F79
19BC:  RETURN 0
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
05C2:  BCF    FC6.7
05C4:  BCF    F9E.3
05C6:  MOVFF  98D,FC9
05CA:  MOVLW  02
05CC:  BTFSC  FC6.7
05CE:  BRA    05DA
05D0:  BTFSC  FC7.2
05D2:  BRA    05D0
05D4:  MOVLW  00
05D6:  BTFSC  FC5.6
05D8:  MOVLW  01
05DA:  MOVWF  01
05DC:  RETURN 0
*
0DEE:  BCF    FC6.6
0DF0:  BSF    FC5.3
0DF2:  BTFSC  FC5.3
0DF4:  BRA    0DF2
0DF6:  BTFSC  00.0
0DF8:  BCF    FC5.5
0DFA:  BTFSS  00.0
0DFC:  BSF    FC5.5
0DFE:  BSF    FC5.4
0E00:  BTFSC  FC5.4
0E02:  BRA    0E00
0E04:  MOVFF  FC9,01
0E08:  RETURN 0
.................... 
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /* device types for struct_device */
.................... #define DEV_TYPE_DISABLED       0
.................... 
.................... /* modbus slave on RS-485 bus */
.................... #define DEV_TYPE_MODBUS_1       1
.................... #define DEV_TYPE_MODBUS_2       2
.................... #define DEV_TYPE_MODBUS_3       3
.................... #define DEV_TYPE_MODBUS_4       4
.................... #define DEV_TYPE_MODBUS_5       5
.................... #define DEV_TYPE_MODBUS_6       6
.................... #define DEV_TYPE_MODBUS_16      7
.................... #define DEV_TYPE_MODBUS_MAX     7
.................... 
.................... /* I2C slave on I2C bus */
.................... #define DEV_TYPE_I2C_READ_8     16
.................... #define DEV_TYPE_I2C_READ_16    17
.................... #define DEV_TYPE_I2C_READ_24    18
.................... #define DEV_TYPE_I2C_READ_32    19
.................... #define DEV_TYPE_I2C_WRITE_8    20
.................... #define DEV_TYPE_I2C_WRITE_16   21
.................... #define DEV_TYPE_I2C_WRITE_24   22
.................... #define DEV_TYPE_I2C_WRITE_32   23
.................... #define DEV_TYPE_I2C_MAX        23
.................... 
.................... /* local registers on this device */
.................... #define DEV_TYPE_LOCAL_READ_16  32
.................... #define DEV_TYPE_LOCAL_WRITE_16 33
.................... #define DEV_TYPE_LOCAL_MAX      33
.................... 
.................... 
.................... 
.................... /* serial port speeds */
.................... #define DEV_SERIAL_9600  0
.................... #define DEV_SERIAL_19200 1
.................... 
.................... 
.................... #define DEV_MAX_N 64
.................... 
.................... #include "worldDeviceTypes.h"
.................... /* Continental Control Systems, Watt Node Modbus */
.................... #define DEVICE_TYPE_WORLD_WNC_BASIC           1  /* 1000, 34 */
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED        2
.................... #define DEVICE_TYPE_WORLD_WNC_CONFIGURATION   3
.................... #define DEVICE_TYPE_WORLD_WNC_DIAGNOSTIC      4
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED_ENERGY 5  /* 1100, 38 */
.................... 
.................... /* APRS World, XRW2G */
.................... #define DEVICE_TYPE_WORLD_XRW2G_BASIC         100 /* 0, 46 */
.................... #define DEVICE_TYPE_WORLD_XRW2G_DIAGNOSTIC    101
.................... #define DEVICE_TYPE_WORLD_XRW2G_CONFIGURATION 102
.................... 
.................... /* Morningstar, Relay Driver */
.................... #define DEVICE_TYPE_WORLD_RD1_RAM             200 /* 0, 18 */
.................... #define DEVICE_TYPE_WORLD_RD1_COILS           201 /* 0, 4 */
.................... 
.................... /* Morningstar, Tri-Star */
.................... #define DEVICE_TYPE_WORLD_TS_RAM              300 /* 8, 21 */
.................... #define DEVICE_TYPE_WORLD_TS_COILS            301
.................... #define DEVICE_TYPE_WORLD_TS_EEPROM           302
.................... #define DEVICE_TYPE_WORLD_TS_KWH              303 /* 57388, 3 */
.................... 
.................... /* Morningstar, Tri-Star MPPT */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_SCALING                  320 /* 0, 4 */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_FILTERED_ADC             321 /* 24, 38 */
.................... 
.................... /* Advancetech, Adam 4xxx MODBUS */
.................... #define ADAM_4XXX_ANALOG_CURRENT                          400 /* 0, 8 */
.................... 
.................... /* smaller block definitions for SatCon PVS50 ... not implemented or seen in the wild. Do not use */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_SOFTWARE           500 /* 30009, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_ACTIVE_FAULTS      501 /* 30017, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_DC                 502 /* 30020, 4 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_CURRENT    503 /* 30035, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_VOLTAGE    504 /* 30040, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_POWER           505 /* 30043, 5 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_GROUND_IMPEDANCE   506 /* 30049, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT     507 /* 30050, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT_AVG 508 /* 30089, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH         509 /* 30090, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH_AVG     510 /* 30129, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_KWH                511 /* 30131, 8 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_TIMERS             512 /* 30275, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STATE              513 /* 30279, 2 */
.................... 
.................... /* SatCon PVS50 inverter. Manual has +30001 offset. */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_0      520 /* 9, 40 registers ... error, should be 41 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_1      521 /* 50, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_2      522 /* 90, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_3      523 /* 131, 8 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_4      524 /* 175, 2 registers ... not programmed at west point! */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_5      525 /* 275, 6 registers ... */
.................... 
.................... 
.................... /* PC&S Multitek MP850MPDV19PE CUSTOM 1 */
.................... /* Registers re-arranged to be consecutive, starting with reg 0 */
.................... /* Values are 32-bit Floating Point */
.................... /* Register list: */
.................... /* 0 - V 1 ... Voltage */
.................... /* 2 - I 1 ... Current */
.................... /* 4 - kW Sum */
.................... /* 6 - kWHr (Import) */
.................... /* 8 - kWd  (Import) ... Demand over last 3 minutes */
.................... /* 10 - Ad ... Demand current over last 3 minutes*/
.................... /* 12 - kWHr (Export) */
.................... /* 14 - A.h */
.................... /* 16 - Max kWd (Import) */
.................... /* 18 - Max Ad */
.................... 
.................... #define DEVICE_TYPE_WORLD_M850MPD_CUSTOM_1	 600 /* 0, 20 registers */
.................... 
.................... 
.................... #define DEVICE_TYPE_WORLD_SHUNTMONITOR_BASIC  700 /* 0, 32 registers */
.................... 
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_BASIC      800 /* 0, 39 registers */
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_CONFIG     801 /* 1000, 15 registers */
.................... 
.................... /* Midnite Solar Classic - based on 2011-05-21 specification */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_BASIC       900 /* 4113, 31 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_WIND_CURVE  901 /* 4300, 16 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_RESTING     902 /* 4274, 3  registers */
.................... 
.................... /* APRS World POE Monitor */
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_BASIC    1000 
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_CONFIG   1001
.................... 
.................... /* APRS World watchdog Arlo */
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_BASIC  1100
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_CONFIG 1101
.................... 
.................... /* China HUM temperature and relative humidity sensor */
.................... #define DEVICE_TYPE_WORLD_HUM_TEMPERATURE      1200
.................... #define DEVICE_TYPE_WORLD_HUM_RELATIVEHUMIDITY 1201
.................... 
.................... /* "Center" brand soundmeter */
.................... #define TYPE_TYPE_WORLD_SOUNDMETER_CENTER      1300
.................... 
.................... /* PS2Tap */
.................... #define DEVICE_TYPE_WORLD_PS2TAP_BASIC         1400 /* 0, 19 registers */
.................... 
.................... /* Veris E50 Series Power Meter */
.................... #define DEVICE_TYPE_WORLD_VERISE50_BASIC       1500 /* 256, 54 registers */
.................... 
.................... 
.................... /* Note: List not complete.  Reference master list in WorldDataCollector. */
.................... 
.................... 
.................... /* generic rsdata */
.................... #define DEVICE_TYPE_WORLD_RSDATA               32000 /* Integer */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT         32001 /* IEEE-754 single precision floating point (32-bit) data */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT_LITTLE  32002 
.................... 
.................... 
.................... typedef struct {
.................... 	int8  type;           /* device query type */
.................... 	int16 typeWorld;      /* see worldDeviceTypes.h for defines */
.................... 	int8  transmitEvery;
.................... 	int8  networkAddress; /* modbus or I2C address */
.................... 	int32 serialNumber;   /* APRS World or other serial number */
.................... 	int16 startRegister;
.................... 	int8  nRegisters;
.................... 	int8  serialSpeed;    /* see rsTap.h for defines */
.................... } struct_device;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  now_poll;
.................... 	int8  world_timeout;
.................... 	int8  factory_unlocked;
.................... 	int8  led_on_green;
.................... 	int16 sbd_cycle;
.................... } struct_timer;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  rException;
.................... 	int8  rResult[256];
.................... 	int8  rResultLength;
.................... 	int8  deviceNumber;
.................... 	int16 measurementNumber;
.................... } struct_qbuff;
.................... 
.................... typedef struct {
.................... 	int8 buff[256];
.................... 	int8 buff_pos;
.................... 	int8 buff_ready;
.................... 
.................... 	int8  packet_length;
.................... 	int32 query_id;
.................... 	int32 device_serial;
.................... 	int16 network_address;
.................... 	int16 function;
.................... 	int16 start_address;
.................... 	int8  n_words;
.................... 	int8  data_start_offset;
.................... 	int16 crc;
.................... 
.................... 	int8  resultException;
.................... 	int8  resultLength;
.................... } struct_query;
.................... 
.................... typedef struct {
.................... 	int8  serial_prefix;
.................... 	int16 serial_number;
.................... 	
.................... 	int16 live_interval;
.................... 
.................... 	/* Iridium SBD or other limited bandwidth transmission */
.................... 	/* 0 is no SBD, 1...5 is SBD modem with power switch on CONTROL pin 1...5 */
.................... 	int8  sbd_config;
.................... 
.................... 	/*	
.................... 	every n'th live transmission we transmit the SBD data
.................... 	Interval should be at least 10 minutes to allow for full retry cycle	
.................... 	on cycle before transmit, we clear previous buffer and turn on modem 
.................... 	*/
.................... 	int16 sbd_every;
.................... 
.................... } struct_config;
.................... 
.................... /* global structures */
.................... struct_device device[DEV_MAX_N];
.................... struct_timer  timers;
.................... struct_qbuff  qbuff;
.................... struct_query  query;
.................... struct_config config;
.................... 
.................... #include "i2c_access_rdTap.c"
.................... int16 i2c_register_read16(int8 i2c_address, int8 regaddr) {
.................... 	int8 msb, lsb;
.................... 
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address);
.................... 	i2c_write(regaddr);
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address | 1);  // read cycle
.................... 	msb=i2c_read(1);
.................... 	lsb=i2c_read(0);                                
.................... 	i2c_stop();
.................... 
.................... 	return make16(msb,lsb);
.................... }
.................... 
.................... void i2c_buff_read(int8 i2c_address, int8 regaddr, int8 *data, int8 count) {
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
*
1CBA:  BSF    FC5.0
1CBC:  BTFSC  FC5.0
1CBE:  BRA    1CBC
.................... 	delay_us(15);
1CC0:  CLRWDT
1CC2:  MOVLW  09
1CC4:  MOVWF  00
1CC6:  DECFSZ 00,F
1CC8:  BRA    1CC6
1CCA:  NOP   
.................... 	i2c_write(i2c_address);
1CCC:  MOVFF  982,98D
1CD0:  CALL   05C2
.................... 	i2c_write(regaddr);
1CD4:  MOVFF  983,98D
1CD8:  CALL   05C2
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
1CDC:  BSF    FC5.1
1CDE:  BTFSC  FC5.1
1CE0:  BRA    1CDE
.................... 	delay_us(15);
1CE2:  CLRWDT
1CE4:  MOVLW  09
1CE6:  MOVWF  00
1CE8:  DECFSZ 00,F
1CEA:  BRA    1CE8
1CEC:  NOP   
.................... 	i2c_write(i2c_address | 1);  // read cycle
1CEE:  MOVLB  9
1CF0:  MOVF   x82,W
1CF2:  IORLW  01
1CF4:  MOVWF  x87
1CF6:  MOVWF  x8D
1CF8:  MOVLB  0
1CFA:  CALL   05C2
.................... 
.................... 	/* stop reading before last byte */	
.................... 	while ( count-- != 1 ) {
1CFE:  MOVLB  9
1D00:  MOVF   x86,W
1D02:  DECF   x86,F
1D04:  SUBLW  01
1D06:  BZ    1D28
.................... 		*data=i2c_read(1);
1D08:  MOVFF  985,FEA
1D0C:  MOVFF  984,FE9
1D10:  MOVLW  01
1D12:  MOVWF  00
1D14:  MOVLB  0
1D16:  CALL   0DEE
1D1A:  MOVFF  01,FEF
.................... 		data++;
1D1E:  MOVLB  9
1D20:  INCF   x84,F
1D22:  BTFSC  FD8.2
1D24:  INCF   x85,F
1D26:  BRA    1D00
.................... 	}
.................... 
.................... 	/* send last byte with a NAK */
.................... 	*data=i2c_read(0);                                
1D28:  MOVFF  985,FEA
1D2C:  MOVFF  984,FE9
1D30:  CLRF   00
1D32:  MOVLB  0
1D34:  CALL   0DEE
1D38:  MOVFF  01,FEF
.................... 	i2c_stop();
1D3C:  BSF    FC5.2
1D3E:  BTFSC  FC5.2
1D40:  BRA    1D3E
1D42:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void i2c_register_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start();
*
30A0:  BSF    FC5.0
30A2:  BTFSC  FC5.0
30A4:  BRA    30A2
.................... 	delay_us(15);                                                 
30A6:  CLRWDT
30A8:  MOVLW  09
30AA:  MOVWF  00
30AC:  DECFSZ 00,F
30AE:  BRA    30AC
30B0:  NOP   
.................... 	i2c_write(i2c_address); // write cycle                       
30B2:  MOVFF  988,98D
30B6:  CALL   05C2
.................... 	i2c_write(regaddr);  // write cycle         
30BA:  MOVFF  989,98D
30BE:  CALL   05C2
.................... 	i2c_write(make8(value,1));
30C2:  MOVFF  98B,98D
30C6:  CALL   05C2
.................... 	i2c_write(make8(value,0));
30CA:  MOVFF  98A,98D
30CE:  CALL   05C2
.................... 	i2c_stop();
30D2:  BSF    FC5.2
30D4:  BTFSC  FC5.2
30D6:  BRA    30D4
30D8:  GOTO   33EC (RETURN)
.................... }
.................... 
.................... void i2c_register_write32(int8 i2c_address, int8 regaddr, int32 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle     
.................... 	i2c_write(make8(value,3));
.................... 	i2c_write(make8(value,2));    
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... #include "mcp3208_rdTap.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
.................... 	output_high(CS_ADC0);
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
.................... 	output_high(MCP3208_DIN);
.................... 
.................... 
.................... 	if ( ch<8 ) {
.................... 		output_low(CS_ADC0);
.................... 	} else {
.................... 		output_low(CS_ADC1);
.................... 		ch-=8;
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
.................... 		c=0b00011;
.................... 	else if ( 1 == ch ) 
.................... 		c=0b10011;
.................... 	else if ( 2 == ch ) 
.................... 		c=0b01011;
.................... 	else if ( 3 == ch ) 
.................... 		c=0b11011;
.................... 	else if ( 4 == ch )
.................... 		c=0b00111;
.................... 	else if ( 5 == ch ) 
.................... 		c=0b10111;
.................... 	else if ( 6 == ch )
.................... 		c=0b01111;
.................... 	else
.................... 		c=0b11111;
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		output_bit(MCP3208_DIN,c&1);
.................... 		c=c>>1;
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 
.................... 	value=0;
.................... 	for ( i=0 ; i<14 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 	bit_clear(value,13);
.................... 	bit_clear(value,12);
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
.................... 
.................... 	return value;
.................... }
.................... 
.................... #include "uart_sc16is740_rdTap.c"
.................... /* register map for SC16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
*
0E0A:  BSF    FC5.0
0E0C:  BTFSC  FC5.0
0E0E:  BRA    0E0C
.................... 	delay_us(15);
0E10:  CLRWDT
0E12:  MOVLW  09
0E14:  MOVWF  00
0E16:  DECFSZ 00,F
0E18:  BRA    0E16
0E1A:  NOP   
.................... 	i2c_write(UART_ADDR);
0E1C:  MOVLW  9A
0E1E:  MOVLB  9
0E20:  MOVWF  x8D
0E22:  MOVLB  0
0E24:  CALL   05C2
.................... 	i2c_write(regaddr<<3);
0E28:  MOVLB  9
0E2A:  RLCF   x7B,W
0E2C:  MOVWF  x7D
0E2E:  RLCF   x7D,F
0E30:  RLCF   x7D,F
0E32:  MOVLW  F8
0E34:  ANDWF  x7D,F
0E36:  MOVFF  97D,98D
0E3A:  MOVLB  0
0E3C:  CALL   05C2
.................... 	i2c_start();
0E40:  BSF    FC5.1
0E42:  BTFSC  FC5.1
0E44:  BRA    0E42
.................... 	delay_us(15);
0E46:  CLRWDT
0E48:  MOVLW  09
0E4A:  MOVWF  00
0E4C:  DECFSZ 00,F
0E4E:  BRA    0E4C
0E50:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
0E52:  MOVLW  9B
0E54:  MOVLB  9
0E56:  MOVWF  x8D
0E58:  MOVLB  0
0E5A:  CALL   05C2
.................... 	data=i2c_read(0);
0E5E:  CLRF   00
0E60:  RCALL  0DEE
0E62:  MOVFF  01,97C
.................... 	i2c_stop();
0E66:  BSF    FC5.2
0E68:  BTFSC  FC5.2
0E6A:  BRA    0E68
.................... 
.................... 	return data;
0E6C:  MOVLB  9
0E6E:  MOVFF  97C,01
0E72:  MOVLB  0
0E74:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
05DE:  BSF    FC5.0
05E0:  BTFSC  FC5.0
05E2:  BRA    05E0
.................... 	delay_us(15);                                                 
05E4:  CLRWDT
05E6:  MOVLW  09
05E8:  MOVWF  00
05EA:  DECFSZ 00,F
05EC:  BRA    05EA
05EE:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
05F0:  MOVLW  9A
05F2:  MOVLB  9
05F4:  MOVWF  x8D
05F6:  MOVLB  0
05F8:  RCALL  05C2
.................... 	i2c_write(regaddr<< 3);  // write cycle         
05FA:  MOVLB  9
05FC:  RLCF   x88,W
05FE:  MOVWF  x8A
0600:  RLCF   x8A,F
0602:  RLCF   x8A,F
0604:  MOVLW  F8
0606:  ANDWF  x8A,F
0608:  MOVFF  98A,98D
060C:  MOVLB  0
060E:  RCALL  05C2
.................... 	i2c_write(data);
0610:  MOVFF  989,98D
0614:  RCALL  05C2
.................... 	i2c_stop();
0616:  BSF    FC5.2
0618:  BTFSC  FC5.2
061A:  BRA    0618
061C:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
0F3C:  MOVLB  9
0F3E:  CLRF   x88
0F40:  MOVFF  987,989
0F44:  MOVLB  0
0F46:  CALL   05DE
0F4A:  RETURN 0
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
0E76:  MOVLW  05
0E78:  MOVLB  9
0E7A:  MOVWF  x7B
0E7C:  MOVLB  0
0E7E:  RCALL  0E0A
0E80:  MOVF   01,W
0E82:  ANDLW  01
0E84:  MOVWF  01
0E86:  RETURN 0
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
0E88:  MOVLB  9
0E8A:  CLRF   x7B
0E8C:  MOVLB  0
0E8E:  RCALL  0E0A
0E90:  MOVF   01,W
*
1068:  MOVLB  9
106A:  CLRF   x7B
106C:  MOVLB  0
106E:  RCALL  0E0A
1070:  MOVF   01,W
*
1090:  MOVLB  9
1092:  CLRF   x7B
1094:  MOVLB  0
1096:  RCALL  0E0A
1098:  MOVF   01,W
*
10DA:  MOVLB  9
10DC:  CLRF   x7B
10DE:  MOVLB  0
10E0:  RCALL  0E0A
10E2:  MOVF   01,W
*
1136:  MOVLB  9
1138:  CLRF   x7B
113A:  MOVLB  0
113C:  RCALL  0E0A
113E:  MOVF   01,W
*
115E:  MOVLB  9
1160:  CLRF   x7B
1162:  MOVLB  0
1164:  RCALL  0E0A
1166:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
061E:  MOVLW  03
0620:  MOVLB  9
0622:  MOVWF  x88
0624:  MOVLW  80
0626:  MOVWF  x89
0628:  MOVLB  0
062A:  RCALL  05DE
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
062C:  MOVLB  9
062E:  CLRF   x88
0630:  MOVFF  97A,989
0634:  MOVLB  0
0636:  RCALL  05DE
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
0638:  MOVLW  01
063A:  MOVLB  9
063C:  MOVWF  x88
063E:  CLRF   x89
0640:  MOVLB  0
0642:  RCALL  05DE
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
0644:  MOVLW  03
0646:  MOVLB  9
0648:  MOVWF  x88
064A:  MOVLW  BF
064C:  MOVWF  x89
064E:  MOVLB  0
0650:  RCALL  05DE
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
0652:  MOVLW  02
0654:  MOVLB  9
0656:  MOVWF  x88
0658:  MOVLW  10
065A:  MOVWF  x89
065C:  MOVLB  0
065E:  RCALL  05DE
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
0660:  MOVLW  03
0662:  MOVLB  9
0664:  MOVWF  x88
0666:  MOVWF  x89
0668:  MOVLB  0
066A:  RCALL  05DE
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
066C:  MOVLW  01
066E:  MOVLB  9
0670:  MOVWF  x88
0672:  CLRF   x89
0674:  MOVLB  0
0676:  RCALL  05DE
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
0678:  MOVLW  02
067A:  MOVLB  9
067C:  MOVWF  x88
067E:  MOVLW  07
0680:  MOVWF  x89
0682:  MOVLB  0
0684:  RCALL  05DE
0686:  GOTO   071E (RETURN)
.................... }
.................... 
.................... 
.................... #include "param_rdTap.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0762:  MOVF   x98,W
0764:  XORWF  x99,W
0766:  MOVWF  01
*
0A06:  MOVF   x98,W
0A08:  XORWF  x99,W
0A0A:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
099A:  MOVLB  9
099C:  CLRF   x83
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
099E:  MOVFF  982,985
09A2:  MOVF   x81,W
09A4:  BTFSC  FD8.2
09A6:  DECF   x82,F
09A8:  DECF   x81,F
09AA:  MOVWF  x84
09AC:  MOVF   x84,F
09AE:  BNZ   09B4
09B0:  MOVF   x85,F
09B2:  BZ    0A18
.................... 		*data = read_eeprom( address++ );
09B4:  MOVFF  980,03
09B8:  MOVF   x7F,W
09BA:  MOVWF  FE9
09BC:  MOVFF  03,FEA
09C0:  MOVF   x7E,W
09C2:  MOVWF  03
09C4:  MOVF   x7D,W
09C6:  INCF   x7D,F
09C8:  BTFSC  FD8.2
09CA:  INCF   x7E,F
09CC:  MOVWF  x86
09CE:  MOVFF  03,987
09D2:  MOVFF  FF2,988
09D6:  BCF    FF2.7
09D8:  MOVFF  987,F75
09DC:  MOVFF  986,F74
09E0:  BCF    F7F.6
09E2:  BCF    F7F.7
09E4:  BSF    F7F.0
09E6:  MOVF   F73,W
09E8:  BTFSC  x88.7
09EA:  BSF    FF2.7
09EC:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
09EE:  MOVFF  980,03
09F2:  MOVF   x7F,W
09F4:  MOVWF  FE9
09F6:  MOVFF  03,FEA
09FA:  MOVFF  FEF,984
09FE:  MOVFF  983,998
0A02:  MOVFF  984,999
*
0A0C:  MOVFF  01,983
.................... 		data++;
0A10:  INCF   x7F,F
0A12:  BTFSC  FD8.2
0A14:  INCF   x80,F
0A16:  BRA    099E
.................... 	}
.................... 	return crc;
0A18:  MOVFF  983,01
0A1C:  MOVLB  0
0A1E:  RETURN 0
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
*
072E:  MOVLB  9
0730:  CLRF   x96
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0732:  MOVFF  995,998
0736:  MOVF   x94,W
0738:  BTFSC  FD8.2
073A:  DECF   x95,F
073C:  DECF   x94,F
073E:  MOVWF  x97
0740:  MOVF   x97,F
0742:  BNZ   0748
0744:  MOVF   x98,F
0746:  BZ    07C6
.................... 		restart_wdt();
0748:  CLRWDT
.................... 		crc = xor_crc(crc,*data);
074A:  MOVFF  993,03
074E:  MOVF   x92,W
0750:  MOVWF  FE9
0752:  MOVFF  03,FEA
0756:  MOVFF  FEF,997
075A:  MOVFF  996,998
075E:  MOVFF  997,999
*
0768:  MOVFF  01,996
.................... 		write_eeprom( address++, *data++ );
076C:  MOVF   x91,W
076E:  MOVWF  03
0770:  MOVF   x90,W
0772:  INCF   x90,F
0774:  BTFSC  FD8.2
0776:  INCF   x91,F
0778:  MOVWF  x97
077A:  MOVFF  03,998
077E:  MOVF   x93,W
0780:  MOVWF  03
0782:  MOVF   x92,W
0784:  INCF   x92,F
0786:  BTFSC  FD8.2
0788:  INCF   x93,F
078A:  MOVWF  FE9
078C:  MOVFF  03,FEA
0790:  MOVFF  FEF,999
0794:  MOVF   FF2,W
0796:  MOVWF  00
0798:  BCF    FF2.7
079A:  MOVFF  998,F75
079E:  MOVFF  997,F74
07A2:  MOVFF  999,F73
07A6:  BCF    F7F.6
07A8:  BCF    F7F.7
07AA:  BSF    F7F.2
07AC:  MOVLB  F
07AE:  MOVLW  55
07B0:  MOVWF  F7E
07B2:  MOVLW  AA
07B4:  MOVWF  F7E
07B6:  BSF    F7F.1
07B8:  BTFSC  F7F.1
07BA:  BRA    07B8
07BC:  BCF    F7F.2
07BE:  MOVF   00,W
07C0:  IORWF  FF2,F
07C2:  MOVLB  9
07C4:  BRA    0732
.................... 	}
.................... 
.................... 	return crc;
07C6:  MOVFF  996,01
07CA:  MOVLB  0
07CC:  RETURN 0
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
07CE:  MOVLW  05
07D0:  MOVLB  9
07D2:  MOVWF  x8E
07D4:  MOVLW  83
07D6:  MOVWF  x8D
07D8:  CLRF   x91
07DA:  MOVLW  04
07DC:  MOVWF  x90
07DE:  MOVFF  98E,993
07E2:  MOVFF  98D,992
07E6:  CLRF   x95
07E8:  MOVLW  08
07EA:  MOVWF  x94
07EC:  MOVLB  0
07EE:  RCALL  072E
07F0:  MOVFF  01,98C
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
07F4:  MOVF   FF2,W
07F6:  MOVWF  00
07F8:  BCF    FF2.7
07FA:  CLRF   F75
07FC:  CLRF   F74
07FE:  MOVFF  98C,F73
0802:  BCF    F7F.6
0804:  BCF    F7F.7
0806:  BSF    F7F.2
0808:  MOVLB  F
080A:  MOVLW  55
080C:  MOVWF  F7E
080E:  MOVLW  AA
0810:  MOVWF  F7E
0812:  BSF    F7F.1
0814:  BTFSC  F7F.1
0816:  BRA    0814
0818:  BCF    F7F.2
081A:  MOVF   00,W
081C:  IORWF  FF2,F
081E:  MOVLB  0
0820:  RETURN 0
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0822:  MOVLW  96
0824:  MOVLB  3
0826:  MOVWF  x64
.................... //	fprintf(world,"# writing default parameters\r\n");
.................... 
.................... 	config.serial_prefix='A';
0828:  MOVLW  41
082A:  MOVLB  5
082C:  MOVWF  x83
.................... 	config.serial_number=4756;
082E:  MOVLW  12
0830:  MOVWF  x85
0832:  MOVLW  94
0834:  MOVWF  x84
.................... 		/* 
.................... 			A4797 Fairway UAF (SBD in slot 5 closest to power connector)
.................... 			A4800 Fairway UVic (SBD in slot 1)
.................... 			A4810 Uvic Spare Fairway panel (SBD in slot 1)
.................... 			A4820 JJJ Bench (SBD in slot 1)
.................... 			A4756 A test unit (SBD in slot 1)
.................... 		*/
.................... 
.................... 	/* data to internet on STREAM_WORLD port */
.................... 	config.live_interval=10; 
0836:  CLRF   x87
0838:  MOVLW  0A
083A:  MOVWF  x86
.................... 
.................... 	/* Iridium SBD requires dcswc_module_rockblock which provides an I2C UART */
.................... 	config.sbd_config=1;   /* physical slot for module. Used for power control */
083C:  MOVLW  01
083E:  MOVWF  x88
.................... 	config.sbd_every=90; /* send SBD message every this number of live_interval */
0840:  CLRF   x8A
0842:  MOVLW  5A
0844:  MOVWF  x89
....................                            /* with 10 second live interval, 4320 => SBD every 12 hours */
....................                            /* with 10 second live interval, 1080 => SBD every 3 hours */			
....................                            /* with 10 second live interval, 90 => SBD every 15 minutes */
.................... 				
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0846:  MOVLB  0
0848:  RCALL  07CE
084A:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS,(void *)&config, sizeof(config)); 
*
0A20:  MOVLW  05
0A22:  MOVLB  9
0A24:  MOVWF  x7C
0A26:  MOVLW  83
0A28:  MOVWF  x7B
0A2A:  CLRF   x7E
0A2C:  MOVLW  04
0A2E:  MOVWF  x7D
0A30:  MOVFF  97C,980
0A34:  MOVFF  97B,97F
0A38:  CLRF   x82
0A3A:  MOVLW  08
0A3C:  MOVWF  x81
0A3E:  MOVLB  0
0A40:  RCALL  099A
0A42:  MOVFF  01,97A
.................... 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
0A46:  MOVFF  FF2,97B
0A4A:  BCF    FF2.7
0A4C:  CLRF   F75
0A4E:  CLRF   F74
0A50:  BCF    F7F.6
0A52:  BCF    F7F.7
0A54:  BSF    F7F.0
0A56:  MOVF   F73,W
0A58:  MOVLB  9
0A5A:  BTFSC  x7B.7
0A5C:  BSF    FF2.7
0A5E:  SUBWF  x7A,W
0A60:  BZ    0A68
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_param_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_param_file();
0A62:  MOVLB  0
0A64:  RCALL  0822
0A66:  MOVLB  9
.................... 	}
0A68:  MOVLB  0
0A6A:  GOTO   3736 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "paramDevice_rdTap.c"
.................... void write_device_file() {
.................... 	int8 crc;
.................... 
.................... 
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(DEVICE_ADDRESS,(void *)&device,sizeof(device));
*
086E:  MOVLB  9
0870:  MOVLW  21
0872:  MOVWF  x8E
0874:  CLRF   x91
0876:  MOVLW  80
0878:  MOVWF  x90
087A:  CLRF   x93
087C:  MOVFF  98E,992
0880:  MOVLW  03
0882:  MOVWF  x95
0884:  MOVLW  40
0886:  MOVWF  x94
0888:  MOVLB  0
088A:  RCALL  072E
088C:  MOVFF  01,98D
.................... 	/* write the CRC that was calculated on the structure */
.................... 	write_eeprom(DEVICE_CRC_ADDRESS,crc);
0890:  MOVF   FF2,W
0892:  MOVWF  00
0894:  BCF    FF2.7
0896:  CLRF   F75
0898:  MOVLW  02
089A:  MOVWF  F74
089C:  MOVFF  98D,F73
08A0:  BCF    F7F.6
08A2:  BCF    F7F.7
08A4:  BSF    F7F.2
08A6:  MOVLB  F
08A8:  MOVLW  55
08AA:  MOVWF  F7E
08AC:  MOVLW  AA
08AE:  MOVWF  F7E
08B0:  BSF    F7F.1
08B2:  BTFSC  F7F.1
08B4:  BRA    08B2
08B6:  BCF    F7F.2
08B8:  MOVF   00,W
08BA:  IORWF  FF2,F
08BC:  MOVLB  0
08BE:  RETURN 0
.................... 
.................... //	fprintf(STREAM_WORLD,"# write_device_file crc=%u\r\n",crc);
.................... }
.................... 
.................... /* load device configuration from program memory */
.................... void write_default_device_file(void) {
.................... 	int8 i;
.................... 
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
08C0:  MOVLW  96
08C2:  MOVLB  3
08C4:  MOVWF  x64
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# disabling all devices\r\n");
.................... #endif
.................... 
.................... 	/* disable all devices */
.................... 	for ( i=0 ; i<DEV_MAX_N ; i++ ) {
08C6:  MOVLB  9
08C8:  CLRF   x8C
08CA:  MOVF   x8C,W
08CC:  SUBLW  3F
08CE:  BNC   08F4
.................... 		device[i].type=DEV_TYPE_DISABLED;	
08D0:  CLRF   x95
08D2:  MOVFF  98C,994
08D6:  CLRF   x97
08D8:  MOVLW  0D
08DA:  MOVWF  x96
08DC:  MOVLB  0
08DE:  RCALL  084C
08E0:  MOVLW  21
08E2:  MOVLB  9
08E4:  ADDWF  01,W
08E6:  MOVWF  FE9
08E8:  MOVLW  00
08EA:  ADDWFC 02,W
08EC:  MOVWF  FEA
08EE:  CLRF   FEF
.................... 	}
.................... 
.................... #if 0
.................... 	/* UAF Fairway */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4790; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4791; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4792; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Fairway on A4800 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4806; /*  4264646 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4808; /* 4264648 */
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4807; /* 4264647 */ 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Spare Panel on A4810 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4801; /* 4264641 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4802; /* 4264642 */ 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38; 
.................... 	device[2].serialNumber=('A'<<16) + 4803; /* 4264643 */
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* JJJ Test board on A4820 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4821; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4822; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4823; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 1
08F0:  INCF   x8C,F
08F2:  BRA    08CA
.................... 	/* N Test A4756 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
08F4:  MOVLW  10
08F6:  MOVWF  21
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
08F8:  MOVLW  7D
08FA:  MOVWF  23
08FC:  CLRF   22
.................... 	device[0].transmitEvery=1;
08FE:  MOVLW  01
0900:  MOVWF  24
.................... 	device[0].networkAddress=0x44; /* on on */
0902:  MOVLW  44
0904:  MOVWF  25
.................... 	device[0].serialNumber=('A'<<16) + 4821; 
0906:  CLRF   29
0908:  MOVLW  41
090A:  MOVWF  28
090C:  MOVLW  12
090E:  MOVWF  27
0910:  MOVLW  D5
0912:  MOVWF  26
.................... 	device[0].startRegister=0;
0914:  CLRF   2B
0916:  CLRF   2A
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
0918:  MOVLW  06
091A:  MOVWF  2C
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
091C:  MOVLW  10
091E:  MOVWF  2E
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0920:  MOVLW  7D
0922:  MOVWF  30
0924:  CLRF   2F
.................... 	device[1].transmitEvery=1;
0926:  MOVLW  01
0928:  MOVWF  31
.................... 	device[1].networkAddress=0x36; /* off off */
092A:  MOVLW  36
092C:  MOVWF  32
.................... 	device[1].serialNumber=('A'<<16) + 4822; 
092E:  CLRF   36
0930:  MOVLW  41
0932:  MOVWF  35
0934:  MOVLW  12
0936:  MOVWF  34
0938:  MOVLW  D6
093A:  MOVWF  33
.................... 	device[1].startRegister=0;
093C:  CLRF   38
093E:  CLRF   37
.................... 	device[1].nRegisters=32;
0940:  MOVLW  20
0942:  MOVWF  39
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
0944:  MOVLW  10
0946:  MOVWF  3B
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0948:  MOVLW  7D
094A:  MOVWF  3D
094C:  CLRF   3C
.................... 	device[2].transmitEvery=1;
094E:  MOVLW  01
0950:  MOVWF  3E
.................... 	device[2].networkAddress=0x38; /* on off */
0952:  MOVLW  38
0954:  MOVWF  3F
.................... 	device[2].serialNumber=('A'<<16) + 4823; 
0956:  CLRF   43
0958:  MOVLW  41
095A:  MOVWF  42
095C:  MOVLW  12
095E:  MOVWF  41
0960:  MOVLW  D7
0962:  MOVWF  40
.................... 	device[2].startRegister=0;
0964:  CLRF   45
0966:  CLRF   44
.................... 	device[2].nRegisters=32;
0968:  MOVLW  20
096A:  MOVWF  46
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[3].type=DEV_TYPE_I2C_READ_8;
096C:  MOVLW  10
096E:  MOVWF  48
.................... 	device[3].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0970:  MOVLW  7D
0972:  MOVWF  4A
0974:  CLRF   49
.................... 	device[3].transmitEvery=1;
0976:  MOVLW  01
0978:  MOVWF  4B
.................... 	device[3].networkAddress=0x3a; /* off /on */
097A:  MOVLW  3A
097C:  MOVWF  4C
.................... 	device[3].serialNumber=('A'<<16) + 4824; 
097E:  CLRF   50
0980:  MOVLW  41
0982:  MOVWF  4F
0984:  MOVLW  12
0986:  MOVWF  4E
0988:  MOVLW  D8
098A:  MOVWF  4D
.................... 	device[3].startRegister=0;
098C:  CLRF   52
098E:  CLRF   51
.................... 	device[3].nRegisters=32;
0990:  MOVLW  20
0992:  MOVWF  53
.................... #endif
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# write_device_file()\r\n");
.................... #endif
.................... 
.................... 	write_device_file();
0994:  MOVLB  0
0996:  RCALL  086E
0998:  RETURN 0
.................... }
.................... 
.................... void read_device_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(DEVICE_ADDRESS,(void *)&device, sizeof(device)); 
*
0A6E:  MOVLB  9
0A70:  MOVLW  21
0A72:  MOVWF  x7B
0A74:  CLRF   x7E
0A76:  MOVLW  80
0A78:  MOVWF  x7D
0A7A:  CLRF   x80
0A7C:  MOVFF  97B,97F
0A80:  MOVLW  03
0A82:  MOVWF  x82
0A84:  MOVLW  40
0A86:  MOVWF  x81
0A88:  MOVLB  0
0A8A:  RCALL  099A
0A8C:  MOVFF  01,97A
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# read_device_file crc=%u\r\n",crc);
.................... #endif
.................... 
.................... 	if ( crc != read_eeprom(DEVICE_CRC_ADDRESS) ) {
0A90:  MOVFF  FF2,97B
0A94:  BCF    FF2.7
0A96:  CLRF   F75
0A98:  MOVLW  02
0A9A:  MOVWF  F74
0A9C:  BCF    F7F.6
0A9E:  BCF    F7F.7
0AA0:  BSF    F7F.0
0AA2:  MOVF   F73,W
0AA4:  MOVLB  9
0AA6:  BTFSC  x7B.7
0AA8:  BSF    FF2.7
0AAA:  SUBWF  x7A,W
0AAC:  BZ    0AB4
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_device_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_device_file();
0AAE:  MOVLB  0
0AB0:  RCALL  08C0
0AB2:  MOVLB  9
.................... 	}
0AB4:  MOVLB  0
0AB6:  GOTO   373A (RETURN)
.................... }
.................... 
.................... void devicesDump(void) {
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... 
.................... 	fprintf(STREAM_WORLD,"# dumping all enabled devices:\r\n");
.................... 	for ( i=0 ; i<16 ; i++ ) {
.................... 		restart_wdt();
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[i].type ) 
.................... 			continue;
.................... 
.................... 		fprintf(STREAM_WORLD,"device[%u]\r\n",i);
.................... 		fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[i].type);
.................... 		fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[i].transmitEvery);
.................... 		fprintf(STREAM_WORLD,"\tnetworkAddress=%u\r\n",device[i].networkAddress);
.................... 		fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 			make8(device[i].serialNumber,3),
.................... 			make8(device[i].serialNumber,2),
.................... 			make8(device[i].serialNumber,1),
.................... 			make8(device[i].serialNumber,0)
.................... 		);
.................... 		fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[i].startRegister);
.................... 		fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[i].nRegisters);
.................... 	}
.................... 	fprintf(STREAM_WORLD,"# done\r\n");
.................... #endif
.................... }
.................... 
.................... #include "modbus_int_uart_rdTap.c"
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //// MASTER API:                                                                      ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /*Some defines so we can use identifiers to set things up*/
.................... #define MODBUS_TYPE_MASTER 99999
.................... #define MODBUS_TYPE_SLAVE 88888
.................... #define MODBUS_INT_RDA 77777
.................... #define MODBUS_INT_RDA2 66666
.................... #define MODBUS_INT_EXT 55555
.................... 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER
.................... 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA  // Select between external interrupt
.................... #define MODBUS_SERIAL_BAUD 9600
.................... #define MODBUS_SERIAL_RX_PIN       NET_RX   // Data receive pin
.................... #define MODBUS_SERIAL_TX_PIN       NET_TX   // Data transmit pin
.................... #define MODBUS_SERIAL_ENABLE_PIN   RS485_DE   // Controls DE pin.  RX low, TX high.
.................... #define MODBUS_SERIAL_RX_ENABLE    RS485_NOT_RE   // Controls RE pin.  Should keep low.
.................... #define MODBUS_SERIAL_TIMEOUT      100000     //in us
.................... 
.................... 
.................... #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, parity=N, stream=MODBUS_SERIAL, errors)
*
0336:  BTFSS  F9E.5
0338:  BRA    0336
033A:  MOVFF  FAB,20
033E:  MOVFF  FAE,01
0342:  BTFSS  20.1
0344:  BRA    034A
0346:  BCF    FAB.4
0348:  BSF    FAB.4
034A:  RETURN 0
*
1774:  BTFSS  F9E.4
1776:  BRA    1774
1778:  MOVWF  FAD
177A:  GOTO   1786 (RETURN)
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);}
.................... 
.................... 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer
.................... 
.................... 
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
.................... 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................     if(address)\
....................     {\
....................         while(!modbus_kbhit() && --modbus_serial_wait)\
....................             delay_us(1);\
....................         if(!modbus_serial_wait)\
....................             modbus_rx.error=TIMEOUT;\
....................     }\
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... //#byte TXSTA=getenv("sfr:TXSTA")
.................... #byte TXSTA=0xfad
.................... #bit TRMT=TXSTA.1
.................... 
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }   
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    int8 b[2];
....................    int16 d;
.................... } modbus_serial_crc;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void rcv_on(void) {
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
.................... 	while(kbhit(MODBUS_SERIAL)) {
*
0ABA:  BTFSS  F9E.5
0ABC:  BRA    0AC2
.................... 		fgetc(MODBUS_SERIAL);
0ABE:  RCALL  0336
0AC0:  BRA    0ABA
.................... 	}  
.................... 	
.................... 	clear_interrupt(INT_RDA);
0AC2:  MOVF   FAE,W
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE);
.................... 	output_low(RS485_DE);
0AC4:  BCF    F94.5
0AC6:  BCF    F8B.5
.................... 	enable_interrupts(INT_RDA);
0AC8:  BSF    F9D.5
0ACA:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init()
.................... {
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
0ACC:  BCF    F94.5
0ACE:  BCF    F8B.5
.................... 
....................    RCV_ON();
0AD0:  RCALL  0ABA
.................... 
.................... //   setup_timer_2(T2_DIV_BY_16,249,5);   //10ms interrupts
....................    setup_timer_2(T2_DIV_BY_16,249,10);   //20ms interrupts
0AD2:  MOVLW  48
0AD4:  IORLW  06
0AD6:  MOVWF  FCA
0AD8:  MOVLW  F9
0ADA:  MOVWF  FCB
.................... 
....................    enable_interrupts(GLOBAL);
0ADC:  MOVLW  C0
0ADE:  IORWF  FF2,F
0AE0:  GOTO   3740 (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... void modbus_enable_timeout(int1 enable)
.................... {
....................    disable_interrupts(INT_TIMER2);
*
02F2:  BCF    F9D.1
....................    if (enable) {
02F4:  MOVLB  9
02F6:  MOVF   x9C,F
02F8:  BZ    0300
....................       set_timer2(0);
02FA:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2);
02FC:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2);
02FE:  BSF    F9D.1
....................    }
0300:  MOVLB  0
0302:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... #int_timer2
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
0304:  MOVLB  5
0306:  MOVF   x90,W
0308:  SUBLW  02
030A:  BNZ   0320
030C:  MOVF   x91,F
030E:  BNZ   0320
0310:  MOVF   x92,F
0312:  BNZ   0320
0314:  BTFSC  x8F.0
0316:  BRA    0320
....................    {
....................       modbus_rx.len-=2;
0318:  MOVLW  02
031A:  SUBWF  x94,F
....................       modbus_serial_new=TRUE;
031C:  BSF    x8F.0
....................    }
031E:  BRA    0322
....................    else
....................       modbus_serial_new=FALSE;
0320:  BCF    x8F.0
.................... 
....................    modbus_serial_crc.d=0xFFFF;
0322:  SETF   x92
0324:  SETF   x91
....................    modbus_serial_state=MODBUS_GETADDY;
0326:  CLRF   x90
....................    modbus_enable_timeout(FALSE);
0328:  MOVLB  9
032A:  CLRF   x9C
032C:  MOVLB  0
032E:  RCALL  02F2
0330:  BCF    F9E.1
0332:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................   int8 uIndex ; // will index into CRC lookup table
.................... 
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
034C:  MOVLB  5
034E:  MOVF   x92,W
0350:  MOVLB  9
0352:  XORWF  x9C,W
0354:  MOVWF  x9D
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
0356:  CLRF   03
0358:  MOVF   x9D,W
035A:  MOVLB  0
035C:  RCALL  00D2
035E:  MOVWF  01
0360:  MOVLB  5
0362:  MOVF   x91,W
0364:  XORWF  01,W
0366:  MOVWF  x92
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0368:  CLRF   03
036A:  MOVLB  9
036C:  MOVF   x9D,W
036E:  MOVLB  0
0370:  RCALL  01E2
0372:  MOVFF  FE8,591
0376:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c)
.................... {
....................    fputc(c, MODBUS_SERIAL);
*
177E:  MOVLB  9
1780:  MOVF   x90,W
1782:  MOVLB  0
1784:  BRA    1774
1786:  CLRF   19
1788:  BTFSC  FF2.7
178A:  BSF    19.7
178C:  BCF    FF2.7
....................    modbus_calc_crc(c);
178E:  MOVFF  990,99C
1792:  CALL   034C
1796:  BTFSC  19.7
1798:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
179A:  CLRWDT
179C:  MOVLW  44
179E:  MOVWF  00
17A0:  DECFSZ 00,F
17A2:  BRA    17A0
17A4:  BRA    17A6
17A6:  RETURN 0
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
.................... #int_rda
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
.................... #int_rda2
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT)
.................... #int_ext
.................... #else
.................... #error Please define a correct interrupt source
.................... #endif
.................... void incomming_modbus_serial() {
....................    char c;
.................... 
....................    c=fgetc(MODBUS_SERIAL);
*
0378:  RCALL  0336
037A:  MOVFF  01,99B
.................... 
....................    if (!modbus_serial_new)
037E:  MOVLB  5
0380:  BTFSC  x8F.0
0382:  BRA    03DA
....................    {
....................       if(modbus_serial_state == MODBUS_GETADDY)
0384:  MOVF   x90,F
0386:  BNZ   0398
....................       {
....................          modbus_serial_crc.d = 0xFFFF;
0388:  SETF   x92
038A:  SETF   x91
....................          modbus_rx.address = c;
038C:  MOVFF  99B,593
....................          modbus_serial_state++;
0390:  INCF   x90,F
....................          modbus_rx.len = 0;
0392:  CLRF   x94
....................          modbus_rx.error=0;
0394:  CLRF   x96
....................       }
0396:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETFUNC)
0398:  DECFSZ x90,W
039A:  BRA    03A4
....................       {
....................          modbus_rx.func = c;
039C:  MOVFF  99B,595
....................          modbus_serial_state++;
03A0:  INCF   x90,F
....................       }
03A2:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETDATA)
03A4:  MOVF   x90,W
03A6:  SUBLW  02
03A8:  BNZ   03C6
....................       {
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;}
03AA:  INCFSZ x94,W
03AC:  BRA    03B2
03AE:  MOVLW  FE
03B0:  MOVWF  x94
....................          modbus_rx.data[modbus_rx.len]=c;
03B2:  MOVLW  97
03B4:  ADDWF  x94,W
03B6:  MOVWF  FE9
03B8:  MOVLW  05
03BA:  MOVWF  FEA
03BC:  BTFSC  FD8.0
03BE:  INCF   FEA,F
03C0:  MOVFF  99B,FEF
....................          modbus_rx.len++;
03C4:  INCF   x94,F
....................       }
.................... 
....................       modbus_calc_crc(c);
03C6:  MOVFF  99B,99C
03CA:  MOVLB  0
03CC:  RCALL  034C
....................       modbus_enable_timeout(TRUE);
03CE:  MOVLW  01
03D0:  MOVLB  9
03D2:  MOVWF  x9C
03D4:  MOVLB  0
03D6:  RCALL  02F2
03D8:  MOVLB  5
....................    }
03DA:  BCF    F9E.5
03DC:  MOVLB  0
03DE:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func)
.................... {
....................    modbus_serial_crc.d=0xFFFF;
*
17A8:  MOVLB  5
17AA:  SETF   x92
17AC:  SETF   x91
....................    modbus_serial_new=FALSE;
17AE:  BCF    x8F.0
.................... 
....................    RCV_OFF();
17B0:  BCF    F9D.5
....................    
....................    output_high(MODBUS_SERIAL_ENABLE_PIN);
17B2:  BCF    F94.5
17B4:  BSF    F8B.5
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
17B6:  CLRWDT
17B8:  MOVLW  F2
17BA:  MOVWF  00
17BC:  DECFSZ 00,F
17BE:  BRA    17BC
.................... 
....................    modbus_serial_putc(to);
17C0:  MOVFF  98D,990
17C4:  MOVLB  0
17C6:  RCALL  177E
....................    modbus_serial_putc(func);
17C8:  MOVFF  98E,990
17CC:  RCALL  177E
17CE:  RETURN 0
.................... }
.................... 
.................... void modbus_serial_send_stop()
.................... {
....................    int8 crc_low, crc_high;
.................... 
.................... 
....................    crc_high=modbus_serial_crc.b[1];
17D0:  MOVFF  592,98E
....................    crc_low=modbus_serial_crc.b[0];
17D4:  MOVFF  591,98D
.................... 
....................    modbus_serial_putc(crc_high);
17D8:  MOVFF  98E,990
17DC:  RCALL  177E
....................    modbus_serial_putc(crc_low);
17DE:  MOVFF  98D,990
17E2:  RCALL  177E
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................    WAIT_FOR_HW_BUFFER();
17E4:  BTFSS  FAD.1
17E6:  BRA    17E4
.................... #endif
....................     
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
17E8:  CLRWDT
17EA:  MOVLW  F2
17EC:  MOVWF  00
17EE:  DECFSZ 00,F
17F0:  BRA    17EE
.................... 
.................... 
....................    RCV_ON();
17F2:  CALL   0ABA
.................... 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
17F6:  BCF    F94.5
17F8:  BCF    F8B.5
.................... 
....................    modbus_serial_crc.d=0xFFFF;
17FA:  MOVLB  5
17FC:  SETF   x92
17FE:  SETF   x91
1800:  MOVLB  0
1802:  RETURN 0
.................... 
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
1804:  MOVLB  5
1806:  BTFSC  x8F.0
1808:  BRA    1812
....................       return FALSE;
180A:  MOVLW  00
180C:  MOVWF  01
180E:  BRA    1824
1810:  BRA    181E
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
1812:  BTFSS  x95.7
1814:  BRA    181E
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
1816:  MOVFF  597,596
....................       modbus_rx.len = 1;
181A:  MOVLW  01
181C:  MOVWF  x94
....................    }
....................    modbus_serial_new=FALSE;
181E:  BCF    x8F.0
....................    return TRUE;
1820:  MOVLW  01
1822:  MOVWF  01
1824:  MOVLB  0
1826:  RETURN 0
.................... }
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... /*MODBUS Master Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
*
1C22:  MOVFF  982,98D
1C26:  MOVLW  01
1C28:  MOVLB  9
1C2A:  MOVWF  x8E
1C2C:  MOVLB  0
1C2E:  RCALL  17A8
.................... 
....................    modbus_serial_putc(make8(start_address,1));
1C30:  MOVFF  984,990
1C34:  RCALL  177E
....................    modbus_serial_putc(make8(start_address,0));
1C36:  MOVFF  983,990
1C3A:  RCALL  177E
.................... 
....................    modbus_serial_putc(make8(quantity,1));
1C3C:  MOVFF  986,990
1C40:  RCALL  177E
....................    modbus_serial_putc(make8(quantity,0));
1C42:  MOVFF  985,990
1C46:  RCALL  177E
.................... 
....................    modbus_serial_send_stop();
1C48:  RCALL  17D0
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
1C4A:  MOVLB  9
1C4C:  MOVF   x82,F
1C4E:  BZ    1CA2
1C50:  MOVLB  0
1C52:  RCALL  1804
1C54:  MOVF   01,F
1C56:  BNZ   1C8A
1C58:  MOVLW  FF
1C5A:  MOVLB  5
1C5C:  ADDWF  x8B,F
1C5E:  BTFSS  FD8.0
1C60:  ADDWF  x8C,F
1C62:  BTFSS  FD8.0
1C64:  ADDWF  x8D,F
1C66:  BTFSS  FD8.0
1C68:  ADDWF  x8E,F
1C6A:  MOVF   x8B,F
1C6C:  BNZ   1C80
1C6E:  MOVF   x8C,F
1C70:  BNZ   1C80
1C72:  MOVF   x8D,F
1C74:  BNZ   1C80
1C76:  MOVF   x8E,F
1C78:  BTFSS  FD8.2
1C7A:  BRA    1C80
1C7C:  MOVLB  0
1C7E:  BRA    1C8A
1C80:  CLRWDT
1C82:  NOP   
1C84:  MOVLB  9
1C86:  BRA    1C50
1C88:  MOVLB  0
1C8A:  MOVLB  5
1C8C:  MOVF   x8B,F
1C8E:  BNZ   1CA0
1C90:  MOVF   x8C,F
1C92:  BNZ   1CA0
1C94:  MOVF   x8D,F
1C96:  BNZ   1CA0
1C98:  MOVF   x8E,F
1C9A:  BNZ   1CA0
1C9C:  MOVLW  0C
1C9E:  MOVWF  x96
1CA0:  MOVLB  9
1CA2:  MOVLB  5
1CA4:  CLRF   x8E
1CA6:  MOVLW  01
1CA8:  MOVWF  x8D
1CAA:  MOVLW  86
1CAC:  MOVWF  x8C
1CAE:  MOVLW  A0
1CB0:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
1CB2:  MOVFF  596,01
1CB6:  MOVLB  0
1CB8:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
*
2D70:  MOVFF  982,98D
2D74:  MOVLW  02
2D76:  MOVLB  9
2D78:  MOVWF  x8E
2D7A:  MOVLB  0
2D7C:  CALL   17A8
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2D80:  MOVFF  984,990
2D84:  CALL   177E
....................    modbus_serial_putc(make8(start_address,0));
2D88:  MOVFF  983,990
2D8C:  CALL   177E
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2D90:  MOVFF  986,990
2D94:  CALL   177E
....................    modbus_serial_putc(make8(quantity,0));
2D98:  MOVFF  985,990
2D9C:  CALL   177E
.................... 
....................    modbus_serial_send_stop();
2DA0:  CALL   17D0
....................       
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2DA4:  MOVLB  9
2DA6:  MOVF   x82,F
2DA8:  BZ    2DFE
2DAA:  MOVLB  0
2DAC:  CALL   1804
2DB0:  MOVF   01,F
2DB2:  BNZ   2DE6
2DB4:  MOVLW  FF
2DB6:  MOVLB  5
2DB8:  ADDWF  x8B,F
2DBA:  BTFSS  FD8.0
2DBC:  ADDWF  x8C,F
2DBE:  BTFSS  FD8.0
2DC0:  ADDWF  x8D,F
2DC2:  BTFSS  FD8.0
2DC4:  ADDWF  x8E,F
2DC6:  MOVF   x8B,F
2DC8:  BNZ   2DDC
2DCA:  MOVF   x8C,F
2DCC:  BNZ   2DDC
2DCE:  MOVF   x8D,F
2DD0:  BNZ   2DDC
2DD2:  MOVF   x8E,F
2DD4:  BTFSS  FD8.2
2DD6:  BRA    2DDC
2DD8:  MOVLB  0
2DDA:  BRA    2DE6
2DDC:  CLRWDT
2DDE:  NOP   
2DE0:  MOVLB  9
2DE2:  BRA    2DAA
2DE4:  MOVLB  0
2DE6:  MOVLB  5
2DE8:  MOVF   x8B,F
2DEA:  BNZ   2DFC
2DEC:  MOVF   x8C,F
2DEE:  BNZ   2DFC
2DF0:  MOVF   x8D,F
2DF2:  BNZ   2DFC
2DF4:  MOVF   x8E,F
2DF6:  BNZ   2DFC
2DF8:  MOVLW  0C
2DFA:  MOVWF  x96
2DFC:  MOVLB  9
2DFE:  MOVLB  5
2E00:  CLRF   x8E
2E02:  MOVLW  01
2E04:  MOVWF  x8D
2E06:  MOVLW  86
2E08:  MOVWF  x8C
2E0A:  MOVLW  A0
2E0C:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2E0E:  MOVFF  596,01
2E12:  MOVLB  0
2E14:  GOTO   31AA (RETURN)
.................... }
.................... 
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
*
18C0:  MOVFF  982,98D
18C4:  MOVLW  03
18C6:  MOVLB  9
18C8:  MOVWF  x8E
18CA:  MOVLB  0
18CC:  RCALL  17A8
.................... 
....................    modbus_serial_putc(make8(start_address,1));
18CE:  MOVFF  984,990
18D2:  RCALL  177E
....................    modbus_serial_putc(make8(start_address,0));
18D4:  MOVFF  983,990
18D8:  RCALL  177E
.................... 
....................    modbus_serial_putc(make8(quantity,1));
18DA:  MOVFF  986,990
18DE:  RCALL  177E
....................    modbus_serial_putc(make8(quantity,0));
18E0:  MOVFF  985,990
18E4:  RCALL  177E
.................... 
....................    modbus_serial_send_stop();
18E6:  RCALL  17D0
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
18E8:  MOVLB  9
18EA:  MOVF   x82,F
18EC:  BZ    1940
18EE:  MOVLB  0
18F0:  RCALL  1804
18F2:  MOVF   01,F
18F4:  BNZ   1928
18F6:  MOVLW  FF
18F8:  MOVLB  5
18FA:  ADDWF  x8B,F
18FC:  BTFSS  FD8.0
18FE:  ADDWF  x8C,F
1900:  BTFSS  FD8.0
1902:  ADDWF  x8D,F
1904:  BTFSS  FD8.0
1906:  ADDWF  x8E,F
1908:  MOVF   x8B,F
190A:  BNZ   191E
190C:  MOVF   x8C,F
190E:  BNZ   191E
1910:  MOVF   x8D,F
1912:  BNZ   191E
1914:  MOVF   x8E,F
1916:  BTFSS  FD8.2
1918:  BRA    191E
191A:  MOVLB  0
191C:  BRA    1928
191E:  CLRWDT
1920:  NOP   
1922:  MOVLB  9
1924:  BRA    18EE
1926:  MOVLB  0
1928:  MOVLB  5
192A:  MOVF   x8B,F
192C:  BNZ   193E
192E:  MOVF   x8C,F
1930:  BNZ   193E
1932:  MOVF   x8D,F
1934:  BNZ   193E
1936:  MOVF   x8E,F
1938:  BNZ   193E
193A:  MOVLW  0C
193C:  MOVWF  x96
193E:  MOVLB  9
1940:  MOVLB  5
1942:  CLRF   x8E
1944:  MOVLW  01
1946:  MOVWF  x8D
1948:  MOVLW  86
194A:  MOVWF  x8C
194C:  MOVLW  A0
194E:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
1950:  MOVFF  596,01
1954:  MOVLB  0
1956:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
*
1828:  MOVFF  982,98D
182C:  MOVLW  04
182E:  MOVLB  9
1830:  MOVWF  x8E
1832:  MOVLB  0
1834:  RCALL  17A8
.................... 
....................    modbus_serial_putc(make8(start_address,1));
1836:  MOVFF  984,990
183A:  RCALL  177E
....................    modbus_serial_putc(make8(start_address,0));
183C:  MOVFF  983,990
1840:  RCALL  177E
.................... 
.................... 
....................    modbus_serial_putc(make8(quantity,1));
1842:  MOVFF  986,990
1846:  RCALL  177E
....................    modbus_serial_putc(make8(quantity,0));
1848:  MOVFF  985,990
184C:  RCALL  177E
.................... 
....................    modbus_serial_send_stop();
184E:  RCALL  17D0
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
1850:  MOVLB  9
1852:  MOVF   x82,F
1854:  BZ    18A8
1856:  MOVLB  0
1858:  RCALL  1804
185A:  MOVF   01,F
185C:  BNZ   1890
185E:  MOVLW  FF
1860:  MOVLB  5
1862:  ADDWF  x8B,F
1864:  BTFSS  FD8.0
1866:  ADDWF  x8C,F
1868:  BTFSS  FD8.0
186A:  ADDWF  x8D,F
186C:  BTFSS  FD8.0
186E:  ADDWF  x8E,F
1870:  MOVF   x8B,F
1872:  BNZ   1886
1874:  MOVF   x8C,F
1876:  BNZ   1886
1878:  MOVF   x8D,F
187A:  BNZ   1886
187C:  MOVF   x8E,F
187E:  BTFSS  FD8.2
1880:  BRA    1886
1882:  MOVLB  0
1884:  BRA    1890
1886:  CLRWDT
1888:  NOP   
188A:  MOVLB  9
188C:  BRA    1856
188E:  MOVLB  0
1890:  MOVLB  5
1892:  MOVF   x8B,F
1894:  BNZ   18A6
1896:  MOVF   x8C,F
1898:  BNZ   18A6
189A:  MOVF   x8D,F
189C:  BNZ   18A6
189E:  MOVF   x8E,F
18A0:  BNZ   18A6
18A2:  MOVLW  0C
18A4:  MOVWF  x96
18A6:  MOVLB  9
18A8:  MOVLB  5
18AA:  CLRF   x8E
18AC:  MOVLW  01
18AE:  MOVWF  x8D
18B0:  MOVLW  86
18B2:  MOVWF  x8C
18B4:  MOVLW  A0
18B6:  MOVWF  x8B
.................... 
.................... 
.................... 
....................    return modbus_rx.error;
18B8:  MOVFF  596,01
18BC:  MOVLB  0
18BE:  RETURN 0
.................... }
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
*
2E18:  MOVFF  983,98D
2E1C:  MOVLW  05
2E1E:  MOVLB  9
2E20:  MOVWF  x8E
2E22:  MOVLB  0
2E24:  CALL   17A8
.................... 
....................    modbus_serial_putc(make8(output_address,1));
2E28:  MOVFF  985,990
2E2C:  CALL   177E
....................    modbus_serial_putc(make8(output_address,0));
2E30:  MOVFF  984,990
2E34:  CALL   177E
.................... 
....................    if(on)
2E38:  MOVLB  9
2E3A:  MOVF   x86,F
2E3C:  BZ    2E4A
....................        modbus_serial_putc(0xFF);
2E3E:  SETF   x90
2E40:  MOVLB  0
2E42:  CALL   177E
2E46:  BRA    2E52
2E48:  MOVLB  9
....................    else
....................        modbus_serial_putc(0x00);
2E4A:  CLRF   x90
2E4C:  MOVLB  0
2E4E:  CALL   177E
....................    
....................    modbus_serial_putc(0x00);
2E52:  MOVLB  9
2E54:  CLRF   x90
2E56:  MOVLB  0
2E58:  CALL   177E
.................... 
....................    modbus_serial_send_stop();
2E5C:  CALL   17D0
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2E60:  MOVLB  9
2E62:  MOVF   x83,F
2E64:  BZ    2EBA
2E66:  MOVLB  0
2E68:  CALL   1804
2E6C:  MOVF   01,F
2E6E:  BNZ   2EA2
2E70:  MOVLW  FF
2E72:  MOVLB  5
2E74:  ADDWF  x8B,F
2E76:  BTFSS  FD8.0
2E78:  ADDWF  x8C,F
2E7A:  BTFSS  FD8.0
2E7C:  ADDWF  x8D,F
2E7E:  BTFSS  FD8.0
2E80:  ADDWF  x8E,F
2E82:  MOVF   x8B,F
2E84:  BNZ   2E98
2E86:  MOVF   x8C,F
2E88:  BNZ   2E98
2E8A:  MOVF   x8D,F
2E8C:  BNZ   2E98
2E8E:  MOVF   x8E,F
2E90:  BTFSS  FD8.2
2E92:  BRA    2E98
2E94:  MOVLB  0
2E96:  BRA    2EA2
2E98:  CLRWDT
2E9A:  NOP   
2E9C:  MOVLB  9
2E9E:  BRA    2E66
2EA0:  MOVLB  0
2EA2:  MOVLB  5
2EA4:  MOVF   x8B,F
2EA6:  BNZ   2EB8
2EA8:  MOVF   x8C,F
2EAA:  BNZ   2EB8
2EAC:  MOVF   x8D,F
2EAE:  BNZ   2EB8
2EB0:  MOVF   x8E,F
2EB2:  BNZ   2EB8
2EB4:  MOVLW  0C
2EB6:  MOVWF  x96
2EB8:  MOVLB  9
2EBA:  MOVLB  5
2EBC:  CLRF   x8E
2EBE:  MOVLW  01
2EC0:  MOVWF  x8D
2EC2:  MOVLW  86
2EC4:  MOVWF  x8C
2EC6:  MOVLW  A0
2EC8:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2ECA:  MOVFF  596,01
2ECE:  MOVLB  0
2ED0:  GOTO   322C (RETURN)
.................... }
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
2ED4:  MOVFF  986,98D
2ED8:  MOVLW  06
2EDA:  MOVLB  9
2EDC:  MOVWF  x8E
2EDE:  MOVLB  0
2EE0:  CALL   17A8
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
2EE4:  MOVFF  988,990
2EE8:  CALL   177E
....................    modbus_serial_putc(make8(reg_address,0));
2EEC:  MOVFF  987,990
2EF0:  CALL   177E
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
2EF4:  MOVFF  98A,990
2EF8:  CALL   177E
....................    modbus_serial_putc(make8(reg_value,0));
2EFC:  MOVFF  989,990
2F00:  CALL   177E
.................... 
....................    modbus_serial_send_stop();
2F04:  CALL   17D0
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2F08:  MOVLB  9
2F0A:  MOVF   x86,F
2F0C:  BZ    2F62
2F0E:  MOVLB  0
2F10:  CALL   1804
2F14:  MOVF   01,F
2F16:  BNZ   2F4A
2F18:  MOVLW  FF
2F1A:  MOVLB  5
2F1C:  ADDWF  x8B,F
2F1E:  BTFSS  FD8.0
2F20:  ADDWF  x8C,F
2F22:  BTFSS  FD8.0
2F24:  ADDWF  x8D,F
2F26:  BTFSS  FD8.0
2F28:  ADDWF  x8E,F
2F2A:  MOVF   x8B,F
2F2C:  BNZ   2F40
2F2E:  MOVF   x8C,F
2F30:  BNZ   2F40
2F32:  MOVF   x8D,F
2F34:  BNZ   2F40
2F36:  MOVF   x8E,F
2F38:  BTFSS  FD8.2
2F3A:  BRA    2F40
2F3C:  MOVLB  0
2F3E:  BRA    2F4A
2F40:  CLRWDT
2F42:  NOP   
2F44:  MOVLB  9
2F46:  BRA    2F0E
2F48:  MOVLB  0
2F4A:  MOVLB  5
2F4C:  MOVF   x8B,F
2F4E:  BNZ   2F60
2F50:  MOVF   x8C,F
2F52:  BNZ   2F60
2F54:  MOVF   x8D,F
2F56:  BNZ   2F60
2F58:  MOVF   x8E,F
2F5A:  BNZ   2F60
2F5C:  MOVLW  0C
2F5E:  MOVWF  x96
2F60:  MOVLB  9
2F62:  MOVLB  5
2F64:  CLRF   x8E
2F66:  MOVLW  01
2F68:  MOVWF  x8D
2F6A:  MOVLW  86
2F6C:  MOVWF  x8C
2F6E:  MOVLW  A0
2F70:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2F72:  MOVFF  596,01
2F76:  MOVLB  0
2F78:  GOTO   3282 (RETURN)
.................... }
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity,
....................                            int8 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = (int8)((quantity/8));
....................    
....................    if(quantity%8)
....................       count++;      
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
....................    
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < quantity; ++i)
....................    {
....................       modbus_serial_putc(make8(values[i],1));
....................       modbus_serial_putc(make8(values[i],0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... exception modbus_write_multiple_registers_flip(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
2F7C:  BCF    FD8.0
2F7E:  MOVLB  9
2F80:  RLCF   x87,W
2F82:  MOVWF  02
2F84:  RLCF   x88,W
2F86:  MOVFF  02,98C
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
2F8A:  MOVFF  984,98D
2F8E:  MOVLW  10
2F90:  MOVWF  x8E
2F92:  MOVLB  0
2F94:  CALL   17A8
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2F98:  MOVFF  986,990
2F9C:  CALL   177E
....................    modbus_serial_putc(make8(start_address,0));
2FA0:  MOVFF  985,990
2FA4:  CALL   177E
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2FA8:  MOVFF  988,990
2FAC:  CALL   177E
....................    modbus_serial_putc(make8(quantity,0));
2FB0:  MOVFF  987,990
2FB4:  CALL   177E
....................    
....................    modbus_serial_putc(count);
2FB8:  MOVFF  98C,990
2FBC:  CALL   177E
.................... 
....................    for(i=0; i < quantity; ++i)
2FC0:  MOVLB  9
2FC2:  CLRF   x8B
2FC4:  MOVF   x88,F
2FC6:  BNZ   2FCE
2FC8:  MOVF   x87,W
2FCA:  SUBWF  x8B,W
2FCC:  BC    3026
....................    {
....................       modbus_serial_putc(make8(values[i],0));
2FCE:  CLRF   03
2FD0:  MOVFF  98B,02
2FD4:  BCF    FD8.0
2FD6:  RLCF   02,F
2FD8:  RLCF   03,F
2FDA:  MOVF   02,W
2FDC:  ADDWF  x89,W
2FDE:  MOVWF  FE9
2FE0:  MOVF   x8A,W
2FE2:  ADDWFC 03,W
2FE4:  MOVWF  FEA
2FE6:  MOVFF  FEC,98E
2FEA:  MOVF   FED,F
2FEC:  MOVFF  FEF,990
2FF0:  MOVLB  0
2FF2:  CALL   177E
....................       modbus_serial_putc(make8(values[i],1));
2FF6:  CLRF   03
2FF8:  MOVLB  9
2FFA:  MOVFF  98B,02
2FFE:  BCF    FD8.0
3000:  RLCF   02,F
3002:  RLCF   03,F
3004:  MOVF   02,W
3006:  ADDWF  x89,W
3008:  MOVWF  FE9
300A:  MOVF   x8A,W
300C:  ADDWFC 03,W
300E:  MOVWF  FEA
3010:  MOVFF  FEC,990
3014:  MOVF   FED,F
3016:  MOVFF  FEF,98D
301A:  MOVLB  0
301C:  CALL   177E
3020:  MOVLB  9
3022:  INCF   x8B,F
3024:  BRA    2FC4
....................    }
.................... 
....................    modbus_serial_send_stop();
3026:  MOVLB  0
3028:  CALL   17D0
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
302C:  MOVLB  9
302E:  MOVF   x84,F
3030:  BZ    3086
3032:  MOVLB  0
3034:  CALL   1804
3038:  MOVF   01,F
303A:  BNZ   306E
303C:  MOVLW  FF
303E:  MOVLB  5
3040:  ADDWF  x8B,F
3042:  BTFSS  FD8.0
3044:  ADDWF  x8C,F
3046:  BTFSS  FD8.0
3048:  ADDWF  x8D,F
304A:  BTFSS  FD8.0
304C:  ADDWF  x8E,F
304E:  MOVF   x8B,F
3050:  BNZ   3064
3052:  MOVF   x8C,F
3054:  BNZ   3064
3056:  MOVF   x8D,F
3058:  BNZ   3064
305A:  MOVF   x8E,F
305C:  BTFSS  FD8.2
305E:  BRA    3064
3060:  MOVLB  0
3062:  BRA    306E
3064:  CLRWDT
3066:  NOP   
3068:  MOVLB  9
306A:  BRA    3032
306C:  MOVLB  0
306E:  MOVLB  5
3070:  MOVF   x8B,F
3072:  BNZ   3084
3074:  MOVF   x8C,F
3076:  BNZ   3084
3078:  MOVF   x8D,F
307A:  BNZ   3084
307C:  MOVF   x8E,F
307E:  BNZ   3084
3080:  MOVLW  0C
3082:  MOVWF  x96
3084:  MOVLB  9
3086:  MOVLB  5
3088:  CLRF   x8E
308A:  MOVLW  01
308C:  MOVWF  x8D
308E:  MOVLW  86
3090:  MOVWF  x8C
3092:  MOVLW  A0
3094:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
3096:  MOVFF  596,01
309A:  MOVLB  0
309C:  GOTO   32C0 (RETURN)
.................... }
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(int8 address, int8 byte_count, 
....................                             modbus_read_sub_request *request)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < (byte_count/7); i+=7)
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(int8 address, int8 byte_count, 
....................                             modbus_write_sub_request *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start,
....................                                     int16 read_quantity, int16 write_start,
....................                                     int16 write_quantity,
....................                                     int16 *write_registers_value)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(read_start,1));
....................    modbus_serial_putc(make8(read_start,0));
.................... 
....................    modbus_serial_putc(make8(read_quantity,1));
....................    modbus_serial_putc(make8(read_quantity,0));
.................... 
....................    modbus_serial_putc(make8(write_start, 1));
....................    modbus_serial_putc(make8(write_start, 0));
.................... 
....................    modbus_serial_putc(make8(write_quantity, 1));
....................    modbus_serial_putc(make8(write_quantity, 0));
.................... 
....................    modbus_serial_putc((int8)(2*write_quantity));
.................... 
....................    for(i=0; i < write_quantity ; i+=2)
....................    {
....................       modbus_serial_putc(make8(write_registers_value[i], 1));
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(FIFO_address, 1));
....................    modbus_serial_putc(make8(FIFO_address, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... #else
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*reg_data);
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... #endif
.................... 
.................... #include "iridium_sbd_rdTap.c"
.................... #define SBD_DEBUG 1
.................... 
.................... typedef struct {
.................... 	/* +SBDIX data from most recent */
.................... 	/* result from modem */
.................... 	int8  sbdix_response[42];
.................... 	/* parsed into */
.................... 	int8  sbdix_mo_status;
.................... 	int16 sbdix_mo_msn;
.................... 	int8  sbdix_mt_status;
.................... 	int16 sbdix_mt_msn;
.................... 	int16 sbdix_mt_length;
.................... 	int8  sbdix_mt_queued;
.................... 
.................... 
.................... 	/* "Mobile Originated" message from us to network */
.................... 	int8  mo_state;
.................... 	int8  mo_buff[272];
.................... 	int16 mo_length;
.................... 	int8  mo_try;
.................... 	int8  mo_sbdix_wait;
.................... 
.................... 	/* "Mobile Terminated" messages from network to us */
.................... 	int8  mt_ready;
.................... 	int8  mt_state;
.................... 	int8  mt_buff[256];
.................... 	int16 mt_length;
.................... 	int16 mt_checksum;
.................... 	
.................... 	/* ring alert */
.................... 	int8  ring_flag;
.................... 	int8  ring_state;
.................... 
.................... 	/* modem talking to us for status, AT commands, etc */
.................... 	int8 mr_ready;          /* 1=> message ready for consumption */
.................... 	int8 mr_buff[64];
.................... 	int8 mr_length;
.................... 	int8 mr_disable;
.................... } struct_iridium_sbd;
.................... 
.................... struct_iridium_sbd sbd={0};
.................... 
.................... int8 a_to_uint8(int8 *s) {
*
0B2A:  MOVLB  9
0B2C:  CLRF   x7E
....................    int8 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
0B2E:  MOVFF  97D,FEA
0B32:  MOVFF  97C,FE9
0B36:  MOVF   FEF,W
0B38:  SUBLW  20
0B3A:  BNZ   0B44
....................       s++;
0B3C:  INCF   x7C,F
0B3E:  BTFSC  FD8.2
0B40:  INCF   x7D,F
0B42:  BRA    0B2E
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
0B44:  MOVFF  97D,FEA
0B48:  MOVFF  97C,FE9
0B4C:  MOVFF  FEF,97F
0B50:  MOVF   x7F,W
0B52:  SUBLW  2F
0B54:  BC    0B7A
0B56:  MOVF   x7F,W
0B58:  SUBLW  39
0B5A:  BNC   0B7A
....................       value *= 10;
0B5C:  MOVF   x7E,W
0B5E:  MULLW  0A
0B60:  MOVFF  FF3,97E
....................       value += (*s-'0');
0B64:  MOVFF  97D,FEA
0B68:  MOVFF  97C,FE9
0B6C:  MOVLW  30
0B6E:  SUBWF  FEF,W
0B70:  ADDWF  x7E,F
....................       s++;
0B72:  INCF   x7C,F
0B74:  BTFSC  FD8.2
0B76:  INCF   x7D,F
0B78:  BRA    0B44
....................    }
.................... 
....................    return value;
0B7A:  MOVFF  97E,01
0B7E:  MOVLB  0
0B80:  RETURN 0
.................... }
.................... 
.................... int16 a_to_uint16(int8 *s) {
*
0BC2:  MOVLB  9
0BC4:  CLRF   x7F
0BC6:  CLRF   x7E
....................    int16 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
0BC8:  MOVFF  97D,FEA
0BCC:  MOVFF  97C,FE9
0BD0:  MOVF   FEF,W
0BD2:  SUBLW  20
0BD4:  BNZ   0BDE
....................       s++;
0BD6:  INCF   x7C,F
0BD8:  BTFSC  FD8.2
0BDA:  INCF   x7D,F
0BDC:  BRA    0BC8
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
0BDE:  MOVFF  97D,FEA
0BE2:  MOVFF  97C,FE9
0BE6:  MOVFF  FEF,980
0BEA:  MOVF   x80,W
0BEC:  SUBLW  2F
0BEE:  BC    0C2C
0BF0:  MOVF   x80,W
0BF2:  SUBLW  39
0BF4:  BNC   0C2C
....................       value *= 10;
0BF6:  MOVFF  97F,995
0BFA:  MOVFF  97E,994
0BFE:  CLRF   x97
0C00:  MOVLW  0A
0C02:  MOVWF  x96
0C04:  MOVLB  0
0C06:  RCALL  084C
0C08:  MOVFF  02,97F
0C0C:  MOVFF  01,97E
....................       value += (*s-'0');
0C10:  MOVFF  97D,FEA
0C14:  MOVLB  9
0C16:  MOVFF  97C,FE9
0C1A:  MOVLW  30
0C1C:  SUBWF  FEF,W
0C1E:  ADDWF  x7E,F
0C20:  MOVLW  00
0C22:  ADDWFC x7F,F
....................       s++;
0C24:  INCF   x7C,F
0C26:  BTFSC  FD8.2
0C28:  INCF   x7D,F
0C2A:  BRA    0BDE
....................    }
.................... 
....................    return value;
0C2C:  MOVFF  97E,01
0C30:  MOVFF  97F,02
0C34:  MOVLB  0
0C36:  RETURN 0
.................... }
.................... 
.................... void iridium_sbdix_parse(void) {
.................... 	int8 *p;
.................... 
.................... 	/*
.................... 	 * Quick check of potential validity of response:
.................... 	 * a) valid response would need to be at least 24 characters
.................... 	 * +SBDIX: 0, 25, 0, 0, 0, 0	
.................... 	 * 012345678901234567890123456789
.................... 	 *           1         2
.................... 	 * b) mo_status always starts at character 8
.................... 	 * */
.................... 	if ( strlen(sbd.sbdix_response) < 24 || ! isdigit(sbd.sbdix_response[8] ) ) {
0C38:  MOVLW  06
0C3A:  MOVLB  9
0C3C:  MOVWF  x7D
0C3E:  MOVLW  96
0C40:  MOVWF  x7C
0C42:  MOVLB  0
0C44:  BRA    0AF0
0C46:  MOVFF  02,97D
0C4A:  MOVFF  01,97C
0C4E:  MOVLB  9
0C50:  MOVF   x7D,F
0C52:  BNZ   0C5A
0C54:  MOVF   x7C,W
0C56:  SUBLW  17
0C58:  BC    0C70
0C5A:  MOVLB  6
0C5C:  MOVF   x9E,W
0C5E:  SUBLW  2F
0C60:  BTFSS  FD8.0
0C62:  BRA    0C68
0C64:  MOVLB  9
0C66:  BRA    0C70
0C68:  MOVF   x9E,W
0C6A:  SUBLW  39
0C6C:  BC    0C74
0C6E:  MOVLB  9
.................... 		/* if not a digit or too short, then we give up */
.................... 		return;
0C70:  BRA    0DE8
0C72:  MOVLB  6
.................... 	}
.................... 	sbd.sbdix_mo_status=a_to_uint8(sbd.sbdix_response+8);
0C74:  MOVLW  06
0C76:  MOVLB  9
0C78:  MOVWF  x7D
0C7A:  MOVLW  9E
0C7C:  MOVWF  x7C
0C7E:  MOVLB  0
0C80:  RCALL  0B2A
0C82:  MOVFF  01,6C0
.................... 
.................... 	/* mo_msn (with preceeding space) starts after comma */
.................... 	p = strchr(sbd.sbdix_response+9,',');
0C86:  MOVLW  06
0C88:  MOVLB  9
0C8A:  MOVWF  x7F
0C8C:  MOVLW  9F
0C8E:  MOVWF  x7E
0C90:  MOVLW  2C
0C92:  MOVWF  x80
0C94:  MOVLB  0
0C96:  RCALL  0B82
0C98:  MOVFF  02,97B
0C9C:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0CA0:  MOVLB  9
0CA2:  MOVF   x7A,F
0CA4:  BNZ   0CAC
0CA6:  MOVF   x7B,F
0CA8:  BNZ   0CAC
.................... 		/* not found */
.................... 		return;
0CAA:  BRA    0DE8
.................... 	}
.................... 	p++; /* swallow the ',' */
0CAC:  INCF   x7A,F
0CAE:  BTFSC  FD8.2
0CB0:  INCF   x7B,F
.................... 	sbd.sbdix_mo_msn=a_to_uint16(p);
0CB2:  MOVFF  97B,97D
0CB6:  MOVFF  97A,97C
0CBA:  MOVLB  0
0CBC:  RCALL  0BC2
0CBE:  MOVFF  02,6C2
0CC2:  MOVFF  01,6C1
.................... 
.................... 	/* mt_status (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0CC6:  MOVLW  01
0CC8:  MOVLB  9
0CCA:  ADDWF  x7A,W
0CCC:  MOVWF  x7C
0CCE:  MOVLW  00
0CD0:  ADDWFC x7B,W
0CD2:  MOVWF  x7D
0CD4:  MOVWF  x7F
0CD6:  MOVFF  97C,97E
0CDA:  MOVLW  2C
0CDC:  MOVWF  x80
0CDE:  MOVLB  0
0CE0:  RCALL  0B82
0CE2:  MOVFF  02,97B
0CE6:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0CEA:  MOVLB  9
0CEC:  MOVF   x7A,F
0CEE:  BNZ   0CF6
0CF0:  MOVF   x7B,F
0CF2:  BNZ   0CF6
.................... 		/* not found */
.................... 		return;
0CF4:  BRA    0DE8
.................... 	}
.................... 	p++; /* swallow the ',' */
0CF6:  INCF   x7A,F
0CF8:  BTFSC  FD8.2
0CFA:  INCF   x7B,F
.................... 	sbd.sbdix_mt_status=a_to_uint8(p);
0CFC:  MOVFF  97B,97D
0D00:  MOVFF  97A,97C
0D04:  MOVLB  0
0D06:  RCALL  0B2A
0D08:  MOVFF  01,6C3
.................... 
.................... 	/* mt_msn (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0D0C:  MOVLW  01
0D0E:  MOVLB  9
0D10:  ADDWF  x7A,W
0D12:  MOVWF  x7C
0D14:  MOVLW  00
0D16:  ADDWFC x7B,W
0D18:  MOVWF  x7D
0D1A:  MOVWF  x7F
0D1C:  MOVFF  97C,97E
0D20:  MOVLW  2C
0D22:  MOVWF  x80
0D24:  MOVLB  0
0D26:  RCALL  0B82
0D28:  MOVFF  02,97B
0D2C:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0D30:  MOVLB  9
0D32:  MOVF   x7A,F
0D34:  BNZ   0D3C
0D36:  MOVF   x7B,F
0D38:  BNZ   0D3C
.................... 		/* not found */
.................... 		return;
0D3A:  BRA    0DE8
.................... 	}
.................... 	p++; /* swallow the ',' */
0D3C:  INCF   x7A,F
0D3E:  BTFSC  FD8.2
0D40:  INCF   x7B,F
.................... 	sbd.sbdix_mt_msn=a_to_uint16(p);
0D42:  MOVFF  97B,97D
0D46:  MOVFF  97A,97C
0D4A:  MOVLB  0
0D4C:  RCALL  0BC2
0D4E:  MOVFF  02,6C5
0D52:  MOVFF  01,6C4
.................... 
.................... 	/* mt_length (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0D56:  MOVLW  01
0D58:  MOVLB  9
0D5A:  ADDWF  x7A,W
0D5C:  MOVWF  x7C
0D5E:  MOVLW  00
0D60:  ADDWFC x7B,W
0D62:  MOVWF  x7D
0D64:  MOVWF  x7F
0D66:  MOVFF  97C,97E
0D6A:  MOVLW  2C
0D6C:  MOVWF  x80
0D6E:  MOVLB  0
0D70:  RCALL  0B82
0D72:  MOVFF  02,97B
0D76:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0D7A:  MOVLB  9
0D7C:  MOVF   x7A,F
0D7E:  BNZ   0D86
0D80:  MOVF   x7B,F
0D82:  BNZ   0D86
.................... 		/* not found */
.................... 		return;
0D84:  BRA    0DE8
.................... 	}
.................... 	p++; /* swallow the ',' */
0D86:  INCF   x7A,F
0D88:  BTFSC  FD8.2
0D8A:  INCF   x7B,F
.................... 	sbd.sbdix_mt_length=a_to_uint16(p);
0D8C:  MOVFF  97B,97D
0D90:  MOVFF  97A,97C
0D94:  MOVLB  0
0D96:  RCALL  0BC2
0D98:  MOVFF  02,6C7
0D9C:  MOVFF  01,6C6
.................... 
.................... 	/* mt_queued (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0DA0:  MOVLW  01
0DA2:  MOVLB  9
0DA4:  ADDWF  x7A,W
0DA6:  MOVWF  x7C
0DA8:  MOVLW  00
0DAA:  ADDWFC x7B,W
0DAC:  MOVWF  x7D
0DAE:  MOVWF  x7F
0DB0:  MOVFF  97C,97E
0DB4:  MOVLW  2C
0DB6:  MOVWF  x80
0DB8:  MOVLB  0
0DBA:  RCALL  0B82
0DBC:  MOVFF  02,97B
0DC0:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0DC4:  MOVLB  9
0DC6:  MOVF   x7A,F
0DC8:  BNZ   0DD0
0DCA:  MOVF   x7B,F
0DCC:  BNZ   0DD0
.................... 		/* not found */
.................... 		return;
0DCE:  BRA    0DE8
.................... 	}
.................... 	p++; /* swallow the ',' */
0DD0:  INCF   x7A,F
0DD2:  BTFSC  FD8.2
0DD4:  INCF   x7B,F
.................... 	sbd.sbdix_mt_queued=a_to_uint8(p);
0DD6:  MOVFF  97B,97D
0DDA:  MOVFF  97A,97C
0DDE:  MOVLB  0
0DE0:  RCALL  0B2A
0DE2:  MOVFF  01,6C8
0DE6:  MOVLB  9
.................... 
.................... #if DEBUG_SBD
0DE8:  MOVLB  0
0DEA:  GOTO   376E (RETURN)
.................... 	fprintf(STREAM_WORLD,"# iridium_sbdix_parse():\r\n");
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_status   = %d\n",sbd.sbdix_mo_status);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_msn      = %lu\n",sbd.sbdix_mo_msn);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_status   = %d\n",sbd.sbdix_mt_status);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_msn      = %lu\n",sbd.sbdix_mt_msn);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_length   = %lu\n",sbd.sbdix_mt_length);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_queued   = %d\n",sbd.sbdix_mt_queued);
.................... #endif
.................... 
.................... }
.................... 
.................... #if 0
.................... void _iridium_on(void) {
.................... 	/* turn power switch on */
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_high(CTRL_0); break;
.................... 		case 2: output_high(CTRL_1); break;
.................... 		case 3: output_high(CTRL_2); break;
.................... 		case 4: output_high(CTRL_3); break;
.................... 		case 5: output_high(CTRL_4); break;
.................... 	}
.................... 	
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000000);
.................... 
.................... }
.................... 
.................... void _iridium_off(void) {
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_low(CTRL_0); break;
.................... 		case 2: output_low(CTRL_1); break;
.................... 		case 3: output_low(CTRL_2); break;
.................... 		case 4: output_low(CTRL_3); break;
.................... 		case 5: output_low(CTRL_4); break;
.................... 	}
.................... 
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000010);
.................... }
.................... #endif
.................... 
.................... void iridium_mr_clear(void) {
.................... 	sbd.mr_ready=0;
*
0AE4:  MOVLB  8
0AE6:  CLRF   xE6
.................... 	sbd.mr_length=0;
0AE8:  MOVLB  9
0AEA:  CLRF   x27
0AEC:  MOVLB  0
0AEE:  RETURN 0
.................... }
.................... 
.................... void iridium_mo_clear(void) {
.................... 	sbd.mo_length=0;
*
137E:  MOVLB  7
1380:  CLRF   xDB
1382:  CLRF   xDA
.................... 	sbd.mo_state=0;
1384:  MOVLB  6
1386:  CLRF   xC9
1388:  MOVLB  0
138A:  RETURN 0
.................... }
.................... 
.................... void iridium_mt_clear(void) {
.................... 	sbd.mt_length=0;
.................... 	sbd.mt_state=0;
.................... }
.................... 
.................... /* if we have characters to be received, this function reads them */
.................... void iridium_getc(void) {
.................... 	int8 c;
.................... 
.................... 
.................... 	/* read character from UART */
.................... 	c = uart_getc();
*
0E92:  MOVFF  01,97A
.................... 
.................... 
.................... 	if ( '\r' == c ) {
0E96:  MOVLB  9
0E98:  MOVF   x7A,W
0E9A:  SUBLW  0D
0E9C:  BNZ   0EA0
.................... 		/* except when receiving binary data, we don't care about '\r' */
.................... 		return;
0E9E:  BRA    0F34
.................... 	}
.................... 
.................... 	/* modem always appears to send '\r' '\n' */
.................... 	
.................... 
.................... 	if ( 0 == sbd.mr_ready ) {
0EA0:  MOVLB  8
0EA2:  MOVF   xE6,F
0EA4:  BNZ   0F36
.................... 		/* receiving data */
.................... 
.................... 		if ( '\n' == c && 0==sbd.mr_length ) {
0EA6:  MOVLB  9
0EA8:  MOVF   x7A,W
0EAA:  SUBLW  0A
0EAC:  BNZ   0EB4
0EAE:  MOVF   x27,F
0EB0:  BNZ   0EB4
.................... 			/* responses usually appear to be \r\nOK\r\n ... this skips the empty message */
.................... 			return;
0EB2:  BRA    0F34
.................... 		}
.................... 
.................... 		
.................... 		/* check for 'SBDRING' message and deal with it accordingly */
.................... 		if ( 'S'==sbd.mr_buff[0] && 'B'==sbd.mr_buff[1] && 'D'==sbd.mr_buff[2] 
.................... 			&& 'R'==sbd.mr_buff[3] && 'I'==sbd.mr_buff[4] && 'N'==sbd.mr_buff[5] && 'G'==c ) {
0EB4:  MOVLB  8
0EB6:  MOVF   xE7,W
0EB8:  SUBLW  53
0EBA:  BNZ   0EF8
0EBC:  MOVF   xE8,W
0EBE:  SUBLW  42
0EC0:  BNZ   0EF8
0EC2:  MOVF   xE9,W
0EC4:  SUBLW  44
0EC6:  BNZ   0EF8
0EC8:  MOVF   xEA,W
0ECA:  SUBLW  52
0ECC:  BNZ   0EF8
0ECE:  MOVF   xEB,W
0ED0:  SUBLW  49
0ED2:  BNZ   0EF8
0ED4:  MOVF   xEC,W
0ED6:  SUBLW  4E
0ED8:  BNZ   0EF8
0EDA:  MOVLB  9
0EDC:  MOVF   x7A,W
0EDE:  SUBLW  47
0EE0:  BTFSC  FD8.2
0EE2:  BRA    0EE8
0EE4:  MOVLB  8
0EE6:  BRA    0EF8
.................... 			sbd.ring_flag=1;
0EE8:  MOVLW  01
0EEA:  MOVLB  8
0EEC:  MOVWF  xE4
.................... 			iridium_mr_clear();
0EEE:  MOVLB  0
0EF0:  RCALL  0AE4
.................... 			return;
0EF2:  MOVLB  9
0EF4:  BRA    0F34
0EF6:  MOVLB  8
.................... 		 }
.................... 
.................... 		if ( '\n' == c ) {
0EF8:  MOVLB  9
0EFA:  MOVF   x7A,W
0EFC:  SUBLW  0A
0EFE:  BNZ   0F1A
.................... 			/* replace '\n' with '\0' */
.................... 			sbd.mr_buff[sbd.mr_length]='\0';
0F00:  MOVLW  E7
0F02:  ADDWF  x27,W
0F04:  MOVWF  FE9
0F06:  MOVLW  08
0F08:  MOVWF  FEA
0F0A:  BTFSC  FD8.0
0F0C:  INCF   FEA,F
0F0E:  CLRF   FEF
.................... 			
.................... 			/* mark that we have a message ready */
.................... 			sbd.mr_ready=1;
0F10:  MOVLW  01
0F12:  MOVLB  8
0F14:  MOVWF  xE6
.................... 
.................... 			/* done */
.................... 			return;
0F16:  MOVLB  9
0F18:  BRA    0F34
.................... 		}
.................... 
.................... 
.................... 		/* put in response buffer if not full */
.................... 		if ( sbd.mr_length < ( sizeof(sbd.mr_buff) - 1 ) ) {
0F1A:  MOVF   x27,W
0F1C:  SUBLW  3E
0F1E:  BNC   0F34
.................... 			sbd.mr_buff[sbd.mr_length]=c;
0F20:  MOVLW  E7
0F22:  ADDWF  x27,W
0F24:  MOVWF  FE9
0F26:  MOVLW  08
0F28:  MOVWF  FEA
0F2A:  BTFSC  FD8.0
0F2C:  INCF   FEA,F
0F2E:  MOVFF  97A,FEF
.................... 			sbd.mr_length++;
0F32:  INCF   x27,F
.................... 		} else {
0F34:  MOVLB  8
.................... 			/* buffer is full ... do nothing and wait for message to be terminated */
.................... 		}
.................... 	}
0F36:  MOVLB  0
0F38:  GOTO   37A6 (RETURN)
.................... }
.................... 
.................... void iridium_ringing(void) {
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_ringing() sbd.ring_state=%u\r\n",sbd.ring_state);
.................... #endif
.................... 
.................... 	if ( 0 == sbd.ring_state ) {
.................... 		/* nothing to do */
.................... 		return;
.................... 	}else if ( 1 == sbd.ring_state ) {
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"ATE0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.ring_state ) {
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT&K0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}	
.................... 	} else if ( 5 == sbd.ring_state ) {
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}
.................... 	} else if ( 7 == sbd.ring_state ) {
.................... 		/* send 'AT+CRIS' to determine why we rang */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+CRIS\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.ring_state ) {
.................... 		/* parse CRIS response. But in reality, with an SBD only device it can only be SBD message that causes us to ring */
.................... 	} 
.................... 
.................... }
.................... 
.................... void iridium_mo_send(void) {
.................... 	int16 l;
.................... 	int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... //	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u sbd.mo_sbdix_wait=%u\r\n",sbd.mo_state,sbd.mo_try,sbd.mo_sbdix_wait);
.................... #endif
.................... 
.................... 
.................... 	if ( 0 == sbd.mo_state ) {
*
138C:  MOVLB  6
138E:  MOVF   xC9,F
1390:  BNZ   1396
.................... 		/* nothing to do */
.................... 		return;
1392:  BRA    176E
.................... 
.................... 	} else if ( 1 == sbd.mo_state ) {
1394:  BRA    1768
1396:  DECFSZ xC9,W
1398:  BRA    13B0
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
139A:  MOVLB  0
139C:  CALL   0AE4
.................... 		printf(uart_putc,"ATE0\r");
13A0:  MOVLW  08
13A2:  MOVWF  FF6
13A4:  MOVLW  04
13A6:  MOVWF  FF7
13A8:  RCALL  0F4C
.................... 		sbd.mo_state++;
13AA:  MOVLB  6
13AC:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mo_state ) {
13AE:  BRA    1768
13B0:  MOVF   xC9,W
13B2:  SUBLW  02
13B4:  BNZ   13DA
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
13B6:  MOVLB  8
13B8:  DECFSZ xE6,W
13BA:  BRA    13D6
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
13BC:  MOVF   xE7,W
13BE:  SUBLW  4F
13C0:  BNZ   13CE
13C2:  MOVF   xE8,W
13C4:  SUBLW  4B
13C6:  BNZ   13CE
.................... 				sbd.mo_state++;
13C8:  MOVLB  6
13CA:  INCF   xC9,F
13CC:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
13CE:  MOVLB  0
13D0:  CALL   0AE4
13D4:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mo_state ) {
13D6:  BRA    176A
13D8:  MOVLB  6
13DA:  MOVF   xC9,W
13DC:  SUBLW  03
13DE:  BNZ   13F6
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
13E0:  MOVLB  0
13E2:  CALL   0AE4
.................... 		printf(uart_putc,"AT&K0\r");
13E6:  MOVLW  0E
13E8:  MOVWF  FF6
13EA:  MOVLW  04
13EC:  MOVWF  FF7
13EE:  RCALL  0F4C
.................... 		sbd.mo_state++;
13F0:  MOVLB  6
13F2:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mo_state ) {
13F4:  BRA    1768
13F6:  MOVF   xC9,W
13F8:  SUBLW  04
13FA:  BNZ   1420
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
13FC:  MOVLB  8
13FE:  DECFSZ xE6,W
1400:  BRA    141C
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1402:  MOVF   xE7,W
1404:  SUBLW  4F
1406:  BNZ   1414
1408:  MOVF   xE8,W
140A:  SUBLW  4B
140C:  BNZ   1414
.................... 				sbd.mo_state++;
140E:  MOVLB  6
1410:  INCF   xC9,F
1412:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1414:  MOVLB  0
1416:  CALL   0AE4
141A:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mo_state ) {
141C:  BRA    176A
141E:  MOVLB  6
1420:  MOVF   xC9,W
1422:  SUBLW  05
1424:  BNZ   143C
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
1426:  MOVLB  0
1428:  CALL   0AE4
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
142C:  MOVLW  16
142E:  MOVWF  FF6
1430:  MOVLW  04
1432:  MOVWF  FF7
1434:  RCALL  0F4C
.................... 		sbd.mo_state++;
1436:  MOVLB  6
1438:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mo_state ) {
143A:  BRA    1768
143C:  MOVF   xC9,W
143E:  SUBLW  06
1440:  BNZ   1466
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
1442:  MOVLB  8
1444:  DECFSZ xE6,W
1446:  BRA    1462
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1448:  MOVF   xE7,W
144A:  SUBLW  4F
144C:  BNZ   145A
144E:  MOVF   xE8,W
1450:  SUBLW  4B
1452:  BNZ   145A
.................... 				sbd.mo_state++;
1454:  MOVLB  6
1456:  INCF   xC9,F
1458:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
145A:  MOVLB  0
145C:  CALL   0AE4
1460:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mo_state ) {
1462:  BRA    176A
1464:  MOVLB  6
1466:  MOVF   xC9,W
1468:  SUBLW  07
146A:  BNZ   14A2
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDWB=[<SBD Message Length>]' to tell modem how long our MO */
.................... 		iridium_mr_clear();
146C:  MOVLB  0
146E:  CALL   0AE4
.................... 		printf(uart_putc,"AT+SBDWB=%lu\r",sbd.mo_length);
1472:  MOVLW  24
1474:  MOVWF  FF6
1476:  MOVLW  04
1478:  MOVWF  FF7
147A:  MOVLW  09
147C:  MOVLB  9
147E:  MOVWF  x7E
1480:  MOVLB  0
1482:  BRA    11DE
1484:  MOVLW  10
1486:  MOVWF  FE9
1488:  MOVFF  7DB,97F
148C:  MOVFF  7DA,97E
1490:  BRA    1208
1492:  MOVLW  0D
1494:  MOVLB  9
1496:  MOVWF  x87
1498:  MOVLB  0
149A:  RCALL  0F3C
.................... 		sbd.mo_state++;
149C:  MOVLB  6
149E:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mo_state ) {
14A0:  BRA    1768
14A2:  MOVF   xC9,W
14A4:  SUBLW  08
14A6:  BNZ   14DE
.................... 		/* receive response 'READY' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
14A8:  MOVLB  8
14AA:  DECFSZ xE6,W
14AC:  BRA    14DA
.................... 			if ( 'R'==sbd.mr_buff[0] 
....................                  && 'E'==sbd.mr_buff[1] 
....................                  && 'A'==sbd.mr_buff[2]
.................... 			     && 'D'==sbd.mr_buff[3]
.................... 			     && 'Y'==sbd.mr_buff[4]
14AE:  MOVF   xE7,W
14B0:  SUBLW  52
14B2:  BNZ   14D2
14B4:  MOVF   xE8,W
14B6:  SUBLW  45
14B8:  BNZ   14D2
14BA:  MOVF   xE9,W
14BC:  SUBLW  41
14BE:  BNZ   14D2
14C0:  MOVF   xEA,W
14C2:  SUBLW  44
14C4:  BNZ   14D2
14C6:  MOVF   xEB,W
14C8:  SUBLW  59
14CA:  BNZ   14D2
.................... 			    ) {
.................... 				sbd.mo_state++;
14CC:  MOVLB  6
14CE:  INCF   xC9,F
14D0:  MOVLB  8
.................... 			}
.................... 		
.................... 			/* clear mr because either we got READY or we got a bad response */
.................... 			iridium_mr_clear();				
14D2:  MOVLB  0
14D4:  CALL   0AE4
14D8:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 9 == sbd.mo_state ) {
14DA:  BRA    176A
14DC:  MOVLB  6
14DE:  MOVF   xC9,W
14E0:  SUBLW  09
14E2:  BNZ   156C
.................... 		/* send binary message and 2 byte checksum */
.................... 		iridium_mr_clear();
14E4:  MOVLB  0
14E6:  CALL   0AE4
.................... 		checksum=0;
14EA:  MOVLB  9
14EC:  CLRF   x7D
14EE:  CLRF   x7C
.................... 		/* send data bytes and update checksum */
.................... 		for ( l=0 ; l<sbd.mo_length ; l++ ) {
14F0:  CLRF   x7B
14F2:  CLRF   x7A
14F4:  MOVF   x7B,W
14F6:  MOVLB  7
14F8:  SUBWF  xDB,W
14FA:  BNC   1558
14FC:  BNZ   150E
14FE:  MOVF   xDA,W
1500:  MOVLB  9
1502:  SUBWF  x7A,W
1504:  BTFSS  FD8.0
1506:  BRA    150C
1508:  MOVLB  7
150A:  BRA    1558
150C:  MOVLB  7
.................... 			uart_putc(sbd.mo_buff[l]);
150E:  MOVLW  CA
1510:  MOVLB  9
1512:  ADDWF  x7A,W
1514:  MOVWF  FE9
1516:  MOVLW  06
1518:  ADDWFC x7B,W
151A:  MOVWF  FEA
151C:  MOVFF  FEF,987
1520:  MOVLB  0
1522:  RCALL  0F3C
.................... 			delay_us(500);
1524:  CLRWDT
1526:  MOVLW  02
1528:  MOVLB  9
152A:  MOVWF  x7E
152C:  MOVLW  F7
152E:  MOVWF  x7F
1530:  MOVLB  0
1532:  BRA    12D0
1534:  MOVLB  9
1536:  DECFSZ x7E,F
1538:  BRA    152C
.................... 			checksum += sbd.mo_buff[l];
153A:  MOVLW  CA
153C:  ADDWF  x7A,W
153E:  MOVWF  FE9
1540:  MOVLW  06
1542:  ADDWFC x7B,W
1544:  MOVWF  FEA
1546:  MOVF   FEF,W
1548:  ADDWF  x7C,F
154A:  MOVLW  00
154C:  ADDWFC x7D,F
154E:  INCF   x7A,F
1550:  BTFSC  FD8.2
1552:  INCF   x7B,F
1554:  BRA    14F4
1556:  MOVLB  7
.................... 		}
.................... 
.................... 		/* send checksum bytes */
.................... 		uart_putc(make8(checksum,1));
1558:  MOVFF  97D,987
155C:  MOVLB  0
155E:  RCALL  0F3C
.................... 		uart_putc(make8(checksum,0));
1560:  MOVFF  97C,987
1564:  RCALL  0F3C
.................... 
.................... 		sbd.mo_state++;
1566:  MOVLB  6
1568:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		
.................... 	} else if ( 10 == sbd.mo_state ) {
156A:  BRA    1768
156C:  MOVF   xC9,W
156E:  SUBLW  0A
1570:  BNZ   1594
.................... 		/* 
.................... 		receive response <Status> which means 
.................... 		
.................... 		0 => SBD message successfully written to the ISU.
.................... 
.................... 		1 => SBD message write timeout. An insufficient number of bytes were transferred 
.................... 		to ISU during the transfer period of 60 seconds.
.................... 
.................... 		2 => SBD message checksum sent from DTE does not match the checksum calculated at 
.................... 		the ISU.
.................... 
.................... 		3 => SBD message size is not correct. The maximum mobile originated SBD message 
.................... 		length is 340 bytes. The minimum mobile originated SBD message length is 1 byte.
.................... 		*/
.................... 
.................... 		/* status must be 0 */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1572:  MOVLB  8
1574:  DECFSZ xE6,W
1576:  BRA    1590
.................... 			if ( '0'==sbd.mr_buff[0] ) {
1578:  MOVF   xE7,W
157A:  SUBLW  30
157C:  BNZ   1586
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
157E:  MOVLB  6
1580:  INCF   xC9,F
.................... 			} else {
1582:  BRA    158E
1584:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
1586:  MOVLB  0
1588:  CALL   0AE4
158C:  MOVLB  6
158E:  MOVLB  8
.................... 			}
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mo_state ) {
1590:  BRA    176A
1592:  MOVLB  6
1594:  MOVF   xC9,W
1596:  SUBLW  0B
1598:  BNZ   15BE
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
159A:  MOVLB  8
159C:  DECFSZ xE6,W
159E:  BRA    15BA
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
15A0:  MOVF   xE7,W
15A2:  SUBLW  4F
15A4:  BNZ   15B2
15A6:  MOVF   xE8,W
15A8:  SUBLW  4B
15AA:  BNZ   15B2
.................... 				sbd.mo_state++;
15AC:  MOVLB  6
15AE:  INCF   xC9,F
15B0:  MOVLB  8
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
15B2:  MOVLB  0
15B4:  CALL   0AE4
15B8:  MOVLB  8
.................... 		}
.................... 
.................... 	} else if ( 12 == sbd.mo_state ) {
15BA:  BRA    176A
15BC:  MOVLB  6
15BE:  MOVF   xC9,W
15C0:  SUBLW  0C
15C2:  BNZ   15EA
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		/* send 'AT+SBDIX' to initiate Extended SBD Session */
.................... 
.................... 		if ( sbd.mo_try > 0 && 0 != sbd.mo_sbdix_wait ) {
15C4:  MOVLB  7
15C6:  MOVF   xDC,F
15C8:  BZ    15D4
15CA:  MOVF   xDD,F
15CC:  BZ    15D4
.................... 			/* external function decrements sbd.mo_sbdix_wait once per second */
.................... 			return;
15CE:  MOVLB  6
15D0:  BRA    176E
15D2:  MOVLB  7
.................... 		}
.................... 
.................... 		iridium_mr_clear();
15D4:  MOVLB  0
15D6:  CALL   0AE4
.................... 		printf(uart_putc,"AT+SBDIX\r");
15DA:  MOVLW  32
15DC:  MOVWF  FF6
15DE:  MOVLW  04
15E0:  MOVWF  FF7
15E2:  RCALL  0F4C
.................... 		sbd.mo_state++;
15E4:  MOVLB  6
15E6:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 13 == sbd.mo_state ) {
15E8:  BRA    1768
15EA:  MOVF   xC9,W
15EC:  SUBLW  0D
15EE:  BNZ   167C
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		/*
.................... 		receive response:
.................... 			 +SBDIX: <MO status>, <MOMSN>, <MT status>, <MTMSN>, <MT length>, <MT queued>
.................... 		which means
.................... 
.................... 		<MO status> - Any returned number with a value of 0 to 2 indicates your message 
.................... 		has been successfully transmitted. Any number above 2 indicates that the message 
.................... 		has not been successfully transmitted.
.................... 
.................... 		Per rock7 website (https://docs.rockblock.rock7.com/reference/sbdix):
.................... 		0	MO message, if any, transferred successfully.
.................... 		1	MO message, if any, transferred successfully, but the MT message in the queue was too big to be transferred.
.................... 		2	MO message, if any, transferred successfully, but the requested Location Update was not accepted.
.................... 		3 .. 4	Reserved, but indicate MO session success if used.
.................... 		5 .. 8	Reserved, but indicate MO session failure if used.
.................... 		10	GSS reported that the call did not complete in the allowed time.
.................... 		11	MO message queue at the GSS is full.
.................... 		12	MO message has too many segments.
.................... 		13	GSS reported that the session did not complete.
.................... 		14	Invalid segment size.
.................... 		15	Access is denied.
.................... 		16	ISU has been locked and may not make SBD calls (see +CULK command).
.................... 		17	Gateway not responding (local session timeout).
.................... 		18	Connection lost (RF drop).
.................... 		19	Link failure (A protocol error caused termination of the call).
.................... 		20 .. 31	Reserved, but indicate failure if used.
.................... 		32	No network service, unable to initiate call.
.................... 		33	Antenna fault, unable to initiate call.
.................... 		34	Radio is disabled, unable to initiate call (see *Rn command).
.................... 		35	ISU is busy, unable to initiate call.
.................... 		36	Try later, must wait 3 minutes since last registration.
.................... 		37	SBD service is temporarily disabled.
.................... 		38	Try later, traffic management period (see +SBDLOE command)
.................... 		39 .. 63	Reserved, but indicate failure if used.
.................... 		64	Band violation (attempt to transmit outside permitted frequency band).
.................... 		65	PLL lock failure; hardware error during attempted transmit.
.................... 
.................... 		<MOMSN> - This number denotes the MO message number and cycles between 0 and 65535.
.................... 
.................... 		<MT status>
.................... 			0 => No messages waiting to be received.
.................... 			1 => New message successfully received.
.................... 			2 => Error during mailbox check / message reception.
.................... 
.................... 		<MTMSN> - This number denotes the MT message number and cycles between 0 and 65535.
.................... 
.................... 		<MT length> - The size (in bytes) of the MT message.
.................... 
.................... 		<MT queued> - The number of MT messages in the queue waiting to be downloaded.
.................... 
.................... 		+SBDIX:32,22, 2, 0, 0, 0
....................         012345678901234567890123
....................         0         1         2
.................... 		*/
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
15F0:  MOVLB  8
15F2:  DECFSZ xE6,W
15F4:  BRA    1678
.................... 			if ( '+'==sbd.mr_buff[0] && 'S'==sbd.mr_buff[1] &&
.................... 			     'B'==sbd.mr_buff[2] && 'D'==sbd.mr_buff[3] &&
.................... 			     'I'==sbd.mr_buff[4] && 'X'==sbd.mr_buff[5] 
15F6:  MOVF   xE7,W
15F8:  SUBLW  2B
15FA:  BNZ   1670
15FC:  MOVF   xE8,W
15FE:  SUBLW  53
1600:  BNZ   1670
1602:  MOVF   xE9,W
1604:  SUBLW  42
1606:  BNZ   1670
1608:  MOVF   xEA,W
160A:  SUBLW  44
160C:  BNZ   1670
160E:  MOVF   xEB,W
1610:  SUBLW  49
1612:  BNZ   1670
1614:  MOVF   xEC,W
1616:  SUBLW  58
1618:  BNZ   1670
.................... 			) {
.................... 				/* copy +SBDIX result to seperate buffer so it can be further processed for message downloading */
.................... 				if ( '\0' == sbd.sbdix_response[0] ) {
161A:  MOVLB  6
161C:  MOVF   x96,F
161E:  BNZ   1640
.................... 					strncpy(sbd.sbdix_response,sbd.mr_buff,sizeof(sbd.sbdix_response)-1);
1620:  MOVLW  06
1622:  MOVLB  9
1624:  MOVWF  x7F
1626:  MOVLW  96
1628:  MOVWF  x7E
162A:  MOVLW  08
162C:  MOVWF  x81
162E:  MOVLW  E7
1630:  MOVWF  x80
1632:  CLRF   x83
1634:  MOVLW  29
1636:  MOVWF  x82
1638:  MOVLB  0
163A:  BRA    12F6
.................... 					sbd.sbdix_response[sizeof(sbd.sbdix_response)-1]='\0';
163C:  MOVLB  6
163E:  CLRF   xBF
.................... 				}
.................... 
.................... 
.................... 				/* so we got an +SBDIX response. If first byte ([8]) is '0', '1', '2' and second byte ([9]) is ',' 
.................... 				we are okay to proceed and clear buffer. If it is anything else, we need to wait and try again */
.................... 				/* TODO: white space location / pading may not be consistent. Use atoi style parsing to determine MO_STATUS reliably */
.................... 				if ( ' '==sbd.mr_buff[7] && ( sbd.mr_buff[8] >= '0' && sbd.mr_buff[8] <= '2'  && ',' == sbd.mr_buff[9]) ) {
1640:  MOVLB  8
1642:  MOVF   xEE,W
1644:  SUBLW  20
1646:  BNZ   1666
1648:  MOVF   xEF,W
164A:  SUBLW  2F
164C:  BC    1666
164E:  MOVF   xEF,W
1650:  SUBLW  32
1652:  BNC   1666
1654:  MOVF   xF0,W
1656:  SUBLW  2C
1658:  BNZ   1666
.................... 					sbd.mo_state++;
165A:  MOVLB  6
165C:  INCF   xC9,F
.................... 					sbd.mo_try=0;
165E:  MOVLB  7
1660:  CLRF   xDC
.................... 				} else {
1662:  BRA    166E
1664:  MOVLB  8
.................... 					/* didn't get a 0 or 1 or 2 ... but still go on to next state for OK */
.................... 					sbd.mo_state++;
1666:  MOVLB  6
1668:  INCF   xC9,F
.................... 					sbd.mo_try++;
166A:  MOVLB  7
166C:  INCF   xDC,F
166E:  MOVLB  8
.................... 				}
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
1670:  MOVLB  0
1672:  CALL   0AE4
1676:  MOVLB  8
.................... 		}
.................... 	} else if ( 14 == sbd.mo_state ) {
1678:  BRA    176A
167A:  MOVLB  6
167C:  MOVF   xC9,W
167E:  SUBLW  0E
1680:  BNZ   16EC
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u start\r\n",sbd.mo_state,sbd.mo_try);
.................... #endif
.................... 
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1682:  MOVLB  8
1684:  DECFSZ xE6,W
1686:  BRA    16A2
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1688:  MOVF   xE7,W
168A:  SUBLW  4F
168C:  BNZ   169A
168E:  MOVF   xE8,W
1690:  SUBLW  4B
1692:  BNZ   169A
.................... 				sbd.mo_state++;
1694:  MOVLB  6
1696:  INCF   xC9,F
1698:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
169A:  MOVLB  0
169C:  CALL   0AE4
16A0:  MOVLB  8
.................... 		}
.................... 
.................... 		if ( 0 != sbd.mo_try ) {
16A2:  MOVLB  7
16A4:  MOVF   xDC,F
16A6:  BZ    16E8
.................... 			/* need to try SBDIX again */
.................... 			sbd.mo_state=12;
16A8:  MOVLW  0C
16AA:  MOVLB  6
16AC:  MOVWF  xC9
.................... 			/* back off */
.................... 			if ( 1 == sbd.mo_try || 2 == sbd.mo_try ) {
16AE:  MOVLB  7
16B0:  DECFSZ xDC,W
16B2:  BRA    16B6
16B4:  BRA    16BC
16B6:  MOVF   xDC,W
16B8:  SUBLW  02
16BA:  BNZ   16C2
.................... 				sbd.mo_sbdix_wait=3;
16BC:  MOVLW  03
16BE:  MOVWF  xDD
.................... 			} else if ( 3 == sbd.mo_try || 4 == sbd.mo_try ) {
16C0:  BRA    16E8
16C2:  MOVF   xDC,W
16C4:  SUBLW  03
16C6:  BZ    16CE
16C8:  MOVF   xDC,W
16CA:  SUBLW  04
16CC:  BNZ   16D4
.................... 				sbd.mo_sbdix_wait=21;
16CE:  MOVLW  15
16D0:  MOVWF  xDD
.................... 			} else if ( 5 == sbd.mo_try ) {
16D2:  BRA    16E8
16D4:  MOVF   xDC,W
16D6:  SUBLW  05
16D8:  BNZ   16E0
.................... 				sbd.mo_sbdix_wait=251;
16DA:  MOVLW  FB
16DC:  MOVWF  xDD
.................... 			} else {
16DE:  BRA    16E8
.................... 				/* give up and clear buffer */
.................... 				sbd.mo_state=15;
16E0:  MOVLW  0F
16E2:  MOVLB  6
16E4:  MOVWF  xC9
16E6:  MOVLB  7
.................... 			}
.................... 		}
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u finish\r\n",sbd.mo_state,sbd.mo_try);
.................... #endif
.................... 	} else if ( 15 == sbd.mo_state ) {
16E8:  BRA    176C
16EA:  MOVLB  6
16EC:  MOVF   xC9,W
16EE:  SUBLW  0F
16F0:  BNZ   1708
.................... 
.................... 		/* send 'AT+SBDD=0' to clear MO buffer */
.................... 		iridium_mr_clear();
16F2:  MOVLB  0
16F4:  CALL   0AE4
.................... 		printf(uart_putc,"AT+SBDD0\r");
16F8:  MOVLW  3C
16FA:  MOVWF  FF6
16FC:  MOVLW  04
16FE:  MOVWF  FF7
1700:  RCALL  0F4C
.................... 		sbd.mo_state++;
1702:  MOVLB  6
1704:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		/* TODO ... be careful about starting over without buffer being cleared */
.................... 	} else if ( 16 == sbd.mo_state ) {
1706:  BRA    1768
1708:  MOVF   xC9,W
170A:  SUBLW  10
170C:  BNZ   1730
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		if ( 1 == sbd.mr_ready ) {
170E:  MOVLB  8
1710:  DECFSZ xE6,W
1712:  BRA    172C
.................... 			if ( '0'==sbd.mr_buff[0] ) {
1714:  MOVF   xE7,W
1716:  SUBLW  30
1718:  BNZ   1722
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
171A:  MOVLB  6
171C:  INCF   xC9,F
.................... 			} else {
171E:  BRA    172A
1720:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
1722:  MOVLB  0
1724:  CALL   0AE4
1728:  MOVLB  6
172A:  MOVLB  8
.................... 			}
.................... 		}
.................... 	} else if ( 17 == sbd.mo_state ) {
172C:  BRA    176A
172E:  MOVLB  6
1730:  MOVF   xC9,W
1732:  SUBLW  11
1734:  BNZ   175A
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
1736:  MOVLB  8
1738:  DECFSZ xE6,W
173A:  BRA    1756
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
173C:  MOVF   xE7,W
173E:  SUBLW  4F
1740:  BNZ   174E
1742:  MOVF   xE8,W
1744:  SUBLW  4B
1746:  BNZ   174E
.................... 				sbd.mo_state++;
1748:  MOVLB  6
174A:  INCF   xC9,F
174C:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
174E:  MOVLB  0
1750:  CALL   0AE4
1754:  MOVLB  8
.................... 		}
.................... 	} else if ( 18 == sbd.mo_state ) {
1756:  BRA    176A
1758:  MOVLB  6
175A:  MOVF   xC9,W
175C:  SUBLW  12
175E:  BNZ   1768
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 
.................... 		/* done sending */
.................... 		/* download MT if needed? */
.................... 		/* turn off modem */
.................... //		iridium_off();
.................... 
.................... 		/* go back to waiting */
.................... 		iridium_mr_clear();
1760:  MOVLB  0
1762:  CALL   0AE4
.................... 		iridium_mo_clear();	
1766:  RCALL  137E
1768:  MOVLB  8
176A:  MOVLB  7
176C:  MOVLB  6
.................... 	}
176E:  MOVLB  0
1770:  GOTO   37CC (RETURN)
.................... }
.................... 
.................... void iridium_mt_receive(void) {
.................... 	int8 c;
.................... 	static int16 l;
.................... 	static int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mt_receive() sbd.mt_state=%u\r\n",sbd.mt_state);
.................... #endif
.................... 
.................... 
.................... 	if ( sbd.mt_state <= 1 ) {
*
0F6C:  MOVLB  7
0F6E:  MOVF   xDF,W
0F70:  SUBLW  01
0F72:  BNC   0F8A
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
0F74:  MOVLB  0
0F76:  RCALL  0AE4
.................... 		printf(uart_putc,"ATE0\r");
0F78:  MOVLW  46
0F7A:  MOVWF  FF6
0F7C:  MOVLW  04
0F7E:  MOVWF  FF7
0F80:  RCALL  0F4C
.................... 		sbd.mt_state = 2;
0F82:  MOVLW  02
0F84:  MOVLB  7
0F86:  MOVWF  xDF
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mt_state ) {
0F88:  BRA    11D6
0F8A:  MOVF   xDF,W
0F8C:  SUBLW  02
0F8E:  BNZ   0FB2
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
0F90:  MOVLB  8
0F92:  DECFSZ xE6,W
0F94:  BRA    0FAE
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
0F96:  MOVF   xE7,W
0F98:  SUBLW  4F
0F9A:  BNZ   0FA8
0F9C:  MOVF   xE8,W
0F9E:  SUBLW  4B
0FA0:  BNZ   0FA8
.................... 				sbd.mt_state++;
0FA2:  MOVLB  7
0FA4:  INCF   xDF,F
0FA6:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
0FA8:  MOVLB  0
0FAA:  RCALL  0AE4
0FAC:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mt_state ) {
0FAE:  BRA    11D6
0FB0:  MOVLB  7
0FB2:  MOVF   xDF,W
0FB4:  SUBLW  03
0FB6:  BNZ   0FCC
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
0FB8:  MOVLB  0
0FBA:  RCALL  0AE4
.................... 		printf(uart_putc,"AT&K0\r");
0FBC:  MOVLW  4C
0FBE:  MOVWF  FF6
0FC0:  MOVLW  04
0FC2:  MOVWF  FF7
0FC4:  RCALL  0F4C
.................... 		sbd.mt_state++;
0FC6:  MOVLB  7
0FC8:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mt_state ) {
0FCA:  BRA    11D6
0FCC:  MOVF   xDF,W
0FCE:  SUBLW  04
0FD0:  BNZ   0FF4
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
0FD2:  MOVLB  8
0FD4:  DECFSZ xE6,W
0FD6:  BRA    0FF0
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
0FD8:  MOVF   xE7,W
0FDA:  SUBLW  4F
0FDC:  BNZ   0FEA
0FDE:  MOVF   xE8,W
0FE0:  SUBLW  4B
0FE2:  BNZ   0FEA
.................... 				sbd.mt_state++;
0FE4:  MOVLB  7
0FE6:  INCF   xDF,F
0FE8:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
0FEA:  MOVLB  0
0FEC:  RCALL  0AE4
0FEE:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mt_state ) {
0FF0:  BRA    11D6
0FF2:  MOVLB  7
0FF4:  MOVF   xDF,W
0FF6:  SUBLW  05
0FF8:  BNZ   100E
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
0FFA:  MOVLB  0
0FFC:  RCALL  0AE4
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
0FFE:  MOVLW  54
1000:  MOVWF  FF6
1002:  MOVLW  04
1004:  MOVWF  FF7
1006:  RCALL  0F4C
.................... 		sbd.mt_state++;
1008:  MOVLB  7
100A:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mt_state ) {
100C:  BRA    11D6
100E:  MOVF   xDF,W
1010:  SUBLW  06
1012:  BNZ   1036
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
1014:  MOVLB  8
1016:  DECFSZ xE6,W
1018:  BRA    1032
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
101A:  MOVF   xE7,W
101C:  SUBLW  4F
101E:  BNZ   102C
1020:  MOVF   xE8,W
1022:  SUBLW  4B
1024:  BNZ   102C
.................... 				sbd.mt_state++;
1026:  MOVLB  7
1028:  INCF   xDF,F
102A:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
102C:  MOVLB  0
102E:  RCALL  0AE4
1030:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mt_state ) {
1032:  BRA    11D6
1034:  MOVLB  7
1036:  MOVF   xDF,W
1038:  SUBLW  07
103A:  BNZ   1058
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDRB' to tell modem to send us our MT */
.................... 		iridium_mr_clear();
103C:  MOVLB  0
103E:  RCALL  0AE4
.................... 		sbd.mr_disable=1; /* switch iridum character receiver to binary */
1040:  MOVLW  01
1042:  MOVLB  9
1044:  MOVWF  x28
.................... 		printf(uart_putc,"AT+SBDRB\r");
1046:  MOVLW  62
1048:  MOVWF  FF6
104A:  MOVLW  04
104C:  MOVWF  FF7
104E:  MOVLB  0
1050:  RCALL  0F4C
.................... 		sbd.mt_state++;
1052:  MOVLB  7
1054:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mt_state ) {
1056:  BRA    11D6
1058:  MOVF   xDF,W
105A:  SUBLW  08
105C:  BNZ   1080
.................... 		/* receive first byte of length */
.................... 		if ( ! uart_kbhit() ) {
105E:  MOVLB  0
1060:  RCALL  0E76
1062:  MOVF   01,F
1064:  BNZ   1068
.................... 			/* no character available */
.................... 			return;
1066:  BRA    11D8
.................... 		}
.................... 	
.................... 		sbd.mt_length=make16(uart_getc(),0);
*
1072:  MOVFF  01,8E1
1076:  MOVLB  8
1078:  CLRF   xE0
.................... 		sbd.mt_state++;
107A:  MOVLB  7
107C:  INCF   xDF,F
.................... 	} else if ( 9 == sbd.mt_state ) {
107E:  BRA    11D6
1080:  MOVF   xDF,W
1082:  SUBLW  09
1084:  BNZ   10B6
.................... 		/* receive second byte of length */
.................... 		if ( ! uart_kbhit() ) {
1086:  MOVLB  0
1088:  RCALL  0E76
108A:  MOVF   01,F
108C:  BNZ   1090
.................... 			/* no character available */
.................... 			return;
108E:  BRA    11D8
.................... 		}
.................... 	
.................... 		sbd.mt_length += uart_getc();
*
109A:  MOVF   01,W
109C:  MOVLB  8
109E:  ADDWF  xE0,F
10A0:  MOVLW  00
10A2:  ADDWFC xE1,F
.................... 		sbd.mt_state++;
10A4:  MOVLB  7
10A6:  INCF   xDF,F
.................... 
.................... 		checksum=0;
10A8:  MOVLB  9
10AA:  CLRF   x2E
10AC:  CLRF   x2D
.................... 		l=0;
10AE:  CLRF   x2C
10B0:  CLRF   x2B
.................... 	} else if ( 10 == sbd.mt_state ) {
10B2:  BRA    11D8
10B4:  MOVLB  7
10B6:  MOVF   xDF,W
10B8:  SUBLW  0A
10BA:  BNZ   1126
.................... 		/* receive MT length of characters and calculate checksum */
.................... 		if ( ! uart_kbhit() ) {
10BC:  MOVLB  0
10BE:  RCALL  0E76
10C0:  MOVF   01,F
10C2:  BNZ   10C6
.................... 			/* no character available */
.................... 			return;
10C4:  BRA    11D8
.................... 		}
.................... 
.................... 		if ( 0 == sbd.mt_length ) {
10C6:  MOVLB  8
10C8:  MOVF   xE0,F
10CA:  BNZ   10DA
10CC:  MOVF   xE1,F
10CE:  BNZ   10DA
.................... 			/* zero byte message skips this state */
.................... 			sbd.mt_state++;
10D0:  MOVLB  7
10D2:  INCF   xDF,F
.................... 			return;
10D4:  MOVLB  0
10D6:  BRA    11D8
10D8:  MOVLB  8
.................... 		}
.................... 
.................... 		c = uart_getc();
*
10E4:  MOVFF  01,97A
.................... 		sbd.mt_buff[l]=c;
10E8:  MOVLW  E0
10EA:  MOVLB  9
10EC:  ADDWF  x2B,W
10EE:  MOVWF  FE9
10F0:  MOVLW  07
10F2:  ADDWFC x2C,W
10F4:  MOVWF  FEA
10F6:  MOVFF  97A,FEF
.................... 		checksum += c;
10FA:  MOVF   x7A,W
10FC:  ADDWF  x2D,F
10FE:  MOVLW  00
1100:  ADDWFC x2E,F
.................... 		l++;
1102:  INCF   x2B,F
1104:  BTFSC  FD8.2
1106:  INCF   x2C,F
.................... 
.................... 		if ( l == sbd.mt_length ) {
1108:  MOVLB  8
110A:  MOVF   xE0,W
110C:  MOVLB  9
110E:  SUBWF  x2B,W
1110:  BNZ   1122
1112:  MOVLB  8
1114:  MOVF   xE1,W
1116:  MOVLB  9
1118:  SUBWF  x2C,W
111A:  BNZ   1122
.................... 			/* received right number of characters */
.................... 			sbd.mt_state++;
111C:  MOVLB  7
111E:  INCF   xDF,F
1120:  MOVLB  9
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mt_state ) {
1122:  BRA    11D8
1124:  MOVLB  7
1126:  MOVF   xDF,W
1128:  SUBLW  0B
112A:  BNZ   114E
.................... 		if ( ! uart_kbhit() ) {
112C:  MOVLB  0
112E:  RCALL  0E76
1130:  MOVF   01,F
1132:  BNZ   1136
.................... 			/* no character available */
.................... 			return;
1134:  BRA    11D8
.................... 		}
.................... 
.................... 		/* high byte of checksum */
.................... 		l=make16(uart_getc(),0);
*
1140:  MOVFF  01,92C
1144:  MOVLB  9
1146:  CLRF   x2B
.................... 		sbd.mt_state++;
1148:  MOVLB  7
114A:  INCF   xDF,F
.................... 	} else if ( 12 == sbd.mt_state ) {
114C:  BRA    11D6
114E:  MOVF   xDF,W
1150:  SUBLW  0C
1152:  BNZ   117E
.................... 		if ( ! uart_kbhit() ) {
1154:  MOVLB  0
1156:  RCALL  0E76
1158:  MOVF   01,F
115A:  BNZ   115E
.................... 			/* no character available */
.................... 			return;
115C:  BRA    11D8
.................... 		}
.................... 
.................... 		/* low byte of checksum */
.................... 		l += uart_getc();
*
1168:  MOVF   01,W
116A:  MOVLB  9
116C:  ADDWF  x2B,F
116E:  MOVLW  00
1170:  ADDWFC x2C,F
.................... 		sbd.mt_state++;
1172:  MOVLB  7
1174:  INCF   xDF,F
.................... 
.................... 		sbd.mr_disable=0;
1176:  MOVLB  9
1178:  CLRF   x28
.................... 	} else if ( 13 == sbd.mt_state ) {
117A:  BRA    11D8
117C:  MOVLB  7
117E:  MOVF   xDF,W
1180:  SUBLW  0D
1182:  BNZ   11A0
.................... 		/* compare local and remote checksum */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mt_receive() checksum l=%lu r=%lu\r\n",checksum,l);
.................... #endif
.................... 
.................... 		if ( checksum == l ) {
1184:  MOVLB  9
1186:  MOVF   x2B,W
1188:  SUBWF  x2D,W
118A:  BNZ   119A
118C:  MOVF   x2C,W
118E:  SUBWF  x2E,W
1190:  BNZ   119A
.................... 			/* checksums matched, we have a good message! */
.................... 			sbd.mt_ready=1;
1192:  MOVLW  01
1194:  MOVLB  7
1196:  MOVWF  xDE
1198:  MOVLB  9
.................... 
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# iridium_mt_receive() mt_ready=1, here is our message:\r\n");
.................... 			for ( l=0 ; l<sbd.mt_length ; l++ ) {
.................... 				fprintf(STREAM_WORLD,"# mt_buff[%lu]=%c\r\n",l,sbd.mt_buff[l]);
.................... 			}
.................... #endif
.................... 		}
.................... 
.................... 		/* even if we have a bad checksum, we advance to next state and watch for OK */
.................... 		sbd.mt_state++;
119A:  MOVLB  7
119C:  INCF   xDF,F
.................... 
.................... 	} else if ( 14 == sbd.mt_state ) {
119E:  BRA    11D6
11A0:  MOVF   xDF,W
11A2:  SUBLW  0E
11A4:  BNZ   11C8
.................... 		/* 
.................... 		Iridium reference manual says:
.................... 		"There are no response codes generated by the ISU for this command".
.................... 		But it does, in fact, give an "OK" (0x0D 0x0A 0x4F 0x4B 0x0D 0x0A) 
.................... 		about 2.7ms after finishing send the SBD data 
.................... 		*/
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
11A6:  MOVLB  8
11A8:  DECFSZ xE6,W
11AA:  BRA    11C4
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
11AC:  MOVF   xE7,W
11AE:  SUBLW  4F
11B0:  BNZ   11BE
11B2:  MOVF   xE8,W
11B4:  SUBLW  4B
11B6:  BNZ   11BE
.................... 				sbd.mt_state++;
11B8:  MOVLB  7
11BA:  INCF   xDF,F
11BC:  MOVLB  8
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# iridium_mt_receive() got final OK\r\n");
.................... #endif
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
11BE:  MOVLB  0
11C0:  RCALL  0AE4
11C2:  MOVLB  8
.................... 		}	
.................... 	} else if ( 15 == sbd.mt_state ) {
11C4:  BRA    11D6
11C6:  MOVLB  7
11C8:  MOVF   xDF,W
11CA:  SUBLW  0F
11CC:  BNZ   11D6
.................... 		/* message has processed */
.................... 		sbd.sbdix_mt_status=0;
11CE:  MOVLB  6
11D0:  CLRF   xC3
.................... 		sbd.mt_state=0;
11D2:  MOVLB  7
11D4:  CLRF   xDF
11D6:  MOVLB  9
11D8:  MOVLB  0
.................... 	}
11DA:  GOTO   37B4 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #if 0
.................... 			/* if not using RING ALERT through the UART, we can do this */
.................... 			/* check if RING ALERT is active via the !CTS pin connected to RING ALERT line on the SBD modem */
.................... 			if ( bit_test(uart_read(UART_MSR),4) ) {
.................... 				sbd.ring_flag=1;
.................... 			}
.................... #endif
.................... 
.................... #include "interrupt_rdTap.c"
.................... /* int_timer2 in modbus_int_uart.c */
.................... 
.................... #int_timer4
.................... void isr_10ms(void) {
.................... 	static int8 sc=0;
.................... 	static int16 li=0;
.................... 
.................... 	/* once per second */
.................... 	sc++;
*
046C:  MOVLB  9
046E:  INCF   x2F,F
.................... 	if ( 100==sc ) {
0470:  MOVF   x2F,W
0472:  SUBLW  64
0474:  BNZ   04AA
.................... 		sc=0;
0476:  CLRF   x2F
.................... 
.................... 		li++;
0478:  INCF   x30,F
047A:  BTFSC  FD8.2
047C:  INCF   x31,F
.................... 		if ( li >= config.live_interval ) {
047E:  MOVLB  5
0480:  MOVF   x87,W
0482:  MOVLB  9
0484:  SUBWF  x31,W
0486:  BNC   04A0
0488:  BNZ   0494
048A:  MOVLB  5
048C:  MOVF   x86,W
048E:  MOVLB  9
0490:  SUBWF  x30,W
0492:  BNC   04A0
.................... 			li=0;
0494:  CLRF   x31
0496:  CLRF   x30
.................... 			timers.now_poll=1;
0498:  MOVLW  01
049A:  MOVLB  3
049C:  MOVWF  x61
049E:  MOVLB  9
.................... 		}
.................... 
.................... 
.................... 		if ( sbd.mo_sbdix_wait > 0 ) {
04A0:  MOVLB  7
04A2:  MOVF   xDD,F
04A4:  BZ    04A8
.................... 			sbd.mo_sbdix_wait--;
04A6:  DECF   xDD,F
04A8:  MOVLB  9
.................... 		}
.................... 	}
.................... 
.................... 	if ( timers.world_timeout < 255 ) {
04AA:  MOVLB  3
04AC:  INCFSZ x62,W
04AE:  BRA    04B2
04B0:  BRA    04B4
.................... 		timers.world_timeout++;
04B2:  INCF   x62,F
.................... 	}
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
04B4:  MOVF   x64,F
04B6:  BNZ   04BE
.................... 		output_low(LED_GREEN);
04B8:  BCF    F93.5
04BA:  BCF    F8A.5
.................... 	} else {
04BC:  BRA    04C4
.................... 		output_high(LED_GREEN);
04BE:  BCF    F93.5
04C0:  BSF    F8A.5
.................... 		timers.led_on_green--;
04C2:  DECF   x64,F
.................... 	}
.................... 
.................... }
.................... 
.................... 
.................... /* int_rda in modbus_int_uart.c */
.................... 
04C4:  BCF    FB7.7
04C6:  MOVLB  0
04C8:  GOTO   0084
.................... #int_rda2
.................... void isr_world(void) {
.................... 	static int8 pre[5];
.................... 
.................... 
.................... 
.................... 	if ( query.buff_ready ) {
*
04E2:  MOVLB  5
04E4:  MOVF   x6D,F
04E6:  BZ    04EE
.................... 		/* throw out data received while processing previous query */
.................... 		fgetc(STREAM_WORLD);
04E8:  MOVLB  0
04EA:  RCALL  04CC
04EC:  MOVLB  5
.................... 	}
.................... 
.................... 	/* timeout after 100 milliseconds */
.................... 	if ( timers.world_timeout > 10 ) {
04EE:  MOVLB  3
04F0:  MOVF   x62,W
04F2:  SUBLW  0A
04F4:  BC    04FC
.................... 		query.buff_pos=0;
04F6:  MOVLB  5
04F8:  CLRF   x6C
04FA:  MOVLB  3
.................... //		output_toggle(LED_RED);
.................... 	}
.................... 	timers.world_timeout=0;
04FC:  CLRF   x62
.................... 
.................... 	if ( 0 == query.buff_pos ) {
04FE:  MOVLB  5
0500:  MOVF   x6C,F
0502:  BNZ   0574
.................... 		pre[0]=pre[1];
0504:  MOVFF  933,932
.................... 		pre[1]=pre[2];
0508:  MOVFF  934,933
.................... 		pre[2]=pre[3];
050C:  MOVFF  935,934
.................... 		pre[3]=pre[4];
0510:  MOVFF  936,935
.................... 		pre[4]=fgetc(STREAM_WORLD);
0514:  MOVLB  0
0516:  RCALL  04CC
0518:  MOVFF  01,936
.................... 
.................... 		/* packet addressed to us */
.................... 		if ( '#'==pre[0] && config.serial_prefix==pre[1] && config.serial_number==make16(pre[2],pre[3]) ) {
051C:  MOVLB  9
051E:  MOVF   x32,W
0520:  SUBLW  23
0522:  BNZ   0570
0524:  MOVF   x33,W
0526:  MOVLB  5
0528:  SUBWF  x83,W
052A:  BTFSC  FD8.2
052C:  BRA    0532
052E:  MOVLB  9
0530:  BRA    0570
0532:  MOVFF  934,03
0536:  MOVLB  9
0538:  MOVF   x35,W
053A:  MOVLB  5
053C:  SUBWF  x84,W
053E:  BTFSC  FD8.2
0540:  BRA    0546
0542:  MOVLB  9
0544:  BRA    0570
0546:  MOVF   03,W
0548:  SUBWF  x85,W
054A:  BTFSC  FD8.2
054C:  BRA    0552
054E:  MOVLB  9
0550:  BRA    0570
.................... 			output_high(CTRL_1);
0552:  BCF    F92.1
0554:  BSF    F89.1
.................... 			query.buff[0]=pre[0];
0556:  MOVFF  932,46C
.................... 			query.buff[1]=pre[1];
055A:  MOVFF  933,46D
.................... 			query.buff[2]=pre[2];
055E:  MOVFF  934,46E
.................... 			query.buff[3]=pre[3];
0562:  MOVFF  935,46F
.................... 			query.buff[4]=pre[4];
0566:  MOVFF  936,470
.................... 			query.buff_pos=5;
056A:  MOVLW  05
056C:  MOVWF  x6C
056E:  MOVLB  9
.................... 		}
.................... 	} else {
0570:  BRA    05B0
0572:  MOVLB  5
.................... 		query.buff[query.buff_pos++]=fgetc(STREAM_WORLD);
0574:  MOVF   x6C,W
0576:  INCF   x6C,F
0578:  ADDLW  6C
057A:  MOVWF  FE9
057C:  MOVLW  04
057E:  MOVWF  FEA
0580:  BTFSC  FD8.0
0582:  INCF   FEA,F
0584:  MOVFF  FEA,99E
0588:  MOVFF  FE9,99D
058C:  MOVLB  0
058E:  RCALL  04CC
0590:  MOVFF  99E,FEA
0594:  MOVFF  99D,FE9
0598:  MOVFF  01,FEF
.................... 
.................... 		if ( query.buff_pos == query.buff[4] ) {
059C:  MOVLB  4
059E:  MOVF   x70,W
05A0:  MOVLB  5
05A2:  SUBWF  x6C,W
05A4:  BNZ   05AE
.................... 			output_toggle(CTRL_1);
05A6:  BCF    F92.1
05A8:  BTG    F89.1
.................... 			query.buff_ready=1;
05AA:  MOVLW  01
05AC:  MOVWF  x6D
05AE:  MOVLB  9
.................... 		}
.................... 	}
.................... }
.................... 
05B0:  BCF    FA4.5
05B2:  MOVLB  0
05B4:  GOTO   0084
.................... #include "live_rdTap.c"
.................... /* pass reg_crc value of 0xFFFF to reset */
.................... int16 crc_chk_pass(int16 reg_crc, int8 *data, int8 length) {
.................... 	int8 j;
.................... 	
.................... 	while ( length-- ) {
*
1958:  MOVLB  9
195A:  MOVF   x97,W
195C:  DECF   x97,F
195E:  XORLW  00
1960:  BZ    19AA
.................... 		reg_crc ^= *data++;
1962:  MOVFF  996,FEA
1966:  MOVF   x95,W
1968:  INCF   x95,F
196A:  BTFSC  FD8.2
196C:  INCF   x96,F
196E:  MOVWF  FE9
1970:  MOVF   FEF,W
1972:  XORWF  x93,F
.................... 
.................... 		for ( j=0 ; j<8 ; j++ ) {
1974:  CLRF   x98
1976:  MOVF   x98,W
1978:  SUBLW  07
197A:  BNC   19A8
.................... 			if ( reg_crc & 0x01 ) {
197C:  MOVF   x93,W
197E:  ANDLW  01
1980:  MOVWF  00
1982:  CLRF   03
1984:  MOVF   00,W
1986:  IORWF  03,W
1988:  BZ    199E
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001;
198A:  BCF    FD8.0
198C:  RRCF   x94,W
198E:  MOVWF  x9A
1990:  RRCF   x93,W
1992:  XORLW  01
1994:  MOVWF  x93
1996:  MOVF   x9A,W
1998:  XORLW  A0
199A:  MOVWF  x94
.................... 			} else {
199C:  BRA    19A4
.................... 				reg_crc=reg_crc>>1;
199E:  BCF    FD8.0
19A0:  RRCF   x94,F
19A2:  RRCF   x93,F
.................... 			}
19A4:  INCF   x98,F
19A6:  BRA    1976
.................... 		}	
19A8:  BRA    195A
.................... 	}
.................... 	
.................... 	return reg_crc;
19AA:  MOVFF  993,01
19AE:  MOVFF  994,02
19B2:  MOVLB  0
19B4:  RETURN 0
.................... }
.................... 
.................... void live_send(void) {
.................... 	int16 lCRC;
.................... 	int8 i;
.................... 	int8 buff[17];
.................... 	int16 completeLength;
.................... 
.................... 	completeLength=sizeof(buff) + qbuff.rResultLength + 2;
*
19BE:  MOVLW  11
19C0:  MOVLB  4
19C2:  ADDWF  x68,W
19C4:  ADDLW  02
19C6:  MOVLB  9
19C8:  MOVWF  x91
19CA:  CLRF   x92
19CC:  BTFSC  FD8.0
19CE:  INCF   x92,F
.................... 
.................... 	buff[0]='#';
19D0:  MOVLW  23
19D2:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
19D4:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
19D8:  MOVFF  585,982
19DC:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0); 
19DE:  MOVFF  584,983
19E2:  MOVLB  9
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */
19E4:  SETF   x84
.................... 	buff[5]=18; /* packet type */
19E6:  MOVLW  12
19E8:  MOVWF  x85
.................... 	buff[6]=make8(completeLength,1);
19EA:  MOVFF  992,986
.................... 	buff[7]=make8(completeLength,0);
19EE:  MOVFF  991,987
.................... 
.................... 	buff[8]=make8(qbuff.measurementNumber,1);
19F2:  MOVFF  46B,988
19F6:  MOVLB  9
.................... 	buff[9]=make8(qbuff.measurementNumber,0);
19F8:  MOVFF  46A,989
19FC:  MOVLB  9
.................... 
.................... 	/* device info */
.................... 	/* WorldData device type identifier (16-bit) */
.................... 	i=qbuff.deviceNumber;
19FE:  MOVFF  469,97F
.................... 	buff[10]=make8(device[i].typeWorld,1);
1A02:  CLRF   x95
1A04:  MOVFF  97F,994
1A08:  CLRF   x97
1A0A:  MOVLW  0D
1A0C:  MOVWF  x96
1A0E:  MOVLB  0
1A10:  CALL   084C
1A14:  MOVFF  01,993
1A18:  MOVLW  01
1A1A:  MOVLB  9
1A1C:  ADDWF  01,W
1A1E:  MOVWF  01
1A20:  MOVLW  00
1A22:  ADDWFC 02,W
1A24:  MOVWF  03
1A26:  MOVF   01,W
1A28:  ADDLW  21
1A2A:  MOVWF  FE9
1A2C:  MOVLW  00
1A2E:  ADDWFC 03,W
1A30:  MOVWF  FEA
1A32:  MOVFF  FEC,98A
1A36:  MOVF   FED,F
1A38:  MOVFF  FEF,993
.................... 	buff[11]=make8(device[i].typeWorld,0);
1A3C:  CLRF   x95
1A3E:  MOVFF  97F,994
1A42:  CLRF   x97
1A44:  MOVLW  0D
1A46:  MOVWF  x96
1A48:  MOVLB  0
1A4A:  CALL   084C
1A4E:  MOVFF  01,993
1A52:  MOVLW  01
1A54:  MOVLB  9
1A56:  ADDWF  01,W
1A58:  MOVWF  01
1A5A:  MOVLW  00
1A5C:  ADDWFC 02,W
1A5E:  MOVWF  03
1A60:  MOVF   01,W
1A62:  ADDLW  21
1A64:  MOVWF  FE9
1A66:  MOVLW  00
1A68:  ADDWFC 03,W
1A6A:  MOVWF  FEA
1A6C:  MOVFF  FEC,994
1A70:  MOVF   FED,F
1A72:  MOVFF  FEF,98B
.................... 	/* manufacturers serial number */
.................... 	buff[12]=make8(device[i].serialNumber,3);
1A76:  CLRF   x95
1A78:  MOVFF  97F,994
1A7C:  CLRF   x97
1A7E:  MOVLW  0D
1A80:  MOVWF  x96
1A82:  MOVLB  0
1A84:  CALL   084C
1A88:  MOVFF  01,993
1A8C:  MOVLW  05
1A8E:  MOVLB  9
1A90:  ADDWF  01,W
1A92:  MOVWF  01
1A94:  MOVLW  00
1A96:  ADDWFC 02,W
1A98:  MOVWF  03
1A9A:  MOVF   01,W
1A9C:  ADDLW  21
1A9E:  MOVWF  FE9
1AA0:  MOVLW  00
1AA2:  ADDWFC 03,W
1AA4:  MOVWF  FEA
1AA6:  MOVFF  FEF,993
1AAA:  MOVFF  FEC,994
1AAE:  MOVFF  FEC,995
1AB2:  MOVFF  FEC,98C
.................... 	buff[13]=make8(device[i].serialNumber,2);
1AB6:  CLRF   x95
1AB8:  MOVFF  97F,994
1ABC:  CLRF   x97
1ABE:  MOVLW  0D
1AC0:  MOVWF  x96
1AC2:  MOVLB  0
1AC4:  CALL   084C
1AC8:  MOVFF  01,993
1ACC:  MOVLW  05
1ACE:  MOVLB  9
1AD0:  ADDWF  01,W
1AD2:  MOVWF  01
1AD4:  MOVLW  00
1AD6:  ADDWFC 02,W
1AD8:  MOVWF  03
1ADA:  MOVF   01,W
1ADC:  ADDLW  21
1ADE:  MOVWF  FE9
1AE0:  MOVLW  00
1AE2:  ADDWFC 03,W
1AE4:  MOVWF  FEA
1AE6:  MOVFF  FEF,993
1AEA:  MOVFF  FEC,994
1AEE:  MOVFF  FEC,98D
1AF2:  MOVFF  FEC,996
.................... 	buff[14]=make8(device[i].serialNumber,1);
1AF6:  CLRF   x95
1AF8:  MOVFF  97F,994
1AFC:  CLRF   x97
1AFE:  MOVLW  0D
1B00:  MOVWF  x96
1B02:  MOVLB  0
1B04:  CALL   084C
1B08:  MOVFF  01,993
1B0C:  MOVLW  05
1B0E:  MOVLB  9
1B10:  ADDWF  01,W
1B12:  MOVWF  01
1B14:  MOVLW  00
1B16:  ADDWFC 02,W
1B18:  MOVWF  03
1B1A:  MOVF   01,W
1B1C:  ADDLW  21
1B1E:  MOVWF  FE9
1B20:  MOVLW  00
1B22:  ADDWFC 03,W
1B24:  MOVWF  FEA
1B26:  MOVFF  FEF,993
1B2A:  MOVFF  FEC,98E
1B2E:  MOVFF  FEC,995
1B32:  MOVFF  FEC,996
.................... 	buff[15]=make8(device[i].serialNumber,0);
1B36:  CLRF   x95
1B38:  MOVFF  97F,994
1B3C:  CLRF   x97
1B3E:  MOVLW  0D
1B40:  MOVWF  x96
1B42:  MOVLB  0
1B44:  CALL   084C
1B48:  MOVFF  01,993
1B4C:  MOVLW  05
1B4E:  MOVLB  9
1B50:  ADDWF  01,W
1B52:  MOVWF  01
1B54:  MOVLW  00
1B56:  ADDWFC 02,W
1B58:  MOVWF  03
1B5A:  MOVF   01,W
1B5C:  ADDLW  21
1B5E:  MOVWF  FE9
1B60:  MOVLW  00
1B62:  ADDWFC 03,W
1B64:  MOVWF  FEA
1B66:  MOVFF  FEF,98F
1B6A:  MOVFF  FEC,994
1B6E:  MOVFF  FEC,995
1B72:  MOVFF  FEC,996
.................... 	/* status of the data read */
.................... 	buff[16]=qbuff.rException;
1B76:  MOVFF  367,990
.................... 
.................... 	/* compute CRC on header and result data */
.................... 	lCRC=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
1B7A:  SETF   x94
1B7C:  SETF   x93
1B7E:  MOVLW  09
1B80:  MOVWF  x96
1B82:  MOVLW  81
1B84:  MOVWF  x95
1B86:  MOVLW  10
1B88:  MOVWF  x97
1B8A:  MOVLB  0
1B8C:  RCALL  1958
1B8E:  MOVFF  02,97E
1B92:  MOVFF  01,97D
.................... 	lCRC=crc_chk_pass(lCRC,qbuff.rResult,qbuff.rResultLength);
1B96:  MOVFF  97E,994
1B9A:  MOVFF  97D,993
1B9E:  MOVLW  03
1BA0:  MOVLB  9
1BA2:  MOVWF  x96
1BA4:  MOVLW  68
1BA6:  MOVWF  x95
1BA8:  MOVFF  468,997
1BAC:  MOVLB  0
1BAE:  RCALL  1958
1BB0:  MOVFF  02,97E
1BB4:  MOVFF  01,97D
.................... 
.................... 	/* send buff, qbuff.rResult, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
1BB8:  MOVLB  9
1BBA:  CLRF   x7F
1BBC:  MOVF   x7F,W
1BBE:  SUBLW  10
1BC0:  BNC   1BE0
.................... 		fputc(buff[i],STREAM_WORLD);
1BC2:  CLRF   03
1BC4:  MOVF   x7F,W
1BC6:  ADDLW  80
1BC8:  MOVWF  FE9
1BCA:  MOVLW  09
1BCC:  ADDWFC 03,W
1BCE:  MOVWF  FEA
1BD0:  MOVFF  FEF,993
1BD4:  MOVF   x93,W
1BD6:  MOVLB  0
1BD8:  RCALL  19B6
1BDA:  MOVLB  9
1BDC:  INCF   x7F,F
1BDE:  BRA    1BBC
.................... 	}	
.................... 	for ( i=0 ; i<qbuff.rResultLength ; i++ ) {
1BE0:  CLRF   x7F
1BE2:  MOVLB  4
1BE4:  MOVF   x68,W
1BE6:  MOVLB  9
1BE8:  SUBWF  x7F,W
1BEA:  BC    1C0A
.................... 		fputc(qbuff.rResult[i],STREAM_WORLD);
1BEC:  MOVLW  68
1BEE:  ADDWF  x7F,W
1BF0:  MOVWF  FE9
1BF2:  MOVLW  03
1BF4:  MOVWF  FEA
1BF6:  BTFSC  FD8.0
1BF8:  INCF   FEA,F
1BFA:  MOVFF  FEF,993
1BFE:  MOVF   x93,W
1C00:  MOVLB  0
1C02:  RCALL  19B6
1C04:  MOVLB  9
1C06:  INCF   x7F,F
1C08:  BRA    1BE2
.................... 	}
.................... 	fputc(make8(lCRC,1),STREAM_WORLD);
1C0A:  MOVFF  97E,993
1C0E:  MOVF   x93,W
1C10:  MOVLB  0
1C12:  RCALL  19B6
.................... 	fputc(make8(lCRC,0),STREAM_WORLD);
1C14:  MOVFF  97D,993
1C18:  MOVLB  9
1C1A:  MOVF   x93,W
1C1C:  MOVLB  0
1C1E:  RCALL  19B6
1C20:  RETURN 0
.................... }
.................... 
.................... 
.................... #include "queryHandler_rdTap.c"
.................... /* this will do an arbitrary query to some other device on the network */
.................... void query_other(void) {
.................... 	int8 parseType;
.................... 	int8 i;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_other()\r\n");
.................... 	fprintf(STREAM_WORLD,"# query function=%lu\r\n",query.function);
.................... #endif
.................... 
.................... 	if ( query.function <= DEV_TYPE_MODBUS_MAX ) {
*
30DC:  MOVLB  5
30DE:  MOVF   x7A,F
30E0:  BTFSS  FD8.2
30E2:  BRA    3334
30E4:  MOVF   x79,W
30E6:  SUBLW  07
30E8:  BTFSS  FD8.0
30EA:  BRA    3334
.................... 		/* modbus device type */
.................... 		switch ( query.function ) {
30EC:  MOVF   x79,W
30EE:  MOVWF  00
30F0:  MOVF   x7A,W
30F2:  MOVWF  03
30F4:  MOVF   03,W
30F6:  BNZ   3100
30F8:  MOVF   00,F
30FA:  MOVLB  0
30FC:  BZ    3168
30FE:  MOVLB  5
3100:  MOVF   03,W
3102:  BNZ   310E
3104:  MOVLW  01
3106:  SUBWF  00,W
3108:  MOVLB  0
310A:  BZ    316A
310C:  MOVLB  5
310E:  MOVF   03,W
3110:  BNZ   311C
3112:  MOVLW  02
3114:  SUBWF  00,W
3116:  MOVLB  0
3118:  BZ    3192
311A:  MOVLB  5
311C:  MOVF   03,W
311E:  BNZ   312A
3120:  MOVLW  03
3122:  SUBWF  00,W
3124:  MOVLB  0
3126:  BZ    31B8
3128:  MOVLB  5
312A:  MOVF   03,W
312C:  BNZ   3138
312E:  MOVLW  04
3130:  SUBWF  00,W
3132:  MOVLB  0
3134:  BZ    31E0
3136:  MOVLB  5
3138:  MOVF   03,W
313A:  BNZ   3146
313C:  MOVLW  05
313E:  SUBWF  00,W
3140:  MOVLB  0
3142:  BZ    3208
3144:  MOVLB  5
3146:  MOVF   03,W
3148:  BNZ   3156
314A:  MOVLW  06
314C:  SUBWF  00,W
314E:  MOVLB  0
3150:  BTFSC  FD8.2
3152:  BRA    323A
3154:  MOVLB  5
3156:  MOVF   03,W
3158:  BNZ   3166
315A:  MOVLW  07
315C:  SUBWF  00,W
315E:  MOVLB  0
3160:  BTFSC  FD8.2
3162:  BRA    3290
3164:  MOVLB  5
3166:  BRA    32D0
.................... 			case DEV_TYPE_DISABLED:
.................... 				return;
3168:  BRA    33FA
.................... 			case DEV_TYPE_MODBUS_1: /* not very well tested */
.................... 				query.resultException=modbus_read_coils(query.network_address, query.start_address, query.n_words);
316A:  MOVFF  577,982
316E:  MOVFF  57C,984
3172:  MOVFF  57B,983
3176:  MOVLB  9
3178:  CLRF   x86
317A:  MOVFF  57D,985
317E:  MOVLB  0
3180:  CALL   1C22
3184:  MOVFF  01,581
.................... 				parseType=1;
3188:  MOVLW  01
318A:  MOVLB  9
318C:  MOVWF  x80
.................... 				break;
318E:  MOVLB  5
3190:  BRA    32D0
.................... 			case DEV_TYPE_MODBUS_2: /* not very well tested */
.................... 				query.resultException=modbus_read_discrete_input(query.network_address, query.start_address, query.n_words);
3192:  MOVFF  577,982
3196:  MOVFF  57C,984
319A:  MOVFF  57B,983
319E:  MOVLB  9
31A0:  CLRF   x86
31A2:  MOVFF  57D,985
31A6:  MOVLB  0
31A8:  BRA    2D70
31AA:  MOVFF  01,581
.................... 				parseType=1;
31AE:  MOVLW  01
31B0:  MOVLB  9
31B2:  MOVWF  x80
.................... 				break;
31B4:  MOVLB  5
31B6:  BRA    32D0
.................... 			case DEV_TYPE_MODBUS_3: /* tested */
.................... 				query.resultException=modbus_read_holding_registers(query.network_address, query.start_address, query.n_words);
31B8:  MOVFF  577,982
31BC:  MOVFF  57C,984
31C0:  MOVFF  57B,983
31C4:  MOVLB  9
31C6:  CLRF   x86
31C8:  MOVFF  57D,985
31CC:  MOVLB  0
31CE:  CALL   18C0
31D2:  MOVFF  01,581
.................... 				parseType=1;
31D6:  MOVLW  01
31D8:  MOVLB  9
31DA:  MOVWF  x80
.................... 				break;
31DC:  MOVLB  5
31DE:  BRA    32D0
.................... 			case DEV_TYPE_MODBUS_4: /* tested */
.................... 				query.resultException=modbus_read_input_registers(query.network_address, query.start_address, query.n_words);
31E0:  MOVFF  577,982
31E4:  MOVFF  57C,984
31E8:  MOVFF  57B,983
31EC:  MOVLB  9
31EE:  CLRF   x86
31F0:  MOVFF  57D,985
31F4:  MOVLB  0
31F6:  CALL   1828
31FA:  MOVFF  01,581
.................... 				parseType=1;
31FE:  MOVLW  01
3200:  MOVLB  9
3202:  MOVWF  x80
.................... 				break;
3204:  MOVLB  5
3206:  BRA    32D0
.................... 			case DEV_TYPE_MODBUS_5: /* tested */
.................... 				query.resultException=modbus_write_single_coil(query.network_address, query.start_address, query.buff[query.data_start_offset]);
3208:  MOVLW  6C
320A:  MOVLB  5
320C:  ADDWF  x7E,W
320E:  MOVWF  FE9
3210:  MOVLW  04
3212:  MOVWF  FEA
3214:  BTFSC  FD8.0
3216:  INCF   FEA,F
3218:  MOVFF  FEF,986
321C:  MOVFF  577,983
3220:  MOVFF  57C,985
3224:  MOVFF  57B,984
3228:  MOVLB  0
322A:  BRA    2E18
322C:  MOVFF  01,581
.................... 				parseType=2;
3230:  MOVLW  02
3232:  MOVLB  9
3234:  MOVWF  x80
.................... 				break;
3236:  MOVLB  5
3238:  BRA    32D0
.................... 			case DEV_TYPE_MODBUS_6: /* tested */
.................... 				query.resultException=modbus_write_single_register(query.network_address, query.start_address, 
.................... 					make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
323A:  MOVLW  6C
323C:  MOVLB  5
323E:  ADDWF  x7E,W
3240:  MOVWF  FE9
3242:  MOVLW  04
3244:  MOVWF  FEA
3246:  BTFSC  FD8.0
3248:  INCF   FEA,F
324A:  MOVFF  FEF,982
324E:  MOVLW  01
3250:  ADDWF  x7E,W
3252:  ADDLW  6C
3254:  MOVWF  FE9
3256:  MOVLW  04
3258:  MOVWF  FEA
325A:  BTFSC  FD8.0
325C:  INCF   FEA,F
325E:  MOVFF  FEF,983
3262:  MOVFF  982,985
3266:  MOVFF  983,984
326A:  MOVFF  577,986
326E:  MOVFF  57C,988
3272:  MOVFF  57B,987
3276:  MOVFF  982,98A
327A:  MOVFF  983,989
327E:  MOVLB  0
3280:  BRA    2ED4
3282:  MOVFF  01,581
.................... 				parseType=2;
3286:  MOVLW  02
3288:  MOVLB  9
328A:  MOVWF  x80
.................... 				return;
328C:  MOVLB  0
328E:  BRA    33FA
.................... 			case DEV_TYPE_MODBUS_16: /* tested ... endian issues lead to having to send data in a (backwards?) order */
.................... 				query.resultException=modbus_write_multiple_registers_flip(query.network_address, query.start_address, 
.................... 					query.n_words,&query.buff+query.data_start_offset
.................... 				);
3290:  MOVLW  6C
3292:  MOVLB  5
3294:  ADDWF  x7E,W
3296:  MOVLB  9
3298:  MOVWF  x82
329A:  MOVLW  04
329C:  MOVWF  x83
329E:  BTFSC  FD8.0
32A0:  INCF   x83,F
32A2:  MOVFF  577,984
32A6:  MOVFF  57C,986
32AA:  MOVFF  57B,985
32AE:  CLRF   x88
32B0:  MOVFF  57D,987
32B4:  MOVFF  983,98A
32B8:  MOVFF  982,989
32BC:  MOVLB  0
32BE:  BRA    2F7C
32C0:  MOVFF  01,581
.................... 				parseType=2;
32C4:  MOVLW  02
32C6:  MOVLB  9
32C8:  MOVWF  x80
.................... 				return;
32CA:  MOVLB  0
32CC:  BRA    33FA
32CE:  MOVLB  5
.................... 		}	
.................... 
.................... 		/* Modbus query performed above. */
.................... 		/* no error, copy data to buffer to send response */
.................... 		if ( 1==parseType && 0==query.resultException ) {
32D0:  MOVLB  9
32D2:  DECFSZ x80,W
32D4:  BRA    3310
32D6:  MOVLB  5
32D8:  MOVF   x81,F
32DA:  BTFSC  FD8.2
32DC:  BRA    32E2
32DE:  MOVLB  9
32E0:  BRA    3310
.................... 			query.resultLength=modbus_rx.len-1;
32E2:  MOVLW  01
32E4:  SUBWF  x94,W
32E6:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[1],modbus_rx.len-1); 
32E8:  MOVLW  01
32EA:  SUBWF  x94,W
32EC:  MOVLB  9
32EE:  MOVWF  x82
32F0:  MOVLW  04
32F2:  MOVWF  FEA
32F4:  MOVLW  6C
32F6:  MOVWF  FE9
32F8:  MOVLW  05
32FA:  MOVWF  FE2
32FC:  MOVLW  98
32FE:  MOVWF  FE1
3300:  MOVF   x82,W
3302:  MOVWF  01
3304:  BZ    330E
3306:  MOVFF  FE6,FEE
330A:  DECFSZ 01,F
330C:  BRA    3306
.................... 		} else if ( 2==parseType && 0==query.resultException ) {
330E:  BRA    3330
3310:  MOVF   x80,W
3312:  SUBLW  02
3314:  BNZ   3330
3316:  MOVLB  5
3318:  MOVF   x81,F
331A:  BTFSC  FD8.2
331C:  BRA    3322
331E:  MOVLB  9
3320:  BRA    3330
.................... 			/* return the value of the coil we wrote */
.................... 			query.resultLength=2;
3322:  MOVLW  02
3324:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[3],2); 
3326:  MOVFF  59A,46C
332A:  MOVFF  59B,46D
332E:  MOVLB  9
.................... 		}
.................... 	} else if ( query.function <= DEV_TYPE_I2C_MAX ) {
3330:  BRA    33F8
3332:  MOVLB  5
3334:  MOVF   x7A,F
3336:  BNZ   33FA
3338:  MOVF   x79,W
333A:  SUBLW  17
333C:  BNC   33FA
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# query_other for I2C network_adress=%lu, start_address=%lu n_words=%u\r\n",
.................... 			query.network_address,
.................... 			query.start_address,
.................... 			query.n_words
.................... 		);
.................... #endif
.................... 
.................... 		if ( DEV_TYPE_I2C_READ_8 == query.function ) {
333E:  MOVF   x79,W
3340:  SUBLW  10
3342:  BNZ   336E
3344:  MOVF   x7A,F
3346:  BNZ   336E
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_READ_8\r\n");
.................... #endif
.................... 
.................... 			/* start a read at start address then just read a byte at a time. n_words is actually bytes */
.................... 			i2c_buff_read(query.network_address, query.start_address, query.buff, query.n_words);
3348:  MOVFF  577,982
334C:  MOVFF  57B,983
3350:  MOVLW  04
3352:  MOVLB  9
3354:  MOVWF  x85
3356:  MOVLW  6C
3358:  MOVWF  x84
335A:  MOVFF  57D,986
335E:  MOVLB  0
3360:  CALL   1CBA
.................... 			query.resultLength = query.n_words; /* in bytes */
3364:  MOVFF  57D,582
.................... 			query.resultException=0;
3368:  MOVLB  5
336A:  CLRF   x81
.................... 		} else if ( DEV_TYPE_I2C_WRITE_16 == query.function ) {
336C:  BRA    33FA
336E:  MOVF   x79,W
3370:  SUBLW  15
3372:  BNZ   33FA
3374:  MOVF   x7A,F
3376:  BNZ   33FA
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_WRITE_16\r\n");
.................... #endif
.................... 
.................... 			for ( i=0 ; i<query.n_words ; i++ ) {
3378:  MOVLB  9
337A:  CLRF   x81
337C:  MOVLB  5
337E:  MOVF   x7D,W
3380:  MOVLB  9
3382:  SUBWF  x81,W
3384:  BC    33F8
.................... #if DEBUG_ASCII
.................... 				fprintf(STREAM_WORLD,"# writing 0x%04lx to I2C device 0x%02x at address %lu\r\n",
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1]),
.................... 					query.network_address,
.................... 					(query.start_address+i*2)
.................... 				);
.................... #endif
.................... 
.................... 				i2c_register_write16(
.................... 					query.network_address,
.................... 					(query.start_address+i*2),
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1])
.................... 				);
3386:  BCF    FD8.0
3388:  RLCF   x81,W
338A:  MOVLB  5
338C:  ADDWF  x7B,W
338E:  MOVLB  9
3390:  MOVWF  x82
3392:  MOVLW  00
3394:  MOVLB  5
3396:  ADDWFC x7C,W
3398:  MOVLB  9
339A:  MOVWF  x83
339C:  BCF    FD8.0
339E:  RLCF   x81,W
33A0:  MOVLB  5
33A2:  ADDWF  x7E,W
33A4:  ADDLW  6C
33A6:  MOVWF  FE9
33A8:  MOVLW  04
33AA:  MOVWF  FEA
33AC:  BTFSC  FD8.0
33AE:  INCF   FEA,F
33B0:  MOVFF  FEF,984
33B4:  BCF    FD8.0
33B6:  MOVLB  9
33B8:  RLCF   x81,W
33BA:  MOVLB  5
33BC:  ADDWF  x7E,W
33BE:  ADDLW  01
33C0:  ADDLW  6C
33C2:  MOVWF  FE9
33C4:  MOVLW  04
33C6:  MOVWF  FEA
33C8:  BTFSC  FD8.0
33CA:  INCF   FEA,F
33CC:  MOVFF  FEF,985
33D0:  MOVFF  984,987
33D4:  MOVFF  985,986
33D8:  MOVFF  577,988
33DC:  MOVFF  982,989
33E0:  MOVFF  984,98B
33E4:  MOVFF  985,98A
33E8:  MOVLB  0
33EA:  BRA    30A0
.................... 
.................... 				query.resultLength = 0; /* in bytes */
33EC:  MOVLB  5
33EE:  CLRF   x82
.................... 				query.resultException=0;
33F0:  CLRF   x81
33F2:  MOVLB  9
33F4:  INCF   x81,F
33F6:  BRA    337C
.................... 
.................... 			}
.................... 
.................... 		} else {
33F8:  MOVLB  5
33FA:  MOVLB  0
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# un-implemented I2C query function\r\n");
.................... #endif
.................... 		}
.................... 
.................... 	}
33FC:  GOTO   361E (RETURN)
.................... }
.................... 
.................... 
.................... /* 
.................... try to write the specified register
.................... if successful, return 0, otherwise return a modbus exception
.................... */
.................... exception query_self_write_register(int16 address, int16 value) {
.................... 	int8 dev, offset;
.................... 	int16 last;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_write_register address=%lu value=%lu\r\n",address,value);
.................... #endif
.................... 
.................... 	/* if we have been unlocked, then we can modify serial number */
.................... 	if ( timers.factory_unlocked ) {
*
2962:  MOVLB  3
2964:  MOVF   x63,F
2966:  BZ    299E
.................... 		if ( 1000 == address ) {
2968:  MOVLB  9
296A:  MOVF   x84,W
296C:  SUBLW  E8
296E:  BNZ   2982
2970:  MOVF   x85,W
2972:  SUBLW  03
2974:  BNZ   2982
.................... 			config.serial_prefix=value;
2976:  MOVFF  986,583
.................... 			return 0;
297A:  MOVLW  00
297C:  MOVWF  01
297E:  BRA    2C8C
.................... 		} else if ( 1001 == address ) {
2980:  BRA    299C
2982:  MOVF   x84,W
2984:  SUBLW  E9
2986:  BNZ   299C
2988:  MOVF   x85,W
298A:  SUBLW  03
298C:  BNZ   299C
.................... 			config.serial_number=value;
298E:  MOVFF  987,585
2992:  MOVFF  986,584
.................... 			return 0;
2996:  MOVLW  00
2998:  MOVWF  01
299A:  BRA    2C8C
299C:  MOVLB  3
.................... 		}
.................... 	}
.................... 
.................... 	if ( address < 1000 ) {
299E:  MOVLB  9
29A0:  MOVF   x85,W
29A2:  SUBLW  03
29A4:  BTFSS  FD8.0
29A6:  BRA    2BB0
29A8:  BNZ   29B2
29AA:  MOVF   x84,W
29AC:  SUBLW  E7
29AE:  BTFSS  FD8.0
29B0:  BRA    2BB0
.................... 		dev=address>>3;
29B2:  RRCF   x85,W
29B4:  MOVWF  03
29B6:  RRCF   x84,W
29B8:  MOVWF  02
29BA:  RRCF   03,F
29BC:  RRCF   02,F
29BE:  RRCF   03,F
29C0:  RRCF   02,F
29C2:  MOVFF  02,988
.................... 		offset=address&0b111;
29C6:  MOVF   x84,W
29C8:  ANDLW  07
29CA:  MOVWF  x89
.................... 
.................... 		if ( dev > DEV_MAX_N )
29CC:  MOVF   x88,W
29CE:  SUBLW  40
29D0:  BC    29D8
.................... 			return ILLEGAL_DATA_ADDRESS;
29D2:  MOVLW  02
29D4:  MOVWF  01
29D6:  BRA    2C8C
.................... 
.................... 		switch ( offset ) {
29D8:  MOVF   x89,W
29DA:  ADDLW  F8
29DC:  BTFSC  FD8.0
29DE:  BRA    2BAE
29E0:  ADDLW  08
29E2:  MOVLB  0
29E4:  GOTO   2C92
.................... 			case 0: device[dev].type=make8(value,0); break;
29E8:  MOVLB  9
29EA:  CLRF   x95
29EC:  MOVFF  988,994
29F0:  CLRF   x97
29F2:  MOVLW  0D
29F4:  MOVWF  x96
29F6:  MOVLB  0
29F8:  CALL   084C
29FC:  MOVFF  02,98D
2A00:  MOVFF  01,98C
2A04:  MOVLW  21
2A06:  MOVLB  9
2A08:  ADDWF  01,W
2A0A:  MOVWF  FE9
2A0C:  MOVLW  00
2A0E:  ADDWFC 02,W
2A10:  MOVWF  FEA
2A12:  MOVFF  986,FEF
2A16:  BRA    2BAE
.................... 			case 1: device[dev].typeWorld=value; break;
2A18:  MOVLB  9
2A1A:  CLRF   x95
2A1C:  MOVFF  988,994
2A20:  CLRF   x97
2A22:  MOVLW  0D
2A24:  MOVWF  x96
2A26:  MOVLB  0
2A28:  CALL   084C
2A2C:  MOVFF  02,98D
2A30:  MOVFF  01,98C
2A34:  MOVLW  01
2A36:  MOVLB  9
2A38:  ADDWF  01,W
2A3A:  MOVWF  01
2A3C:  MOVLW  00
2A3E:  ADDWFC 02,W
2A40:  MOVWF  03
2A42:  MOVF   01,W
2A44:  ADDLW  21
2A46:  MOVWF  FE9
2A48:  MOVLW  00
2A4A:  ADDWFC 03,W
2A4C:  MOVWF  FEA
2A4E:  MOVFF  987,FEC
2A52:  MOVF   FED,F
2A54:  MOVFF  986,FEF
2A58:  BRA    2BAE
.................... 			case 2: device[dev].transmitEvery=make8(value,0); break;
2A5A:  MOVLB  9
2A5C:  CLRF   x95
2A5E:  MOVFF  988,994
2A62:  CLRF   x97
2A64:  MOVLW  0D
2A66:  MOVWF  x96
2A68:  MOVLB  0
2A6A:  CALL   084C
2A6E:  MOVFF  02,98D
2A72:  MOVFF  01,98C
2A76:  MOVLW  03
2A78:  MOVLB  9
2A7A:  ADDWF  01,W
2A7C:  MOVWF  01
2A7E:  MOVLW  00
2A80:  ADDWFC 02,W
2A82:  MOVWF  03
2A84:  MOVF   01,W
2A86:  ADDLW  21
2A88:  MOVWF  FE9
2A8A:  MOVLW  00
2A8C:  ADDWFC 03,W
2A8E:  MOVWF  FEA
2A90:  MOVFF  986,FEF
2A94:  BRA    2BAE
.................... 			case 3: device[dev].networkAddress=make8(value,0); break;
2A96:  MOVLB  9
2A98:  CLRF   x95
2A9A:  MOVFF  988,994
2A9E:  CLRF   x97
2AA0:  MOVLW  0D
2AA2:  MOVWF  x96
2AA4:  MOVLB  0
2AA6:  CALL   084C
2AAA:  MOVFF  02,98D
2AAE:  MOVFF  01,98C
2AB2:  MOVLW  04
2AB4:  MOVLB  9
2AB6:  ADDWF  01,W
2AB8:  MOVWF  01
2ABA:  MOVLW  00
2ABC:  ADDWFC 02,W
2ABE:  MOVWF  03
2AC0:  MOVF   01,W
2AC2:  ADDLW  21
2AC4:  MOVWF  FE9
2AC6:  MOVLW  00
2AC8:  ADDWFC 03,W
2ACA:  MOVWF  FEA
2ACC:  MOVFF  986,FEF
2AD0:  BRA    2BAE
.................... 			/* first pass get the high word of serial number */
.................... 			case 4: last=value; break;
2AD2:  MOVFF  987,98B
2AD6:  MOVFF  986,98A
2ADA:  MOVLB  9
2ADC:  BRA    2BAE
.................... 			/* second pass, combine last value and current value */
.................... 			case 5: device[dev].serialNumber=make32(last,value); break; /* was missing a break prior to 2024-04-03 */
2ADE:  MOVLB  9
2AE0:  CLRF   x95
2AE2:  MOVFF  988,994
2AE6:  CLRF   x97
2AE8:  MOVLW  0D
2AEA:  MOVWF  x96
2AEC:  MOVLB  0
2AEE:  CALL   084C
2AF2:  MOVFF  02,98D
2AF6:  MOVFF  01,98C
2AFA:  MOVLW  05
2AFC:  MOVLB  9
2AFE:  ADDWF  01,W
2B00:  MOVWF  01
2B02:  MOVLW  00
2B04:  ADDWFC 02,W
2B06:  MOVWF  03
2B08:  MOVF   01,W
2B0A:  ADDLW  21
2B0C:  MOVWF  FE9
2B0E:  MOVLW  00
2B10:  ADDWFC 03,W
2B12:  MOVWF  FEA
2B14:  MOVF   FEE,F
2B16:  MOVFF  98A,FEC
2B1A:  MOVFF  98B,FEC
2B1E:  MOVF   FED,F
2B20:  MOVF   FED,F
2B22:  MOVF   FED,F
2B24:  MOVFF  986,FEF
2B28:  MOVFF  987,FEC
2B2C:  BRA    2BAE
.................... 			case 6: device[dev].startRegister=value; break;
2B2E:  MOVLB  9
2B30:  CLRF   x95
2B32:  MOVFF  988,994
2B36:  CLRF   x97
2B38:  MOVLW  0D
2B3A:  MOVWF  x96
2B3C:  MOVLB  0
2B3E:  CALL   084C
2B42:  MOVFF  02,98D
2B46:  MOVFF  01,98C
2B4A:  MOVLW  09
2B4C:  MOVLB  9
2B4E:  ADDWF  01,W
2B50:  MOVWF  01
2B52:  MOVLW  00
2B54:  ADDWFC 02,W
2B56:  MOVWF  03
2B58:  MOVF   01,W
2B5A:  ADDLW  21
2B5C:  MOVWF  FE9
2B5E:  MOVLW  00
2B60:  ADDWFC 03,W
2B62:  MOVWF  FEA
2B64:  MOVFF  987,FEC
2B68:  MOVF   FED,F
2B6A:  MOVFF  986,FEF
2B6E:  BRA    2BAE
.................... 			case 7: device[dev].nRegisters=make8(value,0); break;
2B70:  MOVLB  9
2B72:  CLRF   x95
2B74:  MOVFF  988,994
2B78:  CLRF   x97
2B7A:  MOVLW  0D
2B7C:  MOVWF  x96
2B7E:  MOVLB  0
2B80:  CALL   084C
2B84:  MOVFF  02,98D
2B88:  MOVFF  01,98C
2B8C:  MOVLW  0B
2B8E:  MOVLB  9
2B90:  ADDWF  01,W
2B92:  MOVWF  01
2B94:  MOVLW  00
2B96:  ADDWFC 02,W
2B98:  MOVWF  03
2B9A:  MOVF   01,W
2B9C:  ADDLW  21
2B9E:  MOVWF  FE9
2BA0:  MOVLW  00
2BA2:  ADDWFC 03,W
2BA4:  MOVWF  FEA
2BA6:  MOVFF  986,FEF
2BAA:  BRA    2BAE
2BAC:  MOVLB  9
.................... 		}
.................... 	} else {
2BAE:  BRA    2C84
.................... 		/* publicly writeable addresses */
.................... 
.................... 		switch ( address ) {
2BB0:  MOVF   x84,W
2BB2:  MOVWF  00
2BB4:  MOVF   x85,W
2BB6:  MOVWF  03
2BB8:  MOVLW  04
2BBA:  SUBWF  03,W
2BBC:  BNZ   2BC8
2BBE:  MOVLW  4C
2BC0:  SUBWF  00,W
2BC2:  MOVLB  0
2BC4:  BZ    2C0A
2BC6:  MOVLB  9
2BC8:  MOVLW  07
2BCA:  SUBWF  03,W
2BCC:  BNZ   2BD8
2BCE:  MOVLW  CD
2BD0:  SUBWF  00,W
2BD2:  MOVLB  0
2BD4:  BZ    2C14
2BD6:  MOVLB  9
2BD8:  MOVLW  07
2BDA:  SUBWF  03,W
2BDC:  BNZ   2BE8
2BDE:  MOVLW  CE
2BE0:  SUBWF  00,W
2BE2:  MOVLB  0
2BE4:  BZ    2C18
2BE6:  MOVLB  9
2BE8:  MOVLW  07
2BEA:  SUBWF  03,W
2BEC:  BNZ   2BF8
2BEE:  MOVLW  CF
2BF0:  SUBWF  00,W
2BF2:  MOVLB  0
2BF4:  BZ    2C38
2BF6:  MOVLB  9
2BF8:  MOVLW  4E
2BFA:  SUBWF  03,W
2BFC:  BNZ   2C08
2BFE:  MOVLW  1F
2C00:  SUBWF  00,W
2C02:  MOVLB  0
2C04:  BZ    2C54
2C06:  MOVLB  9
2C08:  BRA    2C7E
.................... 			case 1100: config.live_interval=value; break;
2C0A:  MOVFF  987,587
2C0E:  MOVFF  986,586
2C12:  BRA    2C86
.................... 
.................... 			case 1997:
.................... 				reset_cpu(); break; /* break doesn't do anything, but makes the compiler complain less */
2C14:  RESET
2C16:  BRA    2C86
.................... 			case 1998:
.................... 				if ( 1998 != value ) return ILLEGAL_DATA_VALUE;
2C18:  MOVLB  9
2C1A:  MOVF   x86,W
2C1C:  SUBLW  CE
2C1E:  BNZ   2C26
2C20:  MOVF   x87,W
2C22:  SUBLW  07
2C24:  BZ    2C2C
2C26:  MOVLW  03
2C28:  MOVWF  01
2C2A:  BRA    2C8C
.................... 				write_default_param_file();
2C2C:  MOVLB  0
2C2E:  CALL   0822
.................... 				write_default_device_file();
2C32:  CALL   08C0
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# writing default files\r\n");
.................... #endif
.................... 				break;
2C36:  BRA    2C86
.................... 			case 1999:
.................... 				/* write config to EEPROM */
.................... 				if ( 1 != value ) return ILLEGAL_DATA_VALUE;
2C38:  MOVLB  9
2C3A:  DECFSZ x86,W
2C3C:  BRA    2C42
2C3E:  MOVF   x87,F
2C40:  BZ    2C48
2C42:  MOVLW  03
2C44:  MOVWF  01
2C46:  BRA    2C8C
.................... 				write_param_file();
2C48:  MOVLB  0
2C4A:  CALL   07CE
.................... 				write_device_file();
2C4E:  CALL   086E
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# config.live_interval=%lu\r\n",config.live_interval);
.................... #endif
.................... 
.................... 				break;
2C52:  BRA    2C86
.................... 
.................... 			case 19999:
.................... 				/* unlock factory programming registers when we get 1802 in passcode register */
.................... 				if ( 1802 != value ) {
2C54:  MOVLB  9
2C56:  MOVF   x86,W
2C58:  SUBLW  0A
2C5A:  BNZ   2C62
2C5C:  MOVF   x87,W
2C5E:  SUBLW  07
2C60:  BZ    2C6E
.................... 					timers.factory_unlocked=0;
2C62:  MOVLB  3
2C64:  CLRF   x63
.................... 					return ILLEGAL_DATA_VALUE;
2C66:  MOVLW  03
2C68:  MOVWF  01
2C6A:  MOVLB  9
2C6C:  BRA    2C8C
.................... 				}
.................... 				timers.factory_unlocked=1;
2C6E:  MOVLW  01
2C70:  MOVLB  3
2C72:  MOVWF  x63
.................... 				/* green LED for 2 seconds */
.................... 				timers.led_on_green=200;
2C74:  MOVLW  C8
2C76:  MOVWF  x64
.................... 				break;
2C78:  MOVLB  0
2C7A:  BRA    2C86
2C7C:  MOVLB  9
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# factory unlocked\r\n");
.................... #endif
.................... 
.................... 			default:
.................... 				return ILLEGAL_DATA_ADDRESS;
2C7E:  MOVLW  02
2C80:  MOVWF  01
2C82:  BRA    2C8C
2C84:  MOVLB  0
.................... 		}
.................... 	}
.................... 
.................... 	/* must not have triggered an exception */
.................... 	return 0;
2C86:  MOVLW  00
2C88:  MOVWF  01
2C8A:  MOVLB  9
2C8C:  MOVLB  0
2C8E:  GOTO   2D5A (RETURN)
.................... }
.................... 
.................... 
.................... /* address to read, put 16-bit results in query.buff[n] and query.buff[n+1] */
.................... exception query_self_read_register(int16 address, int8 n) {
.................... 	int16 result;
.................... 	int8 dev;
.................... 	int8 offset;
.................... 
.................... 
.................... 	if ( address < 1000 ) {
*
2510:  MOVLB  9
2512:  MOVF   x89,W
2514:  SUBLW  03
2516:  BTFSS  FD8.0
2518:  BRA    27F6
251A:  BNZ   2524
251C:  MOVF   x88,W
251E:  SUBLW  E7
2520:  BTFSS  FD8.0
2522:  BRA    27F6
.................... 		dev=address>>3;
2524:  RRCF   x89,W
2526:  MOVWF  03
2528:  RRCF   x88,W
252A:  MOVWF  02
252C:  RRCF   03,F
252E:  RRCF   02,F
2530:  RRCF   03,F
2532:  RRCF   02,F
2534:  MOVFF  02,98D
.................... 		offset=address&0b111;
2538:  MOVF   x88,W
253A:  ANDLW  07
253C:  MOVWF  x8E
.................... 
.................... 		if ( dev > DEV_MAX_N )
253E:  MOVF   x8D,W
2540:  SUBLW  40
2542:  BC    254A
.................... 			return ILLEGAL_DATA_ADDRESS;
2544:  MOVLW  02
2546:  MOVWF  01
2548:  BRA    28EE
.................... 
.................... 		switch ( offset ) {
254A:  MOVF   x8E,W
254C:  ADDLW  F8
254E:  BTFSC  FD8.0
2550:  BRA    27F4
2552:  ADDLW  08
2554:  MOVLB  0
2556:  GOTO   28F4
.................... 			case 0: result=device[dev].type; break;
255A:  MOVLB  9
255C:  CLRF   x95
255E:  MOVFF  98D,994
2562:  CLRF   x97
2564:  MOVLW  0D
2566:  MOVWF  x96
2568:  MOVLB  0
256A:  CALL   084C
256E:  MOVFF  02,990
2572:  MOVFF  01,98F
2576:  MOVLW  21
2578:  MOVLB  9
257A:  ADDWF  01,W
257C:  MOVWF  FE9
257E:  MOVLW  00
2580:  ADDWFC 02,W
2582:  MOVWF  FEA
2584:  CLRF   x8C
2586:  MOVFF  FEF,98B
258A:  BRA    27F4
.................... 			case 1: result=device[dev].typeWorld; break;
258C:  MOVLB  9
258E:  CLRF   x95
2590:  MOVFF  98D,994
2594:  CLRF   x97
2596:  MOVLW  0D
2598:  MOVWF  x96
259A:  MOVLB  0
259C:  CALL   084C
25A0:  MOVFF  02,990
25A4:  MOVFF  01,98F
25A8:  MOVLW  01
25AA:  MOVLB  9
25AC:  ADDWF  01,W
25AE:  MOVWF  01
25B0:  MOVLW  00
25B2:  ADDWFC 02,W
25B4:  MOVWF  03
25B6:  MOVF   01,W
25B8:  ADDLW  21
25BA:  MOVWF  FE9
25BC:  MOVLW  00
25BE:  ADDWFC 03,W
25C0:  MOVWF  FEA
25C2:  MOVFF  FEC,98C
25C6:  MOVF   FED,F
25C8:  MOVFF  FEF,98B
25CC:  BRA    27F4
.................... 			case 2: result=device[dev].transmitEvery; break;
25CE:  MOVLB  9
25D0:  CLRF   x95
25D2:  MOVFF  98D,994
25D6:  CLRF   x97
25D8:  MOVLW  0D
25DA:  MOVWF  x96
25DC:  MOVLB  0
25DE:  CALL   084C
25E2:  MOVFF  02,990
25E6:  MOVFF  01,98F
25EA:  MOVLW  03
25EC:  MOVLB  9
25EE:  ADDWF  01,W
25F0:  MOVWF  01
25F2:  MOVLW  00
25F4:  ADDWFC 02,W
25F6:  MOVWF  03
25F8:  MOVF   01,W
25FA:  ADDLW  21
25FC:  MOVWF  FE9
25FE:  MOVLW  00
2600:  ADDWFC 03,W
2602:  MOVWF  FEA
2604:  CLRF   x8C
2606:  MOVFF  FEF,98B
260A:  BRA    27F4
.................... 			case 3: result=device[dev].networkAddress; break;
260C:  MOVLB  9
260E:  CLRF   x95
2610:  MOVFF  98D,994
2614:  CLRF   x97
2616:  MOVLW  0D
2618:  MOVWF  x96
261A:  MOVLB  0
261C:  CALL   084C
2620:  MOVFF  02,990
2624:  MOVFF  01,98F
2628:  MOVLW  04
262A:  MOVLB  9
262C:  ADDWF  01,W
262E:  MOVWF  01
2630:  MOVLW  00
2632:  ADDWFC 02,W
2634:  MOVWF  03
2636:  MOVF   01,W
2638:  ADDLW  21
263A:  MOVWF  FE9
263C:  MOVLW  00
263E:  ADDWFC 03,W
2640:  MOVWF  FEA
2642:  CLRF   x8C
2644:  MOVFF  FEF,98B
2648:  BRA    27F4
.................... 			case 4: result=make16(make8(device[dev].serialNumber,3),make8(device[dev].serialNumber,2)); break;
264A:  MOVLB  9
264C:  CLRF   x95
264E:  MOVFF  98D,994
2652:  CLRF   x97
2654:  MOVLW  0D
2656:  MOVWF  x96
2658:  MOVLB  0
265A:  CALL   084C
265E:  MOVFF  01,98F
2662:  MOVLW  05
2664:  MOVLB  9
2666:  ADDWF  01,W
2668:  MOVWF  01
266A:  MOVLW  00
266C:  ADDWFC 02,W
266E:  MOVWF  03
2670:  MOVF   01,W
2672:  ADDLW  21
2674:  MOVWF  FE9
2676:  MOVLW  00
2678:  ADDWFC 03,W
267A:  MOVWF  FEA
267C:  MOVFF  FEF,98F
2680:  MOVFF  FEC,990
2684:  MOVFF  FEC,991
2688:  MOVFF  FEC,992
268C:  MOVFF  992,993
2690:  CLRF   x95
2692:  MOVFF  98D,994
2696:  CLRF   x97
2698:  MOVLW  0D
269A:  MOVWF  x96
269C:  MOVLB  0
269E:  CALL   084C
26A2:  MOVFF  01,994
26A6:  MOVLW  05
26A8:  MOVLB  9
26AA:  ADDWF  01,W
26AC:  MOVWF  01
26AE:  MOVLW  00
26B0:  ADDWFC 02,W
26B2:  MOVWF  03
26B4:  MOVF   01,W
26B6:  ADDLW  21
26B8:  MOVWF  FE9
26BA:  MOVLW  00
26BC:  ADDWFC 03,W
26BE:  MOVWF  FEA
26C0:  MOVFF  FEF,994
26C4:  MOVFF  FEC,995
26C8:  MOVFF  FEC,996
26CC:  MOVFF  FEC,997
26D0:  MOVFF  996,998
26D4:  MOVFF  992,98C
26D8:  MOVFF  996,98B
26DC:  BRA    27F4
.................... 			case 5: result=make16(make8(device[dev].serialNumber,1),make8(device[dev].serialNumber,0)); break;
26DE:  MOVLB  9
26E0:  CLRF   x95
26E2:  MOVFF  98D,994
26E6:  CLRF   x97
26E8:  MOVLW  0D
26EA:  MOVWF  x96
26EC:  MOVLB  0
26EE:  CALL   084C
26F2:  MOVFF  01,98F
26F6:  MOVLW  05
26F8:  MOVLB  9
26FA:  ADDWF  01,W
26FC:  MOVWF  01
26FE:  MOVLW  00
2700:  ADDWFC 02,W
2702:  MOVWF  03
2704:  MOVF   01,W
2706:  ADDLW  21
2708:  MOVWF  FE9
270A:  MOVLW  00
270C:  ADDWFC 03,W
270E:  MOVWF  FEA
2710:  MOVFF  FEF,98F
2714:  MOVFF  FEC,990
2718:  MOVFF  FEC,991
271C:  MOVFF  FEC,992
2720:  MOVFF  990,993
2724:  CLRF   x95
2726:  MOVFF  98D,994
272A:  CLRF   x97
272C:  MOVLW  0D
272E:  MOVWF  x96
2730:  MOVLB  0
2732:  CALL   084C
2736:  MOVFF  01,994
273A:  MOVLW  05
273C:  MOVLB  9
273E:  ADDWF  01,W
2740:  MOVWF  01
2742:  MOVLW  00
2744:  ADDWFC 02,W
2746:  MOVWF  03
2748:  MOVF   01,W
274A:  ADDLW  21
274C:  MOVWF  FE9
274E:  MOVLW  00
2750:  ADDWFC 03,W
2752:  MOVWF  FEA
2754:  MOVFF  FEF,994
2758:  MOVFF  FEC,995
275C:  MOVFF  FEC,996
2760:  MOVFF  FEC,997
2764:  MOVFF  994,998
2768:  MOVFF  990,98C
276C:  MOVFF  994,98B
2770:  BRA    27F4
.................... 			case 6: result=device[dev].startRegister; break;
2772:  MOVLB  9
2774:  CLRF   x95
2776:  MOVFF  98D,994
277A:  CLRF   x97
277C:  MOVLW  0D
277E:  MOVWF  x96
2780:  MOVLB  0
2782:  CALL   084C
2786:  MOVFF  02,990
278A:  MOVFF  01,98F
278E:  MOVLW  09
2790:  MOVLB  9
2792:  ADDWF  01,W
2794:  MOVWF  01
2796:  MOVLW  00
2798:  ADDWFC 02,W
279A:  MOVWF  03
279C:  MOVF   01,W
279E:  ADDLW  21
27A0:  MOVWF  FE9
27A2:  MOVLW  00
27A4:  ADDWFC 03,W
27A6:  MOVWF  FEA
27A8:  MOVFF  FEC,98C
27AC:  MOVF   FED,F
27AE:  MOVFF  FEF,98B
27B2:  BRA    27F4
.................... 			case 7: result=device[dev].nRegisters; break;
27B4:  MOVLB  9
27B6:  CLRF   x95
27B8:  MOVFF  98D,994
27BC:  CLRF   x97
27BE:  MOVLW  0D
27C0:  MOVWF  x96
27C2:  MOVLB  0
27C4:  CALL   084C
27C8:  MOVFF  02,990
27CC:  MOVFF  01,98F
27D0:  MOVLW  0B
27D2:  MOVLB  9
27D4:  ADDWF  01,W
27D6:  MOVWF  01
27D8:  MOVLW  00
27DA:  ADDWFC 02,W
27DC:  MOVWF  03
27DE:  MOVF   01,W
27E0:  ADDLW  21
27E2:  MOVWF  FE9
27E4:  MOVLW  00
27E6:  ADDWFC 03,W
27E8:  MOVWF  FEA
27EA:  CLRF   x8C
27EC:  MOVFF  FEF,98B
27F0:  BRA    27F4
27F2:  MOVLB  9
.................... 		}
.................... 	} else {
27F4:  BRA    28BC
.................... 		switch ( address ) {
27F6:  MOVF   x88,W
27F8:  MOVWF  00
27FA:  MOVF   x89,W
27FC:  MOVWF  03
27FE:  MOVLW  03
2800:  SUBWF  03,W
2802:  BNZ   280E
2804:  MOVLW  E8
2806:  SUBWF  00,W
2808:  MOVLB  0
280A:  BZ    2870
280C:  MOVLB  9
280E:  MOVLW  03
2810:  SUBWF  03,W
2812:  BNZ   281E
2814:  MOVLW  E9
2816:  SUBWF  00,W
2818:  MOVLB  0
281A:  BZ    287A
281C:  MOVLB  9
281E:  MOVLW  03
2820:  SUBWF  03,W
2822:  BNZ   282E
2824:  MOVLW  EA
2826:  SUBWF  00,W
2828:  MOVLB  0
282A:  BZ    2886
282C:  MOVLB  9
282E:  MOVLW  03
2830:  SUBWF  03,W
2832:  BNZ   283E
2834:  MOVLW  EB
2836:  SUBWF  00,W
2838:  MOVLB  0
283A:  BZ    2890
283C:  MOVLB  9
283E:  MOVLW  03
2840:  SUBWF  03,W
2842:  BNZ   284E
2844:  MOVLW  EC
2846:  SUBWF  00,W
2848:  MOVLB  0
284A:  BZ    2898
284C:  MOVLB  9
284E:  MOVLW  03
2850:  SUBWF  03,W
2852:  BNZ   285E
2854:  MOVLW  ED
2856:  SUBWF  00,W
2858:  MOVLB  0
285A:  BZ    28A2
285C:  MOVLB  9
285E:  MOVLW  04
2860:  SUBWF  03,W
2862:  BNZ   286E
2864:  MOVLW  4C
2866:  SUBWF  00,W
2868:  MOVLB  0
286A:  BZ    28AA
286C:  MOVLB  9
286E:  BRA    28B6
.................... 			case 1000: result=config.serial_prefix; break;
2870:  MOVLB  9
2872:  CLRF   x8C
2874:  MOVFF  583,98B
2878:  BRA    28BC
.................... 			case 1001: result=config.serial_number; break;
287A:  MOVFF  585,98C
287E:  MOVFF  584,98B
2882:  MOVLB  9
2884:  BRA    28BC
.................... 			case 1002: result='R'; break;
2886:  MOVLB  9
2888:  CLRF   x8C
288A:  MOVLW  52
288C:  MOVWF  x8B
288E:  BRA    28BC
.................... 			case 1003: result=0; break;
2890:  MOVLB  9
2892:  CLRF   x8C
2894:  CLRF   x8B
2896:  BRA    28BC
.................... 			case 1004: result='4'; break;
2898:  MOVLB  9
289A:  CLRF   x8C
289C:  MOVLW  34
289E:  MOVWF  x8B
28A0:  BRA    28BC
.................... 			case 1005: result=0; break;
28A2:  MOVLB  9
28A4:  CLRF   x8C
28A6:  CLRF   x8B
28A8:  BRA    28BC
.................... 	
.................... 			case 1100: result=config.live_interval; break;
28AA:  MOVFF  587,98C
28AE:  MOVFF  586,98B
28B2:  MOVLB  9
28B4:  BRA    28BC
.................... 	
.................... 			default: return ILLEGAL_DATA_ADDRESS;
28B6:  MOVLW  02
28B8:  MOVWF  01
28BA:  BRA    28EE
.................... 		}
.................... 	}
.................... 
.................... //	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u) result=%lu\r\n",address,n,result);
.................... 
.................... 	query.buff[n]  =make8(result,1);
28BC:  MOVLW  6C
28BE:  ADDWF  x8A,W
28C0:  MOVWF  FE9
28C2:  MOVLW  04
28C4:  MOVWF  FEA
28C6:  BTFSC  FD8.0
28C8:  INCF   FEA,F
28CA:  MOVFF  98C,FEF
.................... 	query.buff[n+1]=make8(result,0);
28CE:  MOVLW  01
28D0:  ADDWF  x8A,W
28D2:  ADDLW  6C
28D4:  MOVWF  FE9
28D6:  MOVLW  04
28D8:  MOVWF  FEA
28DA:  BTFSC  FD8.0
28DC:  INCF   FEA,F
28DE:  MOVFF  98B,FEF
.................... 	query.resultLength += 2;
28E2:  MOVLW  02
28E4:  MOVLB  5
28E6:  ADDWF  x82,F
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u, result=%lu, query.resultLength=%u)\r\n",
.................... 		address,
.................... 		n,
.................... 		result,
.................... 		query.resultLength
.................... 	);
.................... #endif
.................... 
.................... 
.................... 	return 0;
28E8:  MOVLW  00
28EA:  MOVWF  01
28EC:  MOVLB  9
28EE:  MOVLB  0
28F0:  GOTO   294E (RETURN)
.................... }
.................... 
.................... exception query_self_read_registers(int16 address, int8 nRegisters) {
*
291E:  MOVLB  9
2920:  CLRF   x84
.................... 	int8 i;
.................... 	exception e=0;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers (address=%lu, nRegisters=%u)\r\n",address,nRegisters);
.................... #endif
.................... 
.................... 	for ( i=0 ; i<nRegisters && 0==e ; i++ ) {
2922:  CLRF   x83
2924:  MOVF   x82,W
2926:  SUBWF  x83,W
2928:  BC    2958
292A:  MOVF   x84,F
292C:  BNZ   2958
.................... 		e=query_self_read_register(address+i,i*2);
292E:  MOVF   x83,W
2930:  ADDWF  x80,W
2932:  MOVWF  x85
2934:  MOVLW  00
2936:  ADDWFC x81,W
2938:  MOVWF  x86
293A:  BCF    FD8.0
293C:  RLCF   x83,W
293E:  MOVWF  x87
2940:  MOVFF  986,989
2944:  MOVFF  985,988
2948:  MOVWF  x8A
294A:  MOVLB  0
294C:  BRA    2510
294E:  MOVFF  01,984
.................... 	}
.................... 
.................... 
.................... #if DEBUG_ASCII
2952:  MOVLB  9
2954:  INCF   x83,F
2956:  BRA    2924
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers returning e=%u\r\n",e);
.................... #endif
.................... 
.................... 
.................... 	return e;
2958:  MOVFF  984,01
295C:  MOVLB  0
295E:  GOTO   2D10 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void query_self(void) {
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self( query.function=%lu, query.start_address=%lu, query.n_words=%u)\r\n",
.................... 		query.function,
.................... 		query.start_address,
.................... 		query.n_words
.................... 	);
.................... #endif
.................... 
.................... 	query.resultLength=0;
*
2CBC:  MOVLB  5
2CBE:  CLRF   x82
.................... 
.................... 	switch ( query.function ) {
2CC0:  MOVF   x79,W
2CC2:  MOVWF  00
2CC4:  MOVF   x7A,W
2CC6:  MOVWF  03
2CC8:  MOVF   03,W
2CCA:  BNZ   2CD6
2CCC:  MOVLW  03
2CCE:  SUBWF  00,W
2CD0:  MOVLB  0
2CD2:  BZ    2D02
2CD4:  MOVLB  5
2CD6:  MOVF   03,W
2CD8:  BNZ   2CE4
2CDA:  MOVLW  04
2CDC:  SUBWF  00,W
2CDE:  MOVLB  0
2CE0:  BZ    2D02
2CE2:  MOVLB  5
2CE4:  MOVF   03,W
2CE6:  BNZ   2CF2
2CE8:  MOVLW  06
2CEA:  SUBWF  00,W
2CEC:  MOVLB  0
2CEE:  BZ    2D16
2CF0:  MOVLB  5
2CF2:  MOVF   03,W
2CF4:  BNZ   2D00
2CF6:  MOVLW  07
2CF8:  SUBWF  00,W
2CFA:  MOVLB  0
2CFC:  BZ    2D60
2CFE:  MOVLB  5
2D00:  BRA    2D64
.................... 		case DEV_TYPE_MODBUS_3:
.................... 		case DEV_TYPE_MODBUS_4:
.................... 			/* read registers */
.................... 			query.resultException=query_self_read_registers(query.start_address, query.n_words);
2D02:  MOVFF  57C,981
2D06:  MOVFF  57B,980
2D0A:  MOVFF  57D,982
2D0E:  BRA    291E
2D10:  MOVFF  01,581
.................... 			break;
2D14:  BRA    2D6A
.................... 		case DEV_TYPE_MODBUS_6:
.................... 			/* write single register */
.................... 			query.resultException=query_self_write_register(query.start_address, 
.................... 				make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
2D16:  MOVLW  6C
2D18:  MOVLB  5
2D1A:  ADDWF  x7E,W
2D1C:  MOVWF  FE9
2D1E:  MOVLW  04
2D20:  MOVWF  FEA
2D22:  BTFSC  FD8.0
2D24:  INCF   FEA,F
2D26:  MOVFF  FEF,980
2D2A:  MOVLW  01
2D2C:  ADDWF  x7E,W
2D2E:  ADDLW  6C
2D30:  MOVWF  FE9
2D32:  MOVLW  04
2D34:  MOVWF  FEA
2D36:  BTFSC  FD8.0
2D38:  INCF   FEA,F
2D3A:  MOVFF  FEF,981
2D3E:  MOVFF  980,983
2D42:  MOVFF  981,982
2D46:  MOVFF  57C,985
2D4A:  MOVFF  57B,984
2D4E:  MOVFF  980,987
2D52:  MOVFF  981,986
2D56:  MOVLB  0
2D58:  BRA    2962
2D5A:  MOVFF  01,581
.................... 			break;
2D5E:  BRA    2D6A
.................... 		case DEV_TYPE_MODBUS_16:
.................... 			/* write multiple registers */
.................... 			break;
2D60:  BRA    2D6A
2D62:  MOVLB  5
.................... 		default:
.................... 			query.resultException=ILLEGAL_FUNCTION;
2D64:  MOVLW  01
2D66:  MOVWF  x81
.................... 			query.resultLength=0;
2D68:  CLRF   x82
2D6A:  MOVLB  0
.................... 	}
2D6C:  GOTO   3616 (RETURN)
.................... }
.................... 
.................... /*
.................... Remote query (from WorldData to us) syntax
.................... '#'                 0  STX
.................... RECV'R ID PREFIX    1  First character (A-Z) for gateway serial number
.................... RECV'R ID MSB       2  gateway serial number
.................... RECV'R ID LSB       3  
.................... PACKET LENGTH       4  
.................... PACKET TYPE         5  type of packet we are receiving (19)
.................... QUERY ID MSB        6  32 bit query id that we must answer with
.................... QUERY ID            7
.................... QUERY ID            8
.................... QUERY ID LSB        9
.................... QUERY DEV SN MSB    10 32 bit serial number of device to query
.................... QUERY DEV SN        11
.................... QUERY DEV SN        12
.................... QUERY DEV SN LSB    13
.................... Q NETWORK ADDR MSB  14 Network address of device to query, if SN not specified
.................... Q NETWORK ADDR LSB  15
.................... QUERY FUNCTION MSB  16 type of query to perform
.................... QUERY FUNCTION LSB  17
.................... QUERY ADDRESS MSB   18 start address for query
.................... QUERY ADDRESS LSB   19
.................... QUERY N WORDS       20 number of 16-bit words in query data
.................... QUERY DATA[0] MSB   [] first word of query data
.................... QUERY DATA[0] LSB   [+1]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... 
.................... Parse first four bytes for match to our serial number. If matched, receive rest 
.................... of packet and do checksum.
.................... 
.................... Send query to network one of two ways:
.................... if ( 0 != query_dev_sn ) then scan device table to determine network id
.................... else use network id
.................... 
.................... if ( 0==network id || our_serial_number==query_dev_sn ) then use local registers
.................... else perform network query
.................... */
.................... 
.................... void query_reset(void) {
.................... 	query.buff_pos=0;
*
05B8:  MOVLB  5
05BA:  CLRF   x6C
.................... 	
.................... 	/* !buff_ready causes serial receive interrupt to throw out data ... so clear last */
.................... 	query.buff_ready=0;
05BC:  CLRF   x6D
05BE:  MOVLB  0
05C0:  RETURN 0
.................... }
.................... 
.................... /* 
.................... response to remote query (from us to WorldData)
.................... '#'                 0  STX
.................... SERIAL PREFIX       1  First character (A-Z) for serial number
.................... SERIAL MSB          2  high byte of sending station ID
.................... SERIAL LSB          3  low byte of sending station ID
.................... PACKET LENGTH       4  always 0xff
.................... PACKET TYPE         5  type of packet we are sending (20)
.................... PACKET LENGTH MSB   6  number of byte for packet including STX through CRC
.................... PACKET LENGTH LSB   7
.................... QUERY ID MSB        8  32 bit query id that we are answering
.................... QUERY ID            9
.................... QUERY ID            10
.................... QUERY ID LSB        11
.................... QUERY EXCEPTION     12 exception encountered in performing query
.................... QUERY DATA[0] MSB [13] first word of query data
.................... QUERY DATA[0] LSB [14]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... */
.................... void query_response(void) {
.................... 	int8 buff[13];
.................... 	int16 l;
.................... 	int8 i;
.................... 
.................... 	buff[0]='#';
*
3400:  MOVLW  23
3402:  MOVLB  9
3404:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
3406:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
340A:  MOVFF  585,982
340E:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0);
3410:  MOVFF  584,983
3414:  MOVLB  9
.................... 	buff[4]=0xff;
3416:  SETF   x84
.................... 	buff[5]=20;
3418:  MOVLW  14
341A:  MOVWF  x85
.................... 	/* packet length */
.................... 	l=sizeof(buff)+query.resultLength+2;
341C:  MOVLW  0D
341E:  MOVLB  5
3420:  ADDWF  x82,W
3422:  ADDLW  02
3424:  MOVLB  9
3426:  MOVWF  x8D
3428:  CLRF   x8E
342A:  BTFSC  FD8.0
342C:  INCF   x8E,F
.................... 	buff[6]=make8(l,1);
342E:  MOVFF  98E,986
.................... 	buff[7]=make8(l,0);
3432:  MOVFF  98D,987
.................... 
.................... 	buff[8]=make8(query.query_id,3);
3436:  MOVFF  572,988
343A:  MOVLB  9
.................... 	buff[9]=make8(query.query_id,2);
343C:  MOVFF  571,989
3440:  MOVLB  9
.................... 	buff[10]=make8(query.query_id,1);
3442:  MOVFF  570,98A
3446:  MOVLB  9
.................... 	buff[11]=make8(query.query_id,0);
3448:  MOVFF  56F,98B
344C:  MOVLB  9
.................... 	buff[12]=query.resultException;
344E:  MOVFF  581,98C
.................... 
.................... 	/* compute CRC on header (skip STX) and result data */
.................... 	l=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
3452:  SETF   x94
3454:  SETF   x93
3456:  MOVLW  09
3458:  MOVWF  x96
345A:  MOVLW  81
345C:  MOVWF  x95
345E:  MOVLW  0C
3460:  MOVWF  x97
3462:  MOVLB  0
3464:  CALL   1958
3468:  MOVFF  02,98E
346C:  MOVFF  01,98D
.................... 	l=crc_chk_pass(l,query.buff,query.resultLength);
3470:  MOVFF  98E,994
3474:  MOVFF  98D,993
3478:  MOVLW  04
347A:  MOVLB  9
347C:  MOVWF  x96
347E:  MOVLW  6C
3480:  MOVWF  x95
3482:  MOVFF  582,997
3486:  MOVLB  0
3488:  CALL   1958
348C:  MOVFF  02,98E
3490:  MOVFF  01,98D
.................... 
.................... 	output_high(CTRL_0);
3494:  BCF    F92.0
3496:  BSF    F89.0
.................... 	/* send buff, result, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
3498:  MOVLB  9
349A:  CLRF   x8F
349C:  MOVF   x8F,W
349E:  SUBLW  0C
34A0:  BNC   34C2
.................... 		fputc(buff[i],STREAM_WORLD);
34A2:  CLRF   03
34A4:  MOVF   x8F,W
34A6:  ADDLW  80
34A8:  MOVWF  FE9
34AA:  MOVLW  09
34AC:  ADDWFC 03,W
34AE:  MOVWF  FEA
34B0:  MOVFF  FEF,990
34B4:  MOVF   x90,W
34B6:  MOVLB  0
34B8:  CALL   19B6
34BC:  MOVLB  9
34BE:  INCF   x8F,F
34C0:  BRA    349C
.................... 	}	
.................... 	for ( i=0 ; i<query.resultLength ; i++ ) {
34C2:  CLRF   x8F
34C4:  MOVLB  5
34C6:  MOVF   x82,W
34C8:  MOVLB  9
34CA:  SUBWF  x8F,W
34CC:  BC    34EE
.................... 		fputc(query.buff[i],STREAM_WORLD);
34CE:  MOVLW  6C
34D0:  ADDWF  x8F,W
34D2:  MOVWF  FE9
34D4:  MOVLW  04
34D6:  MOVWF  FEA
34D8:  BTFSC  FD8.0
34DA:  INCF   FEA,F
34DC:  MOVFF  FEF,990
34E0:  MOVF   x90,W
34E2:  MOVLB  0
34E4:  CALL   19B6
34E8:  MOVLB  9
34EA:  INCF   x8F,F
34EC:  BRA    34C4
.................... 	}
.................... 	fputc(make8(l,1),STREAM_WORLD);
34EE:  MOVFF  98E,990
34F2:  MOVF   x90,W
34F4:  MOVLB  0
34F6:  CALL   19B6
.................... 	fputc(make8(l,0),STREAM_WORLD);
34FA:  MOVFF  98D,990
34FE:  MOVLB  9
3500:  MOVF   x90,W
3502:  MOVLB  0
3504:  CALL   19B6
.................... 
.................... 
.................... 	delay_ms(10);
3508:  MOVLW  0A
350A:  MOVLB  9
350C:  MOVWF  x90
350E:  MOVLB  0
3510:  CALL   068A
.................... 	output_low(CTRL_0);
3514:  BCF    F92.0
3516:  BCF    F89.0
.................... 
.................... #if 0
3518:  GOTO   3620 (RETURN)
.................... 	fprintf(STREAM_WORLD,"# query result (query.resultLength=%u query.resultException=%u):\r\n",query.resultLength,query.resultException);
.................... 	/* query.resultLength is in bytes  .... result is in 16-bit words */
.................... 	for ( i=0 ; i<query.resultLength ; i+=2 ) {
.................... 		fprintf(STREAM_WORLD,"# query.buff[%u]=%lu (0x%04lX)\r\n",
.................... 			i/2,
.................... 			make16(query.buff[i],query.buff[i+1]),
.................... 			make16(query.buff[i],query.buff[i+1])
.................... 		);
.................... 		query.buff[i]=0xff;
.................... 		query.buff[i+1]=0xff;
.................... 	}
.................... #endif
.................... }
.................... 
.................... /* we received a query addressed to us */
.................... void query_process(void) {
.................... 	int32 our_serial;
.................... //	int8 i;
.................... 	int16 lCRC;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# in query_process()\r\n");
.................... #endif
.................... 
.................... 	query.packet_length=query.buff[4];
351C:  MOVFF  470,56E
.................... 	query.crc=make16(query.buff[query.packet_length-2],query.buff[query.packet_length-1]);	
3520:  MOVLW  02
3522:  MOVLB  5
3524:  SUBWF  x6E,W
3526:  ADDLW  6C
3528:  MOVWF  FE9
352A:  MOVLW  04
352C:  MOVWF  FEA
352E:  BTFSC  FD8.0
3530:  INCF   FEA,F
3532:  MOVFF  FEF,580
3536:  MOVLW  01
3538:  SUBWF  x6E,W
353A:  ADDLW  6C
353C:  MOVWF  FE9
353E:  MOVLW  04
3540:  MOVWF  FEA
3542:  BTFSC  FD8.0
3544:  INCF   FEA,F
3546:  MOVFF  FEF,57F
.................... 	lCRC = crc_chk_pass(0xFFFF,query.buff+1,query.packet_length-3);
354A:  MOVLW  03
354C:  SUBWF  x6E,W
354E:  MOVLB  9
3550:  MOVWF  x80
3552:  SETF   x94
3554:  SETF   x93
3556:  MOVLW  04
3558:  MOVWF  x96
355A:  MOVLW  6D
355C:  MOVWF  x95
355E:  MOVFF  980,997
3562:  MOVLB  0
3564:  CALL   1958
3568:  MOVFF  02,97F
356C:  MOVFF  01,97E
.................... 
.................... 	if ( lCRC != query.crc ) {
3570:  MOVLB  5
3572:  MOVF   x7F,W
3574:  MOVLB  9
3576:  SUBWF  x7E,W
3578:  BNZ   3584
357A:  MOVLB  5
357C:  MOVF   x80,W
357E:  MOVLB  9
3580:  SUBWF  x7F,W
3582:  BZ    3586
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# CRC 0x%04lX != 0x%04lX (LOCAL)\r\n",query.crc,lCRC);
.................... #endif
.................... 		return;
3584:  BRA    3622
.................... 	}
.................... 
.................... 
.................... 	if ( 19 != query.buff[5] ) {
3586:  MOVLB  4
3588:  MOVF   x71,W
358A:  SUBLW  13
358C:  BZ    3594
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# not query type 19 ... don't know how to handle!\r\n");
.................... #endif
.................... 		return;
358E:  MOVLB  9
3590:  BRA    3622
3592:  MOVLB  4
.................... 	}
.................... 
.................... 	
.................... 	query.query_id=make32(query.buff[6],query.buff[7],query.buff[8],query.buff[9]);
3594:  MOVFF  472,572
3598:  MOVFF  473,571
359C:  MOVFF  474,570
35A0:  MOVFF  475,56F
.................... 	query.device_serial=make32(query.buff[10],query.buff[11],query.buff[12],query.buff[13]);
35A4:  MOVFF  476,576
35A8:  MOVFF  477,575
35AC:  MOVFF  478,574
35B0:  MOVFF  479,573
.................... 	query.network_address=make16(query.buff[14],query.buff[15]);
35B4:  MOVFF  47A,578
35B8:  MOVFF  47B,577
.................... 	query.function=make16(query.buff[16],query.buff[17]);
35BC:  MOVFF  47C,57A
35C0:  MOVFF  47D,579
.................... 	query.start_address=make16(query.buff[18],query.buff[19]);
35C4:  MOVFF  47E,57C
35C8:  MOVFF  47F,57B
.................... 	query.n_words=query.buff[20];
35CC:  MOVFF  480,57D
.................... 	query.data_start_offset=21;
35D0:  MOVLW  15
35D2:  MOVLB  5
35D4:  MOVWF  x7E
.................... 	
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# length=%u (query.buff_pos=%u)\r\n",query.packet_length,query.buff_pos);
.................... 	fprintf(STREAM_WORLD,"# query_id=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.query_id,3),
.................... 		make8(query.query_id,2),
.................... 		make8(query.query_id,1),
.................... 		make8(query.query_id,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# device serial=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.device_serial,3),
.................... 		make8(query.device_serial,2),
.................... 		make8(query.device_serial,1),
.................... 		make8(query.device_serial,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# network address=%lu\r\n",query.network_address);
.................... 	fprintf(STREAM_WORLD,"# function=%lu\r\n",query.function);
.................... 	fprintf(STREAM_WORLD,"# start address=%lu\r\n",query.start_address);
.................... 	fprintf(STREAM_WORLD,"# n_words=%u\r\n",query.n_words);
.................... 
.................... 	/* n words can be the number of query words, in which case we won't have any data besides the CRC */
.................... 	for ( i=0 ; i<query.n_words && i<query.packet_length-2 ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# word[%u]=%lu\r\n",i,make16(query.buff[21+i*2],query.buff[22+i*2]));
.................... 	}
.................... 
.................... 	fprintf(STREAM_WORLD,"# rCRC=%lu\r\n",query.crc);
.................... #endif
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# dump whole packet:\r\n");
.................... 	for ( i=0 ; i<query.packet_length ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# buff[%u]=0x%02X",i,query.buff[i]);
.................... 		if ( i==query.data_start_offset )
.................... 			fprintf(STREAM_WORLD," (start)");
.................... 		fprintf(STREAM_WORLD,"\r\n");
.................... 	}
.................... #endif
.................... 
.................... 	query.resultLength=0;
35D6:  CLRF   x82
.................... 	/* check to see who handles this query */
.................... 	our_serial=make32(0,config.serial_prefix,config.serial_number);
35D8:  MOVLB  9
35DA:  CLRF   x7D
35DC:  MOVFF  583,97C
35E0:  MOVFF  584,97A
35E4:  MOVFF  585,97B
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"#   our serial=%c%lu\r\n",config.serial_prefix,config.serial_number);
.................... 	fprintf(STREAM_WORLD,"# query serial=%c%lu\r\n",make8(query.device_serial,2),(int16) query.device_serial);
.................... #endif
.................... 
.................... 	if ( our_serial == query.device_serial ) {
35E8:  MOVLB  5
35EA:  MOVF   x73,W
35EC:  MOVLB  9
35EE:  SUBWF  x7A,W
35F0:  BNZ   361A
35F2:  MOVLB  5
35F4:  MOVF   x74,W
35F6:  MOVLB  9
35F8:  SUBWF  x7B,W
35FA:  BNZ   361A
35FC:  MOVLB  5
35FE:  MOVF   x75,W
3600:  MOVLB  9
3602:  SUBWF  x7C,W
3604:  BNZ   361A
3606:  MOVLB  5
3608:  MOVF   x76,W
360A:  MOVLB  9
360C:  SUBWF  x7D,W
360E:  BNZ   361A
.................... 		query_self();
3610:  MOVLB  0
3612:  GOTO   2CBC
.................... 	} else {
3616:  BRA    361E
3618:  MOVLB  9
.................... 		query_other();
361A:  MOVLB  0
361C:  BRA    30DC
.................... 		
.................... 	}	
.................... 
.................... 	query_response();
361E:  BRA    3400
3620:  MOVLB  9
3622:  MOVLB  0
3624:  GOTO   3808 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void deviceQuery(void) {
.................... 	static int16 measurementNumber=0;
.................... 	static int8  nCycles[DEV_MAX_N];
.................... 	int8 n;
.................... 	int16 l;
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... #endif
.................... 
.................... 	/* check if next cycle will be an SBD transmission. */
.................... 	if ( 1 == timers.sbd_cycle ) {
*
1D44:  MOVLB  3
1D46:  DECFSZ x65,W
1D48:  BRA    1D56
1D4A:  MOVF   x66,F
1D4C:  BNZ   1D56
.................... 		/* next cycle will be an Iridium transmit cycle, so turn on modem and clear outgoing buffer */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() next cycle will be SBD transmit cycle.\r\n");
.................... #endif
.................... //		iridium_on();
.................... 		iridium_mo_clear();
1D4E:  MOVLB  0
1D50:  CALL   137E
1D54:  MOVLB  3
.................... 	}
.................... 
.................... 	/* check if we are going to be doing a SBD transmision */
.................... 	if ( 0 == timers.sbd_cycle ) {
1D56:  MOVF   x65,F
1D58:  BNZ   1DAA
1D5A:  MOVF   x66,F
1D5C:  BNZ   1DAA
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() this cycle is an SBD transmit cycle.\r\n");
.................... #endif
.................... 		/* turn on modem in case it isn't already on */
.................... //		iridium_on();
.................... 		/* clear MO buffer */
.................... 		iridium_mo_clear();
1D5E:  MOVLB  0
1D60:  CALL   137E
.................... 
.................... 		/* build header */
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,1);
1D64:  MOVLB  7
1D66:  MOVFF  7DB,03
1D6A:  MOVF   xDA,W
1D6C:  INCF   xDA,F
1D6E:  BTFSC  FD8.2
1D70:  INCF   xDB,F
1D72:  MOVLB  9
1D74:  MOVWF  x7D
1D76:  MOVLW  CA
1D78:  ADDWF  x7D,W
1D7A:  MOVWF  FE9
1D7C:  MOVLW  06
1D7E:  ADDWFC 03,W
1D80:  MOVWF  FEA
1D82:  MOVFF  938,FEF
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,0);
1D86:  MOVLB  7
1D88:  MOVFF  7DB,03
1D8C:  MOVF   xDA,W
1D8E:  INCF   xDA,F
1D90:  BTFSC  FD8.2
1D92:  INCF   xDB,F
1D94:  MOVLB  9
1D96:  MOVWF  x7D
1D98:  MOVLW  CA
1D9A:  ADDWF  x7D,W
1D9C:  MOVWF  FE9
1D9E:  MOVLW  06
1DA0:  ADDWFC 03,W
1DA2:  MOVWF  FEA
1DA4:  MOVFF  937,FEF
1DA8:  MOVLB  3
.................... 	}
.................... 
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() querying all enabled devices:\r\n");
.................... #endif
.................... 
.................... 	for ( n=0 ; n<DEV_MAX_N ; n++ ) {
1DAA:  MOVLB  9
1DAC:  CLRF   x7A
1DAE:  MOVF   x7A,W
1DB0:  SUBLW  3F
1DB2:  BTFSS  FD8.0
1DB4:  BRA    24B8
.................... 		restart_wdt();
1DB6:  CLRWDT
.................... 		timers.led_on_green=100;
1DB8:  MOVLW  64
1DBA:  MOVLB  3
1DBC:  MOVWF  x64
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[n].type ) 
1DBE:  MOVLB  9
1DC0:  CLRF   x95
1DC2:  MOVFF  97A,994
1DC6:  CLRF   x97
1DC8:  MOVLW  0D
1DCA:  MOVWF  x96
1DCC:  MOVLB  0
1DCE:  CALL   084C
1DD2:  MOVFF  02,97E
1DD6:  MOVFF  01,97D
1DDA:  MOVLW  21
1DDC:  MOVLB  9
1DDE:  ADDWF  01,W
1DE0:  MOVWF  FE9
1DE2:  MOVLW  00
1DE4:  ADDWFC 02,W
1DE6:  MOVWF  FEA
1DE8:  MOVF   FEF,W
1DEA:  BNZ   1DEE
.................... 			continue;
1DEC:  BRA    24B0
.................... 
.................... 		nCycles[n]++;
1DEE:  CLRF   03
1DF0:  MOVF   x7A,W
1DF2:  ADDLW  39
1DF4:  MOVWF  FE9
1DF6:  MOVLW  09
1DF8:  ADDWFC 03,W
1DFA:  MOVWF  FEA
1DFC:  INCF   FEF,F
.................... 		if ( nCycles[n] < device[n].transmitEvery ) {
1DFE:  CLRF   03
1E00:  MOVF   x7A,W
1E02:  ADDLW  39
1E04:  MOVWF  FE9
1E06:  MOVLW  09
1E08:  ADDWFC 03,W
1E0A:  MOVWF  FEA
1E0C:  MOVFF  FEF,97D
1E10:  CLRF   x95
1E12:  MOVFF  97A,994
1E16:  CLRF   x97
1E18:  MOVLW  0D
1E1A:  MOVWF  x96
1E1C:  MOVLB  0
1E1E:  CALL   084C
1E22:  MOVFF  02,97F
1E26:  MOVFF  01,97E
1E2A:  MOVLW  03
1E2C:  MOVLB  9
1E2E:  ADDWF  01,W
1E30:  MOVWF  01
1E32:  MOVLW  00
1E34:  ADDWFC 02,W
1E36:  MOVWF  03
1E38:  MOVF   01,W
1E3A:  ADDLW  21
1E3C:  MOVWF  FE9
1E3E:  MOVLW  00
1E40:  ADDWFC 03,W
1E42:  MOVWF  FEA
1E44:  MOVF   FEF,W
1E46:  SUBWF  x7D,W
1E48:  BC    1E4E
.................... 			continue;
1E4A:  BRA    24B0
.................... 		} else {
1E4C:  BRA    1E5E
.................... 			nCycles[n]=0;
1E4E:  CLRF   03
1E50:  MOVF   x7A,W
1E52:  ADDLW  39
1E54:  MOVWF  FE9
1E56:  MOVLW  09
1E58:  ADDWFC 03,W
1E5A:  MOVWF  FEA
1E5C:  CLRF   FEF
.................... 		}
.................... 
.................... 
.................... 
.................... 		qbuff.deviceNumber=n;
1E5E:  MOVFF  97A,469
.................... 		qbuff.measurementNumber=measurementNumber;
1E62:  MOVFF  938,46B
1E66:  MOVFF  937,46A
.................... 
.................... 
.................... 		if ( device[n].type <= DEV_TYPE_MODBUS_MAX ) {
1E6A:  CLRF   x95
1E6C:  MOVFF  97A,994
1E70:  CLRF   x97
1E72:  MOVLW  0D
1E74:  MOVWF  x96
1E76:  MOVLB  0
1E78:  CALL   084C
1E7C:  MOVFF  02,97E
1E80:  MOVFF  01,97D
1E84:  MOVLW  21
1E86:  MOVLB  9
1E88:  ADDWF  01,W
1E8A:  MOVWF  FE9
1E8C:  MOVLW  00
1E8E:  ADDWFC 02,W
1E90:  MOVWF  FEA
1E92:  MOVF   FEF,W
1E94:  SUBLW  07
1E96:  BTFSS  FD8.0
1E98:  BRA    22AA
.................... 			/* modbus device type */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() MODBUS device\r\n");
.................... #endif
.................... 			/* set serial port speed */
.................... 			if ( DEV_SERIAL_19200 == device[n].serialSpeed ) {
1E9A:  CLRF   x95
1E9C:  MOVFF  97A,994
1EA0:  CLRF   x97
1EA2:  MOVLW  0D
1EA4:  MOVWF  x96
1EA6:  MOVLB  0
1EA8:  CALL   084C
1EAC:  MOVFF  02,97E
1EB0:  MOVFF  01,97D
1EB4:  MOVLW  0C
1EB6:  MOVLB  9
1EB8:  ADDWF  01,W
1EBA:  MOVWF  01
1EBC:  MOVLW  00
1EBE:  ADDWFC 02,W
1EC0:  MOVWF  03
1EC2:  MOVF   01,W
1EC4:  ADDLW  21
1EC6:  MOVWF  FE9
1EC8:  MOVLW  00
1ECA:  ADDWFC 03,W
1ECC:  MOVWF  FEA
1ECE:  MOVF   FEF,W
1ED0:  SUBLW  01
1ED2:  BNZ   1EE4
.................... 				set_uart_speed(19200,MODBUS_SERIAL);
1ED4:  BCF    FA7.3
1ED6:  MOVLW  19
1ED8:  MOVWF  FAF
1EDA:  MOVLW  A6
1EDC:  MOVWF  FAC
1EDE:  MOVLW  90
1EE0:  MOVWF  FAB
.................... 			} else {
1EE2:  BRA    1EF2
.................... 				set_uart_speed(9600,MODBUS_SERIAL);
1EE4:  BCF    FA7.3
1EE6:  MOVLW  0C
1EE8:  MOVWF  FAF
1EEA:  MOVLW  A2
1EEC:  MOVWF  FAC
1EEE:  MOVLW  90
1EF0:  MOVWF  FAB
.................... 			}
.................... 
.................... 			if ( DEV_TYPE_MODBUS_3 == device[n].type || DEV_TYPE_MODBUS_4 == device[n].type ) {
1EF2:  CLRF   x95
1EF4:  MOVFF  97A,994
1EF8:  CLRF   x97
1EFA:  MOVLW  0D
1EFC:  MOVWF  x96
1EFE:  MOVLB  0
1F00:  CALL   084C
1F04:  MOVFF  02,97E
1F08:  MOVFF  01,97D
1F0C:  MOVLW  21
1F0E:  MOVLB  9
1F10:  ADDWF  01,W
1F12:  MOVWF  FE9
1F14:  MOVLW  00
1F16:  ADDWFC 02,W
1F18:  MOVWF  FEA
1F1A:  MOVF   FEF,W
1F1C:  SUBLW  03
1F1E:  BZ    1F50
1F20:  CLRF   x95
1F22:  MOVFF  97A,994
1F26:  CLRF   x97
1F28:  MOVLW  0D
1F2A:  MOVWF  x96
1F2C:  MOVLB  0
1F2E:  CALL   084C
1F32:  MOVFF  02,980
1F36:  MOVFF  01,97F
1F3A:  MOVLW  21
1F3C:  MOVLB  9
1F3E:  ADDWF  01,W
1F40:  MOVWF  FE9
1F42:  MOVLW  00
1F44:  ADDWFC 02,W
1F46:  MOVWF  FEA
1F48:  MOVF   FEF,W
1F4A:  SUBLW  04
1F4C:  BTFSS  FD8.2
1F4E:  BRA    2148
.................... 				/* Modbus read input or holding registers */
.................... 				if ( DEV_TYPE_MODBUS_4 == device[n].type ) {
1F50:  CLRF   x95
1F52:  MOVFF  97A,994
1F56:  CLRF   x97
1F58:  MOVLW  0D
1F5A:  MOVWF  x96
1F5C:  MOVLB  0
1F5E:  CALL   084C
1F62:  MOVFF  02,97E
1F66:  MOVFF  01,97D
1F6A:  MOVLW  21
1F6C:  MOVLB  9
1F6E:  ADDWF  01,W
1F70:  MOVWF  FE9
1F72:  MOVLW  00
1F74:  ADDWFC 02,W
1F76:  MOVWF  FEA
1F78:  MOVF   FEF,W
1F7A:  SUBLW  04
1F7C:  BNZ   2044
.................... 					qbuff.rException=modbus_read_input_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
1F7E:  CLRF   x95
1F80:  MOVFF  97A,994
1F84:  CLRF   x97
1F86:  MOVLW  0D
1F88:  MOVWF  x96
1F8A:  MOVLB  0
1F8C:  CALL   084C
1F90:  MOVFF  02,97E
1F94:  MOVFF  01,97D
1F98:  MOVLW  04
1F9A:  MOVLB  9
1F9C:  ADDWF  01,W
1F9E:  MOVWF  01
1FA0:  MOVLW  00
1FA2:  ADDWFC 02,W
1FA4:  MOVWF  03
1FA6:  MOVF   01,W
1FA8:  ADDLW  21
1FAA:  MOVWF  FE9
1FAC:  MOVLW  00
1FAE:  ADDWFC 03,W
1FB0:  MOVWF  FEA
1FB2:  MOVFF  FEF,97D
1FB6:  CLRF   x95
1FB8:  MOVFF  97A,994
1FBC:  CLRF   x97
1FBE:  MOVLW  0D
1FC0:  MOVWF  x96
1FC2:  MOVLB  0
1FC4:  CALL   084C
1FC8:  MOVFF  01,97E
1FCC:  MOVLW  09
1FCE:  MOVLB  9
1FD0:  ADDWF  01,W
1FD2:  MOVWF  01
1FD4:  MOVLW  00
1FD6:  ADDWFC 02,W
1FD8:  MOVWF  03
1FDA:  MOVF   01,W
1FDC:  ADDLW  21
1FDE:  MOVWF  FE9
1FE0:  MOVLW  00
1FE2:  ADDWFC 03,W
1FE4:  MOVWF  FEA
1FE6:  MOVFF  FEC,97F
1FEA:  MOVF   FED,F
1FEC:  MOVFF  FEF,97E
1FF0:  CLRF   x95
1FF2:  MOVFF  97A,994
1FF6:  CLRF   x97
1FF8:  MOVLW  0D
1FFA:  MOVWF  x96
1FFC:  MOVLB  0
1FFE:  CALL   084C
2002:  MOVFF  02,981
2006:  MOVFF  01,980
200A:  MOVLW  0B
200C:  MOVLB  9
200E:  ADDWF  01,W
2010:  MOVWF  01
2012:  MOVLW  00
2014:  ADDWFC 02,W
2016:  MOVWF  03
2018:  MOVF   01,W
201A:  ADDLW  21
201C:  MOVWF  FE9
201E:  MOVLW  00
2020:  ADDWFC 03,W
2022:  MOVWF  FEA
2024:  MOVFF  FEF,985
2028:  MOVFF  97D,982
202C:  MOVFF  97F,984
2030:  MOVFF  97E,983
2034:  CLRF   x86
2036:  MOVLB  0
2038:  CALL   1828
203C:  MOVFF  01,367
.................... 				} else {
2040:  BRA    2106
2042:  MOVLB  9
.................... 					qbuff.rException=modbus_read_holding_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
2044:  CLRF   x95
2046:  MOVFF  97A,994
204A:  CLRF   x97
204C:  MOVLW  0D
204E:  MOVWF  x96
2050:  MOVLB  0
2052:  CALL   084C
2056:  MOVFF  02,97E
205A:  MOVFF  01,97D
205E:  MOVLW  04
2060:  MOVLB  9
2062:  ADDWF  01,W
2064:  MOVWF  01
2066:  MOVLW  00
2068:  ADDWFC 02,W
206A:  MOVWF  03
206C:  MOVF   01,W
206E:  ADDLW  21
2070:  MOVWF  FE9
2072:  MOVLW  00
2074:  ADDWFC 03,W
2076:  MOVWF  FEA
2078:  MOVFF  FEF,97D
207C:  CLRF   x95
207E:  MOVFF  97A,994
2082:  CLRF   x97
2084:  MOVLW  0D
2086:  MOVWF  x96
2088:  MOVLB  0
208A:  CALL   084C
208E:  MOVFF  01,97E
2092:  MOVLW  09
2094:  MOVLB  9
2096:  ADDWF  01,W
2098:  MOVWF  01
209A:  MOVLW  00
209C:  ADDWFC 02,W
209E:  MOVWF  03
20A0:  MOVF   01,W
20A2:  ADDLW  21
20A4:  MOVWF  FE9
20A6:  MOVLW  00
20A8:  ADDWFC 03,W
20AA:  MOVWF  FEA
20AC:  MOVFF  FEC,97F
20B0:  MOVF   FED,F
20B2:  MOVFF  FEF,97E
20B6:  CLRF   x95
20B8:  MOVFF  97A,994
20BC:  CLRF   x97
20BE:  MOVLW  0D
20C0:  MOVWF  x96
20C2:  MOVLB  0
20C4:  CALL   084C
20C8:  MOVFF  02,981
20CC:  MOVFF  01,980
20D0:  MOVLW  0B
20D2:  MOVLB  9
20D4:  ADDWF  01,W
20D6:  MOVWF  01
20D8:  MOVLW  00
20DA:  ADDWFC 02,W
20DC:  MOVWF  03
20DE:  MOVF   01,W
20E0:  ADDLW  21
20E2:  MOVWF  FE9
20E4:  MOVLW  00
20E6:  ADDWFC 03,W
20E8:  MOVWF  FEA
20EA:  MOVFF  FEF,985
20EE:  MOVFF  97D,982
20F2:  MOVFF  97F,984
20F6:  MOVFF  97E,983
20FA:  CLRF   x86
20FC:  MOVLB  0
20FE:  CALL   18C0
2102:  MOVFF  01,367
.................... 				}
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
2106:  MOVLB  3
2108:  MOVF   x67,F
210A:  BNZ   2144
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
210C:  MOVLW  01
210E:  MOVLB  5
2110:  SUBWF  x94,W
2112:  MOVLB  4
2114:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
2116:  MOVLW  01
2118:  MOVLB  5
211A:  SUBWF  x94,W
211C:  MOVLB  9
211E:  MOVWF  x7D
2120:  MOVLW  03
2122:  MOVWF  FEA
2124:  MOVLW  68
2126:  MOVWF  FE9
2128:  MOVLW  05
212A:  MOVWF  FE2
212C:  MOVLW  98
212E:  MOVWF  FE1
2130:  MOVF   x7D,W
2132:  MOVWF  01
2134:  BZ    213E
2136:  MOVFF  FE6,FEE
213A:  DECFSZ 01,F
213C:  BRA    2136
.................... 
.................... 					live_send();
213E:  MOVLB  0
2140:  RCALL  19BE
2142:  MOVLB  3
.................... 				}
.................... 			} else if ( DEV_TYPE_MODBUS_1==device[n].type || DEV_TYPE_MODBUS_2==device[n].type ) {
2144:  BRA    22A6
2146:  MOVLB  9
2148:  CLRF   x95
214A:  MOVFF  97A,994
214E:  CLRF   x97
2150:  MOVLW  0D
2152:  MOVWF  x96
2154:  MOVLB  0
2156:  CALL   084C
215A:  MOVFF  02,97E
215E:  MOVFF  01,97D
2162:  MOVLW  21
2164:  MOVLB  9
2166:  ADDWF  01,W
2168:  MOVWF  FE9
216A:  MOVLW  00
216C:  ADDWFC 02,W
216E:  MOVWF  FEA
2170:  MOVF   FEF,W
2172:  SUBLW  01
2174:  BZ    21A6
2176:  CLRF   x95
2178:  MOVFF  97A,994
217C:  CLRF   x97
217E:  MOVLW  0D
2180:  MOVWF  x96
2182:  MOVLB  0
2184:  CALL   084C
2188:  MOVFF  02,980
218C:  MOVFF  01,97F
2190:  MOVLW  21
2192:  MOVLB  9
2194:  ADDWF  01,W
2196:  MOVWF  FE9
2198:  MOVLW  00
219A:  ADDWFC 02,W
219C:  MOVWF  FEA
219E:  MOVF   FEF,W
21A0:  SUBLW  02
21A2:  BTFSS  FD8.2
21A4:  BRA    22A8
.................... 				/* Modbus read coil or discrete input */
.................... 				qbuff.rException=modbus_read_coils(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
21A6:  CLRF   x95
21A8:  MOVFF  97A,994
21AC:  CLRF   x97
21AE:  MOVLW  0D
21B0:  MOVWF  x96
21B2:  MOVLB  0
21B4:  CALL   084C
21B8:  MOVFF  02,97E
21BC:  MOVFF  01,97D
21C0:  MOVLW  04
21C2:  MOVLB  9
21C4:  ADDWF  01,W
21C6:  MOVWF  01
21C8:  MOVLW  00
21CA:  ADDWFC 02,W
21CC:  MOVWF  03
21CE:  MOVF   01,W
21D0:  ADDLW  21
21D2:  MOVWF  FE9
21D4:  MOVLW  00
21D6:  ADDWFC 03,W
21D8:  MOVWF  FEA
21DA:  MOVFF  FEF,97D
21DE:  CLRF   x95
21E0:  MOVFF  97A,994
21E4:  CLRF   x97
21E6:  MOVLW  0D
21E8:  MOVWF  x96
21EA:  MOVLB  0
21EC:  CALL   084C
21F0:  MOVFF  01,97E
21F4:  MOVLW  09
21F6:  MOVLB  9
21F8:  ADDWF  01,W
21FA:  MOVWF  01
21FC:  MOVLW  00
21FE:  ADDWFC 02,W
2200:  MOVWF  03
2202:  MOVF   01,W
2204:  ADDLW  21
2206:  MOVWF  FE9
2208:  MOVLW  00
220A:  ADDWFC 03,W
220C:  MOVWF  FEA
220E:  MOVFF  FEC,97F
2212:  MOVF   FED,F
2214:  MOVFF  FEF,97E
2218:  CLRF   x95
221A:  MOVFF  97A,994
221E:  CLRF   x97
2220:  MOVLW  0D
2222:  MOVWF  x96
2224:  MOVLB  0
2226:  CALL   084C
222A:  MOVFF  02,981
222E:  MOVFF  01,980
2232:  MOVLW  0B
2234:  MOVLB  9
2236:  ADDWF  01,W
2238:  MOVWF  01
223A:  MOVLW  00
223C:  ADDWFC 02,W
223E:  MOVWF  03
2240:  MOVF   01,W
2242:  ADDLW  21
2244:  MOVWF  FE9
2246:  MOVLW  00
2248:  ADDWFC 03,W
224A:  MOVWF  FEA
224C:  MOVFF  FEF,985
2250:  MOVFF  97D,982
2254:  MOVFF  97F,984
2258:  MOVFF  97E,983
225C:  CLRF   x86
225E:  MOVLB  0
2260:  RCALL  1C22
2262:  MOVFF  01,367
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
2266:  MOVLB  3
2268:  MOVF   x67,F
226A:  BNZ   22A6
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
226C:  MOVLW  01
226E:  MOVLB  5
2270:  SUBWF  x94,W
2272:  MOVLB  4
2274:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
2276:  MOVLW  01
2278:  MOVLB  5
227A:  SUBWF  x94,W
227C:  MOVLB  9
227E:  MOVWF  x7D
2280:  MOVLW  03
2282:  MOVWF  FEA
2284:  MOVLW  68
2286:  MOVWF  FE9
2288:  MOVLW  05
228A:  MOVWF  FE2
228C:  MOVLW  98
228E:  MOVWF  FE1
2290:  MOVF   x7D,W
2292:  MOVWF  01
2294:  BZ    229E
2296:  MOVFF  FE6,FEE
229A:  DECFSZ 01,F
229C:  BRA    2296
.................... 
.................... 					live_send();
229E:  MOVLB  0
22A0:  CALL   19BE
22A4:  MOVLB  3
22A6:  MOVLB  9
.................... 				}
.................... 			}
.................... 		} else if ( device[n].type <= DEV_TYPE_I2C_MAX ) {
22A8:  BRA    240A
22AA:  CLRF   x95
22AC:  MOVFF  97A,994
22B0:  CLRF   x97
22B2:  MOVLW  0D
22B4:  MOVWF  x96
22B6:  MOVLB  0
22B8:  CALL   084C
22BC:  MOVFF  02,97E
22C0:  MOVFF  01,97D
22C4:  MOVLW  21
22C6:  MOVLB  9
22C8:  ADDWF  01,W
22CA:  MOVWF  FE9
22CC:  MOVLW  00
22CE:  ADDWFC 02,W
22D0:  MOVWF  FEA
22D2:  MOVF   FEF,W
22D4:  SUBLW  17
22D6:  BTFSS  FD8.0
22D8:  BRA    240A
.................... 			/* I2C device */
.................... 
.................... #if DEBUG_ASCII
.................... 			restart_wdt();
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() I2C device\r\n");
.................... 			fprintf(STREAM_WORLD,"device[%u]\r\n",n);
.................... 			fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[n].type);
.................... 			fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[n].transmitEvery);
.................... 			fprintf(STREAM_WORLD,"\tnetworkAddress=0x%02x\r\n",device[n].networkAddress);
.................... 			fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 				make8(device[n].serialNumber,3),
.................... 				make8(device[n].serialNumber,2),
.................... 				make8(device[n].serialNumber,1),
.................... 				make8(device[n].serialNumber,0)
.................... 			);
.................... 			fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[n].startRegister);
.................... 			fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[n].nRegisters);
.................... #endif
.................... 
.................... 			if ( DEV_TYPE_I2C_READ_8 == device[n].type ) {
22DA:  CLRF   x95
22DC:  MOVFF  97A,994
22E0:  CLRF   x97
22E2:  MOVLW  0D
22E4:  MOVWF  x96
22E6:  MOVLB  0
22E8:  CALL   084C
22EC:  MOVFF  02,97E
22F0:  MOVFF  01,97D
22F4:  MOVLW  21
22F6:  MOVLB  9
22F8:  ADDWF  01,W
22FA:  MOVWF  FE9
22FC:  MOVLW  00
22FE:  ADDWFC 02,W
2300:  MOVWF  FEA
2302:  MOVF   FEF,W
2304:  SUBLW  10
2306:  BTFSS  FD8.2
2308:  BRA    240A
.................... 				/* start a read at start address then just read a byte at a time. nRegisters is bytes */
.................... //fprintf(STREAM_WORLD,"z");
.................... 				i2c_buff_read(device[n].networkAddress, device[n].startRegister, qbuff.rResult, device[n].nRegisters);
230A:  CLRF   x95
230C:  MOVFF  97A,994
2310:  CLRF   x97
2312:  MOVLW  0D
2314:  MOVWF  x96
2316:  MOVLB  0
2318:  CALL   084C
231C:  MOVFF  02,97E
2320:  MOVFF  01,97D
2324:  MOVLW  04
2326:  MOVLB  9
2328:  ADDWF  01,W
232A:  MOVWF  01
232C:  MOVLW  00
232E:  ADDWFC 02,W
2330:  MOVWF  03
2332:  MOVF   01,W
2334:  ADDLW  21
2336:  MOVWF  FE9
2338:  MOVLW  00
233A:  ADDWFC 03,W
233C:  MOVWF  FEA
233E:  MOVFF  FEF,97D
2342:  CLRF   x95
2344:  MOVFF  97A,994
2348:  CLRF   x97
234A:  MOVLW  0D
234C:  MOVWF  x96
234E:  MOVLB  0
2350:  CALL   084C
2354:  MOVFF  01,97E
2358:  MOVLW  09
235A:  MOVLB  9
235C:  ADDWF  01,W
235E:  MOVWF  01
2360:  MOVLW  00
2362:  ADDWFC 02,W
2364:  MOVWF  03
2366:  MOVF   01,W
2368:  ADDLW  21
236A:  MOVWF  FE9
236C:  MOVLW  00
236E:  ADDWFC 03,W
2370:  MOVWF  FEA
2372:  MOVFF  FEC,97F
2376:  MOVF   FED,F
2378:  MOVFF  FEF,97E
237C:  CLRF   x95
237E:  MOVFF  97A,994
2382:  CLRF   x97
2384:  MOVLW  0D
2386:  MOVWF  x96
2388:  MOVLB  0
238A:  CALL   084C
238E:  MOVFF  02,981
2392:  MOVFF  01,980
2396:  MOVLW  0B
2398:  MOVLB  9
239A:  ADDWF  01,W
239C:  MOVWF  01
239E:  MOVLW  00
23A0:  ADDWFC 02,W
23A2:  MOVWF  03
23A4:  MOVF   01,W
23A6:  ADDLW  21
23A8:  MOVWF  FE9
23AA:  MOVLW  00
23AC:  ADDWFC 03,W
23AE:  MOVWF  FEA
23B0:  MOVFF  FEF,986
23B4:  MOVFF  97D,982
23B8:  MOVFF  97E,983
23BC:  MOVLW  03
23BE:  MOVWF  x85
23C0:  MOVLW  68
23C2:  MOVWF  x84
23C4:  MOVLB  0
23C6:  RCALL  1CBA
.................... 
.................... 				qbuff.rException=0;
23C8:  MOVLB  3
23CA:  CLRF   x67
.................... 				qbuff.rResultLength=device[n].nRegisters;
23CC:  MOVLB  9
23CE:  CLRF   x95
23D0:  MOVFF  97A,994
23D4:  CLRF   x97
23D6:  MOVLW  0D
23D8:  MOVWF  x96
23DA:  MOVLB  0
23DC:  CALL   084C
23E0:  MOVFF  01,97D
23E4:  MOVLW  0B
23E6:  MOVLB  9
23E8:  ADDWF  01,W
23EA:  MOVWF  01
23EC:  MOVLW  00
23EE:  ADDWFC 02,W
23F0:  MOVWF  03
23F2:  MOVF   01,W
23F4:  ADDLW  21
23F6:  MOVWF  FE9
23F8:  MOVLW  00
23FA:  ADDWFC 03,W
23FC:  MOVWF  FEA
23FE:  MOVFF  FEF,468
.................... //fprintf(STREAM_WORLD,"Z");
.................... #if DEBUG_ASCII
.................... 				/* debug dump */
.................... 				restart_wdt();
.................... 				for ( i=0 ; i<device[n].nRegisters ; i++ ) {
.................... 					fprintf(STREAM_WORLD,"# reg addr[0x%02x]=0x%02x (%u)\r\n",i+device[n].startRegister,qbuff.rResult[i],qbuff.rResult[i]);
.................... 				}
.................... #endif
.................... 
.................... 				live_send();
2402:  MOVLB  0
2404:  CALL   19BE
2408:  MOVLB  9
.................... 
.................... 			}
.................... 
.................... 		} else {
.................... 			/* local */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() local (not implemented) device\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* Add data to SBD if this is an SBD cycle and we have valid data */
.................... 		if ( 0 == timers.sbd_cycle && 0 == qbuff.rException ) {
240A:  MOVLB  3
240C:  MOVF   x65,F
240E:  BNZ   24B2
2410:  MOVF   x66,F
2412:  BNZ   24B2
2414:  MOVF   x67,F
2416:  BNZ   24B2
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() adding to sbd.mo_buff since qbuff.rException=0\r\n");
.................... #endif
.................... 			/* sub-header, 2 bytes, device number, and data length */
.................... 			sbd.mo_buff[sbd.mo_length++]=n;
2418:  MOVLB  7
241A:  MOVFF  7DB,03
241E:  MOVF   xDA,W
2420:  INCF   xDA,F
2422:  BTFSC  FD8.2
2424:  INCF   xDB,F
2426:  MOVLB  9
2428:  MOVWF  x7D
242A:  MOVLW  CA
242C:  ADDWF  x7D,W
242E:  MOVWF  FE9
2430:  MOVLW  06
2432:  ADDWFC 03,W
2434:  MOVWF  FEA
2436:  MOVFF  97A,FEF
.................... 			sbd.mo_buff[sbd.mo_length++]=qbuff.rResultLength;
243A:  MOVLB  7
243C:  MOVFF  7DB,03
2440:  MOVF   xDA,W
2442:  INCF   xDA,F
2444:  BTFSC  FD8.2
2446:  INCF   xDB,F
2448:  MOVLB  9
244A:  MOVWF  x7D
244C:  MOVLW  CA
244E:  ADDWF  x7D,W
2450:  MOVWF  FE9
2452:  MOVLW  06
2454:  ADDWFC 03,W
2456:  MOVWF  FEA
2458:  MOVFF  468,FEF
.................... 		
.................... 			/* sub-message */
.................... 			for ( l=0 ; l<qbuff.rResultLength ; l++ ) {
245C:  CLRF   x7C
245E:  CLRF   x7B
2460:  MOVF   x7C,F
2462:  BNZ   24B0
2464:  MOVLB  4
2466:  MOVF   x68,W
2468:  MOVLB  9
246A:  SUBWF  x7B,W
246C:  BC    24B0
.................... 				sbd.mo_buff[sbd.mo_length++]=qBuff.rResult[l];
246E:  MOVLB  7
2470:  MOVFF  7DB,97E
2474:  MOVF   xDA,W
2476:  INCF   xDA,F
2478:  BTFSC  FD8.2
247A:  INCF   xDB,F
247C:  MOVLB  9
247E:  MOVWF  x7D
2480:  MOVLW  CA
2482:  ADDWF  x7D,W
2484:  MOVWF  01
2486:  MOVLW  06
2488:  ADDWFC x7E,W
248A:  MOVWF  03
248C:  MOVLW  68
248E:  ADDWF  x7B,W
2490:  MOVWF  FE9
2492:  MOVLW  03
2494:  ADDWFC x7C,W
2496:  MOVWF  FEA
2498:  MOVFF  FEF,981
249C:  MOVFF  03,FEA
24A0:  MOVFF  01,FE9
24A4:  MOVFF  981,FEF
24A8:  INCF   x7B,F
24AA:  BTFSC  FD8.2
24AC:  INCF   x7C,F
24AE:  BRA    2460
24B0:  MOVLB  3
.................... 			}
.................... 		}
24B2:  MOVLB  9
24B4:  INCF   x7A,F
24B6:  BRA    1DAE
.................... 
.................... 	}
.................... 
.................... 	/* if we have data to send, then we sent it */
.................... 	if ( 0 == timers.sbd_cycle && sbd.mo_length > 0 ) {
24B8:  MOVLB  3
24BA:  MOVF   x65,F
24BC:  BNZ   24DA
24BE:  MOVF   x66,F
24C0:  BNZ   24DA
24C2:  MOVLB  7
24C4:  MOVF   xDA,F
24C6:  BNZ   24D2
24C8:  MOVF   xDB,F
24CA:  BTFSS  FD8.2
24CC:  BRA    24D2
24CE:  MOVLB  3
24D0:  BRA    24DA
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() setting sbd.mo_state=1\r\n");
.................... #endif
.................... 		sbd.mo_state=1;
24D2:  MOVLW  01
24D4:  MOVLB  6
24D6:  MOVWF  xC9
24D8:  MOVLB  3
.................... 	}
.................... 
.................... 	measurementNumber++;
24DA:  MOVLB  9
24DC:  INCF   x37,F
24DE:  BTFSC  FD8.2
24E0:  INCF   x38,F
.................... 
.................... 	if ( 0 == timers.sbd_cycle ) {
24E2:  MOVLB  3
24E4:  MOVF   x65,F
24E6:  BNZ   2502
24E8:  MOVF   x66,F
24EA:  BNZ   2502
.................... 		timers.sbd_cycle=(config.sbd_every-1);
24EC:  MOVLW  01
24EE:  MOVLB  5
24F0:  SUBWF  x89,W
24F2:  MOVLB  3
24F4:  MOVWF  x65
24F6:  MOVLW  00
24F8:  MOVLB  5
24FA:  SUBWFB x8A,W
24FC:  MOVLB  3
24FE:  MOVWF  x66
.................... 	} else {
2500:  BRA    250A
.................... 		timers.sbd_cycle--;
2502:  MOVF   x65,W
2504:  BTFSC  FD8.2
2506:  DECF   x66,F
2508:  DECF   x65,F
.................... 	}
250A:  MOVLB  0
250C:  GOTO   37FC (RETURN)
.................... }
.................... 
.................... void init() {
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
06BA:  MOVLW  62
06BC:  MOVWF  FD3
06BE:  CLRF   F9B
06C0:  CLRF   F64
.................... 	setup_adc_ports(NO_ANALOGS);
06C2:  MOVLB  F
06C4:  MOVF   x5C,W
06C6:  ANDLW  80
06C8:  MOVWF  x5C
06CA:  MOVLW  00
06CC:  MOVWF  x5D
06CE:  BCF    FC1.3
06D0:  BCF    FC1.4
06D2:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
06D4:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
06D6:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
06D8:  MOVLW  1F
06DA:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
06DC:  MOVLW  F0
06DE:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
06E0:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
06E2:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
06E4:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
06E6:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
06E8:  BCF    F94.5
06EA:  BCF    F8B.5
.................... 
.................... 	setup_timer_4(T4_DIV_BY_16,77,16); 
06EC:  MOVLW  78
06EE:  IORLW  06
06F0:  MOVWF  F88
06F2:  MOVLW  4D
06F4:  MOVWF  FA9
.................... 	enable_interrupts(INT_TIMER4);	
06F6:  BSF    FB6.7
.................... 
.................... 	/* global structures initialized to 0, set something else below if needed */
.................... 	timers.now_poll=1;
06F8:  MOVLW  01
06FA:  MOVLB  3
06FC:  MOVWF  x61
.................... 	timers.sbd_cycle=1; /* next packet will be an SBD packet */
06FE:  CLRF   x66
0700:  MOVWF  x65
.................... 	timers.world_timeout=255;
0702:  SETF   x62
.................... 	timers.factory_unlocked=0;
0704:  CLRF   x63
.................... 	timers.led_on_green=0;
0706:  CLRF   x64
.................... 
.................... 	query_reset();
0708:  MOVLB  0
070A:  RCALL  05B8
.................... 
.................... 	/* receive data from serial ports */
.................... 	enable_interrupts(INT_RDA2);
070C:  BSF    FA3.5
.................... 
.................... #if MCP3208_ENABLED
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
.................... #endif
.................... 
.................... 
.................... 	if ( config.sbd_config ) {
070E:  MOVLB  5
0710:  MOVF   x88,F
0712:  BZ    0720
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# init() initializing I2C Uart for SBD @ 19200\r\n");
.................... #endif
.................... 		/* initialize I2C UART for Iridium @ 19200 */
.................... 		uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
0714:  MOVLW  06
0716:  MOVLB  9
0718:  MOVWF  x7A
071A:  MOVLB  0
071C:  BRA    061E
071E:  MOVLB  5
.................... 	}
.................... 
.................... 	delay_ms(14);
0720:  MOVLW  0E
0722:  MOVLB  9
0724:  MOVWF  x90
0726:  MOVLB  0
0728:  RCALL  068A
072A:  GOTO   36F2 (RETURN)
.................... }
.................... 
.................... void main(void) {
*
3628:  CLRF   FF8
362A:  BCF    FD0.7
362C:  BSF    07.7
362E:  MOVLW  62
3630:  MOVWF  FD3
3632:  CLRF   F9B
3634:  CLRF   F64
3636:  CLRF   20
3638:  BSF    FB9.3
363A:  MOVLW  22
363C:  MOVWF  F7B
363E:  MOVLW  00
3640:  MOVWF  F7C
3642:  MOVLW  A6
3644:  MOVWF  FBA
3646:  MOVLW  90
3648:  MOVWF  FA6
364A:  BSF    F94.3
364C:  BSF    F94.4
364E:  MOVLW  04
3650:  MOVWF  FC8
3652:  MOVLW  28
3654:  MOVWF  FC6
3656:  BCF    FC7.7
3658:  BCF    FC7.6
365A:  BCF    FA7.3
365C:  MOVLW  0C
365E:  MOVWF  FAF
3660:  MOVLW  A2
3662:  MOVWF  FAC
3664:  MOVLW  90
3666:  MOVWF  FAB
3668:  MOVLB  5
366A:  CLRF   x8E
366C:  MOVLW  01
366E:  MOVWF  x8D
3670:  MOVLW  86
3672:  MOVWF  x8C
3674:  MOVLW  A0
3676:  MOVWF  x8B
3678:  BCF    x8F.0
367A:  CLRF   x90
367C:  MOVLB  9
367E:  CLRF   x2A
3680:  CLRF   x29
3682:  MOVLB  F
3684:  MOVF   x5C,W
3686:  ANDLW  80
3688:  MOVWF  x5C
368A:  MOVLW  00
368C:  MOVWF  x5D
368E:  BCF    FC1.3
3690:  BCF    FC1.4
3692:  BCF    FC1.5
3694:  CLRF   x5E
3696:  CLRF   x5F
3698:  BRA    36AE
369A:  DATA 02,00
369C:  DATA 1A,00
369E:  DATA 00,FF
36A0:  DATA 46,96
36A2:  DATA 00,FF
36A4:  DATA C0,00
36A6:  DATA 95,C0
36A8:  DATA 00,4E
36AA:  DATA 49,2B
36AC:  DATA 00,00
36AE:  MOVLW  00
36B0:  MOVWF  FF8
36B2:  MOVLW  36
36B4:  MOVWF  FF7
36B6:  MOVLW  9A
36B8:  MOVWF  FF6
36BA:  TBLRD*+
36BC:  MOVF   FF5,W
36BE:  MOVWF  00
36C0:  XORLW  00
36C2:  BZ    36EA
36C4:  TBLRD*+
36C6:  MOVF   FF5,W
36C8:  MOVWF  01
36CA:  BTFSC  FE8.7
36CC:  BRA    36D8
36CE:  ANDLW  3F
36D0:  MOVWF  FEA
36D2:  TBLRD*+
36D4:  MOVFF  FF5,FE9
36D8:  BTFSC  01.6
36DA:  TBLRD*+
36DC:  BTFSS  01.6
36DE:  TBLRD*+
36E0:  MOVFF  FF5,FEE
36E4:  DCFSNZ 00,F
36E6:  BRA    36BA
36E8:  BRA    36DC
36EA:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	/* normal device startup */
.................... 	init();
36EC:  MOVLB  0
36EE:  GOTO   06BA
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking wait\r\n");
.................... #endif
.................... 	for ( i=0 ; i<STARTUP_BLINKS ; i++ ) {
36F2:  MOVLB  9
36F4:  CLRF   x79
36F6:  MOVF   x79,W
36F8:  SUBLW  95
36FA:  BNC   3722
.................... 		restart_wdt();
36FC:  CLRWDT
.................... 
.................... 		output_high(LED_GREEN);
36FE:  BCF    F93.5
3700:  BSF    F8A.5
.................... 		delay_ms(100);
3702:  MOVLW  64
3704:  MOVWF  x90
3706:  MOVLB  0
3708:  CALL   068A
.................... 		output_low(LED_GREEN);
370C:  BCF    F93.5
370E:  BCF    F8A.5
.................... 		delay_ms(100);
3710:  MOVLW  64
3712:  MOVLB  9
3714:  MOVWF  x90
3716:  MOVLB  0
3718:  CALL   068A
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# main() blink=%u\r\n",i);
.................... #endif
.................... 	}
.................... 
.................... #if DEBUG_ASCII
371C:  MOVLB  9
371E:  INCF   x79,F
3720:  BRA    36F6
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking done\r\n");
.................... 
.................... 	fprintf(STREAM_WORLD,"# rdTap %s %s\r\n",__DATE__,__TIME__);
.................... 
.................... 	fprintf(STREAM_WORLD,"# restart cause: ");
.................... 	switch ( restart_cause ) {
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_WORLD,"WDT TIMEOUT"); break;
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_WORLD,"MCLR FROM SLEEP"); break;
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_WORLD,"MCLR FROM RUN"); break;
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_WORLD,"NORMAL POWER UP"); break;
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_WORLD,"BROWNOUT RESTART"); break;
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_WORLD,"WDT FROM SLEEP"); break;
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_WORLD,"RESET INSTRUCTION"); break;
.................... 		default:                fprintf(STREAM_WORLD,"UNKNOWN!");
.................... 	}
.................... 	fprintf(STREAM_WORLD,"\r\n");
.................... #endif
.................... 
.................... 	restart_wdt();
3722:  CLRWDT
.................... 	enable_interrupts(GLOBAL);
3724:  MOVLW  C0
3726:  IORWF  FF2,F
.................... 
.................... 	write_default_param_file();
3728:  MOVLB  0
372A:  CALL   0822
.................... 	write_default_device_file();
372E:  CALL   08C0
.................... 
.................... 	read_param_file();
3732:  GOTO   0A20
.................... 	read_device_file();
3736:  GOTO   0A6E
.................... 
.................... 	restart_wdt();
373A:  CLRWDT
.................... 	modbus_init();
373C:  GOTO   0ACC
.................... 
.................... #if DEBUG_ASCII
.................... 	devicesDump();
.................... #endif
.................... 
.................... 	iridium_mr_clear();
3740:  CALL   0AE4
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() starting for ( ; ; ) loop\r\n");
.................... #endif
.................... 
.................... 
.................... 	/* main loop */
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
3744:  CLRWDT
.................... 
.................... 		if ( config.sbd_config ) {
3746:  MOVLB  5
3748:  MOVF   x88,F
374A:  BZ    37EA
.................... 			/* iridium enabled */
.................... 
.................... 			/* act on flag set by SBDRING in UART character processor or RING ALERT line */
.................... 			if ( sbd.ring_flag ) {
374C:  MOVLB  8
374E:  MOVF   xE4,F
3750:  BZ    375E
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# main() sbd.ring_flag=1\r\n");
.................... #endif
.................... 				/* our easiest way to get the ringing message is to send another message. This also
.................... 				would help capture the results from a query */
.................... 				timers.sbd_cycle=1; /* next packet will be an SBD packet */
3752:  MOVLB  3
3754:  CLRF   x66
3756:  MOVLW  01
3758:  MOVWF  x65
.................... 
.................... 				sbd.ring_flag=0;
375A:  MOVLB  8
375C:  CLRF   xE4
.................... 			}
.................... 
.................... 			if ( '\0' != sbd.sbdix_response[0] && 0 == sbd.mo_state ) {
375E:  MOVLB  6
3760:  MOVF   x96,F
3762:  BZ    3780
3764:  MOVF   xC9,F
3766:  BNZ   3780
.................... 				/* 
.................... 				if there is something in our +SBDIX response we should check if we have a message or need to 
.................... 				get a message. But wait until MO sending is done (state machine idle).
.................... 				*/
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_response='%s'\r\n",sbd.sbdix_response);
.................... #endif
.................... 
....................  				iridium_sbdix_parse();
3768:  MOVLB  0
376A:  GOTO   0C38
.................... 
.................... 				/* clear the unparsed buffer so we don't get back here */
.................... 				sbd.sbdix_response[0]='\0';
376E:  MOVLB  6
3770:  CLRF   x96
.................... 
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
3772:  MOVF   xC8,F
3774:  BZ    3780
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
3776:  MOVLB  3
3778:  CLRF   x66
377A:  MOVLW  01
377C:  MOVWF  x65
377E:  MOVLB  6
.................... 					
.................... #if DEBUG_SBD
.................... 					fprintf(STREAM_WORLD,"# sbd.sbdix_mt_queued > 0 (is %u)\r\n",sbd.sbdix_mt_queued);
.................... #endif
.................... 				}
.................... 			}
.................... 
.................... 			/* read character into MR if we don't have an unprocessed message and there is a character available */
.................... 			if ( 0==sbd.mr_ready && ! sbd.mr_disable && uart_kbhit() ) {
3780:  MOVLB  8
3782:  MOVF   xE6,F
3784:  BNZ   37A8
3786:  MOVLB  9
3788:  MOVF   x28,F
378A:  BTFSC  FD8.2
378C:  BRA    3792
378E:  MOVLB  8
3790:  BRA    37A8
3792:  MOVLB  0
3794:  CALL   0E76
3798:  MOVF   01,F
379A:  BTFSS  FD8.2
379C:  BRA    37A2
379E:  MOVLB  8
37A0:  BRA    37A8
.................... 				iridium_getc();
37A2:  GOTO   0E88
37A6:  MOVLB  8
.................... 			}
.................... 
.................... 			/* download message from SBD modem */
.................... 			if ( 1 == sbd.sbdix_mt_status ) {
37A8:  MOVLB  6
37AA:  DECFSZ xC3,W
37AC:  BRA    37B6
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_mt_status=1\r\n");
.................... #endif
.................... 				iridium_mt_receive();
37AE:  MOVLB  0
37B0:  GOTO   0F6C
37B4:  MOVLB  6
.................... 			}
.................... 
.................... 			/* send messages to SBD modem */
.................... 			if ( 0 != sbd.mo_state && 0 == sbd.mt_state ) {
37B6:  MOVF   xC9,F
37B8:  BZ    37CE
37BA:  MOVLB  7
37BC:  MOVF   xDF,F
37BE:  BTFSC  FD8.2
37C0:  BRA    37C6
37C2:  MOVLB  6
37C4:  BRA    37CE
.................... 				iridium_mo_send();
37C6:  MOVLB  0
37C8:  GOTO   138C
37CC:  MOVLB  6
.................... 			}
.................... 
.................... 			if ( 1 == sbd.mt_ready ) {
37CE:  MOVLB  7
37D0:  DECFSZ xDE,W
37D2:  BRA    37E8
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.mt_ready=1\r\n");
.................... #endif
.................... 				/* TODO: send to message parser */
.................... 				sbd.mt_ready=0;
37D4:  CLRF   xDE
.................... 
.................... 				/* do another SBDIX if we have sbd.mt_queued > 0 */
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
37D6:  MOVLB  6
37D8:  MOVF   xC8,F
37DA:  BZ    37E6
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
37DC:  MOVLB  3
37DE:  CLRF   x66
37E0:  MOVLW  01
37E2:  MOVWF  x65
37E4:  MOVLB  6
37E6:  MOVLB  7
37E8:  MOVLB  5
.................... 				}
.................... 			} 
.................... 		}
.................... 
.................... 
.................... 		if ( timers.now_poll ) {
37EA:  MOVLB  3
37EC:  MOVF   x61,F
37EE:  BZ    37FE
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll\r\n");
.................... #endif
.................... 			timers.now_poll=0;
37F0:  CLRF   x61
.................... 			timers.led_on_green=200;
37F2:  MOVLW  C8
37F4:  MOVWF  x64
.................... 			deviceQuery();
37F6:  MOVLB  0
37F8:  GOTO   1D44
37FC:  MOVLB  3
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll done\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* queries are messages send to us that we respond to */
.................... 		if ( query.buff_ready ) {
37FE:  MOVLB  5
3800:  MOVF   x6D,F
3802:  BZ    380E
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_process()\r\n");
.................... #endif
.................... 
.................... 			query_process();
3804:  MOVLB  0
3806:  BRA    351C
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_reset()\r\n");
.................... #endif
.................... 	
.................... 			query_reset();
3808:  CALL   05B8
380C:  MOVLB  5
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() done with query.buff_ready()\r\n");
.................... #endif
.................... 		}
380E:  MOVLB  0
3810:  BRA    3744
.................... 	}
.................... }
.................... 
3812:  SLEEP 

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 2B67   NOPUT BROWNOUT BORV30 ZPBORM WDT WDT1024
   Word  3: 0900   CANB MSSPMSK7 NOMCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
