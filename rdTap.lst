CCS PCH C Compiler, Version 5.117, 2295               16-Oct-24 09:30

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\rdTap\rdTap.lst

               ROM used:   14392 bytes (44%)
                           Largest free fragment is 18372
               RAM used:   2426 (67%) at main() level
                           2463 (68%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   3650
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   0304
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0378
006C:  BTFSS  FA3.5
006E:  GOTO   0078
0072:  BTFSC  FA4.5
0074:  GOTO   04E2
0078:  BTFSS  FB6.7
007A:  GOTO   0084
007E:  BTFSC  FB7.7
0080:  GOTO   046C
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #define DEBUG_ASCII     0
.................... #define DEBUG_SBD       0
.................... #define MCP3208_ENABLED 0
.................... #define STARTUP_BLINKS  150
.................... 
.................... 
.................... #include "rdTap.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 01,C0
00F4:  DATA 80,41
00F6:  DATA 00,C1
00F8:  DATA 81,40
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 00,C1
010C:  DATA 81,40
010E:  DATA 01,C0
0110:  DATA 80,41
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 01,C0
011C:  DATA 80,41
011E:  DATA 00,C1
0120:  DATA 81,40
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 00,C1
0134:  DATA 81,40
0136:  DATA 01,C0
0138:  DATA 80,41
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 01,C0
0154:  DATA 80,41
0156:  DATA 00,C1
0158:  DATA 81,40
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 00,C1
0174:  DATA 81,40
0176:  DATA 01,C0
0178:  DATA 80,41
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 01,C0
018C:  DATA 80,41
018E:  DATA 00,C1
0190:  DATA 81,40
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 00,C1
019C:  DATA 81,40
019E:  DATA 01,C0
01A0:  DATA 80,41
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 01,C0
01B4:  DATA 80,41
01B6:  DATA 00,C1
01B8:  DATA 81,40
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  DATA 00,C1
01CC:  DATA 81,40
01CE:  DATA 01,C0
01D0:  DATA 80,41
01D2:  DATA 00,C1
01D4:  DATA 81,40
01D6:  DATA 01,C0
01D8:  DATA 80,41
01DA:  DATA 01,C0
01DC:  DATA 80,41
01DE:  DATA 00,C1
01E0:  DATA 81,40
01E2:  CLRF   FF7
01E4:  ADDLW  F2
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  RETURN 0
01F2:  DATA 00,C0
01F4:  DATA C1,01
01F6:  DATA C3,03
01F8:  DATA 02,C2
01FA:  DATA C6,06
01FC:  DATA 07,C7
01FE:  DATA 05,C5
0200:  DATA C4,04
0202:  DATA CC,0C
0204:  DATA 0D,CD
0206:  DATA 0F,CF
0208:  DATA CE,0E
020A:  DATA 0A,CA
020C:  DATA CB,0B
020E:  DATA C9,09
0210:  DATA 08,C8
0212:  DATA D8,18
0214:  DATA 19,D9
0216:  DATA 1B,DB
0218:  DATA DA,1A
021A:  DATA 1E,DE
021C:  DATA DF,1F
021E:  DATA DD,1D
0220:  DATA 1C,DC
0222:  DATA 14,D4
0224:  DATA D5,15
0226:  DATA D7,17
0228:  DATA 16,D6
022A:  DATA D2,12
022C:  DATA 13,D3
022E:  DATA 11,D1
0230:  DATA D0,10
0232:  DATA F0,30
0234:  DATA 31,F1
0236:  DATA 33,F3
0238:  DATA F2,32
023A:  DATA 36,F6
023C:  DATA F7,37
023E:  DATA F5,35
0240:  DATA 34,F4
0242:  DATA 3C,FC
0244:  DATA FD,3D
0246:  DATA FF,3F
0248:  DATA 3E,FE
024A:  DATA FA,3A
024C:  DATA 3B,FB
024E:  DATA 39,F9
0250:  DATA F8,38
0252:  DATA 28,E8
0254:  DATA E9,29
0256:  DATA EB,2B
0258:  DATA 2A,EA
025A:  DATA EE,2E
025C:  DATA 2F,EF
025E:  DATA 2D,ED
0260:  DATA EC,2C
0262:  DATA E4,24
0264:  DATA 25,E5
0266:  DATA 27,E7
0268:  DATA E6,26
026A:  DATA 22,E2
026C:  DATA E3,23
026E:  DATA E1,21
0270:  DATA 20,E0
0272:  DATA A0,60
0274:  DATA 61,A1
0276:  DATA 63,A3
0278:  DATA A2,62
027A:  DATA 66,A6
027C:  DATA A7,67
027E:  DATA A5,65
0280:  DATA 64,A4
0282:  DATA 6C,AC
0284:  DATA AD,6D
0286:  DATA AF,6F
0288:  DATA 6E,AE
028A:  DATA AA,6A
028C:  DATA 6B,AB
028E:  DATA 69,A9
0290:  DATA A8,68
0292:  DATA 78,B8
0294:  DATA B9,79
0296:  DATA BB,7B
0298:  DATA 7A,BA
029A:  DATA BE,7E
029C:  DATA 7F,BF
029E:  DATA 7D,BD
02A0:  DATA BC,7C
02A2:  DATA B4,74
02A4:  DATA 75,B5
02A6:  DATA 77,B7
02A8:  DATA B6,76
02AA:  DATA 72,B2
02AC:  DATA B3,73
02AE:  DATA B1,71
02B0:  DATA 70,B0
02B2:  DATA 50,90
02B4:  DATA 91,51
02B6:  DATA 93,53
02B8:  DATA 52,92
02BA:  DATA 96,56
02BC:  DATA 57,97
02BE:  DATA 55,95
02C0:  DATA 94,54
02C2:  DATA 9C,5C
02C4:  DATA 5D,9D
02C6:  DATA 5F,9F
02C8:  DATA 9E,5E
02CA:  DATA 5A,9A
02CC:  DATA 9B,5B
02CE:  DATA 99,59
02D0:  DATA 58,98
02D2:  DATA 88,48
02D4:  DATA 49,89
02D6:  DATA 4B,8B
02D8:  DATA 8A,4A
02DA:  DATA 4E,8E
02DC:  DATA 8F,4F
02DE:  DATA 8D,4D
02E0:  DATA 4C,8C
02E2:  DATA 44,84
02E4:  DATA 85,45
02E6:  DATA 87,47
02E8:  DATA 46,86
02EA:  DATA 82,42
02EC:  DATA 43,83
02EE:  DATA 41,81
02F0:  DATA 80,40
*
03E2:  DATA 41,54
03E4:  DATA 45,30
03E6:  DATA 0D,00
03E8:  DATA 41,54
03EA:  DATA 26,4B
03EC:  DATA 30,0D
03EE:  DATA 00,00
03F0:  DATA 41,54
03F2:  DATA 2B,53
03F4:  DATA 42,44
03F6:  DATA 4D,54
03F8:  DATA 41,3D
03FA:  DATA 31,0D
03FC:  DATA 00,00
03FE:  DATA 41,54
0400:  DATA 2B,43
0402:  DATA 52,49
0404:  DATA 53,0D
0406:  DATA 00,00
0408:  DATA 41,54
040A:  DATA 45,30
040C:  DATA 0D,00
040E:  DATA 41,54
0410:  DATA 26,4B
0412:  DATA 30,0D
0414:  DATA 00,00
0416:  DATA 41,54
0418:  DATA 2B,53
041A:  DATA 42,44
041C:  DATA 4D,54
041E:  DATA 41,3D
0420:  DATA 31,0D
0422:  DATA 00,00
0424:  DATA 41,54
0426:  DATA 2B,53
0428:  DATA 42,44
042A:  DATA 57,42
042C:  DATA 3D,25
042E:  DATA 6C,75
0430:  DATA 0D,00
0432:  DATA 41,54
0434:  DATA 2B,53
0436:  DATA 42,44
0438:  DATA 49,58
043A:  DATA 0D,00
043C:  DATA 41,54
043E:  DATA 2B,53
0440:  DATA 42,44
0442:  DATA 44,30
0444:  DATA 0D,00
0446:  DATA 41,54
0448:  DATA 45,30
044A:  DATA 0D,00
044C:  DATA 41,54
044E:  DATA 26,4B
0450:  DATA 30,0D
0452:  DATA 00,00
0454:  DATA 41,54
0456:  DATA 2B,53
0458:  DATA 42,44
045A:  DATA 4D,54
045C:  DATA 41,3D
045E:  DATA 31,0D
0460:  DATA 00,00
0462:  DATA 41,54
0464:  DATA 2B,53
0466:  DATA 42,44
0468:  DATA 52,42
046A:  DATA 0D,00
*
084C:  MOVLB  9
084E:  MOVF   x94,W
0850:  MULWF  x96
0852:  MOVFF  FF3,01
0856:  MOVFF  FF4,00
085A:  MULWF  x97
085C:  MOVF   FF3,W
085E:  ADDWF  00,F
0860:  MOVF   x95,W
0862:  MULWF  x96
0864:  MOVF   FF3,W
0866:  ADDWFC 00,W
0868:  MOVWF  02
086A:  MOVLB  0
086C:  RETURN 0
*
0F74:  TBLRD*+
0F76:  MOVF   FF5,F
0F78:  BZ    0F92
0F7A:  MOVFF  FF6,97E
0F7E:  MOVFF  FF7,97F
0F82:  MOVFF  FF5,987
0F86:  RCALL  0F64
0F88:  MOVFF  97E,FF6
0F8C:  MOVFF  97F,FF7
0F90:  BRA    0F74
0F92:  RETURN 0
*
1206:  TBLRD*+
1208:  MOVFF  FF6,97F
120C:  MOVFF  FF7,980
1210:  MOVFF  FF5,987
1214:  RCALL  0F64
1216:  MOVFF  97F,FF6
121A:  MOVFF  980,FF7
121E:  MOVLB  9
1220:  DECFSZ x7E,F
1222:  BRA    1226
1224:  BRA    122A
1226:  MOVLB  0
1228:  BRA    1206
122A:  MOVLB  0
122C:  GOTO   14AC (RETURN)
1230:  MOVFF  FEA,986
1234:  MOVFF  FE9,985
1238:  MOVLB  9
123A:  SWAPF  x7F,W
123C:  IORLW  F0
123E:  MOVWF  x81
1240:  ADDWF  x81,F
1242:  ADDLW  E2
1244:  MOVWF  x82
1246:  ADDLW  32
1248:  MOVWF  x84
124A:  MOVF   x7F,W
124C:  ANDLW  0F
124E:  ADDWF  x82,F
1250:  ADDWF  x82,F
1252:  ADDWF  x84,F
1254:  ADDLW  E9
1256:  MOVWF  x83
1258:  ADDWF  x83,F
125A:  ADDWF  x83,F
125C:  SWAPF  x7E,W
125E:  ANDLW  0F
1260:  ADDWF  x83,F
1262:  ADDWF  x84,F
1264:  RLCF   x83,F
1266:  RLCF   x84,F
1268:  COMF   x84,F
126A:  RLCF   x84,F
126C:  MOVF   x7E,W
126E:  ANDLW  0F
1270:  ADDWF  x84,F
1272:  RLCF   x81,F
1274:  MOVLW  07
1276:  MOVWF  x80
1278:  MOVLW  0A
127A:  DECF   x83,F
127C:  ADDWF  x84,F
127E:  BNC   127A
1280:  DECF   x82,F
1282:  ADDWF  x83,F
1284:  BNC   1280
1286:  DECF   x81,F
1288:  ADDWF  x82,F
128A:  BNC   1286
128C:  DECF   x80,F
128E:  ADDWF  x81,F
1290:  BNC   128C
1292:  MOVLW  09
1294:  MOVWF  FEA
1296:  MOVLW  80
1298:  MOVWF  FE9
129A:  MOVLW  07
129C:  ANDWF  x85,W
129E:  BCF    x85.6
12A0:  ADDWF  FE9,F
12A2:  MOVLW  00
12A4:  ADDWFC FEA,F
12A6:  MOVF   FE9,W
12A8:  SUBLW  84
12AA:  BNZ   12B4
12AC:  MOVF   FEA,W
12AE:  SUBLW  09
12B0:  BNZ   12B4
12B2:  BSF    x85.6
12B4:  MOVF   FEF,W
12B6:  MOVWF  00
12B8:  BNZ   12CA
12BA:  BTFSC  x85.6
12BC:  BRA    12CA
12BE:  BTFSC  x85.4
12C0:  BRA    12EC
12C2:  BTFSC  x85.3
12C4:  BRA    12CA
12C6:  MOVLW  20
12C8:  BRA    12D0
12CA:  BSF    x85.3
12CC:  BCF    x85.4
12CE:  MOVLW  30
12D0:  ADDWF  00,F
12D2:  MOVFF  FEA,97F
12D6:  MOVFF  FE9,97E
12DA:  MOVFF  00,987
12DE:  MOVLB  0
12E0:  RCALL  0F64
12E2:  MOVFF  97F,FEA
12E6:  MOVFF  97E,FE9
12EA:  MOVLB  9
12EC:  MOVF   FEE,W
12EE:  BTFSS  x85.6
12F0:  BRA    12A6
12F2:  MOVLB  0
12F4:  GOTO   14BA (RETURN)
*
291C:  ADDWF  FE8,W
291E:  CLRF   FF7
2920:  RLCF   FF7,F
2922:  ADDLW  37
2924:  MOVWF  FF6
2926:  MOVLW  29
2928:  ADDWFC FF7,F
292A:  TBLRD*-
292C:  MOVF   FF5,W
292E:  MOVWF  FFA
2930:  TBLRD*
2932:  MOVF   FF5,W
2934:  MOVWF  FF9
2936:  DATA 82,25
2938:  DATA B4,25
293A:  DATA F6,25
293C:  DATA 34,26
293E:  DATA 72,26
2940:  DATA 06,27
2942:  DATA 9A,27
2944:  DATA DC,27
*
2CBA:  ADDWF  FE8,W
2CBC:  CLRF   FF7
2CBE:  RLCF   FF7,F
2CC0:  ADDLW  D5
2CC2:  MOVWF  FF6
2CC4:  MOVLW  2C
2CC6:  ADDWFC FF7,F
2CC8:  TBLRD*-
2CCA:  MOVF   FF5,W
2CCC:  MOVWF  FFA
2CCE:  TBLRD*
2CD0:  MOVF   FF5,W
2CD2:  MOVWF  FF9
2CD4:  DATA 10,2A
2CD6:  DATA 40,2A
2CD8:  DATA 82,2A
2CDA:  DATA BE,2A
2CDC:  DATA FA,2A
2CDE:  DATA 06,2B
2CE0:  DATA 56,2B
2CE2:  DATA 98,2B
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses NOPUT
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... //#fuses WDT512
.................... #fuses WDT1024
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... 
.................... 
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
*
131E:  MOVFF  97F,985
1322:  MOVFF  97E,984
1326:  MOVLB  9
1328:  MOVF   x82,F
132A:  BNZ   1330
132C:  MOVF   x83,F
132E:  BZ    1376
1330:  MOVFF  981,FEA
1334:  MOVFF  980,FE9
1338:  MOVF   FEF,F
133A:  BZ    1376
....................      *s++ = *s2++;
133C:  MOVFF  985,03
1340:  MOVF   x84,W
1342:  INCF   x84,F
1344:  BTFSC  FD8.2
1346:  INCF   x85,F
1348:  MOVWF  x86
134A:  MOVFF  03,987
134E:  MOVFF  981,FEA
1352:  MOVF   x80,W
1354:  INCF   x80,F
1356:  BTFSC  FD8.2
1358:  INCF   x81,F
135A:  MOVWF  FE9
135C:  MOVFF  FEF,988
1360:  MOVFF  03,FEA
1364:  MOVFF  986,FE9
1368:  MOVFF  988,FEF
136C:  MOVF   x82,W
136E:  BTFSC  FD8.2
1370:  DECF   x83,F
1372:  DECF   x82,F
1374:  BRA    1328
....................   for (; n > 0; n--)
1376:  MOVF   x82,F
1378:  BNZ   137E
137A:  MOVF   x83,F
137C:  BZ    1398
....................      *s++ = '\0';
137E:  MOVFF  985,FEA
1382:  MOVF   x84,W
1384:  INCF   x84,F
1386:  BTFSC  FD8.2
1388:  INCF   x85,F
138A:  MOVWF  FE9
138C:  CLRF   FEF
138E:  MOVF   x82,W
1390:  BTFSC  FD8.2
1392:  DECF   x83,F
1394:  DECF   x82,F
1396:  BRA    1376
.................... 
....................   return(s1);
1398:  MOVFF  97E,01
139C:  MOVFF  97F,02
13A0:  MOVLB  0
13A2:  GOTO   1664 (RETURN)
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
*
0BAA:  MOVFF  97F,FEA
0BAE:  MOVLB  9
0BB0:  MOVFF  97E,FE9
0BB4:  MOVF   x80,W
0BB6:  SUBWF  FEF,W
0BB8:  BZ    0BDE
....................       if (*s == '\0')
0BBA:  MOVFF  97F,03
0BBE:  MOVFF  97E,FE9
0BC2:  MOVFF  03,FEA
0BC6:  MOVF   FEF,F
0BC8:  BNZ   0BD2
....................          return(0);
0BCA:  MOVLW  00
0BCC:  MOVWF  01
0BCE:  MOVWF  02
0BD0:  BRA    0BE6
0BD2:  INCF   x7E,F
0BD4:  BTFSC  FD8.2
0BD6:  INCF   x7F,F
0BD8:  MOVLB  0
0BDA:  BRA    0BAA
0BDC:  MOVLB  9
....................    return(s);
0BDE:  MOVFF  97E,01
0BE2:  MOVFF  97F,02
0BE6:  MOVLB  0
0BE8:  RETURN 0
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0B18:  MOVFF  97D,97F
0B1C:  MOVFF  97C,97E
0B20:  MOVFF  97F,FEA
0B24:  MOVLB  9
0B26:  MOVFF  97E,FE9
0B2A:  MOVF   FEF,F
0B2C:  BZ    0B3A
0B2E:  INCF   x7E,F
0B30:  BTFSC  FD8.2
0B32:  INCF   x7F,F
0B34:  MOVLB  0
0B36:  BRA    0B20
0B38:  MOVLB  9
....................    return(sc - s);
0B3A:  MOVF   x7C,W
0B3C:  SUBWF  x7E,W
0B3E:  MOVWF  00
0B40:  MOVF   x7D,W
0B42:  SUBWFB x7F,W
0B44:  MOVWF  03
0B46:  MOVFF  00,01
0B4A:  MOVWF  02
0B4C:  MOVLB  0
0B4E:  GOTO   0C6E (RETURN)
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
068A:  MOVLW  09
068C:  MOVWF  FEA
068E:  MOVLW  90
0690:  MOVWF  FE9
0692:  MOVF   FEF,W
0694:  BZ    06B8
0696:  MOVLW  02
0698:  MOVWF  01
069A:  MOVLW  BF
069C:  MOVWF  00
069E:  CLRWDT
06A0:  DECFSZ 00,F
06A2:  BRA    069E
06A4:  DECFSZ 01,F
06A6:  BRA    069A
06A8:  MOVLW  96
06AA:  MOVWF  00
06AC:  DECFSZ 00,F
06AE:  BRA    06AC
06B0:  BRA    06B2
06B2:  CLRWDT
06B4:  DECFSZ FEF,F
06B6:  BRA    0696
06B8:  RETURN 0
*
12F8:  MOVLW  09
12FA:  MOVLB  9
12FC:  SUBWF  x7F,F
12FE:  BNC   1318
1300:  MOVLW  09
1302:  MOVWF  FEA
1304:  MOVLW  7F
1306:  MOVWF  FE9
1308:  BCF    FD8.0
130A:  RRCF   FEF,F
130C:  MOVF   FEF,W
130E:  BZ    1318
1310:  BRA    1314
1312:  CLRWDT
1314:  DECFSZ FEF,F
1316:  BRA    1312
1318:  MOVLB  0
131A:  GOTO   155C (RETURN)
.................... 
.................... /* 
.................... Parameters and devices are stored in 1024 byte EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x0000
.................... #define DEVICE_CRC_ADDRESS 0x0002
.................... 
.................... #define PARAM_ADDRESS      0x0004 /* parameters go from 4 to 127 ... 123 bytes max */ 
.................... #define DEVICE_ADDRESS     0x0080 /* devices go from 128 to 1024 ... 896 bytes max */
.................... 
.................... 
.................... /* uart1 is for modbus and set in modbus_int_uart */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600, errors)	
*
04CC:  BTFSS  FA4.5
04CE:  BRA    04CC
04D0:  MOVFF  FA6,20
04D4:  MOVFF  F7A,01
04D8:  BTFSS  20.1
04DA:  BRA    04E0
04DC:  BCF    FA6.4
04DE:  BSF    FA6.4
04E0:  RETURN 0
*
19DE:  BTFSS  FA4.4
19E0:  BRA    19DE
19E2:  MOVWF  F79
19E4:  RETURN 0
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
05C2:  BCF    FC6.7
05C4:  BCF    F9E.3
05C6:  MOVFF  98D,FC9
05CA:  MOVLW  02
05CC:  BTFSC  FC6.7
05CE:  BRA    05DA
05D0:  BTFSC  FC7.2
05D2:  BRA    05D0
05D4:  MOVLW  00
05D6:  BTFSC  FC5.6
05D8:  MOVLW  01
05DA:  MOVWF  01
05DC:  RETURN 0
*
0E16:  BCF    FC6.6
0E18:  BSF    FC5.3
0E1A:  BTFSC  FC5.3
0E1C:  BRA    0E1A
0E1E:  BTFSC  00.0
0E20:  BCF    FC5.5
0E22:  BTFSS  00.0
0E24:  BSF    FC5.5
0E26:  BSF    FC5.4
0E28:  BTFSC  FC5.4
0E2A:  BRA    0E28
0E2C:  MOVFF  FC9,01
0E30:  RETURN 0
.................... 
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /* device types for struct_device */
.................... #define DEV_TYPE_DISABLED       0
.................... 
.................... /* modbus slave on RS-485 bus */
.................... #define DEV_TYPE_MODBUS_1       1
.................... #define DEV_TYPE_MODBUS_2       2
.................... #define DEV_TYPE_MODBUS_3       3
.................... #define DEV_TYPE_MODBUS_4       4
.................... #define DEV_TYPE_MODBUS_5       5
.................... #define DEV_TYPE_MODBUS_6       6
.................... #define DEV_TYPE_MODBUS_16      7
.................... #define DEV_TYPE_MODBUS_MAX     7
.................... 
.................... /* I2C slave on I2C bus */
.................... #define DEV_TYPE_I2C_READ_8     16
.................... #define DEV_TYPE_I2C_READ_16    17
.................... #define DEV_TYPE_I2C_READ_24    18
.................... #define DEV_TYPE_I2C_READ_32    19
.................... #define DEV_TYPE_I2C_WRITE_8    20
.................... #define DEV_TYPE_I2C_WRITE_16   21
.................... #define DEV_TYPE_I2C_WRITE_24   22
.................... #define DEV_TYPE_I2C_WRITE_32   23
.................... #define DEV_TYPE_I2C_MAX        23
.................... 
.................... /* local registers on this device */
.................... #define DEV_TYPE_LOCAL_READ_16  32
.................... #define DEV_TYPE_LOCAL_WRITE_16 33
.................... #define DEV_TYPE_LOCAL_MAX      33
.................... 
.................... 
.................... 
.................... /* serial port speeds */
.................... #define DEV_SERIAL_9600  0
.................... #define DEV_SERIAL_19200 1
.................... 
.................... 
.................... #define DEV_MAX_N 64
.................... 
.................... #include "worldDeviceTypes.h"
.................... /* Continental Control Systems, Watt Node Modbus */
.................... #define DEVICE_TYPE_WORLD_WNC_BASIC           1  /* 1000, 34 */
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED        2
.................... #define DEVICE_TYPE_WORLD_WNC_CONFIGURATION   3
.................... #define DEVICE_TYPE_WORLD_WNC_DIAGNOSTIC      4
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED_ENERGY 5  /* 1100, 38 */
.................... 
.................... /* APRS World, XRW2G */
.................... #define DEVICE_TYPE_WORLD_XRW2G_BASIC         100 /* 0, 46 */
.................... #define DEVICE_TYPE_WORLD_XRW2G_DIAGNOSTIC    101
.................... #define DEVICE_TYPE_WORLD_XRW2G_CONFIGURATION 102
.................... 
.................... /* Morningstar, Relay Driver */
.................... #define DEVICE_TYPE_WORLD_RD1_RAM             200 /* 0, 18 */
.................... #define DEVICE_TYPE_WORLD_RD1_COILS           201 /* 0, 4 */
.................... 
.................... /* Morningstar, Tri-Star */
.................... #define DEVICE_TYPE_WORLD_TS_RAM              300 /* 8, 21 */
.................... #define DEVICE_TYPE_WORLD_TS_COILS            301
.................... #define DEVICE_TYPE_WORLD_TS_EEPROM           302
.................... #define DEVICE_TYPE_WORLD_TS_KWH              303 /* 57388, 3 */
.................... 
.................... /* Morningstar, Tri-Star MPPT */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_SCALING                  320 /* 0, 4 */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_FILTERED_ADC             321 /* 24, 38 */
.................... 
.................... /* Advancetech, Adam 4xxx MODBUS */
.................... #define ADAM_4XXX_ANALOG_CURRENT                          400 /* 0, 8 */
.................... 
.................... /* smaller block definitions for SatCon PVS50 ... not implemented or seen in the wild. Do not use */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_SOFTWARE           500 /* 30009, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_ACTIVE_FAULTS      501 /* 30017, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_DC                 502 /* 30020, 4 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_CURRENT    503 /* 30035, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_VOLTAGE    504 /* 30040, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_POWER           505 /* 30043, 5 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_GROUND_IMPEDANCE   506 /* 30049, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT     507 /* 30050, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT_AVG 508 /* 30089, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH         509 /* 30090, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH_AVG     510 /* 30129, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_KWH                511 /* 30131, 8 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_TIMERS             512 /* 30275, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STATE              513 /* 30279, 2 */
.................... 
.................... /* SatCon PVS50 inverter. Manual has +30001 offset. */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_0      520 /* 9, 40 registers ... error, should be 41 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_1      521 /* 50, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_2      522 /* 90, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_3      523 /* 131, 8 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_4      524 /* 175, 2 registers ... not programmed at west point! */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_5      525 /* 275, 6 registers ... */
.................... 
.................... 
.................... /* PC&S Multitek MP850MPDV19PE CUSTOM 1 */
.................... /* Registers re-arranged to be consecutive, starting with reg 0 */
.................... /* Values are 32-bit Floating Point */
.................... /* Register list: */
.................... /* 0 - V 1 ... Voltage */
.................... /* 2 - I 1 ... Current */
.................... /* 4 - kW Sum */
.................... /* 6 - kWHr (Import) */
.................... /* 8 - kWd  (Import) ... Demand over last 3 minutes */
.................... /* 10 - Ad ... Demand current over last 3 minutes*/
.................... /* 12 - kWHr (Export) */
.................... /* 14 - A.h */
.................... /* 16 - Max kWd (Import) */
.................... /* 18 - Max Ad */
.................... 
.................... #define DEVICE_TYPE_WORLD_M850MPD_CUSTOM_1	 600 /* 0, 20 registers */
.................... 
.................... 
.................... #define DEVICE_TYPE_WORLD_SHUNTMONITOR_BASIC  700 /* 0, 32 registers */
.................... 
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_BASIC      800 /* 0, 39 registers */
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_CONFIG     801 /* 1000, 15 registers */
.................... 
.................... /* Midnite Solar Classic - based on 2011-05-21 specification */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_BASIC       900 /* 4113, 31 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_WIND_CURVE  901 /* 4300, 16 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_RESTING     902 /* 4274, 3  registers */
.................... 
.................... /* APRS World POE Monitor */
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_BASIC    1000 
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_CONFIG   1001
.................... 
.................... /* APRS World watchdog Arlo */
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_BASIC  1100
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_CONFIG 1101
.................... 
.................... /* China HUM temperature and relative humidity sensor */
.................... #define DEVICE_TYPE_WORLD_HUM_TEMPERATURE      1200
.................... #define DEVICE_TYPE_WORLD_HUM_RELATIVEHUMIDITY 1201
.................... 
.................... /* "Center" brand soundmeter */
.................... #define TYPE_TYPE_WORLD_SOUNDMETER_CENTER      1300
.................... 
.................... /* PS2Tap */
.................... #define DEVICE_TYPE_WORLD_PS2TAP_BASIC         1400 /* 0, 19 registers */
.................... 
.................... /* Veris E50 Series Power Meter */
.................... #define DEVICE_TYPE_WORLD_VERISE50_BASIC       1500 /* 256, 54 registers */
.................... 
.................... 
.................... /* Note: List not complete.  Reference master list in WorldDataCollector. */
.................... 
.................... 
.................... /* generic rsdata */
.................... #define DEVICE_TYPE_WORLD_RSDATA               32000 /* Integer */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT         32001 /* IEEE-754 single precision floating point (32-bit) data */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT_LITTLE  32002 
.................... 
.................... 
.................... typedef struct {
.................... 	int8  type;           /* device query type */
.................... 	int16 typeWorld;      /* see worldDeviceTypes.h for defines */
.................... 	int8  transmitEvery;
.................... 	int8  networkAddress; /* modbus or I2C address */
.................... 	int32 serialNumber;   /* APRS World or other serial number */
.................... 	int16 startRegister;
.................... 	int8  nRegisters;
.................... 	int8  serialSpeed;    /* see rsTap.h for defines */
.................... } struct_device;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  now_poll;
.................... 	int8  world_timeout;
.................... 	int8  factory_unlocked;
.................... 	int8  led_on_green;
.................... 	int16 sbd_cycle;
.................... } struct_timer;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  rException;
.................... 	int8  rResult[256];
.................... 	int8  rResultLength;
.................... 	int8  deviceNumber;
.................... 	int16 measurementNumber;
.................... } struct_qbuff;
.................... 
.................... typedef struct {
.................... 	int8 buff[256];
.................... 	int8 buff_pos;
.................... 	int8 buff_ready;
.................... 
.................... 	int8  packet_length;
.................... 	int32 query_id;
.................... 	int32 device_serial;
.................... 	int16 network_address;
.................... 	int16 function;
.................... 	int16 start_address;
.................... 	int8  n_words;
.................... 	int8  data_start_offset;
.................... 	int16 crc;
.................... 
.................... 	int8  resultException;
.................... 	int8  resultLength;
.................... } struct_query;
.................... 
.................... typedef struct {
.................... 	int8  serial_prefix;
.................... 	int16 serial_number;
.................... 	
.................... 	int16 live_interval;
.................... 
.................... 	/* Iridium SBD or other limited bandwidth transmission */
.................... 	/* 0 is no SBD, 1...5 is SBD modem with power switch on CONTROL pin 1...5 */
.................... 	int8  sbd_config;
.................... 
.................... 	/*	
.................... 	every n'th live transmission we transmit the SBD data
.................... 	Interval should be at least 10 minutes to allow for full retry cycle	
.................... 	on cycle before transmit, we clear previous buffer and turn on modem 
.................... 	*/
.................... 	int16 sbd_every;
.................... 
.................... } struct_config;
.................... 
.................... /* global structures */
.................... struct_device device[DEV_MAX_N];
.................... struct_timer  timers;
.................... struct_qbuff  qbuff;
.................... struct_query  query;
.................... struct_config config;
.................... 
.................... #include "i2c_access_rdTap.c"
.................... int16 i2c_register_read16(int8 i2c_address, int8 regaddr) {
.................... 	int8 msb, lsb;
.................... 
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address);
.................... 	i2c_write(regaddr);
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address | 1);  // read cycle
.................... 	msb=i2c_read(1);
.................... 	lsb=i2c_read(0);                                
.................... 	i2c_stop();
.................... 
.................... 	return make16(msb,lsb);
.................... }
.................... 
.................... void i2c_buff_read(int8 i2c_address, int8 regaddr, int8 *data, int8 count) {
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
*
1CE2:  BSF    FC5.0
1CE4:  BTFSC  FC5.0
1CE6:  BRA    1CE4
.................... 	delay_us(15);
1CE8:  CLRWDT
1CEA:  MOVLW  09
1CEC:  MOVWF  00
1CEE:  DECFSZ 00,F
1CF0:  BRA    1CEE
1CF2:  NOP   
.................... 	i2c_write(i2c_address);
1CF4:  MOVFF  982,98D
1CF8:  CALL   05C2
.................... 	i2c_write(regaddr);
1CFC:  MOVFF  983,98D
1D00:  CALL   05C2
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
1D04:  BSF    FC5.1
1D06:  BTFSC  FC5.1
1D08:  BRA    1D06
.................... 	delay_us(15);
1D0A:  CLRWDT
1D0C:  MOVLW  09
1D0E:  MOVWF  00
1D10:  DECFSZ 00,F
1D12:  BRA    1D10
1D14:  NOP   
.................... 	i2c_write(i2c_address | 1);  // read cycle
1D16:  MOVLB  9
1D18:  MOVF   x82,W
1D1A:  IORLW  01
1D1C:  MOVWF  x87
1D1E:  MOVWF  x8D
1D20:  MOVLB  0
1D22:  CALL   05C2
.................... 
.................... 	/* stop reading before last byte */	
.................... 	while ( count-- != 1 ) {
1D26:  MOVLB  9
1D28:  MOVF   x86,W
1D2A:  DECF   x86,F
1D2C:  SUBLW  01
1D2E:  BZ    1D50
.................... 		*data=i2c_read(1);
1D30:  MOVFF  985,FEA
1D34:  MOVFF  984,FE9
1D38:  MOVLW  01
1D3A:  MOVWF  00
1D3C:  MOVLB  0
1D3E:  CALL   0E16
1D42:  MOVFF  01,FEF
.................... 		data++;
1D46:  MOVLB  9
1D48:  INCF   x84,F
1D4A:  BTFSC  FD8.2
1D4C:  INCF   x85,F
1D4E:  BRA    1D28
.................... 	}
.................... 
.................... 	/* send last byte with a NAK */
.................... 	*data=i2c_read(0);                                
1D50:  MOVFF  985,FEA
1D54:  MOVFF  984,FE9
1D58:  CLRF   00
1D5A:  MOVLB  0
1D5C:  CALL   0E16
1D60:  MOVFF  01,FEF
.................... 	i2c_stop();
1D64:  BSF    FC5.2
1D66:  BTFSC  FC5.2
1D68:  BRA    1D66
1D6A:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void i2c_register_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start();
*
30C8:  BSF    FC5.0
30CA:  BTFSC  FC5.0
30CC:  BRA    30CA
.................... 	delay_us(15);                                                 
30CE:  CLRWDT
30D0:  MOVLW  09
30D2:  MOVWF  00
30D4:  DECFSZ 00,F
30D6:  BRA    30D4
30D8:  NOP   
.................... 	i2c_write(i2c_address); // write cycle                       
30DA:  MOVFF  988,98D
30DE:  CALL   05C2
.................... 	i2c_write(regaddr);  // write cycle         
30E2:  MOVFF  989,98D
30E6:  CALL   05C2
.................... 	i2c_write(make8(value,1));
30EA:  MOVFF  98B,98D
30EE:  CALL   05C2
.................... 	i2c_write(make8(value,0));
30F2:  MOVFF  98A,98D
30F6:  CALL   05C2
.................... 	i2c_stop();
30FA:  BSF    FC5.2
30FC:  BTFSC  FC5.2
30FE:  BRA    30FC
3100:  GOTO   3414 (RETURN)
.................... }
.................... 
.................... void i2c_register_write32(int8 i2c_address, int8 regaddr, int32 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle     
.................... 	i2c_write(make8(value,3));
.................... 	i2c_write(make8(value,2));    
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... #include "mcp3208_rdTap.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
.................... 	output_high(CS_ADC0);
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
.................... 	output_high(MCP3208_DIN);
.................... 
.................... 
.................... 	if ( ch<8 ) {
.................... 		output_low(CS_ADC0);
.................... 	} else {
.................... 		output_low(CS_ADC1);
.................... 		ch-=8;
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
.................... 		c=0b00011;
.................... 	else if ( 1 == ch ) 
.................... 		c=0b10011;
.................... 	else if ( 2 == ch ) 
.................... 		c=0b01011;
.................... 	else if ( 3 == ch ) 
.................... 		c=0b11011;
.................... 	else if ( 4 == ch )
.................... 		c=0b00111;
.................... 	else if ( 5 == ch ) 
.................... 		c=0b10111;
.................... 	else if ( 6 == ch )
.................... 		c=0b01111;
.................... 	else
.................... 		c=0b11111;
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		output_bit(MCP3208_DIN,c&1);
.................... 		c=c>>1;
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 
.................... 	value=0;
.................... 	for ( i=0 ; i<14 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 	bit_clear(value,13);
.................... 	bit_clear(value,12);
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
.................... 
.................... 	return value;
.................... }
.................... 
.................... #include "uart_sc16is740_rdTap.c"
.................... /* register map for SC16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
*
0E32:  BSF    FC5.0
0E34:  BTFSC  FC5.0
0E36:  BRA    0E34
.................... 	delay_us(15);
0E38:  CLRWDT
0E3A:  MOVLW  09
0E3C:  MOVWF  00
0E3E:  DECFSZ 00,F
0E40:  BRA    0E3E
0E42:  NOP   
.................... 	i2c_write(UART_ADDR);
0E44:  MOVLW  9A
0E46:  MOVLB  9
0E48:  MOVWF  x8D
0E4A:  MOVLB  0
0E4C:  CALL   05C2
.................... 	i2c_write(regaddr<<3);
0E50:  MOVLB  9
0E52:  RLCF   x7B,W
0E54:  MOVWF  x7D
0E56:  RLCF   x7D,F
0E58:  RLCF   x7D,F
0E5A:  MOVLW  F8
0E5C:  ANDWF  x7D,F
0E5E:  MOVFF  97D,98D
0E62:  MOVLB  0
0E64:  CALL   05C2
.................... 	i2c_start();
0E68:  BSF    FC5.1
0E6A:  BTFSC  FC5.1
0E6C:  BRA    0E6A
.................... 	delay_us(15);
0E6E:  CLRWDT
0E70:  MOVLW  09
0E72:  MOVWF  00
0E74:  DECFSZ 00,F
0E76:  BRA    0E74
0E78:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
0E7A:  MOVLW  9B
0E7C:  MOVLB  9
0E7E:  MOVWF  x8D
0E80:  MOVLB  0
0E82:  CALL   05C2
.................... 	data=i2c_read(0);
0E86:  CLRF   00
0E88:  RCALL  0E16
0E8A:  MOVFF  01,97C
.................... 	i2c_stop();
0E8E:  BSF    FC5.2
0E90:  BTFSC  FC5.2
0E92:  BRA    0E90
.................... 
.................... 	return data;
0E94:  MOVLB  9
0E96:  MOVFF  97C,01
0E9A:  MOVLB  0
0E9C:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
05DE:  BSF    FC5.0
05E0:  BTFSC  FC5.0
05E2:  BRA    05E0
.................... 	delay_us(15);                                                 
05E4:  CLRWDT
05E6:  MOVLW  09
05E8:  MOVWF  00
05EA:  DECFSZ 00,F
05EC:  BRA    05EA
05EE:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
05F0:  MOVLW  9A
05F2:  MOVLB  9
05F4:  MOVWF  x8D
05F6:  MOVLB  0
05F8:  RCALL  05C2
.................... 	i2c_write(regaddr<< 3);  // write cycle         
05FA:  MOVLB  9
05FC:  RLCF   x88,W
05FE:  MOVWF  x8A
0600:  RLCF   x8A,F
0602:  RLCF   x8A,F
0604:  MOVLW  F8
0606:  ANDWF  x8A,F
0608:  MOVFF  98A,98D
060C:  MOVLB  0
060E:  RCALL  05C2
.................... 	i2c_write(data);
0610:  MOVFF  989,98D
0614:  RCALL  05C2
.................... 	i2c_stop();
0616:  BSF    FC5.2
0618:  BTFSC  FC5.2
061A:  BRA    0618
061C:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
0F64:  MOVLB  9
0F66:  CLRF   x88
0F68:  MOVFF  987,989
0F6C:  MOVLB  0
0F6E:  CALL   05DE
0F72:  RETURN 0
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
0E9E:  MOVLW  05
0EA0:  MOVLB  9
0EA2:  MOVWF  x7B
0EA4:  MOVLB  0
0EA6:  RCALL  0E32
0EA8:  MOVF   01,W
0EAA:  ANDLW  01
0EAC:  MOVWF  01
0EAE:  RETURN 0
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
0EB0:  MOVLB  9
0EB2:  CLRF   x7B
0EB4:  MOVLB  0
0EB6:  RCALL  0E32
0EB8:  MOVF   01,W
*
1090:  MOVLB  9
1092:  CLRF   x7B
1094:  MOVLB  0
1096:  RCALL  0E32
1098:  MOVF   01,W
*
10B8:  MOVLB  9
10BA:  CLRF   x7B
10BC:  MOVLB  0
10BE:  RCALL  0E32
10C0:  MOVF   01,W
*
1102:  MOVLB  9
1104:  CLRF   x7B
1106:  MOVLB  0
1108:  RCALL  0E32
110A:  MOVF   01,W
*
115E:  MOVLB  9
1160:  CLRF   x7B
1162:  MOVLB  0
1164:  RCALL  0E32
1166:  MOVF   01,W
*
1186:  MOVLB  9
1188:  CLRF   x7B
118A:  MOVLB  0
118C:  RCALL  0E32
118E:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
061E:  MOVLW  03
0620:  MOVLB  9
0622:  MOVWF  x88
0624:  MOVLW  80
0626:  MOVWF  x89
0628:  MOVLB  0
062A:  RCALL  05DE
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
062C:  MOVLB  9
062E:  CLRF   x88
0630:  MOVFF  97A,989
0634:  MOVLB  0
0636:  RCALL  05DE
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
0638:  MOVLW  01
063A:  MOVLB  9
063C:  MOVWF  x88
063E:  CLRF   x89
0640:  MOVLB  0
0642:  RCALL  05DE
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
0644:  MOVLW  03
0646:  MOVLB  9
0648:  MOVWF  x88
064A:  MOVLW  BF
064C:  MOVWF  x89
064E:  MOVLB  0
0650:  RCALL  05DE
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
0652:  MOVLW  02
0654:  MOVLB  9
0656:  MOVWF  x88
0658:  MOVLW  10
065A:  MOVWF  x89
065C:  MOVLB  0
065E:  RCALL  05DE
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
0660:  MOVLW  03
0662:  MOVLB  9
0664:  MOVWF  x88
0666:  MOVWF  x89
0668:  MOVLB  0
066A:  RCALL  05DE
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
066C:  MOVLW  01
066E:  MOVLB  9
0670:  MOVWF  x88
0672:  CLRF   x89
0674:  MOVLB  0
0676:  RCALL  05DE
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
0678:  MOVLW  02
067A:  MOVLB  9
067C:  MOVWF  x88
067E:  MOVLW  07
0680:  MOVWF  x89
0682:  MOVLB  0
0684:  RCALL  05DE
0686:  GOTO   071E (RETURN)
.................... }
.................... 
.................... 
.................... #include "param_rdTap.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0762:  MOVF   x98,W
0764:  XORWF  x99,W
0766:  MOVWF  01
*
0A2E:  MOVF   x98,W
0A30:  XORWF  x99,W
0A32:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
09C2:  MOVLB  9
09C4:  CLRF   x83
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
09C6:  MOVFF  982,985
09CA:  MOVF   x81,W
09CC:  BTFSC  FD8.2
09CE:  DECF   x82,F
09D0:  DECF   x81,F
09D2:  MOVWF  x84
09D4:  MOVF   x84,F
09D6:  BNZ   09DC
09D8:  MOVF   x85,F
09DA:  BZ    0A40
.................... 		*data = read_eeprom( address++ );
09DC:  MOVFF  980,03
09E0:  MOVF   x7F,W
09E2:  MOVWF  FE9
09E4:  MOVFF  03,FEA
09E8:  MOVF   x7E,W
09EA:  MOVWF  03
09EC:  MOVF   x7D,W
09EE:  INCF   x7D,F
09F0:  BTFSC  FD8.2
09F2:  INCF   x7E,F
09F4:  MOVWF  x86
09F6:  MOVFF  03,987
09FA:  MOVFF  FF2,988
09FE:  BCF    FF2.7
0A00:  MOVFF  987,F75
0A04:  MOVFF  986,F74
0A08:  BCF    F7F.6
0A0A:  BCF    F7F.7
0A0C:  BSF    F7F.0
0A0E:  MOVF   F73,W
0A10:  BTFSC  x88.7
0A12:  BSF    FF2.7
0A14:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
0A16:  MOVFF  980,03
0A1A:  MOVF   x7F,W
0A1C:  MOVWF  FE9
0A1E:  MOVFF  03,FEA
0A22:  MOVFF  FEF,984
0A26:  MOVFF  983,998
0A2A:  MOVFF  984,999
*
0A34:  MOVFF  01,983
.................... 		data++;
0A38:  INCF   x7F,F
0A3A:  BTFSC  FD8.2
0A3C:  INCF   x80,F
0A3E:  BRA    09C6
.................... 	}
.................... 	return crc;
0A40:  MOVFF  983,01
0A44:  MOVLB  0
0A46:  RETURN 0
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
*
072E:  MOVLB  9
0730:  CLRF   x96
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0732:  MOVFF  995,998
0736:  MOVF   x94,W
0738:  BTFSC  FD8.2
073A:  DECF   x95,F
073C:  DECF   x94,F
073E:  MOVWF  x97
0740:  MOVF   x97,F
0742:  BNZ   0748
0744:  MOVF   x98,F
0746:  BZ    07C6
.................... 		restart_wdt();
0748:  CLRWDT
.................... 		crc = xor_crc(crc,*data);
074A:  MOVFF  993,03
074E:  MOVF   x92,W
0750:  MOVWF  FE9
0752:  MOVFF  03,FEA
0756:  MOVFF  FEF,997
075A:  MOVFF  996,998
075E:  MOVFF  997,999
*
0768:  MOVFF  01,996
.................... 		write_eeprom( address++, *data++ );
076C:  MOVF   x91,W
076E:  MOVWF  03
0770:  MOVF   x90,W
0772:  INCF   x90,F
0774:  BTFSC  FD8.2
0776:  INCF   x91,F
0778:  MOVWF  x97
077A:  MOVFF  03,998
077E:  MOVF   x93,W
0780:  MOVWF  03
0782:  MOVF   x92,W
0784:  INCF   x92,F
0786:  BTFSC  FD8.2
0788:  INCF   x93,F
078A:  MOVWF  FE9
078C:  MOVFF  03,FEA
0790:  MOVFF  FEF,999
0794:  MOVF   FF2,W
0796:  MOVWF  00
0798:  BCF    FF2.7
079A:  MOVFF  998,F75
079E:  MOVFF  997,F74
07A2:  MOVFF  999,F73
07A6:  BCF    F7F.6
07A8:  BCF    F7F.7
07AA:  BSF    F7F.2
07AC:  MOVLB  F
07AE:  MOVLW  55
07B0:  MOVWF  F7E
07B2:  MOVLW  AA
07B4:  MOVWF  F7E
07B6:  BSF    F7F.1
07B8:  BTFSC  F7F.1
07BA:  BRA    07B8
07BC:  BCF    F7F.2
07BE:  MOVF   00,W
07C0:  IORWF  FF2,F
07C2:  MOVLB  9
07C4:  BRA    0732
.................... 	}
.................... 
.................... 	return crc;
07C6:  MOVFF  996,01
07CA:  MOVLB  0
07CC:  RETURN 0
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
07CE:  MOVLW  05
07D0:  MOVLB  9
07D2:  MOVWF  x8E
07D4:  MOVLW  83
07D6:  MOVWF  x8D
07D8:  CLRF   x91
07DA:  MOVLW  04
07DC:  MOVWF  x90
07DE:  MOVFF  98E,993
07E2:  MOVFF  98D,992
07E6:  CLRF   x95
07E8:  MOVLW  08
07EA:  MOVWF  x94
07EC:  MOVLB  0
07EE:  RCALL  072E
07F0:  MOVFF  01,98C
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
07F4:  MOVF   FF2,W
07F6:  MOVWF  00
07F8:  BCF    FF2.7
07FA:  CLRF   F75
07FC:  CLRF   F74
07FE:  MOVFF  98C,F73
0802:  BCF    F7F.6
0804:  BCF    F7F.7
0806:  BSF    F7F.2
0808:  MOVLB  F
080A:  MOVLW  55
080C:  MOVWF  F7E
080E:  MOVLW  AA
0810:  MOVWF  F7E
0812:  BSF    F7F.1
0814:  BTFSC  F7F.1
0816:  BRA    0814
0818:  BCF    F7F.2
081A:  MOVF   00,W
081C:  IORWF  FF2,F
081E:  MOVLB  0
0820:  RETURN 0
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0822:  MOVLW  96
0824:  MOVLB  3
0826:  MOVWF  x64
.................... //	fprintf(world,"# writing default parameters\r\n");
.................... 
.................... 	config.serial_prefix='A';
0828:  MOVLW  41
082A:  MOVLB  5
082C:  MOVWF  x83
.................... 	config.serial_number=4812;
082E:  MOVLW  12
0830:  MOVWF  x85
0832:  MOVLW  CC
0834:  MOVWF  x84
.................... 		/* 
.................... 			A4797 Fairway UAF (SBD in slot 5 closest to power connector)
.................... 			A4800 Fairway UVic (SBD in slot 1)
.................... 			A4810 Uvic Spare Fairway panel (SBD in slot 1)
.................... 			A4820 JJJ Bench (SBD in slot 1)
.................... 			A4756 A test unit (SBD in slot 1)
.................... 		*/
.................... 
.................... 	/* data to internet on STREAM_WORLD port */
.................... 	config.live_interval=10; 
0836:  CLRF   x87
0838:  MOVLW  0A
083A:  MOVWF  x86
.................... 
.................... 	/* Iridium SBD requires dcswc_module_rockblock which provides an I2C UART */
.................... 	config.sbd_config=1;   /* physical slot for module. Used for power control */
083C:  MOVLW  01
083E:  MOVWF  x88
.................... 	config.sbd_every=90;   /* send SBD message every this number of live_interval */
0840:  CLRF   x8A
0842:  MOVLW  5A
0844:  MOVWF  x89
....................                            /* with 10 second live interval, 4320 => SBD every 12 hours */
....................                            /* with 10 second live interval, 1080 => SBD every 3 hours */	
.................... 						   /* with 10 second live interval, 360  => SBD every 1 hour */			
....................                            /* with 10 second live interval, 90   => SBD every 15 minutes */
....................                            /* values less than 15 minutes don't work well with the SBD backoff algorithm */
.................... 				
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0846:  MOVLB  0
0848:  RCALL  07CE
084A:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS,(void *)&config, sizeof(config)); 
*
0A48:  MOVLW  05
0A4A:  MOVLB  9
0A4C:  MOVWF  x7C
0A4E:  MOVLW  83
0A50:  MOVWF  x7B
0A52:  CLRF   x7E
0A54:  MOVLW  04
0A56:  MOVWF  x7D
0A58:  MOVFF  97C,980
0A5C:  MOVFF  97B,97F
0A60:  CLRF   x82
0A62:  MOVLW  08
0A64:  MOVWF  x81
0A66:  MOVLB  0
0A68:  RCALL  09C2
0A6A:  MOVFF  01,97A
.................... 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
0A6E:  MOVFF  FF2,97B
0A72:  BCF    FF2.7
0A74:  CLRF   F75
0A76:  CLRF   F74
0A78:  BCF    F7F.6
0A7A:  BCF    F7F.7
0A7C:  BSF    F7F.0
0A7E:  MOVF   F73,W
0A80:  MOVLB  9
0A82:  BTFSC  x7B.7
0A84:  BSF    FF2.7
0A86:  SUBWF  x7A,W
0A88:  BZ    0A90
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_param_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_param_file();
0A8A:  MOVLB  0
0A8C:  RCALL  0822
0A8E:  MOVLB  9
.................... 	}
0A90:  MOVLB  0
0A92:  GOTO   375E (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "paramDevice_rdTap.c"
.................... void write_device_file() {
.................... 	int8 crc;
.................... 
.................... 
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(DEVICE_ADDRESS,(void *)&device,sizeof(device));
*
086E:  MOVLB  9
0870:  MOVLW  21
0872:  MOVWF  x8E
0874:  CLRF   x91
0876:  MOVLW  80
0878:  MOVWF  x90
087A:  CLRF   x93
087C:  MOVFF  98E,992
0880:  MOVLW  03
0882:  MOVWF  x95
0884:  MOVLW  40
0886:  MOVWF  x94
0888:  MOVLB  0
088A:  RCALL  072E
088C:  MOVFF  01,98D
.................... 	/* write the CRC that was calculated on the structure */
.................... 	write_eeprom(DEVICE_CRC_ADDRESS,crc);
0890:  MOVF   FF2,W
0892:  MOVWF  00
0894:  BCF    FF2.7
0896:  CLRF   F75
0898:  MOVLW  02
089A:  MOVWF  F74
089C:  MOVFF  98D,F73
08A0:  BCF    F7F.6
08A2:  BCF    F7F.7
08A4:  BSF    F7F.2
08A6:  MOVLB  F
08A8:  MOVLW  55
08AA:  MOVWF  F7E
08AC:  MOVLW  AA
08AE:  MOVWF  F7E
08B0:  BSF    F7F.1
08B2:  BTFSC  F7F.1
08B4:  BRA    08B2
08B6:  BCF    F7F.2
08B8:  MOVF   00,W
08BA:  IORWF  FF2,F
08BC:  MOVLB  0
08BE:  RETURN 0
.................... 
.................... //	fprintf(STREAM_WORLD,"# write_device_file crc=%u\r\n",crc);
.................... }
.................... 
.................... /* load device configuration from program memory */
.................... void write_default_device_file(void) {
.................... 	int8 i;
.................... 
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
08C0:  MOVLW  96
08C2:  MOVLB  3
08C4:  MOVWF  x64
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# disabling all devices\r\n");
.................... #endif
.................... 
.................... 	/* disable all devices */
.................... 	for ( i=0 ; i<DEV_MAX_N ; i++ ) {
08C6:  MOVLB  9
08C8:  CLRF   x8C
08CA:  MOVF   x8C,W
08CC:  SUBLW  3F
08CE:  BNC   08F4
.................... 		device[i].type=DEV_TYPE_DISABLED;	
08D0:  CLRF   x95
08D2:  MOVFF  98C,994
08D6:  CLRF   x97
08D8:  MOVLW  0D
08DA:  MOVWF  x96
08DC:  MOVLB  0
08DE:  RCALL  084C
08E0:  MOVLW  21
08E2:  MOVLB  9
08E4:  ADDWF  01,W
08E6:  MOVWF  FE9
08E8:  MOVLW  00
08EA:  ADDWFC 02,W
08EC:  MOVWF  FEA
08EE:  CLRF   FEF
.................... 	}
.................... 
.................... #if 0
.................... 	/* UAF Fairway */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4790; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4791; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4792; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Fairway on A4800 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4806; /*  4264646 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4808; /* 4264648 */
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4807; /* 4264647 */ 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Spare Panel on A4810 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4801; /* 4264641 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4802; /* 4264642 */ 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38; 
.................... 	device[2].serialNumber=('A'<<16) + 4803; /* 4264643 */
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* JJJ Test board on A4820 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4821; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4822; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4823; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* N Test A4756 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x44; /* on on */
.................... 	device[0].serialNumber=('A'<<16) + 4821; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36; /* off off */
.................... 	device[1].serialNumber=('A'<<16) + 4822; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38; /* on off */
.................... 	device[2].serialNumber=('A'<<16) + 4823; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[3].type=DEV_TYPE_I2C_READ_8;
.................... 	device[3].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[3].transmitEvery=1;
.................... 	device[3].networkAddress=0x3a; /* off /on */
.................... 	device[3].serialNumber=('A'<<16) + 4824; 
.................... 	device[3].startRegister=0;
.................... 	device[3].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* Q Test board on A4815 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4815; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... #endif
.................... 
.................... #if 0
.................... 	/* Q Test board on A4816 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4816; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... #endif
.................... 
.................... #if 0
.................... 	/* Q Test board on A4817 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4817; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... #endif
.................... 
.................... #if 0
.................... 	/* Q Test board on A4818 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4818; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... #endif
.................... 
.................... #if 0
.................... 	/* N Test A4756 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x44; /* on on */
.................... 	device[0].serialNumber=('A'<<16) + 4821; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36; /* off off */
.................... 	device[1].serialNumber=('A'<<16) + 4822; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38; /* on off */
.................... 	device[2].serialNumber=('A'<<16) + 4823; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[3].type=DEV_TYPE_I2C_READ_8;
.................... 	device[3].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[3].transmitEvery=1;
.................... 	device[3].networkAddress=0x3a; /* off /on */
.................... 	device[3].serialNumber=('A'<<16) + 4824; 
.................... 	device[3].startRegister=0;
.................... 	device[3].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* N Test A4811 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x44; /* on on */
.................... 	device[0].serialNumber=('A'<<16) + 4811; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36; /* off off */
.................... 	device[1].serialNumber=('A'<<16) + 4811; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38; /* on off */
.................... 	device[2].serialNumber=('A'<<16) + 4811; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[3].type=DEV_TYPE_I2C_READ_8;
.................... 	device[3].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[3].transmitEvery=1;
.................... 	device[3].networkAddress=0x3a; /* off / on */
.................... 	device[3].serialNumber=('A'<<16) + 4811; 
.................... 	device[3].startRegister=0;
.................... 	device[3].nRegisters=32;
.................... #endif
.................... 
.................... #if 1
08F0:  INCF   x8C,F
08F2:  BRA    08CA
.................... 	/* N Test A4812 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
08F4:  MOVLW  10
08F6:  MOVWF  21
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
08F8:  MOVLW  7D
08FA:  MOVWF  23
08FC:  CLRF   22
.................... 	device[0].transmitEvery=1;
08FE:  MOVLW  01
0900:  MOVWF  24
.................... 	device[0].networkAddress=0x44; /* on on */
0902:  MOVLW  44
0904:  MOVWF  25
.................... 	device[0].serialNumber=('A'<<16) + 4812; 
0906:  CLRF   29
0908:  MOVLW  41
090A:  MOVWF  28
090C:  MOVLW  12
090E:  MOVWF  27
0910:  MOVLW  CC
0912:  MOVWF  26
.................... 	device[0].startRegister=0;
0914:  CLRF   2B
0916:  CLRF   2A
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
0918:  MOVLW  06
091A:  MOVWF  2C
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
091C:  MOVLW  10
091E:  MOVWF  2E
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0920:  MOVLW  7D
0922:  MOVWF  30
0924:  CLRF   2F
.................... 	device[1].transmitEvery=1;
0926:  MOVLW  01
0928:  MOVWF  31
.................... 	device[1].networkAddress=0x36; /* off off */
092A:  MOVLW  36
092C:  MOVWF  32
.................... 	device[1].serialNumber=('A'<<16) + 4812; 
092E:  CLRF   36
0930:  MOVLW  41
0932:  MOVWF  35
0934:  MOVLW  12
0936:  MOVWF  34
0938:  MOVLW  CC
093A:  MOVWF  33
.................... 	device[1].startRegister=0;
093C:  CLRF   38
093E:  CLRF   37
.................... 	device[1].nRegisters=32;
0940:  MOVLW  20
0942:  MOVWF  39
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
0944:  MOVLW  10
0946:  MOVWF  3B
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0948:  MOVLW  7D
094A:  MOVWF  3D
094C:  CLRF   3C
.................... 	device[2].transmitEvery=1;
094E:  MOVLW  01
0950:  MOVWF  3E
.................... 	device[2].networkAddress=0x38; /* on off */
0952:  MOVLW  38
0954:  MOVWF  3F
.................... 	device[2].serialNumber=('A'<<16) + 4812; 
0956:  CLRF   43
0958:  MOVLW  41
095A:  MOVWF  42
095C:  MOVLW  12
095E:  MOVWF  41
0960:  MOVLW  CC
0962:  MOVWF  40
.................... 	device[2].startRegister=0;
0964:  CLRF   45
0966:  CLRF   44
.................... 	device[2].nRegisters=32;
0968:  MOVLW  20
096A:  MOVWF  46
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[3].type=DEV_TYPE_I2C_READ_8;
096C:  MOVLW  10
096E:  MOVWF  48
.................... 	device[3].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0970:  MOVLW  7D
0972:  MOVWF  4A
0974:  CLRF   49
.................... 	device[3].transmitEvery=1;
0976:  MOVLW  01
0978:  MOVWF  4B
.................... 	device[3].networkAddress=0x3a; /* off / on */
097A:  MOVLW  3A
097C:  MOVWF  4C
.................... 	device[3].serialNumber=('A'<<16) + 4812; 
097E:  CLRF   50
0980:  MOVLW  41
0982:  MOVWF  4F
0984:  MOVLW  12
0986:  MOVWF  4E
0988:  MOVLW  CC
098A:  MOVWF  4D
.................... 	device[3].startRegister=0;
098C:  CLRF   52
098E:  CLRF   51
.................... 	device[3].nRegisters=32;
0990:  MOVLW  20
0992:  MOVWF  53
.................... #endif
.................... 
.................... #if 0
.................... 	/* N Test A4813 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x44; /* on on */
.................... 	device[0].serialNumber=('A'<<16) + 4813; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... #endif
.................... 
.................... #if 0
.................... 	/* N Test A4814 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x44; /* on on */
.................... 	device[0].serialNumber=('A'<<16) + 4814; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... #endif
.................... 
.................... #if 1
.................... 	/* N Test A4819 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
0994:  MOVLW  10
0996:  MOVWF  21
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0998:  MOVLW  7D
099A:  MOVWF  23
099C:  CLRF   22
.................... 	device[0].transmitEvery=1;
099E:  MOVLW  01
09A0:  MOVWF  24
.................... 	device[0].networkAddress=0x44; /* on on */
09A2:  MOVLW  44
09A4:  MOVWF  25
.................... 	device[0].serialNumber=('A'<<16) + 4819; 
09A6:  CLRF   29
09A8:  MOVLW  41
09AA:  MOVWF  28
09AC:  MOVLW  12
09AE:  MOVWF  27
09B0:  MOVLW  D3
09B2:  MOVWF  26
.................... 	device[0].startRegister=0;
09B4:  CLRF   2B
09B6:  CLRF   2A
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
09B8:  MOVLW  06
09BA:  MOVWF  2C
.................... #endif
.................... 
.................... 
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# write_device_file()\r\n");
.................... #endif
.................... 
.................... 	write_device_file();
09BC:  MOVLB  0
09BE:  RCALL  086E
09C0:  RETURN 0
.................... }
.................... 
.................... void read_device_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(DEVICE_ADDRESS,(void *)&device, sizeof(device)); 
*
0A96:  MOVLB  9
0A98:  MOVLW  21
0A9A:  MOVWF  x7B
0A9C:  CLRF   x7E
0A9E:  MOVLW  80
0AA0:  MOVWF  x7D
0AA2:  CLRF   x80
0AA4:  MOVFF  97B,97F
0AA8:  MOVLW  03
0AAA:  MOVWF  x82
0AAC:  MOVLW  40
0AAE:  MOVWF  x81
0AB0:  MOVLB  0
0AB2:  RCALL  09C2
0AB4:  MOVFF  01,97A
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# read_device_file crc=%u\r\n",crc);
.................... #endif
.................... 
.................... 	if ( crc != read_eeprom(DEVICE_CRC_ADDRESS) ) {
0AB8:  MOVFF  FF2,97B
0ABC:  BCF    FF2.7
0ABE:  CLRF   F75
0AC0:  MOVLW  02
0AC2:  MOVWF  F74
0AC4:  BCF    F7F.6
0AC6:  BCF    F7F.7
0AC8:  BSF    F7F.0
0ACA:  MOVF   F73,W
0ACC:  MOVLB  9
0ACE:  BTFSC  x7B.7
0AD0:  BSF    FF2.7
0AD2:  SUBWF  x7A,W
0AD4:  BZ    0ADC
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_device_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_device_file();
0AD6:  MOVLB  0
0AD8:  RCALL  08C0
0ADA:  MOVLB  9
.................... 	}
0ADC:  MOVLB  0
0ADE:  GOTO   3762 (RETURN)
.................... }
.................... 
.................... void devicesDump(void) {
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... 
.................... 	fprintf(STREAM_WORLD,"# dumping all enabled devices:\r\n");
.................... 	for ( i=0 ; i<16 ; i++ ) {
.................... 		restart_wdt();
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[i].type ) 
.................... 			continue;
.................... 
.................... 		fprintf(STREAM_WORLD,"device[%u]\r\n",i);
.................... 		fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[i].type);
.................... 		fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[i].transmitEvery);
.................... 		fprintf(STREAM_WORLD,"\tnetworkAddress=%u\r\n",device[i].networkAddress);
.................... 		fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 			make8(device[i].serialNumber,3),
.................... 			make8(device[i].serialNumber,2),
.................... 			make8(device[i].serialNumber,1),
.................... 			make8(device[i].serialNumber,0)
.................... 		);
.................... 		fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[i].startRegister);
.................... 		fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[i].nRegisters);
.................... 	}
.................... 	fprintf(STREAM_WORLD,"# done\r\n");
.................... #endif
.................... }
.................... 
.................... #include "modbus_int_uart_rdTap.c"
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //// MASTER API:                                                                      ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /*Some defines so we can use identifiers to set things up*/
.................... #define MODBUS_TYPE_MASTER 99999
.................... #define MODBUS_TYPE_SLAVE 88888
.................... #define MODBUS_INT_RDA 77777
.................... #define MODBUS_INT_RDA2 66666
.................... #define MODBUS_INT_EXT 55555
.................... 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER
.................... 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA  // Select between external interrupt
.................... #define MODBUS_SERIAL_BAUD 9600
.................... #define MODBUS_SERIAL_RX_PIN       NET_RX   // Data receive pin
.................... #define MODBUS_SERIAL_TX_PIN       NET_TX   // Data transmit pin
.................... #define MODBUS_SERIAL_ENABLE_PIN   RS485_DE   // Controls DE pin.  RX low, TX high.
.................... #define MODBUS_SERIAL_RX_ENABLE    RS485_NOT_RE   // Controls RE pin.  Should keep low.
.................... #define MODBUS_SERIAL_TIMEOUT      100000     //in us
.................... 
.................... 
.................... #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, parity=N, stream=MODBUS_SERIAL, errors)
*
0336:  BTFSS  F9E.5
0338:  BRA    0336
033A:  MOVFF  FAB,20
033E:  MOVFF  FAE,01
0342:  BTFSS  20.1
0344:  BRA    034A
0346:  BCF    FAB.4
0348:  BSF    FAB.4
034A:  RETURN 0
*
179C:  BTFSS  F9E.4
179E:  BRA    179C
17A0:  MOVWF  FAD
17A2:  GOTO   17AE (RETURN)
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);}
.................... 
.................... 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer
.................... 
.................... 
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
.................... 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................     if(address)\
....................     {\
....................         while(!modbus_kbhit() && --modbus_serial_wait)\
....................             delay_us(1);\
....................         if(!modbus_serial_wait)\
....................             modbus_rx.error=TIMEOUT;\
....................     }\
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... //#byte TXSTA=getenv("sfr:TXSTA")
.................... #byte TXSTA=0xfad
.................... #bit TRMT=TXSTA.1
.................... 
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }   
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    int8 b[2];
....................    int16 d;
.................... } modbus_serial_crc;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void rcv_on(void) {
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
.................... 	while(kbhit(MODBUS_SERIAL)) {
*
0AE2:  BTFSS  F9E.5
0AE4:  BRA    0AEA
.................... 		fgetc(MODBUS_SERIAL);
0AE6:  RCALL  0336
0AE8:  BRA    0AE2
.................... 	}  
.................... 	
.................... 	clear_interrupt(INT_RDA);
0AEA:  MOVF   FAE,W
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE);
.................... 	output_low(RS485_DE);
0AEC:  BCF    F94.5
0AEE:  BCF    F8B.5
.................... 	enable_interrupts(INT_RDA);
0AF0:  BSF    F9D.5
0AF2:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init()
.................... {
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
0AF4:  BCF    F94.5
0AF6:  BCF    F8B.5
.................... 
....................    RCV_ON();
0AF8:  RCALL  0AE2
.................... 
.................... //   setup_timer_2(T2_DIV_BY_16,249,5);   //10ms interrupts
....................    setup_timer_2(T2_DIV_BY_16,249,10);   //20ms interrupts
0AFA:  MOVLW  48
0AFC:  IORLW  06
0AFE:  MOVWF  FCA
0B00:  MOVLW  F9
0B02:  MOVWF  FCB
.................... 
....................    enable_interrupts(GLOBAL);
0B04:  MOVLW  C0
0B06:  IORWF  FF2,F
0B08:  GOTO   3768 (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... void modbus_enable_timeout(int1 enable)
.................... {
....................    disable_interrupts(INT_TIMER2);
*
02F2:  BCF    F9D.1
....................    if (enable) {
02F4:  MOVLB  9
02F6:  MOVF   x9C,F
02F8:  BZ    0300
....................       set_timer2(0);
02FA:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2);
02FC:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2);
02FE:  BSF    F9D.1
....................    }
0300:  MOVLB  0
0302:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... #int_timer2
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
0304:  MOVLB  5
0306:  MOVF   x90,W
0308:  SUBLW  02
030A:  BNZ   0320
030C:  MOVF   x91,F
030E:  BNZ   0320
0310:  MOVF   x92,F
0312:  BNZ   0320
0314:  BTFSC  x8F.0
0316:  BRA    0320
....................    {
....................       modbus_rx.len-=2;
0318:  MOVLW  02
031A:  SUBWF  x94,F
....................       modbus_serial_new=TRUE;
031C:  BSF    x8F.0
....................    }
031E:  BRA    0322
....................    else
....................       modbus_serial_new=FALSE;
0320:  BCF    x8F.0
.................... 
....................    modbus_serial_crc.d=0xFFFF;
0322:  SETF   x92
0324:  SETF   x91
....................    modbus_serial_state=MODBUS_GETADDY;
0326:  CLRF   x90
....................    modbus_enable_timeout(FALSE);
0328:  MOVLB  9
032A:  CLRF   x9C
032C:  MOVLB  0
032E:  RCALL  02F2
0330:  BCF    F9E.1
0332:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................   int8 uIndex ; // will index into CRC lookup table
.................... 
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
034C:  MOVLB  5
034E:  MOVF   x92,W
0350:  MOVLB  9
0352:  XORWF  x9C,W
0354:  MOVWF  x9D
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
0356:  CLRF   03
0358:  MOVF   x9D,W
035A:  MOVLB  0
035C:  RCALL  00D2
035E:  MOVWF  01
0360:  MOVLB  5
0362:  MOVF   x91,W
0364:  XORWF  01,W
0366:  MOVWF  x92
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0368:  CLRF   03
036A:  MOVLB  9
036C:  MOVF   x9D,W
036E:  MOVLB  0
0370:  RCALL  01E2
0372:  MOVFF  FE8,591
0376:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c)
.................... {
....................    fputc(c, MODBUS_SERIAL);
*
17A6:  MOVLB  9
17A8:  MOVF   x90,W
17AA:  MOVLB  0
17AC:  BRA    179C
17AE:  CLRF   19
17B0:  BTFSC  FF2.7
17B2:  BSF    19.7
17B4:  BCF    FF2.7
....................    modbus_calc_crc(c);
17B6:  MOVFF  990,99C
17BA:  CALL   034C
17BE:  BTFSC  19.7
17C0:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
17C2:  CLRWDT
17C4:  MOVLW  44
17C6:  MOVWF  00
17C8:  DECFSZ 00,F
17CA:  BRA    17C8
17CC:  BRA    17CE
17CE:  RETURN 0
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
.................... #int_rda
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
.................... #int_rda2
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT)
.................... #int_ext
.................... #else
.................... #error Please define a correct interrupt source
.................... #endif
.................... void incomming_modbus_serial() {
....................    char c;
.................... 
....................    c=fgetc(MODBUS_SERIAL);
*
0378:  RCALL  0336
037A:  MOVFF  01,99B
.................... 
....................    if (!modbus_serial_new)
037E:  MOVLB  5
0380:  BTFSC  x8F.0
0382:  BRA    03DA
....................    {
....................       if(modbus_serial_state == MODBUS_GETADDY)
0384:  MOVF   x90,F
0386:  BNZ   0398
....................       {
....................          modbus_serial_crc.d = 0xFFFF;
0388:  SETF   x92
038A:  SETF   x91
....................          modbus_rx.address = c;
038C:  MOVFF  99B,593
....................          modbus_serial_state++;
0390:  INCF   x90,F
....................          modbus_rx.len = 0;
0392:  CLRF   x94
....................          modbus_rx.error=0;
0394:  CLRF   x96
....................       }
0396:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETFUNC)
0398:  DECFSZ x90,W
039A:  BRA    03A4
....................       {
....................          modbus_rx.func = c;
039C:  MOVFF  99B,595
....................          modbus_serial_state++;
03A0:  INCF   x90,F
....................       }
03A2:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETDATA)
03A4:  MOVF   x90,W
03A6:  SUBLW  02
03A8:  BNZ   03C6
....................       {
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;}
03AA:  INCFSZ x94,W
03AC:  BRA    03B2
03AE:  MOVLW  FE
03B0:  MOVWF  x94
....................          modbus_rx.data[modbus_rx.len]=c;
03B2:  MOVLW  97
03B4:  ADDWF  x94,W
03B6:  MOVWF  FE9
03B8:  MOVLW  05
03BA:  MOVWF  FEA
03BC:  BTFSC  FD8.0
03BE:  INCF   FEA,F
03C0:  MOVFF  99B,FEF
....................          modbus_rx.len++;
03C4:  INCF   x94,F
....................       }
.................... 
....................       modbus_calc_crc(c);
03C6:  MOVFF  99B,99C
03CA:  MOVLB  0
03CC:  RCALL  034C
....................       modbus_enable_timeout(TRUE);
03CE:  MOVLW  01
03D0:  MOVLB  9
03D2:  MOVWF  x9C
03D4:  MOVLB  0
03D6:  RCALL  02F2
03D8:  MOVLB  5
....................    }
03DA:  BCF    F9E.5
03DC:  MOVLB  0
03DE:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func)
.................... {
....................    modbus_serial_crc.d=0xFFFF;
*
17D0:  MOVLB  5
17D2:  SETF   x92
17D4:  SETF   x91
....................    modbus_serial_new=FALSE;
17D6:  BCF    x8F.0
.................... 
....................    RCV_OFF();
17D8:  BCF    F9D.5
....................    
....................    output_high(MODBUS_SERIAL_ENABLE_PIN);
17DA:  BCF    F94.5
17DC:  BSF    F8B.5
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
17DE:  CLRWDT
17E0:  MOVLW  F2
17E2:  MOVWF  00
17E4:  DECFSZ 00,F
17E6:  BRA    17E4
.................... 
....................    modbus_serial_putc(to);
17E8:  MOVFF  98D,990
17EC:  MOVLB  0
17EE:  RCALL  17A6
....................    modbus_serial_putc(func);
17F0:  MOVFF  98E,990
17F4:  RCALL  17A6
17F6:  RETURN 0
.................... }
.................... 
.................... void modbus_serial_send_stop()
.................... {
....................    int8 crc_low, crc_high;
.................... 
.................... 
....................    crc_high=modbus_serial_crc.b[1];
17F8:  MOVFF  592,98E
....................    crc_low=modbus_serial_crc.b[0];
17FC:  MOVFF  591,98D
.................... 
....................    modbus_serial_putc(crc_high);
1800:  MOVFF  98E,990
1804:  RCALL  17A6
....................    modbus_serial_putc(crc_low);
1806:  MOVFF  98D,990
180A:  RCALL  17A6
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................    WAIT_FOR_HW_BUFFER();
180C:  BTFSS  FAD.1
180E:  BRA    180C
.................... #endif
....................     
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
1810:  CLRWDT
1812:  MOVLW  F2
1814:  MOVWF  00
1816:  DECFSZ 00,F
1818:  BRA    1816
.................... 
.................... 
....................    RCV_ON();
181A:  CALL   0AE2
.................... 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
181E:  BCF    F94.5
1820:  BCF    F8B.5
.................... 
....................    modbus_serial_crc.d=0xFFFF;
1822:  MOVLB  5
1824:  SETF   x92
1826:  SETF   x91
1828:  MOVLB  0
182A:  RETURN 0
.................... 
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
182C:  MOVLB  5
182E:  BTFSC  x8F.0
1830:  BRA    183A
....................       return FALSE;
1832:  MOVLW  00
1834:  MOVWF  01
1836:  BRA    184C
1838:  BRA    1846
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
183A:  BTFSS  x95.7
183C:  BRA    1846
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
183E:  MOVFF  597,596
....................       modbus_rx.len = 1;
1842:  MOVLW  01
1844:  MOVWF  x94
....................    }
....................    modbus_serial_new=FALSE;
1846:  BCF    x8F.0
....................    return TRUE;
1848:  MOVLW  01
184A:  MOVWF  01
184C:  MOVLB  0
184E:  RETURN 0
.................... }
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... /*MODBUS Master Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
*
1C4A:  MOVFF  982,98D
1C4E:  MOVLW  01
1C50:  MOVLB  9
1C52:  MOVWF  x8E
1C54:  MOVLB  0
1C56:  RCALL  17D0
.................... 
....................    modbus_serial_putc(make8(start_address,1));
1C58:  MOVFF  984,990
1C5C:  RCALL  17A6
....................    modbus_serial_putc(make8(start_address,0));
1C5E:  MOVFF  983,990
1C62:  RCALL  17A6
.................... 
....................    modbus_serial_putc(make8(quantity,1));
1C64:  MOVFF  986,990
1C68:  RCALL  17A6
....................    modbus_serial_putc(make8(quantity,0));
1C6A:  MOVFF  985,990
1C6E:  RCALL  17A6
.................... 
....................    modbus_serial_send_stop();
1C70:  RCALL  17F8
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
1C72:  MOVLB  9
1C74:  MOVF   x82,F
1C76:  BZ    1CCA
1C78:  MOVLB  0
1C7A:  RCALL  182C
1C7C:  MOVF   01,F
1C7E:  BNZ   1CB2
1C80:  MOVLW  FF
1C82:  MOVLB  5
1C84:  ADDWF  x8B,F
1C86:  BTFSS  FD8.0
1C88:  ADDWF  x8C,F
1C8A:  BTFSS  FD8.0
1C8C:  ADDWF  x8D,F
1C8E:  BTFSS  FD8.0
1C90:  ADDWF  x8E,F
1C92:  MOVF   x8B,F
1C94:  BNZ   1CA8
1C96:  MOVF   x8C,F
1C98:  BNZ   1CA8
1C9A:  MOVF   x8D,F
1C9C:  BNZ   1CA8
1C9E:  MOVF   x8E,F
1CA0:  BTFSS  FD8.2
1CA2:  BRA    1CA8
1CA4:  MOVLB  0
1CA6:  BRA    1CB2
1CA8:  CLRWDT
1CAA:  NOP   
1CAC:  MOVLB  9
1CAE:  BRA    1C78
1CB0:  MOVLB  0
1CB2:  MOVLB  5
1CB4:  MOVF   x8B,F
1CB6:  BNZ   1CC8
1CB8:  MOVF   x8C,F
1CBA:  BNZ   1CC8
1CBC:  MOVF   x8D,F
1CBE:  BNZ   1CC8
1CC0:  MOVF   x8E,F
1CC2:  BNZ   1CC8
1CC4:  MOVLW  0C
1CC6:  MOVWF  x96
1CC8:  MOVLB  9
1CCA:  MOVLB  5
1CCC:  CLRF   x8E
1CCE:  MOVLW  01
1CD0:  MOVWF  x8D
1CD2:  MOVLW  86
1CD4:  MOVWF  x8C
1CD6:  MOVLW  A0
1CD8:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
1CDA:  MOVFF  596,01
1CDE:  MOVLB  0
1CE0:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
*
2D98:  MOVFF  982,98D
2D9C:  MOVLW  02
2D9E:  MOVLB  9
2DA0:  MOVWF  x8E
2DA2:  MOVLB  0
2DA4:  CALL   17D0
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2DA8:  MOVFF  984,990
2DAC:  CALL   17A6
....................    modbus_serial_putc(make8(start_address,0));
2DB0:  MOVFF  983,990
2DB4:  CALL   17A6
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2DB8:  MOVFF  986,990
2DBC:  CALL   17A6
....................    modbus_serial_putc(make8(quantity,0));
2DC0:  MOVFF  985,990
2DC4:  CALL   17A6
.................... 
....................    modbus_serial_send_stop();
2DC8:  CALL   17F8
....................       
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2DCC:  MOVLB  9
2DCE:  MOVF   x82,F
2DD0:  BZ    2E26
2DD2:  MOVLB  0
2DD4:  CALL   182C
2DD8:  MOVF   01,F
2DDA:  BNZ   2E0E
2DDC:  MOVLW  FF
2DDE:  MOVLB  5
2DE0:  ADDWF  x8B,F
2DE2:  BTFSS  FD8.0
2DE4:  ADDWF  x8C,F
2DE6:  BTFSS  FD8.0
2DE8:  ADDWF  x8D,F
2DEA:  BTFSS  FD8.0
2DEC:  ADDWF  x8E,F
2DEE:  MOVF   x8B,F
2DF0:  BNZ   2E04
2DF2:  MOVF   x8C,F
2DF4:  BNZ   2E04
2DF6:  MOVF   x8D,F
2DF8:  BNZ   2E04
2DFA:  MOVF   x8E,F
2DFC:  BTFSS  FD8.2
2DFE:  BRA    2E04
2E00:  MOVLB  0
2E02:  BRA    2E0E
2E04:  CLRWDT
2E06:  NOP   
2E08:  MOVLB  9
2E0A:  BRA    2DD2
2E0C:  MOVLB  0
2E0E:  MOVLB  5
2E10:  MOVF   x8B,F
2E12:  BNZ   2E24
2E14:  MOVF   x8C,F
2E16:  BNZ   2E24
2E18:  MOVF   x8D,F
2E1A:  BNZ   2E24
2E1C:  MOVF   x8E,F
2E1E:  BNZ   2E24
2E20:  MOVLW  0C
2E22:  MOVWF  x96
2E24:  MOVLB  9
2E26:  MOVLB  5
2E28:  CLRF   x8E
2E2A:  MOVLW  01
2E2C:  MOVWF  x8D
2E2E:  MOVLW  86
2E30:  MOVWF  x8C
2E32:  MOVLW  A0
2E34:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2E36:  MOVFF  596,01
2E3A:  MOVLB  0
2E3C:  GOTO   31D2 (RETURN)
.................... }
.................... 
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
*
18E8:  MOVFF  982,98D
18EC:  MOVLW  03
18EE:  MOVLB  9
18F0:  MOVWF  x8E
18F2:  MOVLB  0
18F4:  RCALL  17D0
.................... 
....................    modbus_serial_putc(make8(start_address,1));
18F6:  MOVFF  984,990
18FA:  RCALL  17A6
....................    modbus_serial_putc(make8(start_address,0));
18FC:  MOVFF  983,990
1900:  RCALL  17A6
.................... 
....................    modbus_serial_putc(make8(quantity,1));
1902:  MOVFF  986,990
1906:  RCALL  17A6
....................    modbus_serial_putc(make8(quantity,0));
1908:  MOVFF  985,990
190C:  RCALL  17A6
.................... 
....................    modbus_serial_send_stop();
190E:  RCALL  17F8
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
1910:  MOVLB  9
1912:  MOVF   x82,F
1914:  BZ    1968
1916:  MOVLB  0
1918:  RCALL  182C
191A:  MOVF   01,F
191C:  BNZ   1950
191E:  MOVLW  FF
1920:  MOVLB  5
1922:  ADDWF  x8B,F
1924:  BTFSS  FD8.0
1926:  ADDWF  x8C,F
1928:  BTFSS  FD8.0
192A:  ADDWF  x8D,F
192C:  BTFSS  FD8.0
192E:  ADDWF  x8E,F
1930:  MOVF   x8B,F
1932:  BNZ   1946
1934:  MOVF   x8C,F
1936:  BNZ   1946
1938:  MOVF   x8D,F
193A:  BNZ   1946
193C:  MOVF   x8E,F
193E:  BTFSS  FD8.2
1940:  BRA    1946
1942:  MOVLB  0
1944:  BRA    1950
1946:  CLRWDT
1948:  NOP   
194A:  MOVLB  9
194C:  BRA    1916
194E:  MOVLB  0
1950:  MOVLB  5
1952:  MOVF   x8B,F
1954:  BNZ   1966
1956:  MOVF   x8C,F
1958:  BNZ   1966
195A:  MOVF   x8D,F
195C:  BNZ   1966
195E:  MOVF   x8E,F
1960:  BNZ   1966
1962:  MOVLW  0C
1964:  MOVWF  x96
1966:  MOVLB  9
1968:  MOVLB  5
196A:  CLRF   x8E
196C:  MOVLW  01
196E:  MOVWF  x8D
1970:  MOVLW  86
1972:  MOVWF  x8C
1974:  MOVLW  A0
1976:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
1978:  MOVFF  596,01
197C:  MOVLB  0
197E:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
*
1850:  MOVFF  982,98D
1854:  MOVLW  04
1856:  MOVLB  9
1858:  MOVWF  x8E
185A:  MOVLB  0
185C:  RCALL  17D0
.................... 
....................    modbus_serial_putc(make8(start_address,1));
185E:  MOVFF  984,990
1862:  RCALL  17A6
....................    modbus_serial_putc(make8(start_address,0));
1864:  MOVFF  983,990
1868:  RCALL  17A6
.................... 
.................... 
....................    modbus_serial_putc(make8(quantity,1));
186A:  MOVFF  986,990
186E:  RCALL  17A6
....................    modbus_serial_putc(make8(quantity,0));
1870:  MOVFF  985,990
1874:  RCALL  17A6
.................... 
....................    modbus_serial_send_stop();
1876:  RCALL  17F8
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
1878:  MOVLB  9
187A:  MOVF   x82,F
187C:  BZ    18D0
187E:  MOVLB  0
1880:  RCALL  182C
1882:  MOVF   01,F
1884:  BNZ   18B8
1886:  MOVLW  FF
1888:  MOVLB  5
188A:  ADDWF  x8B,F
188C:  BTFSS  FD8.0
188E:  ADDWF  x8C,F
1890:  BTFSS  FD8.0
1892:  ADDWF  x8D,F
1894:  BTFSS  FD8.0
1896:  ADDWF  x8E,F
1898:  MOVF   x8B,F
189A:  BNZ   18AE
189C:  MOVF   x8C,F
189E:  BNZ   18AE
18A0:  MOVF   x8D,F
18A2:  BNZ   18AE
18A4:  MOVF   x8E,F
18A6:  BTFSS  FD8.2
18A8:  BRA    18AE
18AA:  MOVLB  0
18AC:  BRA    18B8
18AE:  CLRWDT
18B0:  NOP   
18B2:  MOVLB  9
18B4:  BRA    187E
18B6:  MOVLB  0
18B8:  MOVLB  5
18BA:  MOVF   x8B,F
18BC:  BNZ   18CE
18BE:  MOVF   x8C,F
18C0:  BNZ   18CE
18C2:  MOVF   x8D,F
18C4:  BNZ   18CE
18C6:  MOVF   x8E,F
18C8:  BNZ   18CE
18CA:  MOVLW  0C
18CC:  MOVWF  x96
18CE:  MOVLB  9
18D0:  MOVLB  5
18D2:  CLRF   x8E
18D4:  MOVLW  01
18D6:  MOVWF  x8D
18D8:  MOVLW  86
18DA:  MOVWF  x8C
18DC:  MOVLW  A0
18DE:  MOVWF  x8B
.................... 
.................... 
.................... 
....................    return modbus_rx.error;
18E0:  MOVFF  596,01
18E4:  MOVLB  0
18E6:  RETURN 0
.................... }
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
*
2E40:  MOVFF  983,98D
2E44:  MOVLW  05
2E46:  MOVLB  9
2E48:  MOVWF  x8E
2E4A:  MOVLB  0
2E4C:  CALL   17D0
.................... 
....................    modbus_serial_putc(make8(output_address,1));
2E50:  MOVFF  985,990
2E54:  CALL   17A6
....................    modbus_serial_putc(make8(output_address,0));
2E58:  MOVFF  984,990
2E5C:  CALL   17A6
.................... 
....................    if(on)
2E60:  MOVLB  9
2E62:  MOVF   x86,F
2E64:  BZ    2E72
....................        modbus_serial_putc(0xFF);
2E66:  SETF   x90
2E68:  MOVLB  0
2E6A:  CALL   17A6
2E6E:  BRA    2E7A
2E70:  MOVLB  9
....................    else
....................        modbus_serial_putc(0x00);
2E72:  CLRF   x90
2E74:  MOVLB  0
2E76:  CALL   17A6
....................    
....................    modbus_serial_putc(0x00);
2E7A:  MOVLB  9
2E7C:  CLRF   x90
2E7E:  MOVLB  0
2E80:  CALL   17A6
.................... 
....................    modbus_serial_send_stop();
2E84:  CALL   17F8
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2E88:  MOVLB  9
2E8A:  MOVF   x83,F
2E8C:  BZ    2EE2
2E8E:  MOVLB  0
2E90:  CALL   182C
2E94:  MOVF   01,F
2E96:  BNZ   2ECA
2E98:  MOVLW  FF
2E9A:  MOVLB  5
2E9C:  ADDWF  x8B,F
2E9E:  BTFSS  FD8.0
2EA0:  ADDWF  x8C,F
2EA2:  BTFSS  FD8.0
2EA4:  ADDWF  x8D,F
2EA6:  BTFSS  FD8.0
2EA8:  ADDWF  x8E,F
2EAA:  MOVF   x8B,F
2EAC:  BNZ   2EC0
2EAE:  MOVF   x8C,F
2EB0:  BNZ   2EC0
2EB2:  MOVF   x8D,F
2EB4:  BNZ   2EC0
2EB6:  MOVF   x8E,F
2EB8:  BTFSS  FD8.2
2EBA:  BRA    2EC0
2EBC:  MOVLB  0
2EBE:  BRA    2ECA
2EC0:  CLRWDT
2EC2:  NOP   
2EC4:  MOVLB  9
2EC6:  BRA    2E8E
2EC8:  MOVLB  0
2ECA:  MOVLB  5
2ECC:  MOVF   x8B,F
2ECE:  BNZ   2EE0
2ED0:  MOVF   x8C,F
2ED2:  BNZ   2EE0
2ED4:  MOVF   x8D,F
2ED6:  BNZ   2EE0
2ED8:  MOVF   x8E,F
2EDA:  BNZ   2EE0
2EDC:  MOVLW  0C
2EDE:  MOVWF  x96
2EE0:  MOVLB  9
2EE2:  MOVLB  5
2EE4:  CLRF   x8E
2EE6:  MOVLW  01
2EE8:  MOVWF  x8D
2EEA:  MOVLW  86
2EEC:  MOVWF  x8C
2EEE:  MOVLW  A0
2EF0:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2EF2:  MOVFF  596,01
2EF6:  MOVLB  0
2EF8:  GOTO   3254 (RETURN)
.................... }
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
2EFC:  MOVFF  986,98D
2F00:  MOVLW  06
2F02:  MOVLB  9
2F04:  MOVWF  x8E
2F06:  MOVLB  0
2F08:  CALL   17D0
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
2F0C:  MOVFF  988,990
2F10:  CALL   17A6
....................    modbus_serial_putc(make8(reg_address,0));
2F14:  MOVFF  987,990
2F18:  CALL   17A6
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
2F1C:  MOVFF  98A,990
2F20:  CALL   17A6
....................    modbus_serial_putc(make8(reg_value,0));
2F24:  MOVFF  989,990
2F28:  CALL   17A6
.................... 
....................    modbus_serial_send_stop();
2F2C:  CALL   17F8
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2F30:  MOVLB  9
2F32:  MOVF   x86,F
2F34:  BZ    2F8A
2F36:  MOVLB  0
2F38:  CALL   182C
2F3C:  MOVF   01,F
2F3E:  BNZ   2F72
2F40:  MOVLW  FF
2F42:  MOVLB  5
2F44:  ADDWF  x8B,F
2F46:  BTFSS  FD8.0
2F48:  ADDWF  x8C,F
2F4A:  BTFSS  FD8.0
2F4C:  ADDWF  x8D,F
2F4E:  BTFSS  FD8.0
2F50:  ADDWF  x8E,F
2F52:  MOVF   x8B,F
2F54:  BNZ   2F68
2F56:  MOVF   x8C,F
2F58:  BNZ   2F68
2F5A:  MOVF   x8D,F
2F5C:  BNZ   2F68
2F5E:  MOVF   x8E,F
2F60:  BTFSS  FD8.2
2F62:  BRA    2F68
2F64:  MOVLB  0
2F66:  BRA    2F72
2F68:  CLRWDT
2F6A:  NOP   
2F6C:  MOVLB  9
2F6E:  BRA    2F36
2F70:  MOVLB  0
2F72:  MOVLB  5
2F74:  MOVF   x8B,F
2F76:  BNZ   2F88
2F78:  MOVF   x8C,F
2F7A:  BNZ   2F88
2F7C:  MOVF   x8D,F
2F7E:  BNZ   2F88
2F80:  MOVF   x8E,F
2F82:  BNZ   2F88
2F84:  MOVLW  0C
2F86:  MOVWF  x96
2F88:  MOVLB  9
2F8A:  MOVLB  5
2F8C:  CLRF   x8E
2F8E:  MOVLW  01
2F90:  MOVWF  x8D
2F92:  MOVLW  86
2F94:  MOVWF  x8C
2F96:  MOVLW  A0
2F98:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2F9A:  MOVFF  596,01
2F9E:  MOVLB  0
2FA0:  GOTO   32AA (RETURN)
.................... }
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity,
....................                            int8 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = (int8)((quantity/8));
....................    
....................    if(quantity%8)
....................       count++;      
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
....................    
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < quantity; ++i)
....................    {
....................       modbus_serial_putc(make8(values[i],1));
....................       modbus_serial_putc(make8(values[i],0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... exception modbus_write_multiple_registers_flip(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
2FA4:  BCF    FD8.0
2FA6:  MOVLB  9
2FA8:  RLCF   x87,W
2FAA:  MOVWF  02
2FAC:  RLCF   x88,W
2FAE:  MOVFF  02,98C
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
2FB2:  MOVFF  984,98D
2FB6:  MOVLW  10
2FB8:  MOVWF  x8E
2FBA:  MOVLB  0
2FBC:  CALL   17D0
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2FC0:  MOVFF  986,990
2FC4:  CALL   17A6
....................    modbus_serial_putc(make8(start_address,0));
2FC8:  MOVFF  985,990
2FCC:  CALL   17A6
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2FD0:  MOVFF  988,990
2FD4:  CALL   17A6
....................    modbus_serial_putc(make8(quantity,0));
2FD8:  MOVFF  987,990
2FDC:  CALL   17A6
....................    
....................    modbus_serial_putc(count);
2FE0:  MOVFF  98C,990
2FE4:  CALL   17A6
.................... 
....................    for(i=0; i < quantity; ++i)
2FE8:  MOVLB  9
2FEA:  CLRF   x8B
2FEC:  MOVF   x88,F
2FEE:  BNZ   2FF6
2FF0:  MOVF   x87,W
2FF2:  SUBWF  x8B,W
2FF4:  BC    304E
....................    {
....................       modbus_serial_putc(make8(values[i],0));
2FF6:  CLRF   03
2FF8:  MOVFF  98B,02
2FFC:  BCF    FD8.0
2FFE:  RLCF   02,F
3000:  RLCF   03,F
3002:  MOVF   02,W
3004:  ADDWF  x89,W
3006:  MOVWF  FE9
3008:  MOVF   x8A,W
300A:  ADDWFC 03,W
300C:  MOVWF  FEA
300E:  MOVFF  FEC,98E
3012:  MOVF   FED,F
3014:  MOVFF  FEF,990
3018:  MOVLB  0
301A:  CALL   17A6
....................       modbus_serial_putc(make8(values[i],1));
301E:  CLRF   03
3020:  MOVLB  9
3022:  MOVFF  98B,02
3026:  BCF    FD8.0
3028:  RLCF   02,F
302A:  RLCF   03,F
302C:  MOVF   02,W
302E:  ADDWF  x89,W
3030:  MOVWF  FE9
3032:  MOVF   x8A,W
3034:  ADDWFC 03,W
3036:  MOVWF  FEA
3038:  MOVFF  FEC,990
303C:  MOVF   FED,F
303E:  MOVFF  FEF,98D
3042:  MOVLB  0
3044:  CALL   17A6
3048:  MOVLB  9
304A:  INCF   x8B,F
304C:  BRA    2FEC
....................    }
.................... 
....................    modbus_serial_send_stop();
304E:  MOVLB  0
3050:  CALL   17F8
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
3054:  MOVLB  9
3056:  MOVF   x84,F
3058:  BZ    30AE
305A:  MOVLB  0
305C:  CALL   182C
3060:  MOVF   01,F
3062:  BNZ   3096
3064:  MOVLW  FF
3066:  MOVLB  5
3068:  ADDWF  x8B,F
306A:  BTFSS  FD8.0
306C:  ADDWF  x8C,F
306E:  BTFSS  FD8.0
3070:  ADDWF  x8D,F
3072:  BTFSS  FD8.0
3074:  ADDWF  x8E,F
3076:  MOVF   x8B,F
3078:  BNZ   308C
307A:  MOVF   x8C,F
307C:  BNZ   308C
307E:  MOVF   x8D,F
3080:  BNZ   308C
3082:  MOVF   x8E,F
3084:  BTFSS  FD8.2
3086:  BRA    308C
3088:  MOVLB  0
308A:  BRA    3096
308C:  CLRWDT
308E:  NOP   
3090:  MOVLB  9
3092:  BRA    305A
3094:  MOVLB  0
3096:  MOVLB  5
3098:  MOVF   x8B,F
309A:  BNZ   30AC
309C:  MOVF   x8C,F
309E:  BNZ   30AC
30A0:  MOVF   x8D,F
30A2:  BNZ   30AC
30A4:  MOVF   x8E,F
30A6:  BNZ   30AC
30A8:  MOVLW  0C
30AA:  MOVWF  x96
30AC:  MOVLB  9
30AE:  MOVLB  5
30B0:  CLRF   x8E
30B2:  MOVLW  01
30B4:  MOVWF  x8D
30B6:  MOVLW  86
30B8:  MOVWF  x8C
30BA:  MOVLW  A0
30BC:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
30BE:  MOVFF  596,01
30C2:  MOVLB  0
30C4:  GOTO   32E8 (RETURN)
.................... }
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(int8 address, int8 byte_count, 
....................                             modbus_read_sub_request *request)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < (byte_count/7); i+=7)
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(int8 address, int8 byte_count, 
....................                             modbus_write_sub_request *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start,
....................                                     int16 read_quantity, int16 write_start,
....................                                     int16 write_quantity,
....................                                     int16 *write_registers_value)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(read_start,1));
....................    modbus_serial_putc(make8(read_start,0));
.................... 
....................    modbus_serial_putc(make8(read_quantity,1));
....................    modbus_serial_putc(make8(read_quantity,0));
.................... 
....................    modbus_serial_putc(make8(write_start, 1));
....................    modbus_serial_putc(make8(write_start, 0));
.................... 
....................    modbus_serial_putc(make8(write_quantity, 1));
....................    modbus_serial_putc(make8(write_quantity, 0));
.................... 
....................    modbus_serial_putc((int8)(2*write_quantity));
.................... 
....................    for(i=0; i < write_quantity ; i+=2)
....................    {
....................       modbus_serial_putc(make8(write_registers_value[i], 1));
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(FIFO_address, 1));
....................    modbus_serial_putc(make8(FIFO_address, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... #else
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*reg_data);
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... #endif
.................... 
.................... #include "iridium_sbd_rdTap.c"
.................... #define SBD_DEBUG 1
.................... 
.................... typedef struct {
.................... 	/* +SBDIX data from most recent */
.................... 	/* result from modem */
.................... 	int8  sbdix_response[42];
.................... 	/* parsed into */
.................... 	int8  sbdix_mo_status;
.................... 	int16 sbdix_mo_msn;
.................... 	int8  sbdix_mt_status;
.................... 	int16 sbdix_mt_msn;
.................... 	int16 sbdix_mt_length;
.................... 	int8  sbdix_mt_queued;
.................... 
.................... 
.................... 	/* "Mobile Originated" message from us to network */
.................... 	int8  mo_state;
.................... 	int8  mo_buff[272];
.................... 	int16 mo_length;
.................... 	int8  mo_try;
.................... 	int8  mo_sbdix_wait;
.................... 
.................... 	/* "Mobile Terminated" messages from network to us */
.................... 	int8  mt_ready;
.................... 	int8  mt_state;
.................... 	int8  mt_buff[256];
.................... 	int16 mt_length;
.................... 	int16 mt_checksum;
.................... 	
.................... 	/* ring alert */
.................... 	int8  ring_flag;
.................... 	int8  ring_state;
.................... 
.................... 	/* modem talking to us for status, AT commands, etc */
.................... 	int8 mr_ready;          /* 1=> message ready for consumption */
.................... 	int8 mr_buff[64];
.................... 	int8 mr_length;
.................... 	int8 mr_disable;
.................... } struct_iridium_sbd;
.................... 
.................... struct_iridium_sbd sbd={0};
.................... 
.................... int8 a_to_uint8(int8 *s) {
*
0B52:  MOVLB  9
0B54:  CLRF   x7E
....................    int8 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
0B56:  MOVFF  97D,FEA
0B5A:  MOVFF  97C,FE9
0B5E:  MOVF   FEF,W
0B60:  SUBLW  20
0B62:  BNZ   0B6C
....................       s++;
0B64:  INCF   x7C,F
0B66:  BTFSC  FD8.2
0B68:  INCF   x7D,F
0B6A:  BRA    0B56
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
0B6C:  MOVFF  97D,FEA
0B70:  MOVFF  97C,FE9
0B74:  MOVFF  FEF,97F
0B78:  MOVF   x7F,W
0B7A:  SUBLW  2F
0B7C:  BC    0BA2
0B7E:  MOVF   x7F,W
0B80:  SUBLW  39
0B82:  BNC   0BA2
....................       value *= 10;
0B84:  MOVF   x7E,W
0B86:  MULLW  0A
0B88:  MOVFF  FF3,97E
....................       value += (*s-'0');
0B8C:  MOVFF  97D,FEA
0B90:  MOVFF  97C,FE9
0B94:  MOVLW  30
0B96:  SUBWF  FEF,W
0B98:  ADDWF  x7E,F
....................       s++;
0B9A:  INCF   x7C,F
0B9C:  BTFSC  FD8.2
0B9E:  INCF   x7D,F
0BA0:  BRA    0B6C
....................    }
.................... 
....................    return value;
0BA2:  MOVFF  97E,01
0BA6:  MOVLB  0
0BA8:  RETURN 0
.................... }
.................... 
.................... int16 a_to_uint16(int8 *s) {
*
0BEA:  MOVLB  9
0BEC:  CLRF   x7F
0BEE:  CLRF   x7E
....................    int16 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
0BF0:  MOVFF  97D,FEA
0BF4:  MOVFF  97C,FE9
0BF8:  MOVF   FEF,W
0BFA:  SUBLW  20
0BFC:  BNZ   0C06
....................       s++;
0BFE:  INCF   x7C,F
0C00:  BTFSC  FD8.2
0C02:  INCF   x7D,F
0C04:  BRA    0BF0
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
0C06:  MOVFF  97D,FEA
0C0A:  MOVFF  97C,FE9
0C0E:  MOVFF  FEF,980
0C12:  MOVF   x80,W
0C14:  SUBLW  2F
0C16:  BC    0C54
0C18:  MOVF   x80,W
0C1A:  SUBLW  39
0C1C:  BNC   0C54
....................       value *= 10;
0C1E:  MOVFF  97F,995
0C22:  MOVFF  97E,994
0C26:  CLRF   x97
0C28:  MOVLW  0A
0C2A:  MOVWF  x96
0C2C:  MOVLB  0
0C2E:  RCALL  084C
0C30:  MOVFF  02,97F
0C34:  MOVFF  01,97E
....................       value += (*s-'0');
0C38:  MOVFF  97D,FEA
0C3C:  MOVLB  9
0C3E:  MOVFF  97C,FE9
0C42:  MOVLW  30
0C44:  SUBWF  FEF,W
0C46:  ADDWF  x7E,F
0C48:  MOVLW  00
0C4A:  ADDWFC x7F,F
....................       s++;
0C4C:  INCF   x7C,F
0C4E:  BTFSC  FD8.2
0C50:  INCF   x7D,F
0C52:  BRA    0C06
....................    }
.................... 
....................    return value;
0C54:  MOVFF  97E,01
0C58:  MOVFF  97F,02
0C5C:  MOVLB  0
0C5E:  RETURN 0
.................... }
.................... 
.................... void iridium_sbdix_parse(void) {
.................... 	int8 *p;
.................... 
.................... 	/*
.................... 	 * Quick check of potential validity of response:
.................... 	 * a) valid response would need to be at least 24 characters
.................... 	 * +SBDIX: 0, 25, 0, 0, 0, 0	
.................... 	 * 012345678901234567890123456789
.................... 	 *           1         2
.................... 	 * b) mo_status always starts at character 8
.................... 	 * */
.................... 	if ( strlen(sbd.sbdix_response) < 24 || ! isdigit(sbd.sbdix_response[8] ) ) {
0C60:  MOVLW  06
0C62:  MOVLB  9
0C64:  MOVWF  x7D
0C66:  MOVLW  96
0C68:  MOVWF  x7C
0C6A:  MOVLB  0
0C6C:  BRA    0B18
0C6E:  MOVFF  02,97D
0C72:  MOVFF  01,97C
0C76:  MOVLB  9
0C78:  MOVF   x7D,F
0C7A:  BNZ   0C82
0C7C:  MOVF   x7C,W
0C7E:  SUBLW  17
0C80:  BC    0C98
0C82:  MOVLB  6
0C84:  MOVF   x9E,W
0C86:  SUBLW  2F
0C88:  BTFSS  FD8.0
0C8A:  BRA    0C90
0C8C:  MOVLB  9
0C8E:  BRA    0C98
0C90:  MOVF   x9E,W
0C92:  SUBLW  39
0C94:  BC    0C9C
0C96:  MOVLB  9
.................... 		/* if not a digit or too short, then we give up */
.................... 		return;
0C98:  BRA    0E10
0C9A:  MOVLB  6
.................... 	}
.................... 	sbd.sbdix_mo_status=a_to_uint8(sbd.sbdix_response+8);
0C9C:  MOVLW  06
0C9E:  MOVLB  9
0CA0:  MOVWF  x7D
0CA2:  MOVLW  9E
0CA4:  MOVWF  x7C
0CA6:  MOVLB  0
0CA8:  RCALL  0B52
0CAA:  MOVFF  01,6C0
.................... 
.................... 	/* mo_msn (with preceeding space) starts after comma */
.................... 	p = strchr(sbd.sbdix_response+9,',');
0CAE:  MOVLW  06
0CB0:  MOVLB  9
0CB2:  MOVWF  x7F
0CB4:  MOVLW  9F
0CB6:  MOVWF  x7E
0CB8:  MOVLW  2C
0CBA:  MOVWF  x80
0CBC:  MOVLB  0
0CBE:  RCALL  0BAA
0CC0:  MOVFF  02,97B
0CC4:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0CC8:  MOVLB  9
0CCA:  MOVF   x7A,F
0CCC:  BNZ   0CD4
0CCE:  MOVF   x7B,F
0CD0:  BNZ   0CD4
.................... 		/* not found */
.................... 		return;
0CD2:  BRA    0E10
.................... 	}
.................... 	p++; /* swallow the ',' */
0CD4:  INCF   x7A,F
0CD6:  BTFSC  FD8.2
0CD8:  INCF   x7B,F
.................... 	sbd.sbdix_mo_msn=a_to_uint16(p);
0CDA:  MOVFF  97B,97D
0CDE:  MOVFF  97A,97C
0CE2:  MOVLB  0
0CE4:  RCALL  0BEA
0CE6:  MOVFF  02,6C2
0CEA:  MOVFF  01,6C1
.................... 
.................... 	/* mt_status (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0CEE:  MOVLW  01
0CF0:  MOVLB  9
0CF2:  ADDWF  x7A,W
0CF4:  MOVWF  x7C
0CF6:  MOVLW  00
0CF8:  ADDWFC x7B,W
0CFA:  MOVWF  x7D
0CFC:  MOVWF  x7F
0CFE:  MOVFF  97C,97E
0D02:  MOVLW  2C
0D04:  MOVWF  x80
0D06:  MOVLB  0
0D08:  RCALL  0BAA
0D0A:  MOVFF  02,97B
0D0E:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0D12:  MOVLB  9
0D14:  MOVF   x7A,F
0D16:  BNZ   0D1E
0D18:  MOVF   x7B,F
0D1A:  BNZ   0D1E
.................... 		/* not found */
.................... 		return;
0D1C:  BRA    0E10
.................... 	}
.................... 	p++; /* swallow the ',' */
0D1E:  INCF   x7A,F
0D20:  BTFSC  FD8.2
0D22:  INCF   x7B,F
.................... 	sbd.sbdix_mt_status=a_to_uint8(p);
0D24:  MOVFF  97B,97D
0D28:  MOVFF  97A,97C
0D2C:  MOVLB  0
0D2E:  RCALL  0B52
0D30:  MOVFF  01,6C3
.................... 
.................... 	/* mt_msn (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0D34:  MOVLW  01
0D36:  MOVLB  9
0D38:  ADDWF  x7A,W
0D3A:  MOVWF  x7C
0D3C:  MOVLW  00
0D3E:  ADDWFC x7B,W
0D40:  MOVWF  x7D
0D42:  MOVWF  x7F
0D44:  MOVFF  97C,97E
0D48:  MOVLW  2C
0D4A:  MOVWF  x80
0D4C:  MOVLB  0
0D4E:  RCALL  0BAA
0D50:  MOVFF  02,97B
0D54:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0D58:  MOVLB  9
0D5A:  MOVF   x7A,F
0D5C:  BNZ   0D64
0D5E:  MOVF   x7B,F
0D60:  BNZ   0D64
.................... 		/* not found */
.................... 		return;
0D62:  BRA    0E10
.................... 	}
.................... 	p++; /* swallow the ',' */
0D64:  INCF   x7A,F
0D66:  BTFSC  FD8.2
0D68:  INCF   x7B,F
.................... 	sbd.sbdix_mt_msn=a_to_uint16(p);
0D6A:  MOVFF  97B,97D
0D6E:  MOVFF  97A,97C
0D72:  MOVLB  0
0D74:  RCALL  0BEA
0D76:  MOVFF  02,6C5
0D7A:  MOVFF  01,6C4
.................... 
.................... 	/* mt_length (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0D7E:  MOVLW  01
0D80:  MOVLB  9
0D82:  ADDWF  x7A,W
0D84:  MOVWF  x7C
0D86:  MOVLW  00
0D88:  ADDWFC x7B,W
0D8A:  MOVWF  x7D
0D8C:  MOVWF  x7F
0D8E:  MOVFF  97C,97E
0D92:  MOVLW  2C
0D94:  MOVWF  x80
0D96:  MOVLB  0
0D98:  RCALL  0BAA
0D9A:  MOVFF  02,97B
0D9E:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0DA2:  MOVLB  9
0DA4:  MOVF   x7A,F
0DA6:  BNZ   0DAE
0DA8:  MOVF   x7B,F
0DAA:  BNZ   0DAE
.................... 		/* not found */
.................... 		return;
0DAC:  BRA    0E10
.................... 	}
.................... 	p++; /* swallow the ',' */
0DAE:  INCF   x7A,F
0DB0:  BTFSC  FD8.2
0DB2:  INCF   x7B,F
.................... 	sbd.sbdix_mt_length=a_to_uint16(p);
0DB4:  MOVFF  97B,97D
0DB8:  MOVFF  97A,97C
0DBC:  MOVLB  0
0DBE:  RCALL  0BEA
0DC0:  MOVFF  02,6C7
0DC4:  MOVFF  01,6C6
.................... 
.................... 	/* mt_queued (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
0DC8:  MOVLW  01
0DCA:  MOVLB  9
0DCC:  ADDWF  x7A,W
0DCE:  MOVWF  x7C
0DD0:  MOVLW  00
0DD2:  ADDWFC x7B,W
0DD4:  MOVWF  x7D
0DD6:  MOVWF  x7F
0DD8:  MOVFF  97C,97E
0DDC:  MOVLW  2C
0DDE:  MOVWF  x80
0DE0:  MOVLB  0
0DE2:  RCALL  0BAA
0DE4:  MOVFF  02,97B
0DE8:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
0DEC:  MOVLB  9
0DEE:  MOVF   x7A,F
0DF0:  BNZ   0DF8
0DF2:  MOVF   x7B,F
0DF4:  BNZ   0DF8
.................... 		/* not found */
.................... 		return;
0DF6:  BRA    0E10
.................... 	}
.................... 	p++; /* swallow the ',' */
0DF8:  INCF   x7A,F
0DFA:  BTFSC  FD8.2
0DFC:  INCF   x7B,F
.................... 	sbd.sbdix_mt_queued=a_to_uint8(p);
0DFE:  MOVFF  97B,97D
0E02:  MOVFF  97A,97C
0E06:  MOVLB  0
0E08:  RCALL  0B52
0E0A:  MOVFF  01,6C8
0E0E:  MOVLB  9
.................... 
.................... #if DEBUG_SBD
0E10:  MOVLB  0
0E12:  GOTO   3796 (RETURN)
.................... 	fprintf(STREAM_WORLD,"# iridium_sbdix_parse():\r\n");
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_status   = %d\n",sbd.sbdix_mo_status);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_msn      = %lu\n",sbd.sbdix_mo_msn);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_status   = %d\n",sbd.sbdix_mt_status);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_msn      = %lu\n",sbd.sbdix_mt_msn);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_length   = %lu\n",sbd.sbdix_mt_length);
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_queued   = %d\n",sbd.sbdix_mt_queued);
.................... #endif
.................... 
.................... }
.................... 
.................... #if 0
.................... void _iridium_on(void) {
.................... 	/* turn power switch on */
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_high(CTRL_0); break;
.................... 		case 2: output_high(CTRL_1); break;
.................... 		case 3: output_high(CTRL_2); break;
.................... 		case 4: output_high(CTRL_3); break;
.................... 		case 5: output_high(CTRL_4); break;
.................... 	}
.................... 	
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000000);
.................... 
.................... }
.................... 
.................... void _iridium_off(void) {
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_low(CTRL_0); break;
.................... 		case 2: output_low(CTRL_1); break;
.................... 		case 3: output_low(CTRL_2); break;
.................... 		case 4: output_low(CTRL_3); break;
.................... 		case 5: output_low(CTRL_4); break;
.................... 	}
.................... 
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000010);
.................... }
.................... #endif
.................... 
.................... void iridium_mr_clear(void) {
.................... 	sbd.mr_ready=0;
*
0B0C:  MOVLB  8
0B0E:  CLRF   xE6
.................... 	sbd.mr_length=0;
0B10:  MOVLB  9
0B12:  CLRF   x27
0B14:  MOVLB  0
0B16:  RETURN 0
.................... }
.................... 
.................... void iridium_mo_clear(void) {
.................... 	sbd.mo_length=0;
*
13A6:  MOVLB  7
13A8:  CLRF   xDB
13AA:  CLRF   xDA
.................... 	sbd.mo_state=0;
13AC:  MOVLB  6
13AE:  CLRF   xC9
13B0:  MOVLB  0
13B2:  RETURN 0
.................... }
.................... 
.................... void iridium_mt_clear(void) {
.................... 	sbd.mt_length=0;
.................... 	sbd.mt_state=0;
.................... }
.................... 
.................... /* if we have characters to be received, this function reads them */
.................... void iridium_getc(void) {
.................... 	int8 c;
.................... 
.................... 
.................... 	/* read character from UART */
.................... 	c = uart_getc();
*
0EBA:  MOVFF  01,97A
.................... 
.................... 
.................... 	if ( '\r' == c ) {
0EBE:  MOVLB  9
0EC0:  MOVF   x7A,W
0EC2:  SUBLW  0D
0EC4:  BNZ   0EC8
.................... 		/* except when receiving binary data, we don't care about '\r' */
.................... 		return;
0EC6:  BRA    0F5C
.................... 	}
.................... 
.................... 	/* modem always appears to send '\r' '\n' */
.................... 	
.................... 
.................... 	if ( 0 == sbd.mr_ready ) {
0EC8:  MOVLB  8
0ECA:  MOVF   xE6,F
0ECC:  BNZ   0F5E
.................... 		/* receiving data */
.................... 
.................... 		if ( '\n' == c && 0==sbd.mr_length ) {
0ECE:  MOVLB  9
0ED0:  MOVF   x7A,W
0ED2:  SUBLW  0A
0ED4:  BNZ   0EDC
0ED6:  MOVF   x27,F
0ED8:  BNZ   0EDC
.................... 			/* responses usually appear to be \r\nOK\r\n ... this skips the empty message */
.................... 			return;
0EDA:  BRA    0F5C
.................... 		}
.................... 
.................... 		
.................... 		/* check for 'SBDRING' message and deal with it accordingly */
.................... 		if ( 'S'==sbd.mr_buff[0] && 'B'==sbd.mr_buff[1] && 'D'==sbd.mr_buff[2] 
.................... 			&& 'R'==sbd.mr_buff[3] && 'I'==sbd.mr_buff[4] && 'N'==sbd.mr_buff[5] && 'G'==c ) {
0EDC:  MOVLB  8
0EDE:  MOVF   xE7,W
0EE0:  SUBLW  53
0EE2:  BNZ   0F20
0EE4:  MOVF   xE8,W
0EE6:  SUBLW  42
0EE8:  BNZ   0F20
0EEA:  MOVF   xE9,W
0EEC:  SUBLW  44
0EEE:  BNZ   0F20
0EF0:  MOVF   xEA,W
0EF2:  SUBLW  52
0EF4:  BNZ   0F20
0EF6:  MOVF   xEB,W
0EF8:  SUBLW  49
0EFA:  BNZ   0F20
0EFC:  MOVF   xEC,W
0EFE:  SUBLW  4E
0F00:  BNZ   0F20
0F02:  MOVLB  9
0F04:  MOVF   x7A,W
0F06:  SUBLW  47
0F08:  BTFSC  FD8.2
0F0A:  BRA    0F10
0F0C:  MOVLB  8
0F0E:  BRA    0F20
.................... 			sbd.ring_flag=1;
0F10:  MOVLW  01
0F12:  MOVLB  8
0F14:  MOVWF  xE4
.................... 			iridium_mr_clear();
0F16:  MOVLB  0
0F18:  RCALL  0B0C
.................... 			return;
0F1A:  MOVLB  9
0F1C:  BRA    0F5C
0F1E:  MOVLB  8
.................... 		 }
.................... 
.................... 		if ( '\n' == c ) {
0F20:  MOVLB  9
0F22:  MOVF   x7A,W
0F24:  SUBLW  0A
0F26:  BNZ   0F42
.................... 			/* replace '\n' with '\0' */
.................... 			sbd.mr_buff[sbd.mr_length]='\0';
0F28:  MOVLW  E7
0F2A:  ADDWF  x27,W
0F2C:  MOVWF  FE9
0F2E:  MOVLW  08
0F30:  MOVWF  FEA
0F32:  BTFSC  FD8.0
0F34:  INCF   FEA,F
0F36:  CLRF   FEF
.................... 			
.................... 			/* mark that we have a message ready */
.................... 			sbd.mr_ready=1;
0F38:  MOVLW  01
0F3A:  MOVLB  8
0F3C:  MOVWF  xE6
.................... 
.................... 			/* done */
.................... 			return;
0F3E:  MOVLB  9
0F40:  BRA    0F5C
.................... 		}
.................... 
.................... 
.................... 		/* put in response buffer if not full */
.................... 		if ( sbd.mr_length < ( sizeof(sbd.mr_buff) - 1 ) ) {
0F42:  MOVF   x27,W
0F44:  SUBLW  3E
0F46:  BNC   0F5C
.................... 			sbd.mr_buff[sbd.mr_length]=c;
0F48:  MOVLW  E7
0F4A:  ADDWF  x27,W
0F4C:  MOVWF  FE9
0F4E:  MOVLW  08
0F50:  MOVWF  FEA
0F52:  BTFSC  FD8.0
0F54:  INCF   FEA,F
0F56:  MOVFF  97A,FEF
.................... 			sbd.mr_length++;
0F5A:  INCF   x27,F
.................... 		} else {
0F5C:  MOVLB  8
.................... 			/* buffer is full ... do nothing and wait for message to be terminated */
.................... 		}
.................... 	}
0F5E:  MOVLB  0
0F60:  GOTO   37CE (RETURN)
.................... }
.................... 
.................... void iridium_ringing(void) {
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_ringing() sbd.ring_state=%u\r\n",sbd.ring_state);
.................... #endif
.................... 
.................... 	if ( 0 == sbd.ring_state ) {
.................... 		/* nothing to do */
.................... 		return;
.................... 	}else if ( 1 == sbd.ring_state ) {
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"ATE0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.ring_state ) {
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT&K0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}	
.................... 	} else if ( 5 == sbd.ring_state ) {
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}
.................... 	} else if ( 7 == sbd.ring_state ) {
.................... 		/* send 'AT+CRIS' to determine why we rang */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+CRIS\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.ring_state ) {
.................... 		/* parse CRIS response. But in reality, with an SBD only device it can only be SBD message that causes us to ring */
.................... 	} 
.................... 
.................... }
.................... 
.................... void iridium_mo_send(void) {
.................... 	int16 l;
.................... 	int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... //	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u sbd.mo_sbdix_wait=%u\r\n",sbd.mo_state,sbd.mo_try,sbd.mo_sbdix_wait);
.................... #endif
.................... 
.................... 
.................... 	if ( 0 == sbd.mo_state ) {
*
13B4:  MOVLB  6
13B6:  MOVF   xC9,F
13B8:  BNZ   13BE
.................... 		/* nothing to do */
.................... 		return;
13BA:  BRA    1796
.................... 
.................... 	} else if ( 1 == sbd.mo_state ) {
13BC:  BRA    1790
13BE:  DECFSZ xC9,W
13C0:  BRA    13D8
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
13C2:  MOVLB  0
13C4:  CALL   0B0C
.................... 		printf(uart_putc,"ATE0\r");
13C8:  MOVLW  08
13CA:  MOVWF  FF6
13CC:  MOVLW  04
13CE:  MOVWF  FF7
13D0:  RCALL  0F74
.................... 		sbd.mo_state++;
13D2:  MOVLB  6
13D4:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mo_state ) {
13D6:  BRA    1790
13D8:  MOVF   xC9,W
13DA:  SUBLW  02
13DC:  BNZ   1402
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
13DE:  MOVLB  8
13E0:  DECFSZ xE6,W
13E2:  BRA    13FE
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
13E4:  MOVF   xE7,W
13E6:  SUBLW  4F
13E8:  BNZ   13F6
13EA:  MOVF   xE8,W
13EC:  SUBLW  4B
13EE:  BNZ   13F6
.................... 				sbd.mo_state++;
13F0:  MOVLB  6
13F2:  INCF   xC9,F
13F4:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
13F6:  MOVLB  0
13F8:  CALL   0B0C
13FC:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mo_state ) {
13FE:  BRA    1792
1400:  MOVLB  6
1402:  MOVF   xC9,W
1404:  SUBLW  03
1406:  BNZ   141E
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
1408:  MOVLB  0
140A:  CALL   0B0C
.................... 		printf(uart_putc,"AT&K0\r");
140E:  MOVLW  0E
1410:  MOVWF  FF6
1412:  MOVLW  04
1414:  MOVWF  FF7
1416:  RCALL  0F74
.................... 		sbd.mo_state++;
1418:  MOVLB  6
141A:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mo_state ) {
141C:  BRA    1790
141E:  MOVF   xC9,W
1420:  SUBLW  04
1422:  BNZ   1448
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1424:  MOVLB  8
1426:  DECFSZ xE6,W
1428:  BRA    1444
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
142A:  MOVF   xE7,W
142C:  SUBLW  4F
142E:  BNZ   143C
1430:  MOVF   xE8,W
1432:  SUBLW  4B
1434:  BNZ   143C
.................... 				sbd.mo_state++;
1436:  MOVLB  6
1438:  INCF   xC9,F
143A:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
143C:  MOVLB  0
143E:  CALL   0B0C
1442:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mo_state ) {
1444:  BRA    1792
1446:  MOVLB  6
1448:  MOVF   xC9,W
144A:  SUBLW  05
144C:  BNZ   1464
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
144E:  MOVLB  0
1450:  CALL   0B0C
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
1454:  MOVLW  16
1456:  MOVWF  FF6
1458:  MOVLW  04
145A:  MOVWF  FF7
145C:  RCALL  0F74
.................... 		sbd.mo_state++;
145E:  MOVLB  6
1460:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mo_state ) {
1462:  BRA    1790
1464:  MOVF   xC9,W
1466:  SUBLW  06
1468:  BNZ   148E
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
146A:  MOVLB  8
146C:  DECFSZ xE6,W
146E:  BRA    148A
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1470:  MOVF   xE7,W
1472:  SUBLW  4F
1474:  BNZ   1482
1476:  MOVF   xE8,W
1478:  SUBLW  4B
147A:  BNZ   1482
.................... 				sbd.mo_state++;
147C:  MOVLB  6
147E:  INCF   xC9,F
1480:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1482:  MOVLB  0
1484:  CALL   0B0C
1488:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mo_state ) {
148A:  BRA    1792
148C:  MOVLB  6
148E:  MOVF   xC9,W
1490:  SUBLW  07
1492:  BNZ   14CA
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDWB=[<SBD Message Length>]' to tell modem how long our MO */
.................... 		iridium_mr_clear();
1494:  MOVLB  0
1496:  CALL   0B0C
.................... 		printf(uart_putc,"AT+SBDWB=%lu\r",sbd.mo_length);
149A:  MOVLW  24
149C:  MOVWF  FF6
149E:  MOVLW  04
14A0:  MOVWF  FF7
14A2:  MOVLW  09
14A4:  MOVLB  9
14A6:  MOVWF  x7E
14A8:  MOVLB  0
14AA:  BRA    1206
14AC:  MOVLW  10
14AE:  MOVWF  FE9
14B0:  MOVFF  7DB,97F
14B4:  MOVFF  7DA,97E
14B8:  BRA    1230
14BA:  MOVLW  0D
14BC:  MOVLB  9
14BE:  MOVWF  x87
14C0:  MOVLB  0
14C2:  RCALL  0F64
.................... 		sbd.mo_state++;
14C4:  MOVLB  6
14C6:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mo_state ) {
14C8:  BRA    1790
14CA:  MOVF   xC9,W
14CC:  SUBLW  08
14CE:  BNZ   1506
.................... 		/* receive response 'READY' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
14D0:  MOVLB  8
14D2:  DECFSZ xE6,W
14D4:  BRA    1502
.................... 			if ( 'R'==sbd.mr_buff[0] 
....................                  && 'E'==sbd.mr_buff[1] 
....................                  && 'A'==sbd.mr_buff[2]
.................... 			     && 'D'==sbd.mr_buff[3]
.................... 			     && 'Y'==sbd.mr_buff[4]
14D6:  MOVF   xE7,W
14D8:  SUBLW  52
14DA:  BNZ   14FA
14DC:  MOVF   xE8,W
14DE:  SUBLW  45
14E0:  BNZ   14FA
14E2:  MOVF   xE9,W
14E4:  SUBLW  41
14E6:  BNZ   14FA
14E8:  MOVF   xEA,W
14EA:  SUBLW  44
14EC:  BNZ   14FA
14EE:  MOVF   xEB,W
14F0:  SUBLW  59
14F2:  BNZ   14FA
.................... 			    ) {
.................... 				sbd.mo_state++;
14F4:  MOVLB  6
14F6:  INCF   xC9,F
14F8:  MOVLB  8
.................... 			}
.................... 		
.................... 			/* clear mr because either we got READY or we got a bad response */
.................... 			iridium_mr_clear();				
14FA:  MOVLB  0
14FC:  CALL   0B0C
1500:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 9 == sbd.mo_state ) {
1502:  BRA    1792
1504:  MOVLB  6
1506:  MOVF   xC9,W
1508:  SUBLW  09
150A:  BNZ   1594
.................... 		/* send binary message and 2 byte checksum */
.................... 		iridium_mr_clear();
150C:  MOVLB  0
150E:  CALL   0B0C
.................... 		checksum=0;
1512:  MOVLB  9
1514:  CLRF   x7D
1516:  CLRF   x7C
.................... 		/* send data bytes and update checksum */
.................... 		for ( l=0 ; l<sbd.mo_length ; l++ ) {
1518:  CLRF   x7B
151A:  CLRF   x7A
151C:  MOVF   x7B,W
151E:  MOVLB  7
1520:  SUBWF  xDB,W
1522:  BNC   1580
1524:  BNZ   1536
1526:  MOVF   xDA,W
1528:  MOVLB  9
152A:  SUBWF  x7A,W
152C:  BTFSS  FD8.0
152E:  BRA    1534
1530:  MOVLB  7
1532:  BRA    1580
1534:  MOVLB  7
.................... 			uart_putc(sbd.mo_buff[l]);
1536:  MOVLW  CA
1538:  MOVLB  9
153A:  ADDWF  x7A,W
153C:  MOVWF  FE9
153E:  MOVLW  06
1540:  ADDWFC x7B,W
1542:  MOVWF  FEA
1544:  MOVFF  FEF,987
1548:  MOVLB  0
154A:  RCALL  0F64
.................... 			delay_us(500);
154C:  CLRWDT
154E:  MOVLW  02
1550:  MOVLB  9
1552:  MOVWF  x7E
1554:  MOVLW  F7
1556:  MOVWF  x7F
1558:  MOVLB  0
155A:  BRA    12F8
155C:  MOVLB  9
155E:  DECFSZ x7E,F
1560:  BRA    1554
.................... 			checksum += sbd.mo_buff[l];
1562:  MOVLW  CA
1564:  ADDWF  x7A,W
1566:  MOVWF  FE9
1568:  MOVLW  06
156A:  ADDWFC x7B,W
156C:  MOVWF  FEA
156E:  MOVF   FEF,W
1570:  ADDWF  x7C,F
1572:  MOVLW  00
1574:  ADDWFC x7D,F
1576:  INCF   x7A,F
1578:  BTFSC  FD8.2
157A:  INCF   x7B,F
157C:  BRA    151C
157E:  MOVLB  7
.................... 		}
.................... 
.................... 		/* send checksum bytes */
.................... 		uart_putc(make8(checksum,1));
1580:  MOVFF  97D,987
1584:  MOVLB  0
1586:  RCALL  0F64
.................... 		uart_putc(make8(checksum,0));
1588:  MOVFF  97C,987
158C:  RCALL  0F64
.................... 
.................... 		sbd.mo_state++;
158E:  MOVLB  6
1590:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		
.................... 	} else if ( 10 == sbd.mo_state ) {
1592:  BRA    1790
1594:  MOVF   xC9,W
1596:  SUBLW  0A
1598:  BNZ   15BC
.................... 		/* 
.................... 		receive response <Status> which means 
.................... 		
.................... 		0 => SBD message successfully written to the ISU.
.................... 
.................... 		1 => SBD message write timeout. An insufficient number of bytes were transferred 
.................... 		to ISU during the transfer period of 60 seconds.
.................... 
.................... 		2 => SBD message checksum sent from DTE does not match the checksum calculated at 
.................... 		the ISU.
.................... 
.................... 		3 => SBD message size is not correct. The maximum mobile originated SBD message 
.................... 		length is 340 bytes. The minimum mobile originated SBD message length is 1 byte.
.................... 		*/
.................... 
.................... 		/* status must be 0 */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
159A:  MOVLB  8
159C:  DECFSZ xE6,W
159E:  BRA    15B8
.................... 			if ( '0'==sbd.mr_buff[0] ) {
15A0:  MOVF   xE7,W
15A2:  SUBLW  30
15A4:  BNZ   15AE
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
15A6:  MOVLB  6
15A8:  INCF   xC9,F
.................... 			} else {
15AA:  BRA    15B6
15AC:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
15AE:  MOVLB  0
15B0:  CALL   0B0C
15B4:  MOVLB  6
15B6:  MOVLB  8
.................... 			}
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mo_state ) {
15B8:  BRA    1792
15BA:  MOVLB  6
15BC:  MOVF   xC9,W
15BE:  SUBLW  0B
15C0:  BNZ   15E6
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
15C2:  MOVLB  8
15C4:  DECFSZ xE6,W
15C6:  BRA    15E2
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
15C8:  MOVF   xE7,W
15CA:  SUBLW  4F
15CC:  BNZ   15DA
15CE:  MOVF   xE8,W
15D0:  SUBLW  4B
15D2:  BNZ   15DA
.................... 				sbd.mo_state++;
15D4:  MOVLB  6
15D6:  INCF   xC9,F
15D8:  MOVLB  8
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
15DA:  MOVLB  0
15DC:  CALL   0B0C
15E0:  MOVLB  8
.................... 		}
.................... 
.................... 	} else if ( 12 == sbd.mo_state ) {
15E2:  BRA    1792
15E4:  MOVLB  6
15E6:  MOVF   xC9,W
15E8:  SUBLW  0C
15EA:  BNZ   1612
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		/* send 'AT+SBDIX' to initiate Extended SBD Session */
.................... 
.................... 		if ( sbd.mo_try > 0 && 0 != sbd.mo_sbdix_wait ) {
15EC:  MOVLB  7
15EE:  MOVF   xDC,F
15F0:  BZ    15FC
15F2:  MOVF   xDD,F
15F4:  BZ    15FC
.................... 			/* external function decrements sbd.mo_sbdix_wait once per second */
.................... 			return;
15F6:  MOVLB  6
15F8:  BRA    1796
15FA:  MOVLB  7
.................... 		}
.................... 
.................... 		iridium_mr_clear();
15FC:  MOVLB  0
15FE:  CALL   0B0C
.................... 		printf(uart_putc,"AT+SBDIX\r");
1602:  MOVLW  32
1604:  MOVWF  FF6
1606:  MOVLW  04
1608:  MOVWF  FF7
160A:  RCALL  0F74
.................... 		sbd.mo_state++;
160C:  MOVLB  6
160E:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 13 == sbd.mo_state ) {
1610:  BRA    1790
1612:  MOVF   xC9,W
1614:  SUBLW  0D
1616:  BNZ   16A4
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		/*
.................... 		receive response:
.................... 			 +SBDIX: <MO status>, <MOMSN>, <MT status>, <MTMSN>, <MT length>, <MT queued>
.................... 		which means
.................... 
.................... 		<MO status> - Any returned number with a value of 0 to 2 indicates your message 
.................... 		has been successfully transmitted. Any number above 2 indicates that the message 
.................... 		has not been successfully transmitted.
.................... 
.................... 		Per rock7 website (https://docs.rockblock.rock7.com/reference/sbdix):
.................... 		0	MO message, if any, transferred successfully.
.................... 		1	MO message, if any, transferred successfully, but the MT message in the queue was too big to be transferred.
.................... 		2	MO message, if any, transferred successfully, but the requested Location Update was not accepted.
.................... 		3 .. 4	Reserved, but indicate MO session success if used.
.................... 		5 .. 8	Reserved, but indicate MO session failure if used.
.................... 		10	GSS reported that the call did not complete in the allowed time.
.................... 		11	MO message queue at the GSS is full.
.................... 		12	MO message has too many segments.
.................... 		13	GSS reported that the session did not complete.
.................... 		14	Invalid segment size.
.................... 		15	Access is denied.
.................... 		16	ISU has been locked and may not make SBD calls (see +CULK command).
.................... 		17	Gateway not responding (local session timeout).
.................... 		18	Connection lost (RF drop).
.................... 		19	Link failure (A protocol error caused termination of the call).
.................... 		20 .. 31	Reserved, but indicate failure if used.
.................... 		32	No network service, unable to initiate call.
.................... 		33	Antenna fault, unable to initiate call.
.................... 		34	Radio is disabled, unable to initiate call (see *Rn command).
.................... 		35	ISU is busy, unable to initiate call.
.................... 		36	Try later, must wait 3 minutes since last registration.
.................... 		37	SBD service is temporarily disabled.
.................... 		38	Try later, traffic management period (see +SBDLOE command)
.................... 		39 .. 63	Reserved, but indicate failure if used.
.................... 		64	Band violation (attempt to transmit outside permitted frequency band).
.................... 		65	PLL lock failure; hardware error during attempted transmit.
.................... 
.................... 		<MOMSN> - This number denotes the MO message number and cycles between 0 and 65535.
.................... 
.................... 		<MT status>
.................... 			0 => No messages waiting to be received.
.................... 			1 => New message successfully received.
.................... 			2 => Error during mailbox check / message reception.
.................... 
.................... 		<MTMSN> - This number denotes the MT message number and cycles between 0 and 65535.
.................... 
.................... 		<MT length> - The size (in bytes) of the MT message.
.................... 
.................... 		<MT queued> - The number of MT messages in the queue waiting to be downloaded.
.................... 
.................... 		+SBDIX:32,22, 2, 0, 0, 0
....................         012345678901234567890123
....................         0         1         2
.................... 		*/
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1618:  MOVLB  8
161A:  DECFSZ xE6,W
161C:  BRA    16A0
.................... 			if ( '+'==sbd.mr_buff[0] && 'S'==sbd.mr_buff[1] &&
.................... 			     'B'==sbd.mr_buff[2] && 'D'==sbd.mr_buff[3] &&
.................... 			     'I'==sbd.mr_buff[4] && 'X'==sbd.mr_buff[5] 
161E:  MOVF   xE7,W
1620:  SUBLW  2B
1622:  BNZ   1698
1624:  MOVF   xE8,W
1626:  SUBLW  53
1628:  BNZ   1698
162A:  MOVF   xE9,W
162C:  SUBLW  42
162E:  BNZ   1698
1630:  MOVF   xEA,W
1632:  SUBLW  44
1634:  BNZ   1698
1636:  MOVF   xEB,W
1638:  SUBLW  49
163A:  BNZ   1698
163C:  MOVF   xEC,W
163E:  SUBLW  58
1640:  BNZ   1698
.................... 			) {
.................... 				/* copy +SBDIX result to seperate buffer so it can be further processed for message downloading */
.................... 				if ( '\0' == sbd.sbdix_response[0] ) {
1642:  MOVLB  6
1644:  MOVF   x96,F
1646:  BNZ   1668
.................... 					strncpy(sbd.sbdix_response,sbd.mr_buff,sizeof(sbd.sbdix_response)-1);
1648:  MOVLW  06
164A:  MOVLB  9
164C:  MOVWF  x7F
164E:  MOVLW  96
1650:  MOVWF  x7E
1652:  MOVLW  08
1654:  MOVWF  x81
1656:  MOVLW  E7
1658:  MOVWF  x80
165A:  CLRF   x83
165C:  MOVLW  29
165E:  MOVWF  x82
1660:  MOVLB  0
1662:  BRA    131E
.................... 					sbd.sbdix_response[sizeof(sbd.sbdix_response)-1]='\0';
1664:  MOVLB  6
1666:  CLRF   xBF
.................... 				}
.................... 
.................... 
.................... 				/* so we got an +SBDIX response. If first byte ([8]) is '0', '1', '2' and second byte ([9]) is ',' 
.................... 				we are okay to proceed and clear buffer. If it is anything else, we need to wait and try again */
.................... 				/* TODO: white space location / pading may not be consistent. Use atoi style parsing to determine MO_STATUS reliably */
.................... 				if ( ' '==sbd.mr_buff[7] && ( sbd.mr_buff[8] >= '0' && sbd.mr_buff[8] <= '2'  && ',' == sbd.mr_buff[9]) ) {
1668:  MOVLB  8
166A:  MOVF   xEE,W
166C:  SUBLW  20
166E:  BNZ   168E
1670:  MOVF   xEF,W
1672:  SUBLW  2F
1674:  BC    168E
1676:  MOVF   xEF,W
1678:  SUBLW  32
167A:  BNC   168E
167C:  MOVF   xF0,W
167E:  SUBLW  2C
1680:  BNZ   168E
.................... 					sbd.mo_state++;
1682:  MOVLB  6
1684:  INCF   xC9,F
.................... 					sbd.mo_try=0;
1686:  MOVLB  7
1688:  CLRF   xDC
.................... 				} else {
168A:  BRA    1696
168C:  MOVLB  8
.................... 					/* didn't get a 0 or 1 or 2 ... but still go on to next state for OK */
.................... 					sbd.mo_state++;
168E:  MOVLB  6
1690:  INCF   xC9,F
.................... 					sbd.mo_try++;
1692:  MOVLB  7
1694:  INCF   xDC,F
1696:  MOVLB  8
.................... 				}
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
1698:  MOVLB  0
169A:  CALL   0B0C
169E:  MOVLB  8
.................... 		}
.................... 	} else if ( 14 == sbd.mo_state ) {
16A0:  BRA    1792
16A2:  MOVLB  6
16A4:  MOVF   xC9,W
16A6:  SUBLW  0E
16A8:  BNZ   1714
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u start\r\n",sbd.mo_state,sbd.mo_try);
.................... #endif
.................... 
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
16AA:  MOVLB  8
16AC:  DECFSZ xE6,W
16AE:  BRA    16CA
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
16B0:  MOVF   xE7,W
16B2:  SUBLW  4F
16B4:  BNZ   16C2
16B6:  MOVF   xE8,W
16B8:  SUBLW  4B
16BA:  BNZ   16C2
.................... 				sbd.mo_state++;
16BC:  MOVLB  6
16BE:  INCF   xC9,F
16C0:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
16C2:  MOVLB  0
16C4:  CALL   0B0C
16C8:  MOVLB  8
.................... 		}
.................... 
.................... 		if ( 0 != sbd.mo_try ) {
16CA:  MOVLB  7
16CC:  MOVF   xDC,F
16CE:  BZ    1710
.................... 			/* need to try SBDIX again */
.................... 			sbd.mo_state=12;
16D0:  MOVLW  0C
16D2:  MOVLB  6
16D4:  MOVWF  xC9
.................... 			/* back off */
.................... 			if ( 1 == sbd.mo_try || 2 == sbd.mo_try ) {
16D6:  MOVLB  7
16D8:  DECFSZ xDC,W
16DA:  BRA    16DE
16DC:  BRA    16E4
16DE:  MOVF   xDC,W
16E0:  SUBLW  02
16E2:  BNZ   16EA
.................... 				sbd.mo_sbdix_wait=3;
16E4:  MOVLW  03
16E6:  MOVWF  xDD
.................... 			} else if ( 3 == sbd.mo_try || 4 == sbd.mo_try ) {
16E8:  BRA    1710
16EA:  MOVF   xDC,W
16EC:  SUBLW  03
16EE:  BZ    16F6
16F0:  MOVF   xDC,W
16F2:  SUBLW  04
16F4:  BNZ   16FC
.................... 				sbd.mo_sbdix_wait=21;
16F6:  MOVLW  15
16F8:  MOVWF  xDD
.................... 			} else if ( 5 == sbd.mo_try ) {
16FA:  BRA    1710
16FC:  MOVF   xDC,W
16FE:  SUBLW  05
1700:  BNZ   1708
.................... 				sbd.mo_sbdix_wait=251;
1702:  MOVLW  FB
1704:  MOVWF  xDD
.................... 			} else {
1706:  BRA    1710
.................... 				/* give up and clear buffer */
.................... 				sbd.mo_state=15;
1708:  MOVLW  0F
170A:  MOVLB  6
170C:  MOVWF  xC9
170E:  MOVLB  7
.................... 			}
.................... 		}
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u finish\r\n",sbd.mo_state,sbd.mo_try);
.................... #endif
.................... 	} else if ( 15 == sbd.mo_state ) {
1710:  BRA    1794
1712:  MOVLB  6
1714:  MOVF   xC9,W
1716:  SUBLW  0F
1718:  BNZ   1730
.................... 
.................... 		/* send 'AT+SBDD=0' to clear MO buffer */
.................... 		iridium_mr_clear();
171A:  MOVLB  0
171C:  CALL   0B0C
.................... 		printf(uart_putc,"AT+SBDD0\r");
1720:  MOVLW  3C
1722:  MOVWF  FF6
1724:  MOVLW  04
1726:  MOVWF  FF7
1728:  RCALL  0F74
.................... 		sbd.mo_state++;
172A:  MOVLB  6
172C:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		/* TODO ... be careful about starting over without buffer being cleared */
.................... 	} else if ( 16 == sbd.mo_state ) {
172E:  BRA    1790
1730:  MOVF   xC9,W
1732:  SUBLW  10
1734:  BNZ   1758
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 		if ( 1 == sbd.mr_ready ) {
1736:  MOVLB  8
1738:  DECFSZ xE6,W
173A:  BRA    1754
.................... 			if ( '0'==sbd.mr_buff[0] ) {
173C:  MOVF   xE7,W
173E:  SUBLW  30
1740:  BNZ   174A
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
1742:  MOVLB  6
1744:  INCF   xC9,F
.................... 			} else {
1746:  BRA    1752
1748:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
174A:  MOVLB  0
174C:  CALL   0B0C
1750:  MOVLB  6
1752:  MOVLB  8
.................... 			}
.................... 		}
.................... 	} else if ( 17 == sbd.mo_state ) {
1754:  BRA    1792
1756:  MOVLB  6
1758:  MOVF   xC9,W
175A:  SUBLW  11
175C:  BNZ   1782
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
175E:  MOVLB  8
1760:  DECFSZ xE6,W
1762:  BRA    177E
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1764:  MOVF   xE7,W
1766:  SUBLW  4F
1768:  BNZ   1776
176A:  MOVF   xE8,W
176C:  SUBLW  4B
176E:  BNZ   1776
.................... 				sbd.mo_state++;
1770:  MOVLB  6
1772:  INCF   xC9,F
1774:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
1776:  MOVLB  0
1778:  CALL   0B0C
177C:  MOVLB  8
.................... 		}
.................... 	} else if ( 18 == sbd.mo_state ) {
177E:  BRA    1792
1780:  MOVLB  6
1782:  MOVF   xC9,W
1784:  SUBLW  12
1786:  BNZ   1790
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
.................... #endif
.................... 
.................... 		/* done sending */
.................... 		/* download MT if needed? */
.................... 		/* turn off modem */
.................... //		iridium_off();
.................... 
.................... 		/* go back to waiting */
.................... 		iridium_mr_clear();
1788:  MOVLB  0
178A:  CALL   0B0C
.................... 		iridium_mo_clear();	
178E:  RCALL  13A6
1790:  MOVLB  8
1792:  MOVLB  7
1794:  MOVLB  6
.................... 	}
1796:  MOVLB  0
1798:  GOTO   37F4 (RETURN)
.................... }
.................... 
.................... void iridium_mt_receive(void) {
.................... 	int8 c;
.................... 	static int16 l;
.................... 	static int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mt_receive() sbd.mt_state=%u\r\n",sbd.mt_state);
.................... #endif
.................... 
.................... 
.................... 	if ( sbd.mt_state <= 1 ) {
*
0F94:  MOVLB  7
0F96:  MOVF   xDF,W
0F98:  SUBLW  01
0F9A:  BNC   0FB2
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
0F9C:  MOVLB  0
0F9E:  RCALL  0B0C
.................... 		printf(uart_putc,"ATE0\r");
0FA0:  MOVLW  46
0FA2:  MOVWF  FF6
0FA4:  MOVLW  04
0FA6:  MOVWF  FF7
0FA8:  RCALL  0F74
.................... 		sbd.mt_state = 2;
0FAA:  MOVLW  02
0FAC:  MOVLB  7
0FAE:  MOVWF  xDF
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mt_state ) {
0FB0:  BRA    11FE
0FB2:  MOVF   xDF,W
0FB4:  SUBLW  02
0FB6:  BNZ   0FDA
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
0FB8:  MOVLB  8
0FBA:  DECFSZ xE6,W
0FBC:  BRA    0FD6
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
0FBE:  MOVF   xE7,W
0FC0:  SUBLW  4F
0FC2:  BNZ   0FD0
0FC4:  MOVF   xE8,W
0FC6:  SUBLW  4B
0FC8:  BNZ   0FD0
.................... 				sbd.mt_state++;
0FCA:  MOVLB  7
0FCC:  INCF   xDF,F
0FCE:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
0FD0:  MOVLB  0
0FD2:  RCALL  0B0C
0FD4:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mt_state ) {
0FD6:  BRA    11FE
0FD8:  MOVLB  7
0FDA:  MOVF   xDF,W
0FDC:  SUBLW  03
0FDE:  BNZ   0FF4
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
0FE0:  MOVLB  0
0FE2:  RCALL  0B0C
.................... 		printf(uart_putc,"AT&K0\r");
0FE4:  MOVLW  4C
0FE6:  MOVWF  FF6
0FE8:  MOVLW  04
0FEA:  MOVWF  FF7
0FEC:  RCALL  0F74
.................... 		sbd.mt_state++;
0FEE:  MOVLB  7
0FF0:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mt_state ) {
0FF2:  BRA    11FE
0FF4:  MOVF   xDF,W
0FF6:  SUBLW  04
0FF8:  BNZ   101C
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
0FFA:  MOVLB  8
0FFC:  DECFSZ xE6,W
0FFE:  BRA    1018
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1000:  MOVF   xE7,W
1002:  SUBLW  4F
1004:  BNZ   1012
1006:  MOVF   xE8,W
1008:  SUBLW  4B
100A:  BNZ   1012
.................... 				sbd.mt_state++;
100C:  MOVLB  7
100E:  INCF   xDF,F
1010:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1012:  MOVLB  0
1014:  RCALL  0B0C
1016:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mt_state ) {
1018:  BRA    11FE
101A:  MOVLB  7
101C:  MOVF   xDF,W
101E:  SUBLW  05
1020:  BNZ   1036
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
1022:  MOVLB  0
1024:  RCALL  0B0C
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
1026:  MOVLW  54
1028:  MOVWF  FF6
102A:  MOVLW  04
102C:  MOVWF  FF7
102E:  RCALL  0F74
.................... 		sbd.mt_state++;
1030:  MOVLB  7
1032:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mt_state ) {
1034:  BRA    11FE
1036:  MOVF   xDF,W
1038:  SUBLW  06
103A:  BNZ   105E
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
103C:  MOVLB  8
103E:  DECFSZ xE6,W
1040:  BRA    105A
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1042:  MOVF   xE7,W
1044:  SUBLW  4F
1046:  BNZ   1054
1048:  MOVF   xE8,W
104A:  SUBLW  4B
104C:  BNZ   1054
.................... 				sbd.mt_state++;
104E:  MOVLB  7
1050:  INCF   xDF,F
1052:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1054:  MOVLB  0
1056:  RCALL  0B0C
1058:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mt_state ) {
105A:  BRA    11FE
105C:  MOVLB  7
105E:  MOVF   xDF,W
1060:  SUBLW  07
1062:  BNZ   1080
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDRB' to tell modem to send us our MT */
.................... 		iridium_mr_clear();
1064:  MOVLB  0
1066:  RCALL  0B0C
.................... 		sbd.mr_disable=1; /* switch iridum character receiver to binary */
1068:  MOVLW  01
106A:  MOVLB  9
106C:  MOVWF  x28
.................... 		printf(uart_putc,"AT+SBDRB\r");
106E:  MOVLW  62
1070:  MOVWF  FF6
1072:  MOVLW  04
1074:  MOVWF  FF7
1076:  MOVLB  0
1078:  RCALL  0F74
.................... 		sbd.mt_state++;
107A:  MOVLB  7
107C:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mt_state ) {
107E:  BRA    11FE
1080:  MOVF   xDF,W
1082:  SUBLW  08
1084:  BNZ   10A8
.................... 		/* receive first byte of length */
.................... 		if ( ! uart_kbhit() ) {
1086:  MOVLB  0
1088:  RCALL  0E9E
108A:  MOVF   01,F
108C:  BNZ   1090
.................... 			/* no character available */
.................... 			return;
108E:  BRA    1200
.................... 		}
.................... 	
.................... 		sbd.mt_length=make16(uart_getc(),0);
*
109A:  MOVFF  01,8E1
109E:  MOVLB  8
10A0:  CLRF   xE0
.................... 		sbd.mt_state++;
10A2:  MOVLB  7
10A4:  INCF   xDF,F
.................... 	} else if ( 9 == sbd.mt_state ) {
10A6:  BRA    11FE
10A8:  MOVF   xDF,W
10AA:  SUBLW  09
10AC:  BNZ   10DE
.................... 		/* receive second byte of length */
.................... 		if ( ! uart_kbhit() ) {
10AE:  MOVLB  0
10B0:  RCALL  0E9E
10B2:  MOVF   01,F
10B4:  BNZ   10B8
.................... 			/* no character available */
.................... 			return;
10B6:  BRA    1200
.................... 		}
.................... 	
.................... 		sbd.mt_length += uart_getc();
*
10C2:  MOVF   01,W
10C4:  MOVLB  8
10C6:  ADDWF  xE0,F
10C8:  MOVLW  00
10CA:  ADDWFC xE1,F
.................... 		sbd.mt_state++;
10CC:  MOVLB  7
10CE:  INCF   xDF,F
.................... 
.................... 		checksum=0;
10D0:  MOVLB  9
10D2:  CLRF   x2E
10D4:  CLRF   x2D
.................... 		l=0;
10D6:  CLRF   x2C
10D8:  CLRF   x2B
.................... 	} else if ( 10 == sbd.mt_state ) {
10DA:  BRA    1200
10DC:  MOVLB  7
10DE:  MOVF   xDF,W
10E0:  SUBLW  0A
10E2:  BNZ   114E
.................... 		/* receive MT length of characters and calculate checksum */
.................... 		if ( ! uart_kbhit() ) {
10E4:  MOVLB  0
10E6:  RCALL  0E9E
10E8:  MOVF   01,F
10EA:  BNZ   10EE
.................... 			/* no character available */
.................... 			return;
10EC:  BRA    1200
.................... 		}
.................... 
.................... 		if ( 0 == sbd.mt_length ) {
10EE:  MOVLB  8
10F0:  MOVF   xE0,F
10F2:  BNZ   1102
10F4:  MOVF   xE1,F
10F6:  BNZ   1102
.................... 			/* zero byte message skips this state */
.................... 			sbd.mt_state++;
10F8:  MOVLB  7
10FA:  INCF   xDF,F
.................... 			return;
10FC:  MOVLB  0
10FE:  BRA    1200
1100:  MOVLB  8
.................... 		}
.................... 
.................... 		c = uart_getc();
*
110C:  MOVFF  01,97A
.................... 		sbd.mt_buff[l]=c;
1110:  MOVLW  E0
1112:  MOVLB  9
1114:  ADDWF  x2B,W
1116:  MOVWF  FE9
1118:  MOVLW  07
111A:  ADDWFC x2C,W
111C:  MOVWF  FEA
111E:  MOVFF  97A,FEF
.................... 		checksum += c;
1122:  MOVF   x7A,W
1124:  ADDWF  x2D,F
1126:  MOVLW  00
1128:  ADDWFC x2E,F
.................... 		l++;
112A:  INCF   x2B,F
112C:  BTFSC  FD8.2
112E:  INCF   x2C,F
.................... 
.................... 		if ( l == sbd.mt_length ) {
1130:  MOVLB  8
1132:  MOVF   xE0,W
1134:  MOVLB  9
1136:  SUBWF  x2B,W
1138:  BNZ   114A
113A:  MOVLB  8
113C:  MOVF   xE1,W
113E:  MOVLB  9
1140:  SUBWF  x2C,W
1142:  BNZ   114A
.................... 			/* received right number of characters */
.................... 			sbd.mt_state++;
1144:  MOVLB  7
1146:  INCF   xDF,F
1148:  MOVLB  9
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mt_state ) {
114A:  BRA    1200
114C:  MOVLB  7
114E:  MOVF   xDF,W
1150:  SUBLW  0B
1152:  BNZ   1176
.................... 		if ( ! uart_kbhit() ) {
1154:  MOVLB  0
1156:  RCALL  0E9E
1158:  MOVF   01,F
115A:  BNZ   115E
.................... 			/* no character available */
.................... 			return;
115C:  BRA    1200
.................... 		}
.................... 
.................... 		/* high byte of checksum */
.................... 		l=make16(uart_getc(),0);
*
1168:  MOVFF  01,92C
116C:  MOVLB  9
116E:  CLRF   x2B
.................... 		sbd.mt_state++;
1170:  MOVLB  7
1172:  INCF   xDF,F
.................... 	} else if ( 12 == sbd.mt_state ) {
1174:  BRA    11FE
1176:  MOVF   xDF,W
1178:  SUBLW  0C
117A:  BNZ   11A6
.................... 		if ( ! uart_kbhit() ) {
117C:  MOVLB  0
117E:  RCALL  0E9E
1180:  MOVF   01,F
1182:  BNZ   1186
.................... 			/* no character available */
.................... 			return;
1184:  BRA    1200
.................... 		}
.................... 
.................... 		/* low byte of checksum */
.................... 		l += uart_getc();
*
1190:  MOVF   01,W
1192:  MOVLB  9
1194:  ADDWF  x2B,F
1196:  MOVLW  00
1198:  ADDWFC x2C,F
.................... 		sbd.mt_state++;
119A:  MOVLB  7
119C:  INCF   xDF,F
.................... 
.................... 		sbd.mr_disable=0;
119E:  MOVLB  9
11A0:  CLRF   x28
.................... 	} else if ( 13 == sbd.mt_state ) {
11A2:  BRA    1200
11A4:  MOVLB  7
11A6:  MOVF   xDF,W
11A8:  SUBLW  0D
11AA:  BNZ   11C8
.................... 		/* compare local and remote checksum */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mt_receive() checksum l=%lu r=%lu\r\n",checksum,l);
.................... #endif
.................... 
.................... 		if ( checksum == l ) {
11AC:  MOVLB  9
11AE:  MOVF   x2B,W
11B0:  SUBWF  x2D,W
11B2:  BNZ   11C2
11B4:  MOVF   x2C,W
11B6:  SUBWF  x2E,W
11B8:  BNZ   11C2
.................... 			/* checksums matched, we have a good message! */
.................... 			sbd.mt_ready=1;
11BA:  MOVLW  01
11BC:  MOVLB  7
11BE:  MOVWF  xDE
11C0:  MOVLB  9
.................... 
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# iridium_mt_receive() mt_ready=1, here is our message:\r\n");
.................... 			for ( l=0 ; l<sbd.mt_length ; l++ ) {
.................... 				fprintf(STREAM_WORLD,"# mt_buff[%lu]=%c\r\n",l,sbd.mt_buff[l]);
.................... 			}
.................... #endif
.................... 		}
.................... 
.................... 		/* even if we have a bad checksum, we advance to next state and watch for OK */
.................... 		sbd.mt_state++;
11C2:  MOVLB  7
11C4:  INCF   xDF,F
.................... 
.................... 	} else if ( 14 == sbd.mt_state ) {
11C6:  BRA    11FE
11C8:  MOVF   xDF,W
11CA:  SUBLW  0E
11CC:  BNZ   11F0
.................... 		/* 
.................... 		Iridium reference manual says:
.................... 		"There are no response codes generated by the ISU for this command".
.................... 		But it does, in fact, give an "OK" (0x0D 0x0A 0x4F 0x4B 0x0D 0x0A) 
.................... 		about 2.7ms after finishing send the SBD data 
.................... 		*/
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
11CE:  MOVLB  8
11D0:  DECFSZ xE6,W
11D2:  BRA    11EC
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
11D4:  MOVF   xE7,W
11D6:  SUBLW  4F
11D8:  BNZ   11E6
11DA:  MOVF   xE8,W
11DC:  SUBLW  4B
11DE:  BNZ   11E6
.................... 				sbd.mt_state++;
11E0:  MOVLB  7
11E2:  INCF   xDF,F
11E4:  MOVLB  8
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# iridium_mt_receive() got final OK\r\n");
.................... #endif
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
11E6:  MOVLB  0
11E8:  RCALL  0B0C
11EA:  MOVLB  8
.................... 		}	
.................... 	} else if ( 15 == sbd.mt_state ) {
11EC:  BRA    11FE
11EE:  MOVLB  7
11F0:  MOVF   xDF,W
11F2:  SUBLW  0F
11F4:  BNZ   11FE
.................... 		/* message has processed */
.................... 		sbd.sbdix_mt_status=0;
11F6:  MOVLB  6
11F8:  CLRF   xC3
.................... 		sbd.mt_state=0;
11FA:  MOVLB  7
11FC:  CLRF   xDF
11FE:  MOVLB  9
1200:  MOVLB  0
.................... 	}
1202:  GOTO   37DC (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #if 0
.................... 			/* if not using RING ALERT through the UART, we can do this */
.................... 			/* check if RING ALERT is active via the !CTS pin connected to RING ALERT line on the SBD modem */
.................... 			if ( bit_test(uart_read(UART_MSR),4) ) {
.................... 				sbd.ring_flag=1;
.................... 			}
.................... #endif
.................... 
.................... #include "interrupt_rdTap.c"
.................... /* int_timer2 in modbus_int_uart.c */
.................... 
.................... #int_timer4
.................... void isr_10ms(void) {
.................... 	static int8 sc=0;
.................... 	static int16 li=0;
.................... 
.................... 	/* once per second */
.................... 	sc++;
*
046C:  MOVLB  9
046E:  INCF   x2F,F
.................... 	if ( 100==sc ) {
0470:  MOVF   x2F,W
0472:  SUBLW  64
0474:  BNZ   04AA
.................... 		sc=0;
0476:  CLRF   x2F
.................... 
.................... 		li++;
0478:  INCF   x30,F
047A:  BTFSC  FD8.2
047C:  INCF   x31,F
.................... 		if ( li >= config.live_interval ) {
047E:  MOVLB  5
0480:  MOVF   x87,W
0482:  MOVLB  9
0484:  SUBWF  x31,W
0486:  BNC   04A0
0488:  BNZ   0494
048A:  MOVLB  5
048C:  MOVF   x86,W
048E:  MOVLB  9
0490:  SUBWF  x30,W
0492:  BNC   04A0
.................... 			li=0;
0494:  CLRF   x31
0496:  CLRF   x30
.................... 			timers.now_poll=1;
0498:  MOVLW  01
049A:  MOVLB  3
049C:  MOVWF  x61
049E:  MOVLB  9
.................... 		}
.................... 
.................... 
.................... 		if ( sbd.mo_sbdix_wait > 0 ) {
04A0:  MOVLB  7
04A2:  MOVF   xDD,F
04A4:  BZ    04A8
.................... 			sbd.mo_sbdix_wait--;
04A6:  DECF   xDD,F
04A8:  MOVLB  9
.................... 		}
.................... 	}
.................... 
.................... 	if ( timers.world_timeout < 255 ) {
04AA:  MOVLB  3
04AC:  INCFSZ x62,W
04AE:  BRA    04B2
04B0:  BRA    04B4
.................... 		timers.world_timeout++;
04B2:  INCF   x62,F
.................... 	}
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
04B4:  MOVF   x64,F
04B6:  BNZ   04BE
.................... 		output_low(LED_GREEN);
04B8:  BCF    F93.5
04BA:  BCF    F8A.5
.................... 	} else {
04BC:  BRA    04C4
.................... 		output_high(LED_GREEN);
04BE:  BCF    F93.5
04C0:  BSF    F8A.5
.................... 		timers.led_on_green--;
04C2:  DECF   x64,F
.................... 	}
.................... 
.................... }
.................... 
.................... 
.................... /* int_rda in modbus_int_uart.c */
.................... 
04C4:  BCF    FB7.7
04C6:  MOVLB  0
04C8:  GOTO   0084
.................... #int_rda2
.................... void isr_world(void) {
.................... 	static int8 pre[5];
.................... 
.................... 
.................... 
.................... 	if ( query.buff_ready ) {
*
04E2:  MOVLB  5
04E4:  MOVF   x6D,F
04E6:  BZ    04EE
.................... 		/* throw out data received while processing previous query */
.................... 		fgetc(STREAM_WORLD);
04E8:  MOVLB  0
04EA:  RCALL  04CC
04EC:  MOVLB  5
.................... 	}
.................... 
.................... 	/* timeout after 100 milliseconds */
.................... 	if ( timers.world_timeout > 10 ) {
04EE:  MOVLB  3
04F0:  MOVF   x62,W
04F2:  SUBLW  0A
04F4:  BC    04FC
.................... 		query.buff_pos=0;
04F6:  MOVLB  5
04F8:  CLRF   x6C
04FA:  MOVLB  3
.................... //		output_toggle(LED_RED);
.................... 	}
.................... 	timers.world_timeout=0;
04FC:  CLRF   x62
.................... 
.................... 	if ( 0 == query.buff_pos ) {
04FE:  MOVLB  5
0500:  MOVF   x6C,F
0502:  BNZ   0574
.................... 		pre[0]=pre[1];
0504:  MOVFF  933,932
.................... 		pre[1]=pre[2];
0508:  MOVFF  934,933
.................... 		pre[2]=pre[3];
050C:  MOVFF  935,934
.................... 		pre[3]=pre[4];
0510:  MOVFF  936,935
.................... 		pre[4]=fgetc(STREAM_WORLD);
0514:  MOVLB  0
0516:  RCALL  04CC
0518:  MOVFF  01,936
.................... 
.................... 		/* packet addressed to us */
.................... 		if ( '#'==pre[0] && config.serial_prefix==pre[1] && config.serial_number==make16(pre[2],pre[3]) ) {
051C:  MOVLB  9
051E:  MOVF   x32,W
0520:  SUBLW  23
0522:  BNZ   0570
0524:  MOVF   x33,W
0526:  MOVLB  5
0528:  SUBWF  x83,W
052A:  BTFSC  FD8.2
052C:  BRA    0532
052E:  MOVLB  9
0530:  BRA    0570
0532:  MOVFF  934,03
0536:  MOVLB  9
0538:  MOVF   x35,W
053A:  MOVLB  5
053C:  SUBWF  x84,W
053E:  BTFSC  FD8.2
0540:  BRA    0546
0542:  MOVLB  9
0544:  BRA    0570
0546:  MOVF   03,W
0548:  SUBWF  x85,W
054A:  BTFSC  FD8.2
054C:  BRA    0552
054E:  MOVLB  9
0550:  BRA    0570
.................... 			output_high(CTRL_1);
0552:  BCF    F92.1
0554:  BSF    F89.1
.................... 			query.buff[0]=pre[0];
0556:  MOVFF  932,46C
.................... 			query.buff[1]=pre[1];
055A:  MOVFF  933,46D
.................... 			query.buff[2]=pre[2];
055E:  MOVFF  934,46E
.................... 			query.buff[3]=pre[3];
0562:  MOVFF  935,46F
.................... 			query.buff[4]=pre[4];
0566:  MOVFF  936,470
.................... 			query.buff_pos=5;
056A:  MOVLW  05
056C:  MOVWF  x6C
056E:  MOVLB  9
.................... 		}
.................... 	} else {
0570:  BRA    05B0
0572:  MOVLB  5
.................... 		query.buff[query.buff_pos++]=fgetc(STREAM_WORLD);
0574:  MOVF   x6C,W
0576:  INCF   x6C,F
0578:  ADDLW  6C
057A:  MOVWF  FE9
057C:  MOVLW  04
057E:  MOVWF  FEA
0580:  BTFSC  FD8.0
0582:  INCF   FEA,F
0584:  MOVFF  FEA,99E
0588:  MOVFF  FE9,99D
058C:  MOVLB  0
058E:  RCALL  04CC
0590:  MOVFF  99E,FEA
0594:  MOVFF  99D,FE9
0598:  MOVFF  01,FEF
.................... 
.................... 		if ( query.buff_pos == query.buff[4] ) {
059C:  MOVLB  4
059E:  MOVF   x70,W
05A0:  MOVLB  5
05A2:  SUBWF  x6C,W
05A4:  BNZ   05AE
.................... 			output_toggle(CTRL_1);
05A6:  BCF    F92.1
05A8:  BTG    F89.1
.................... 			query.buff_ready=1;
05AA:  MOVLW  01
05AC:  MOVWF  x6D
05AE:  MOVLB  9
.................... 		}
.................... 	}
.................... }
.................... 
05B0:  BCF    FA4.5
05B2:  MOVLB  0
05B4:  GOTO   0084
.................... #include "live_rdTap.c"
.................... /* pass reg_crc value of 0xFFFF to reset */
.................... int16 crc_chk_pass(int16 reg_crc, int8 *data, int8 length) {
.................... 	int8 j;
.................... 	
.................... 	while ( length-- ) {
*
1980:  MOVLB  9
1982:  MOVF   x97,W
1984:  DECF   x97,F
1986:  XORLW  00
1988:  BZ    19D2
.................... 		reg_crc ^= *data++;
198A:  MOVFF  996,FEA
198E:  MOVF   x95,W
1990:  INCF   x95,F
1992:  BTFSC  FD8.2
1994:  INCF   x96,F
1996:  MOVWF  FE9
1998:  MOVF   FEF,W
199A:  XORWF  x93,F
.................... 
.................... 		for ( j=0 ; j<8 ; j++ ) {
199C:  CLRF   x98
199E:  MOVF   x98,W
19A0:  SUBLW  07
19A2:  BNC   19D0
.................... 			if ( reg_crc & 0x01 ) {
19A4:  MOVF   x93,W
19A6:  ANDLW  01
19A8:  MOVWF  00
19AA:  CLRF   03
19AC:  MOVF   00,W
19AE:  IORWF  03,W
19B0:  BZ    19C6
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001;
19B2:  BCF    FD8.0
19B4:  RRCF   x94,W
19B6:  MOVWF  x9A
19B8:  RRCF   x93,W
19BA:  XORLW  01
19BC:  MOVWF  x93
19BE:  MOVF   x9A,W
19C0:  XORLW  A0
19C2:  MOVWF  x94
.................... 			} else {
19C4:  BRA    19CC
.................... 				reg_crc=reg_crc>>1;
19C6:  BCF    FD8.0
19C8:  RRCF   x94,F
19CA:  RRCF   x93,F
.................... 			}
19CC:  INCF   x98,F
19CE:  BRA    199E
.................... 		}	
19D0:  BRA    1982
.................... 	}
.................... 	
.................... 	return reg_crc;
19D2:  MOVFF  993,01
19D6:  MOVFF  994,02
19DA:  MOVLB  0
19DC:  RETURN 0
.................... }
.................... 
.................... void live_send(void) {
.................... 	int16 lCRC;
.................... 	int8 i;
.................... 	int8 buff[17];
.................... 	int16 completeLength;
.................... 
.................... 	completeLength=sizeof(buff) + qbuff.rResultLength + 2;
*
19E6:  MOVLW  11
19E8:  MOVLB  4
19EA:  ADDWF  x68,W
19EC:  ADDLW  02
19EE:  MOVLB  9
19F0:  MOVWF  x91
19F2:  CLRF   x92
19F4:  BTFSC  FD8.0
19F6:  INCF   x92,F
.................... 
.................... 	buff[0]='#';
19F8:  MOVLW  23
19FA:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
19FC:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
1A00:  MOVFF  585,982
1A04:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0); 
1A06:  MOVFF  584,983
1A0A:  MOVLB  9
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */
1A0C:  SETF   x84
.................... 	buff[5]=18; /* packet type */
1A0E:  MOVLW  12
1A10:  MOVWF  x85
.................... 	buff[6]=make8(completeLength,1);
1A12:  MOVFF  992,986
.................... 	buff[7]=make8(completeLength,0);
1A16:  MOVFF  991,987
.................... 
.................... 	buff[8]=make8(qbuff.measurementNumber,1);
1A1A:  MOVFF  46B,988
1A1E:  MOVLB  9
.................... 	buff[9]=make8(qbuff.measurementNumber,0);
1A20:  MOVFF  46A,989
1A24:  MOVLB  9
.................... 
.................... 	/* device info */
.................... 	/* WorldData device type identifier (16-bit) */
.................... 	i=qbuff.deviceNumber;
1A26:  MOVFF  469,97F
.................... 	buff[10]=make8(device[i].typeWorld,1);
1A2A:  CLRF   x95
1A2C:  MOVFF  97F,994
1A30:  CLRF   x97
1A32:  MOVLW  0D
1A34:  MOVWF  x96
1A36:  MOVLB  0
1A38:  CALL   084C
1A3C:  MOVFF  01,993
1A40:  MOVLW  01
1A42:  MOVLB  9
1A44:  ADDWF  01,W
1A46:  MOVWF  01
1A48:  MOVLW  00
1A4A:  ADDWFC 02,W
1A4C:  MOVWF  03
1A4E:  MOVF   01,W
1A50:  ADDLW  21
1A52:  MOVWF  FE9
1A54:  MOVLW  00
1A56:  ADDWFC 03,W
1A58:  MOVWF  FEA
1A5A:  MOVFF  FEC,98A
1A5E:  MOVF   FED,F
1A60:  MOVFF  FEF,993
.................... 	buff[11]=make8(device[i].typeWorld,0);
1A64:  CLRF   x95
1A66:  MOVFF  97F,994
1A6A:  CLRF   x97
1A6C:  MOVLW  0D
1A6E:  MOVWF  x96
1A70:  MOVLB  0
1A72:  CALL   084C
1A76:  MOVFF  01,993
1A7A:  MOVLW  01
1A7C:  MOVLB  9
1A7E:  ADDWF  01,W
1A80:  MOVWF  01
1A82:  MOVLW  00
1A84:  ADDWFC 02,W
1A86:  MOVWF  03
1A88:  MOVF   01,W
1A8A:  ADDLW  21
1A8C:  MOVWF  FE9
1A8E:  MOVLW  00
1A90:  ADDWFC 03,W
1A92:  MOVWF  FEA
1A94:  MOVFF  FEC,994
1A98:  MOVF   FED,F
1A9A:  MOVFF  FEF,98B
.................... 	/* manufacturers serial number */
.................... 	buff[12]=make8(device[i].serialNumber,3);
1A9E:  CLRF   x95
1AA0:  MOVFF  97F,994
1AA4:  CLRF   x97
1AA6:  MOVLW  0D
1AA8:  MOVWF  x96
1AAA:  MOVLB  0
1AAC:  CALL   084C
1AB0:  MOVFF  01,993
1AB4:  MOVLW  05
1AB6:  MOVLB  9
1AB8:  ADDWF  01,W
1ABA:  MOVWF  01
1ABC:  MOVLW  00
1ABE:  ADDWFC 02,W
1AC0:  MOVWF  03
1AC2:  MOVF   01,W
1AC4:  ADDLW  21
1AC6:  MOVWF  FE9
1AC8:  MOVLW  00
1ACA:  ADDWFC 03,W
1ACC:  MOVWF  FEA
1ACE:  MOVFF  FEF,993
1AD2:  MOVFF  FEC,994
1AD6:  MOVFF  FEC,995
1ADA:  MOVFF  FEC,98C
.................... 	buff[13]=make8(device[i].serialNumber,2);
1ADE:  CLRF   x95
1AE0:  MOVFF  97F,994
1AE4:  CLRF   x97
1AE6:  MOVLW  0D
1AE8:  MOVWF  x96
1AEA:  MOVLB  0
1AEC:  CALL   084C
1AF0:  MOVFF  01,993
1AF4:  MOVLW  05
1AF6:  MOVLB  9
1AF8:  ADDWF  01,W
1AFA:  MOVWF  01
1AFC:  MOVLW  00
1AFE:  ADDWFC 02,W
1B00:  MOVWF  03
1B02:  MOVF   01,W
1B04:  ADDLW  21
1B06:  MOVWF  FE9
1B08:  MOVLW  00
1B0A:  ADDWFC 03,W
1B0C:  MOVWF  FEA
1B0E:  MOVFF  FEF,993
1B12:  MOVFF  FEC,994
1B16:  MOVFF  FEC,98D
1B1A:  MOVFF  FEC,996
.................... 	buff[14]=make8(device[i].serialNumber,1);
1B1E:  CLRF   x95
1B20:  MOVFF  97F,994
1B24:  CLRF   x97
1B26:  MOVLW  0D
1B28:  MOVWF  x96
1B2A:  MOVLB  0
1B2C:  CALL   084C
1B30:  MOVFF  01,993
1B34:  MOVLW  05
1B36:  MOVLB  9
1B38:  ADDWF  01,W
1B3A:  MOVWF  01
1B3C:  MOVLW  00
1B3E:  ADDWFC 02,W
1B40:  MOVWF  03
1B42:  MOVF   01,W
1B44:  ADDLW  21
1B46:  MOVWF  FE9
1B48:  MOVLW  00
1B4A:  ADDWFC 03,W
1B4C:  MOVWF  FEA
1B4E:  MOVFF  FEF,993
1B52:  MOVFF  FEC,98E
1B56:  MOVFF  FEC,995
1B5A:  MOVFF  FEC,996
.................... 	buff[15]=make8(device[i].serialNumber,0);
1B5E:  CLRF   x95
1B60:  MOVFF  97F,994
1B64:  CLRF   x97
1B66:  MOVLW  0D
1B68:  MOVWF  x96
1B6A:  MOVLB  0
1B6C:  CALL   084C
1B70:  MOVFF  01,993
1B74:  MOVLW  05
1B76:  MOVLB  9
1B78:  ADDWF  01,W
1B7A:  MOVWF  01
1B7C:  MOVLW  00
1B7E:  ADDWFC 02,W
1B80:  MOVWF  03
1B82:  MOVF   01,W
1B84:  ADDLW  21
1B86:  MOVWF  FE9
1B88:  MOVLW  00
1B8A:  ADDWFC 03,W
1B8C:  MOVWF  FEA
1B8E:  MOVFF  FEF,98F
1B92:  MOVFF  FEC,994
1B96:  MOVFF  FEC,995
1B9A:  MOVFF  FEC,996
.................... 	/* status of the data read */
.................... 	buff[16]=qbuff.rException;
1B9E:  MOVFF  367,990
.................... 
.................... 	/* compute CRC on header and result data */
.................... 	lCRC=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
1BA2:  SETF   x94
1BA4:  SETF   x93
1BA6:  MOVLW  09
1BA8:  MOVWF  x96
1BAA:  MOVLW  81
1BAC:  MOVWF  x95
1BAE:  MOVLW  10
1BB0:  MOVWF  x97
1BB2:  MOVLB  0
1BB4:  RCALL  1980
1BB6:  MOVFF  02,97E
1BBA:  MOVFF  01,97D
.................... 	lCRC=crc_chk_pass(lCRC,qbuff.rResult,qbuff.rResultLength);
1BBE:  MOVFF  97E,994
1BC2:  MOVFF  97D,993
1BC6:  MOVLW  03
1BC8:  MOVLB  9
1BCA:  MOVWF  x96
1BCC:  MOVLW  68
1BCE:  MOVWF  x95
1BD0:  MOVFF  468,997
1BD4:  MOVLB  0
1BD6:  RCALL  1980
1BD8:  MOVFF  02,97E
1BDC:  MOVFF  01,97D
.................... 
.................... 	/* send buff, qbuff.rResult, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
1BE0:  MOVLB  9
1BE2:  CLRF   x7F
1BE4:  MOVF   x7F,W
1BE6:  SUBLW  10
1BE8:  BNC   1C08
.................... 		fputc(buff[i],STREAM_WORLD);
1BEA:  CLRF   03
1BEC:  MOVF   x7F,W
1BEE:  ADDLW  80
1BF0:  MOVWF  FE9
1BF2:  MOVLW  09
1BF4:  ADDWFC 03,W
1BF6:  MOVWF  FEA
1BF8:  MOVFF  FEF,993
1BFC:  MOVF   x93,W
1BFE:  MOVLB  0
1C00:  RCALL  19DE
1C02:  MOVLB  9
1C04:  INCF   x7F,F
1C06:  BRA    1BE4
.................... 	}	
.................... 	for ( i=0 ; i<qbuff.rResultLength ; i++ ) {
1C08:  CLRF   x7F
1C0A:  MOVLB  4
1C0C:  MOVF   x68,W
1C0E:  MOVLB  9
1C10:  SUBWF  x7F,W
1C12:  BC    1C32
.................... 		fputc(qbuff.rResult[i],STREAM_WORLD);
1C14:  MOVLW  68
1C16:  ADDWF  x7F,W
1C18:  MOVWF  FE9
1C1A:  MOVLW  03
1C1C:  MOVWF  FEA
1C1E:  BTFSC  FD8.0
1C20:  INCF   FEA,F
1C22:  MOVFF  FEF,993
1C26:  MOVF   x93,W
1C28:  MOVLB  0
1C2A:  RCALL  19DE
1C2C:  MOVLB  9
1C2E:  INCF   x7F,F
1C30:  BRA    1C0A
.................... 	}
.................... 	fputc(make8(lCRC,1),STREAM_WORLD);
1C32:  MOVFF  97E,993
1C36:  MOVF   x93,W
1C38:  MOVLB  0
1C3A:  RCALL  19DE
.................... 	fputc(make8(lCRC,0),STREAM_WORLD);
1C3C:  MOVFF  97D,993
1C40:  MOVLB  9
1C42:  MOVF   x93,W
1C44:  MOVLB  0
1C46:  RCALL  19DE
1C48:  RETURN 0
.................... }
.................... 
.................... 
.................... #include "queryHandler_rdTap.c"
.................... /* this will do an arbitrary query to some other device on the network */
.................... void query_other(void) {
.................... 	int8 parseType;
.................... 	int8 i;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_other()\r\n");
.................... 	fprintf(STREAM_WORLD,"# query function=%lu\r\n",query.function);
.................... #endif
.................... 
.................... 	if ( query.function <= DEV_TYPE_MODBUS_MAX ) {
*
3104:  MOVLB  5
3106:  MOVF   x7A,F
3108:  BTFSS  FD8.2
310A:  BRA    335C
310C:  MOVF   x79,W
310E:  SUBLW  07
3110:  BTFSS  FD8.0
3112:  BRA    335C
.................... 		/* modbus device type */
.................... 		switch ( query.function ) {
3114:  MOVF   x79,W
3116:  MOVWF  00
3118:  MOVF   x7A,W
311A:  MOVWF  03
311C:  MOVF   03,W
311E:  BNZ   3128
3120:  MOVF   00,F
3122:  MOVLB  0
3124:  BZ    3190
3126:  MOVLB  5
3128:  MOVF   03,W
312A:  BNZ   3136
312C:  MOVLW  01
312E:  SUBWF  00,W
3130:  MOVLB  0
3132:  BZ    3192
3134:  MOVLB  5
3136:  MOVF   03,W
3138:  BNZ   3144
313A:  MOVLW  02
313C:  SUBWF  00,W
313E:  MOVLB  0
3140:  BZ    31BA
3142:  MOVLB  5
3144:  MOVF   03,W
3146:  BNZ   3152
3148:  MOVLW  03
314A:  SUBWF  00,W
314C:  MOVLB  0
314E:  BZ    31E0
3150:  MOVLB  5
3152:  MOVF   03,W
3154:  BNZ   3160
3156:  MOVLW  04
3158:  SUBWF  00,W
315A:  MOVLB  0
315C:  BZ    3208
315E:  MOVLB  5
3160:  MOVF   03,W
3162:  BNZ   316E
3164:  MOVLW  05
3166:  SUBWF  00,W
3168:  MOVLB  0
316A:  BZ    3230
316C:  MOVLB  5
316E:  MOVF   03,W
3170:  BNZ   317E
3172:  MOVLW  06
3174:  SUBWF  00,W
3176:  MOVLB  0
3178:  BTFSC  FD8.2
317A:  BRA    3262
317C:  MOVLB  5
317E:  MOVF   03,W
3180:  BNZ   318E
3182:  MOVLW  07
3184:  SUBWF  00,W
3186:  MOVLB  0
3188:  BTFSC  FD8.2
318A:  BRA    32B8
318C:  MOVLB  5
318E:  BRA    32F8
.................... 			case DEV_TYPE_DISABLED:
.................... 				return;
3190:  BRA    3422
.................... 			case DEV_TYPE_MODBUS_1: /* not very well tested */
.................... 				query.resultException=modbus_read_coils(query.network_address, query.start_address, query.n_words);
3192:  MOVFF  577,982
3196:  MOVFF  57C,984
319A:  MOVFF  57B,983
319E:  MOVLB  9
31A0:  CLRF   x86
31A2:  MOVFF  57D,985
31A6:  MOVLB  0
31A8:  CALL   1C4A
31AC:  MOVFF  01,581
.................... 				parseType=1;
31B0:  MOVLW  01
31B2:  MOVLB  9
31B4:  MOVWF  x80
.................... 				break;
31B6:  MOVLB  5
31B8:  BRA    32F8
.................... 			case DEV_TYPE_MODBUS_2: /* not very well tested */
.................... 				query.resultException=modbus_read_discrete_input(query.network_address, query.start_address, query.n_words);
31BA:  MOVFF  577,982
31BE:  MOVFF  57C,984
31C2:  MOVFF  57B,983
31C6:  MOVLB  9
31C8:  CLRF   x86
31CA:  MOVFF  57D,985
31CE:  MOVLB  0
31D0:  BRA    2D98
31D2:  MOVFF  01,581
.................... 				parseType=1;
31D6:  MOVLW  01
31D8:  MOVLB  9
31DA:  MOVWF  x80
.................... 				break;
31DC:  MOVLB  5
31DE:  BRA    32F8
.................... 			case DEV_TYPE_MODBUS_3: /* tested */
.................... 				query.resultException=modbus_read_holding_registers(query.network_address, query.start_address, query.n_words);
31E0:  MOVFF  577,982
31E4:  MOVFF  57C,984
31E8:  MOVFF  57B,983
31EC:  MOVLB  9
31EE:  CLRF   x86
31F0:  MOVFF  57D,985
31F4:  MOVLB  0
31F6:  CALL   18E8
31FA:  MOVFF  01,581
.................... 				parseType=1;
31FE:  MOVLW  01
3200:  MOVLB  9
3202:  MOVWF  x80
.................... 				break;
3204:  MOVLB  5
3206:  BRA    32F8
.................... 			case DEV_TYPE_MODBUS_4: /* tested */
.................... 				query.resultException=modbus_read_input_registers(query.network_address, query.start_address, query.n_words);
3208:  MOVFF  577,982
320C:  MOVFF  57C,984
3210:  MOVFF  57B,983
3214:  MOVLB  9
3216:  CLRF   x86
3218:  MOVFF  57D,985
321C:  MOVLB  0
321E:  CALL   1850
3222:  MOVFF  01,581
.................... 				parseType=1;
3226:  MOVLW  01
3228:  MOVLB  9
322A:  MOVWF  x80
.................... 				break;
322C:  MOVLB  5
322E:  BRA    32F8
.................... 			case DEV_TYPE_MODBUS_5: /* tested */
.................... 				query.resultException=modbus_write_single_coil(query.network_address, query.start_address, query.buff[query.data_start_offset]);
3230:  MOVLW  6C
3232:  MOVLB  5
3234:  ADDWF  x7E,W
3236:  MOVWF  FE9
3238:  MOVLW  04
323A:  MOVWF  FEA
323C:  BTFSC  FD8.0
323E:  INCF   FEA,F
3240:  MOVFF  FEF,986
3244:  MOVFF  577,983
3248:  MOVFF  57C,985
324C:  MOVFF  57B,984
3250:  MOVLB  0
3252:  BRA    2E40
3254:  MOVFF  01,581
.................... 				parseType=2;
3258:  MOVLW  02
325A:  MOVLB  9
325C:  MOVWF  x80
.................... 				break;
325E:  MOVLB  5
3260:  BRA    32F8
.................... 			case DEV_TYPE_MODBUS_6: /* tested */
.................... 				query.resultException=modbus_write_single_register(query.network_address, query.start_address, 
.................... 					make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
3262:  MOVLW  6C
3264:  MOVLB  5
3266:  ADDWF  x7E,W
3268:  MOVWF  FE9
326A:  MOVLW  04
326C:  MOVWF  FEA
326E:  BTFSC  FD8.0
3270:  INCF   FEA,F
3272:  MOVFF  FEF,982
3276:  MOVLW  01
3278:  ADDWF  x7E,W
327A:  ADDLW  6C
327C:  MOVWF  FE9
327E:  MOVLW  04
3280:  MOVWF  FEA
3282:  BTFSC  FD8.0
3284:  INCF   FEA,F
3286:  MOVFF  FEF,983
328A:  MOVFF  982,985
328E:  MOVFF  983,984
3292:  MOVFF  577,986
3296:  MOVFF  57C,988
329A:  MOVFF  57B,987
329E:  MOVFF  982,98A
32A2:  MOVFF  983,989
32A6:  MOVLB  0
32A8:  BRA    2EFC
32AA:  MOVFF  01,581
.................... 				parseType=2;
32AE:  MOVLW  02
32B0:  MOVLB  9
32B2:  MOVWF  x80
.................... 				return;
32B4:  MOVLB  0
32B6:  BRA    3422
.................... 			case DEV_TYPE_MODBUS_16: /* tested ... endian issues lead to having to send data in a (backwards?) order */
.................... 				query.resultException=modbus_write_multiple_registers_flip(query.network_address, query.start_address, 
.................... 					query.n_words,&query.buff+query.data_start_offset
.................... 				);
32B8:  MOVLW  6C
32BA:  MOVLB  5
32BC:  ADDWF  x7E,W
32BE:  MOVLB  9
32C0:  MOVWF  x82
32C2:  MOVLW  04
32C4:  MOVWF  x83
32C6:  BTFSC  FD8.0
32C8:  INCF   x83,F
32CA:  MOVFF  577,984
32CE:  MOVFF  57C,986
32D2:  MOVFF  57B,985
32D6:  CLRF   x88
32D8:  MOVFF  57D,987
32DC:  MOVFF  983,98A
32E0:  MOVFF  982,989
32E4:  MOVLB  0
32E6:  BRA    2FA4
32E8:  MOVFF  01,581
.................... 				parseType=2;
32EC:  MOVLW  02
32EE:  MOVLB  9
32F0:  MOVWF  x80
.................... 				return;
32F2:  MOVLB  0
32F4:  BRA    3422
32F6:  MOVLB  5
.................... 		}	
.................... 
.................... 		/* Modbus query performed above. */
.................... 		/* no error, copy data to buffer to send response */
.................... 		if ( 1==parseType && 0==query.resultException ) {
32F8:  MOVLB  9
32FA:  DECFSZ x80,W
32FC:  BRA    3338
32FE:  MOVLB  5
3300:  MOVF   x81,F
3302:  BTFSC  FD8.2
3304:  BRA    330A
3306:  MOVLB  9
3308:  BRA    3338
.................... 			query.resultLength=modbus_rx.len-1;
330A:  MOVLW  01
330C:  SUBWF  x94,W
330E:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[1],modbus_rx.len-1); 
3310:  MOVLW  01
3312:  SUBWF  x94,W
3314:  MOVLB  9
3316:  MOVWF  x82
3318:  MOVLW  04
331A:  MOVWF  FEA
331C:  MOVLW  6C
331E:  MOVWF  FE9
3320:  MOVLW  05
3322:  MOVWF  FE2
3324:  MOVLW  98
3326:  MOVWF  FE1
3328:  MOVF   x82,W
332A:  MOVWF  01
332C:  BZ    3336
332E:  MOVFF  FE6,FEE
3332:  DECFSZ 01,F
3334:  BRA    332E
.................... 		} else if ( 2==parseType && 0==query.resultException ) {
3336:  BRA    3358
3338:  MOVF   x80,W
333A:  SUBLW  02
333C:  BNZ   3358
333E:  MOVLB  5
3340:  MOVF   x81,F
3342:  BTFSC  FD8.2
3344:  BRA    334A
3346:  MOVLB  9
3348:  BRA    3358
.................... 			/* return the value of the coil we wrote */
.................... 			query.resultLength=2;
334A:  MOVLW  02
334C:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[3],2); 
334E:  MOVFF  59A,46C
3352:  MOVFF  59B,46D
3356:  MOVLB  9
.................... 		}
.................... 	} else if ( query.function <= DEV_TYPE_I2C_MAX ) {
3358:  BRA    3420
335A:  MOVLB  5
335C:  MOVF   x7A,F
335E:  BNZ   3422
3360:  MOVF   x79,W
3362:  SUBLW  17
3364:  BNC   3422
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# query_other for I2C network_adress=%lu, start_address=%lu n_words=%u\r\n",
.................... 			query.network_address,
.................... 			query.start_address,
.................... 			query.n_words
.................... 		);
.................... #endif
.................... 
.................... 		if ( DEV_TYPE_I2C_READ_8 == query.function ) {
3366:  MOVF   x79,W
3368:  SUBLW  10
336A:  BNZ   3396
336C:  MOVF   x7A,F
336E:  BNZ   3396
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_READ_8\r\n");
.................... #endif
.................... 
.................... 			/* start a read at start address then just read a byte at a time. n_words is actually bytes */
.................... 			i2c_buff_read(query.network_address, query.start_address, query.buff, query.n_words);
3370:  MOVFF  577,982
3374:  MOVFF  57B,983
3378:  MOVLW  04
337A:  MOVLB  9
337C:  MOVWF  x85
337E:  MOVLW  6C
3380:  MOVWF  x84
3382:  MOVFF  57D,986
3386:  MOVLB  0
3388:  CALL   1CE2
.................... 			query.resultLength = query.n_words; /* in bytes */
338C:  MOVFF  57D,582
.................... 			query.resultException=0;
3390:  MOVLB  5
3392:  CLRF   x81
.................... 		} else if ( DEV_TYPE_I2C_WRITE_16 == query.function ) {
3394:  BRA    3422
3396:  MOVF   x79,W
3398:  SUBLW  15
339A:  BNZ   3422
339C:  MOVF   x7A,F
339E:  BNZ   3422
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_WRITE_16\r\n");
.................... #endif
.................... 
.................... 			for ( i=0 ; i<query.n_words ; i++ ) {
33A0:  MOVLB  9
33A2:  CLRF   x81
33A4:  MOVLB  5
33A6:  MOVF   x7D,W
33A8:  MOVLB  9
33AA:  SUBWF  x81,W
33AC:  BC    3420
.................... #if DEBUG_ASCII
.................... 				fprintf(STREAM_WORLD,"# writing 0x%04lx to I2C device 0x%02x at address %lu\r\n",
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1]),
.................... 					query.network_address,
.................... 					(query.start_address+i*2)
.................... 				);
.................... #endif
.................... 
.................... 				i2c_register_write16(
.................... 					query.network_address,
.................... 					(query.start_address+i*2),
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1])
.................... 				);
33AE:  BCF    FD8.0
33B0:  RLCF   x81,W
33B2:  MOVLB  5
33B4:  ADDWF  x7B,W
33B6:  MOVLB  9
33B8:  MOVWF  x82
33BA:  MOVLW  00
33BC:  MOVLB  5
33BE:  ADDWFC x7C,W
33C0:  MOVLB  9
33C2:  MOVWF  x83
33C4:  BCF    FD8.0
33C6:  RLCF   x81,W
33C8:  MOVLB  5
33CA:  ADDWF  x7E,W
33CC:  ADDLW  6C
33CE:  MOVWF  FE9
33D0:  MOVLW  04
33D2:  MOVWF  FEA
33D4:  BTFSC  FD8.0
33D6:  INCF   FEA,F
33D8:  MOVFF  FEF,984
33DC:  BCF    FD8.0
33DE:  MOVLB  9
33E0:  RLCF   x81,W
33E2:  MOVLB  5
33E4:  ADDWF  x7E,W
33E6:  ADDLW  01
33E8:  ADDLW  6C
33EA:  MOVWF  FE9
33EC:  MOVLW  04
33EE:  MOVWF  FEA
33F0:  BTFSC  FD8.0
33F2:  INCF   FEA,F
33F4:  MOVFF  FEF,985
33F8:  MOVFF  984,987
33FC:  MOVFF  985,986
3400:  MOVFF  577,988
3404:  MOVFF  982,989
3408:  MOVFF  984,98B
340C:  MOVFF  985,98A
3410:  MOVLB  0
3412:  BRA    30C8
.................... 
.................... 				query.resultLength = 0; /* in bytes */
3414:  MOVLB  5
3416:  CLRF   x82
.................... 				query.resultException=0;
3418:  CLRF   x81
341A:  MOVLB  9
341C:  INCF   x81,F
341E:  BRA    33A4
.................... 
.................... 			}
.................... 
.................... 		} else {
3420:  MOVLB  5
3422:  MOVLB  0
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# un-implemented I2C query function\r\n");
.................... #endif
.................... 		}
.................... 
.................... 	}
3424:  GOTO   3646 (RETURN)
.................... }
.................... 
.................... 
.................... /* 
.................... try to write the specified register
.................... if successful, return 0, otherwise return a modbus exception
.................... */
.................... exception query_self_write_register(int16 address, int16 value) {
.................... 	int8 dev, offset;
.................... 	int16 last;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_write_register address=%lu value=%lu\r\n",address,value);
.................... #endif
.................... 
.................... 	/* if we have been unlocked, then we can modify serial number */
.................... 	if ( timers.factory_unlocked ) {
*
298A:  MOVLB  3
298C:  MOVF   x63,F
298E:  BZ    29C6
.................... 		if ( 1000 == address ) {
2990:  MOVLB  9
2992:  MOVF   x84,W
2994:  SUBLW  E8
2996:  BNZ   29AA
2998:  MOVF   x85,W
299A:  SUBLW  03
299C:  BNZ   29AA
.................... 			config.serial_prefix=value;
299E:  MOVFF  986,583
.................... 			return 0;
29A2:  MOVLW  00
29A4:  MOVWF  01
29A6:  BRA    2CB4
.................... 		} else if ( 1001 == address ) {
29A8:  BRA    29C4
29AA:  MOVF   x84,W
29AC:  SUBLW  E9
29AE:  BNZ   29C4
29B0:  MOVF   x85,W
29B2:  SUBLW  03
29B4:  BNZ   29C4
.................... 			config.serial_number=value;
29B6:  MOVFF  987,585
29BA:  MOVFF  986,584
.................... 			return 0;
29BE:  MOVLW  00
29C0:  MOVWF  01
29C2:  BRA    2CB4
29C4:  MOVLB  3
.................... 		}
.................... 	}
.................... 
.................... 	if ( address < 1000 ) {
29C6:  MOVLB  9
29C8:  MOVF   x85,W
29CA:  SUBLW  03
29CC:  BTFSS  FD8.0
29CE:  BRA    2BD8
29D0:  BNZ   29DA
29D2:  MOVF   x84,W
29D4:  SUBLW  E7
29D6:  BTFSS  FD8.0
29D8:  BRA    2BD8
.................... 		dev=address>>3;
29DA:  RRCF   x85,W
29DC:  MOVWF  03
29DE:  RRCF   x84,W
29E0:  MOVWF  02
29E2:  RRCF   03,F
29E4:  RRCF   02,F
29E6:  RRCF   03,F
29E8:  RRCF   02,F
29EA:  MOVFF  02,988
.................... 		offset=address&0b111;
29EE:  MOVF   x84,W
29F0:  ANDLW  07
29F2:  MOVWF  x89
.................... 
.................... 		if ( dev > DEV_MAX_N )
29F4:  MOVF   x88,W
29F6:  SUBLW  40
29F8:  BC    2A00
.................... 			return ILLEGAL_DATA_ADDRESS;
29FA:  MOVLW  02
29FC:  MOVWF  01
29FE:  BRA    2CB4
.................... 
.................... 		switch ( offset ) {
2A00:  MOVF   x89,W
2A02:  ADDLW  F8
2A04:  BTFSC  FD8.0
2A06:  BRA    2BD6
2A08:  ADDLW  08
2A0A:  MOVLB  0
2A0C:  GOTO   2CBA
.................... 			case 0: device[dev].type=make8(value,0); break;
2A10:  MOVLB  9
2A12:  CLRF   x95
2A14:  MOVFF  988,994
2A18:  CLRF   x97
2A1A:  MOVLW  0D
2A1C:  MOVWF  x96
2A1E:  MOVLB  0
2A20:  CALL   084C
2A24:  MOVFF  02,98D
2A28:  MOVFF  01,98C
2A2C:  MOVLW  21
2A2E:  MOVLB  9
2A30:  ADDWF  01,W
2A32:  MOVWF  FE9
2A34:  MOVLW  00
2A36:  ADDWFC 02,W
2A38:  MOVWF  FEA
2A3A:  MOVFF  986,FEF
2A3E:  BRA    2BD6
.................... 			case 1: device[dev].typeWorld=value; break;
2A40:  MOVLB  9
2A42:  CLRF   x95
2A44:  MOVFF  988,994
2A48:  CLRF   x97
2A4A:  MOVLW  0D
2A4C:  MOVWF  x96
2A4E:  MOVLB  0
2A50:  CALL   084C
2A54:  MOVFF  02,98D
2A58:  MOVFF  01,98C
2A5C:  MOVLW  01
2A5E:  MOVLB  9
2A60:  ADDWF  01,W
2A62:  MOVWF  01
2A64:  MOVLW  00
2A66:  ADDWFC 02,W
2A68:  MOVWF  03
2A6A:  MOVF   01,W
2A6C:  ADDLW  21
2A6E:  MOVWF  FE9
2A70:  MOVLW  00
2A72:  ADDWFC 03,W
2A74:  MOVWF  FEA
2A76:  MOVFF  987,FEC
2A7A:  MOVF   FED,F
2A7C:  MOVFF  986,FEF
2A80:  BRA    2BD6
.................... 			case 2: device[dev].transmitEvery=make8(value,0); break;
2A82:  MOVLB  9
2A84:  CLRF   x95
2A86:  MOVFF  988,994
2A8A:  CLRF   x97
2A8C:  MOVLW  0D
2A8E:  MOVWF  x96
2A90:  MOVLB  0
2A92:  CALL   084C
2A96:  MOVFF  02,98D
2A9A:  MOVFF  01,98C
2A9E:  MOVLW  03
2AA0:  MOVLB  9
2AA2:  ADDWF  01,W
2AA4:  MOVWF  01
2AA6:  MOVLW  00
2AA8:  ADDWFC 02,W
2AAA:  MOVWF  03
2AAC:  MOVF   01,W
2AAE:  ADDLW  21
2AB0:  MOVWF  FE9
2AB2:  MOVLW  00
2AB4:  ADDWFC 03,W
2AB6:  MOVWF  FEA
2AB8:  MOVFF  986,FEF
2ABC:  BRA    2BD6
.................... 			case 3: device[dev].networkAddress=make8(value,0); break;
2ABE:  MOVLB  9
2AC0:  CLRF   x95
2AC2:  MOVFF  988,994
2AC6:  CLRF   x97
2AC8:  MOVLW  0D
2ACA:  MOVWF  x96
2ACC:  MOVLB  0
2ACE:  CALL   084C
2AD2:  MOVFF  02,98D
2AD6:  MOVFF  01,98C
2ADA:  MOVLW  04
2ADC:  MOVLB  9
2ADE:  ADDWF  01,W
2AE0:  MOVWF  01
2AE2:  MOVLW  00
2AE4:  ADDWFC 02,W
2AE6:  MOVWF  03
2AE8:  MOVF   01,W
2AEA:  ADDLW  21
2AEC:  MOVWF  FE9
2AEE:  MOVLW  00
2AF0:  ADDWFC 03,W
2AF2:  MOVWF  FEA
2AF4:  MOVFF  986,FEF
2AF8:  BRA    2BD6
.................... 			/* first pass get the high word of serial number */
.................... 			case 4: last=value; break;
2AFA:  MOVFF  987,98B
2AFE:  MOVFF  986,98A
2B02:  MOVLB  9
2B04:  BRA    2BD6
.................... 			/* second pass, combine last value and current value */
.................... 			case 5: device[dev].serialNumber=make32(last,value); break; /* was missing a break prior to 2024-04-03 */
2B06:  MOVLB  9
2B08:  CLRF   x95
2B0A:  MOVFF  988,994
2B0E:  CLRF   x97
2B10:  MOVLW  0D
2B12:  MOVWF  x96
2B14:  MOVLB  0
2B16:  CALL   084C
2B1A:  MOVFF  02,98D
2B1E:  MOVFF  01,98C
2B22:  MOVLW  05
2B24:  MOVLB  9
2B26:  ADDWF  01,W
2B28:  MOVWF  01
2B2A:  MOVLW  00
2B2C:  ADDWFC 02,W
2B2E:  MOVWF  03
2B30:  MOVF   01,W
2B32:  ADDLW  21
2B34:  MOVWF  FE9
2B36:  MOVLW  00
2B38:  ADDWFC 03,W
2B3A:  MOVWF  FEA
2B3C:  MOVF   FEE,F
2B3E:  MOVFF  98A,FEC
2B42:  MOVFF  98B,FEC
2B46:  MOVF   FED,F
2B48:  MOVF   FED,F
2B4A:  MOVF   FED,F
2B4C:  MOVFF  986,FEF
2B50:  MOVFF  987,FEC
2B54:  BRA    2BD6
.................... 			case 6: device[dev].startRegister=value; break;
2B56:  MOVLB  9
2B58:  CLRF   x95
2B5A:  MOVFF  988,994
2B5E:  CLRF   x97
2B60:  MOVLW  0D
2B62:  MOVWF  x96
2B64:  MOVLB  0
2B66:  CALL   084C
2B6A:  MOVFF  02,98D
2B6E:  MOVFF  01,98C
2B72:  MOVLW  09
2B74:  MOVLB  9
2B76:  ADDWF  01,W
2B78:  MOVWF  01
2B7A:  MOVLW  00
2B7C:  ADDWFC 02,W
2B7E:  MOVWF  03
2B80:  MOVF   01,W
2B82:  ADDLW  21
2B84:  MOVWF  FE9
2B86:  MOVLW  00
2B88:  ADDWFC 03,W
2B8A:  MOVWF  FEA
2B8C:  MOVFF  987,FEC
2B90:  MOVF   FED,F
2B92:  MOVFF  986,FEF
2B96:  BRA    2BD6
.................... 			case 7: device[dev].nRegisters=make8(value,0); break;
2B98:  MOVLB  9
2B9A:  CLRF   x95
2B9C:  MOVFF  988,994
2BA0:  CLRF   x97
2BA2:  MOVLW  0D
2BA4:  MOVWF  x96
2BA6:  MOVLB  0
2BA8:  CALL   084C
2BAC:  MOVFF  02,98D
2BB0:  MOVFF  01,98C
2BB4:  MOVLW  0B
2BB6:  MOVLB  9
2BB8:  ADDWF  01,W
2BBA:  MOVWF  01
2BBC:  MOVLW  00
2BBE:  ADDWFC 02,W
2BC0:  MOVWF  03
2BC2:  MOVF   01,W
2BC4:  ADDLW  21
2BC6:  MOVWF  FE9
2BC8:  MOVLW  00
2BCA:  ADDWFC 03,W
2BCC:  MOVWF  FEA
2BCE:  MOVFF  986,FEF
2BD2:  BRA    2BD6
2BD4:  MOVLB  9
.................... 		}
.................... 	} else {
2BD6:  BRA    2CAC
.................... 		/* publicly writeable addresses */
.................... 
.................... 		switch ( address ) {
2BD8:  MOVF   x84,W
2BDA:  MOVWF  00
2BDC:  MOVF   x85,W
2BDE:  MOVWF  03
2BE0:  MOVLW  04
2BE2:  SUBWF  03,W
2BE4:  BNZ   2BF0
2BE6:  MOVLW  4C
2BE8:  SUBWF  00,W
2BEA:  MOVLB  0
2BEC:  BZ    2C32
2BEE:  MOVLB  9
2BF0:  MOVLW  07
2BF2:  SUBWF  03,W
2BF4:  BNZ   2C00
2BF6:  MOVLW  CD
2BF8:  SUBWF  00,W
2BFA:  MOVLB  0
2BFC:  BZ    2C3C
2BFE:  MOVLB  9
2C00:  MOVLW  07
2C02:  SUBWF  03,W
2C04:  BNZ   2C10
2C06:  MOVLW  CE
2C08:  SUBWF  00,W
2C0A:  MOVLB  0
2C0C:  BZ    2C40
2C0E:  MOVLB  9
2C10:  MOVLW  07
2C12:  SUBWF  03,W
2C14:  BNZ   2C20
2C16:  MOVLW  CF
2C18:  SUBWF  00,W
2C1A:  MOVLB  0
2C1C:  BZ    2C60
2C1E:  MOVLB  9
2C20:  MOVLW  4E
2C22:  SUBWF  03,W
2C24:  BNZ   2C30
2C26:  MOVLW  1F
2C28:  SUBWF  00,W
2C2A:  MOVLB  0
2C2C:  BZ    2C7C
2C2E:  MOVLB  9
2C30:  BRA    2CA6
.................... 			case 1100: config.live_interval=value; break;
2C32:  MOVFF  987,587
2C36:  MOVFF  986,586
2C3A:  BRA    2CAE
.................... 
.................... 			case 1997:
.................... 				reset_cpu(); break; /* break doesn't do anything, but makes the compiler complain less */
2C3C:  RESET
2C3E:  BRA    2CAE
.................... 			case 1998:
.................... 				if ( 1998 != value ) return ILLEGAL_DATA_VALUE;
2C40:  MOVLB  9
2C42:  MOVF   x86,W
2C44:  SUBLW  CE
2C46:  BNZ   2C4E
2C48:  MOVF   x87,W
2C4A:  SUBLW  07
2C4C:  BZ    2C54
2C4E:  MOVLW  03
2C50:  MOVWF  01
2C52:  BRA    2CB4
.................... 				write_default_param_file();
2C54:  MOVLB  0
2C56:  CALL   0822
.................... 				write_default_device_file();
2C5A:  CALL   08C0
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# writing default files\r\n");
.................... #endif
.................... 				break;
2C5E:  BRA    2CAE
.................... 			case 1999:
.................... 				/* write config to EEPROM */
.................... 				if ( 1 != value ) return ILLEGAL_DATA_VALUE;
2C60:  MOVLB  9
2C62:  DECFSZ x86,W
2C64:  BRA    2C6A
2C66:  MOVF   x87,F
2C68:  BZ    2C70
2C6A:  MOVLW  03
2C6C:  MOVWF  01
2C6E:  BRA    2CB4
.................... 				write_param_file();
2C70:  MOVLB  0
2C72:  CALL   07CE
.................... 				write_device_file();
2C76:  CALL   086E
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# config.live_interval=%lu\r\n",config.live_interval);
.................... #endif
.................... 
.................... 				break;
2C7A:  BRA    2CAE
.................... 
.................... 			case 19999:
.................... 				/* unlock factory programming registers when we get 1802 in passcode register */
.................... 				if ( 1802 != value ) {
2C7C:  MOVLB  9
2C7E:  MOVF   x86,W
2C80:  SUBLW  0A
2C82:  BNZ   2C8A
2C84:  MOVF   x87,W
2C86:  SUBLW  07
2C88:  BZ    2C96
.................... 					timers.factory_unlocked=0;
2C8A:  MOVLB  3
2C8C:  CLRF   x63
.................... 					return ILLEGAL_DATA_VALUE;
2C8E:  MOVLW  03
2C90:  MOVWF  01
2C92:  MOVLB  9
2C94:  BRA    2CB4
.................... 				}
.................... 				timers.factory_unlocked=1;
2C96:  MOVLW  01
2C98:  MOVLB  3
2C9A:  MOVWF  x63
.................... 				/* green LED for 2 seconds */
.................... 				timers.led_on_green=200;
2C9C:  MOVLW  C8
2C9E:  MOVWF  x64
.................... 				break;
2CA0:  MOVLB  0
2CA2:  BRA    2CAE
2CA4:  MOVLB  9
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# factory unlocked\r\n");
.................... #endif
.................... 
.................... 			default:
.................... 				return ILLEGAL_DATA_ADDRESS;
2CA6:  MOVLW  02
2CA8:  MOVWF  01
2CAA:  BRA    2CB4
2CAC:  MOVLB  0
.................... 		}
.................... 	}
.................... 
.................... 	/* must not have triggered an exception */
.................... 	return 0;
2CAE:  MOVLW  00
2CB0:  MOVWF  01
2CB2:  MOVLB  9
2CB4:  MOVLB  0
2CB6:  GOTO   2D82 (RETURN)
.................... }
.................... 
.................... 
.................... /* address to read, put 16-bit results in query.buff[n] and query.buff[n+1] */
.................... exception query_self_read_register(int16 address, int8 n) {
.................... 	int16 result;
.................... 	int8 dev;
.................... 	int8 offset;
.................... 
.................... 
.................... 	if ( address < 1000 ) {
*
2538:  MOVLB  9
253A:  MOVF   x89,W
253C:  SUBLW  03
253E:  BTFSS  FD8.0
2540:  BRA    281E
2542:  BNZ   254C
2544:  MOVF   x88,W
2546:  SUBLW  E7
2548:  BTFSS  FD8.0
254A:  BRA    281E
.................... 		dev=address>>3;
254C:  RRCF   x89,W
254E:  MOVWF  03
2550:  RRCF   x88,W
2552:  MOVWF  02
2554:  RRCF   03,F
2556:  RRCF   02,F
2558:  RRCF   03,F
255A:  RRCF   02,F
255C:  MOVFF  02,98D
.................... 		offset=address&0b111;
2560:  MOVF   x88,W
2562:  ANDLW  07
2564:  MOVWF  x8E
.................... 
.................... 		if ( dev > DEV_MAX_N )
2566:  MOVF   x8D,W
2568:  SUBLW  40
256A:  BC    2572
.................... 			return ILLEGAL_DATA_ADDRESS;
256C:  MOVLW  02
256E:  MOVWF  01
2570:  BRA    2916
.................... 
.................... 		switch ( offset ) {
2572:  MOVF   x8E,W
2574:  ADDLW  F8
2576:  BTFSC  FD8.0
2578:  BRA    281C
257A:  ADDLW  08
257C:  MOVLB  0
257E:  GOTO   291C
.................... 			case 0: result=device[dev].type; break;
2582:  MOVLB  9
2584:  CLRF   x95
2586:  MOVFF  98D,994
258A:  CLRF   x97
258C:  MOVLW  0D
258E:  MOVWF  x96
2590:  MOVLB  0
2592:  CALL   084C
2596:  MOVFF  02,990
259A:  MOVFF  01,98F
259E:  MOVLW  21
25A0:  MOVLB  9
25A2:  ADDWF  01,W
25A4:  MOVWF  FE9
25A6:  MOVLW  00
25A8:  ADDWFC 02,W
25AA:  MOVWF  FEA
25AC:  CLRF   x8C
25AE:  MOVFF  FEF,98B
25B2:  BRA    281C
.................... 			case 1: result=device[dev].typeWorld; break;
25B4:  MOVLB  9
25B6:  CLRF   x95
25B8:  MOVFF  98D,994
25BC:  CLRF   x97
25BE:  MOVLW  0D
25C0:  MOVWF  x96
25C2:  MOVLB  0
25C4:  CALL   084C
25C8:  MOVFF  02,990
25CC:  MOVFF  01,98F
25D0:  MOVLW  01
25D2:  MOVLB  9
25D4:  ADDWF  01,W
25D6:  MOVWF  01
25D8:  MOVLW  00
25DA:  ADDWFC 02,W
25DC:  MOVWF  03
25DE:  MOVF   01,W
25E0:  ADDLW  21
25E2:  MOVWF  FE9
25E4:  MOVLW  00
25E6:  ADDWFC 03,W
25E8:  MOVWF  FEA
25EA:  MOVFF  FEC,98C
25EE:  MOVF   FED,F
25F0:  MOVFF  FEF,98B
25F4:  BRA    281C
.................... 			case 2: result=device[dev].transmitEvery; break;
25F6:  MOVLB  9
25F8:  CLRF   x95
25FA:  MOVFF  98D,994
25FE:  CLRF   x97
2600:  MOVLW  0D
2602:  MOVWF  x96
2604:  MOVLB  0
2606:  CALL   084C
260A:  MOVFF  02,990
260E:  MOVFF  01,98F
2612:  MOVLW  03
2614:  MOVLB  9
2616:  ADDWF  01,W
2618:  MOVWF  01
261A:  MOVLW  00
261C:  ADDWFC 02,W
261E:  MOVWF  03
2620:  MOVF   01,W
2622:  ADDLW  21
2624:  MOVWF  FE9
2626:  MOVLW  00
2628:  ADDWFC 03,W
262A:  MOVWF  FEA
262C:  CLRF   x8C
262E:  MOVFF  FEF,98B
2632:  BRA    281C
.................... 			case 3: result=device[dev].networkAddress; break;
2634:  MOVLB  9
2636:  CLRF   x95
2638:  MOVFF  98D,994
263C:  CLRF   x97
263E:  MOVLW  0D
2640:  MOVWF  x96
2642:  MOVLB  0
2644:  CALL   084C
2648:  MOVFF  02,990
264C:  MOVFF  01,98F
2650:  MOVLW  04
2652:  MOVLB  9
2654:  ADDWF  01,W
2656:  MOVWF  01
2658:  MOVLW  00
265A:  ADDWFC 02,W
265C:  MOVWF  03
265E:  MOVF   01,W
2660:  ADDLW  21
2662:  MOVWF  FE9
2664:  MOVLW  00
2666:  ADDWFC 03,W
2668:  MOVWF  FEA
266A:  CLRF   x8C
266C:  MOVFF  FEF,98B
2670:  BRA    281C
.................... 			case 4: result=make16(make8(device[dev].serialNumber,3),make8(device[dev].serialNumber,2)); break;
2672:  MOVLB  9
2674:  CLRF   x95
2676:  MOVFF  98D,994
267A:  CLRF   x97
267C:  MOVLW  0D
267E:  MOVWF  x96
2680:  MOVLB  0
2682:  CALL   084C
2686:  MOVFF  01,98F
268A:  MOVLW  05
268C:  MOVLB  9
268E:  ADDWF  01,W
2690:  MOVWF  01
2692:  MOVLW  00
2694:  ADDWFC 02,W
2696:  MOVWF  03
2698:  MOVF   01,W
269A:  ADDLW  21
269C:  MOVWF  FE9
269E:  MOVLW  00
26A0:  ADDWFC 03,W
26A2:  MOVWF  FEA
26A4:  MOVFF  FEF,98F
26A8:  MOVFF  FEC,990
26AC:  MOVFF  FEC,991
26B0:  MOVFF  FEC,992
26B4:  MOVFF  992,993
26B8:  CLRF   x95
26BA:  MOVFF  98D,994
26BE:  CLRF   x97
26C0:  MOVLW  0D
26C2:  MOVWF  x96
26C4:  MOVLB  0
26C6:  CALL   084C
26CA:  MOVFF  01,994
26CE:  MOVLW  05
26D0:  MOVLB  9
26D2:  ADDWF  01,W
26D4:  MOVWF  01
26D6:  MOVLW  00
26D8:  ADDWFC 02,W
26DA:  MOVWF  03
26DC:  MOVF   01,W
26DE:  ADDLW  21
26E0:  MOVWF  FE9
26E2:  MOVLW  00
26E4:  ADDWFC 03,W
26E6:  MOVWF  FEA
26E8:  MOVFF  FEF,994
26EC:  MOVFF  FEC,995
26F0:  MOVFF  FEC,996
26F4:  MOVFF  FEC,997
26F8:  MOVFF  996,998
26FC:  MOVFF  992,98C
2700:  MOVFF  996,98B
2704:  BRA    281C
.................... 			case 5: result=make16(make8(device[dev].serialNumber,1),make8(device[dev].serialNumber,0)); break;
2706:  MOVLB  9
2708:  CLRF   x95
270A:  MOVFF  98D,994
270E:  CLRF   x97
2710:  MOVLW  0D
2712:  MOVWF  x96
2714:  MOVLB  0
2716:  CALL   084C
271A:  MOVFF  01,98F
271E:  MOVLW  05
2720:  MOVLB  9
2722:  ADDWF  01,W
2724:  MOVWF  01
2726:  MOVLW  00
2728:  ADDWFC 02,W
272A:  MOVWF  03
272C:  MOVF   01,W
272E:  ADDLW  21
2730:  MOVWF  FE9
2732:  MOVLW  00
2734:  ADDWFC 03,W
2736:  MOVWF  FEA
2738:  MOVFF  FEF,98F
273C:  MOVFF  FEC,990
2740:  MOVFF  FEC,991
2744:  MOVFF  FEC,992
2748:  MOVFF  990,993
274C:  CLRF   x95
274E:  MOVFF  98D,994
2752:  CLRF   x97
2754:  MOVLW  0D
2756:  MOVWF  x96
2758:  MOVLB  0
275A:  CALL   084C
275E:  MOVFF  01,994
2762:  MOVLW  05
2764:  MOVLB  9
2766:  ADDWF  01,W
2768:  MOVWF  01
276A:  MOVLW  00
276C:  ADDWFC 02,W
276E:  MOVWF  03
2770:  MOVF   01,W
2772:  ADDLW  21
2774:  MOVWF  FE9
2776:  MOVLW  00
2778:  ADDWFC 03,W
277A:  MOVWF  FEA
277C:  MOVFF  FEF,994
2780:  MOVFF  FEC,995
2784:  MOVFF  FEC,996
2788:  MOVFF  FEC,997
278C:  MOVFF  994,998
2790:  MOVFF  990,98C
2794:  MOVFF  994,98B
2798:  BRA    281C
.................... 			case 6: result=device[dev].startRegister; break;
279A:  MOVLB  9
279C:  CLRF   x95
279E:  MOVFF  98D,994
27A2:  CLRF   x97
27A4:  MOVLW  0D
27A6:  MOVWF  x96
27A8:  MOVLB  0
27AA:  CALL   084C
27AE:  MOVFF  02,990
27B2:  MOVFF  01,98F
27B6:  MOVLW  09
27B8:  MOVLB  9
27BA:  ADDWF  01,W
27BC:  MOVWF  01
27BE:  MOVLW  00
27C0:  ADDWFC 02,W
27C2:  MOVWF  03
27C4:  MOVF   01,W
27C6:  ADDLW  21
27C8:  MOVWF  FE9
27CA:  MOVLW  00
27CC:  ADDWFC 03,W
27CE:  MOVWF  FEA
27D0:  MOVFF  FEC,98C
27D4:  MOVF   FED,F
27D6:  MOVFF  FEF,98B
27DA:  BRA    281C
.................... 			case 7: result=device[dev].nRegisters; break;
27DC:  MOVLB  9
27DE:  CLRF   x95
27E0:  MOVFF  98D,994
27E4:  CLRF   x97
27E6:  MOVLW  0D
27E8:  MOVWF  x96
27EA:  MOVLB  0
27EC:  CALL   084C
27F0:  MOVFF  02,990
27F4:  MOVFF  01,98F
27F8:  MOVLW  0B
27FA:  MOVLB  9
27FC:  ADDWF  01,W
27FE:  MOVWF  01
2800:  MOVLW  00
2802:  ADDWFC 02,W
2804:  MOVWF  03
2806:  MOVF   01,W
2808:  ADDLW  21
280A:  MOVWF  FE9
280C:  MOVLW  00
280E:  ADDWFC 03,W
2810:  MOVWF  FEA
2812:  CLRF   x8C
2814:  MOVFF  FEF,98B
2818:  BRA    281C
281A:  MOVLB  9
.................... 		}
.................... 	} else {
281C:  BRA    28E4
.................... 		switch ( address ) {
281E:  MOVF   x88,W
2820:  MOVWF  00
2822:  MOVF   x89,W
2824:  MOVWF  03
2826:  MOVLW  03
2828:  SUBWF  03,W
282A:  BNZ   2836
282C:  MOVLW  E8
282E:  SUBWF  00,W
2830:  MOVLB  0
2832:  BZ    2898
2834:  MOVLB  9
2836:  MOVLW  03
2838:  SUBWF  03,W
283A:  BNZ   2846
283C:  MOVLW  E9
283E:  SUBWF  00,W
2840:  MOVLB  0
2842:  BZ    28A2
2844:  MOVLB  9
2846:  MOVLW  03
2848:  SUBWF  03,W
284A:  BNZ   2856
284C:  MOVLW  EA
284E:  SUBWF  00,W
2850:  MOVLB  0
2852:  BZ    28AE
2854:  MOVLB  9
2856:  MOVLW  03
2858:  SUBWF  03,W
285A:  BNZ   2866
285C:  MOVLW  EB
285E:  SUBWF  00,W
2860:  MOVLB  0
2862:  BZ    28B8
2864:  MOVLB  9
2866:  MOVLW  03
2868:  SUBWF  03,W
286A:  BNZ   2876
286C:  MOVLW  EC
286E:  SUBWF  00,W
2870:  MOVLB  0
2872:  BZ    28C0
2874:  MOVLB  9
2876:  MOVLW  03
2878:  SUBWF  03,W
287A:  BNZ   2886
287C:  MOVLW  ED
287E:  SUBWF  00,W
2880:  MOVLB  0
2882:  BZ    28CA
2884:  MOVLB  9
2886:  MOVLW  04
2888:  SUBWF  03,W
288A:  BNZ   2896
288C:  MOVLW  4C
288E:  SUBWF  00,W
2890:  MOVLB  0
2892:  BZ    28D2
2894:  MOVLB  9
2896:  BRA    28DE
.................... 			case 1000: result=config.serial_prefix; break;
2898:  MOVLB  9
289A:  CLRF   x8C
289C:  MOVFF  583,98B
28A0:  BRA    28E4
.................... 			case 1001: result=config.serial_number; break;
28A2:  MOVFF  585,98C
28A6:  MOVFF  584,98B
28AA:  MOVLB  9
28AC:  BRA    28E4
.................... 			case 1002: result='R'; break;
28AE:  MOVLB  9
28B0:  CLRF   x8C
28B2:  MOVLW  52
28B4:  MOVWF  x8B
28B6:  BRA    28E4
.................... 			case 1003: result=0; break;
28B8:  MOVLB  9
28BA:  CLRF   x8C
28BC:  CLRF   x8B
28BE:  BRA    28E4
.................... 			case 1004: result='4'; break;
28C0:  MOVLB  9
28C2:  CLRF   x8C
28C4:  MOVLW  34
28C6:  MOVWF  x8B
28C8:  BRA    28E4
.................... 			case 1005: result=0; break;
28CA:  MOVLB  9
28CC:  CLRF   x8C
28CE:  CLRF   x8B
28D0:  BRA    28E4
.................... 	
.................... 			case 1100: result=config.live_interval; break;
28D2:  MOVFF  587,98C
28D6:  MOVFF  586,98B
28DA:  MOVLB  9
28DC:  BRA    28E4
.................... 	
.................... 			default: return ILLEGAL_DATA_ADDRESS;
28DE:  MOVLW  02
28E0:  MOVWF  01
28E2:  BRA    2916
.................... 		}
.................... 	}
.................... 
.................... //	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u) result=%lu\r\n",address,n,result);
.................... 
.................... 	query.buff[n]  =make8(result,1);
28E4:  MOVLW  6C
28E6:  ADDWF  x8A,W
28E8:  MOVWF  FE9
28EA:  MOVLW  04
28EC:  MOVWF  FEA
28EE:  BTFSC  FD8.0
28F0:  INCF   FEA,F
28F2:  MOVFF  98C,FEF
.................... 	query.buff[n+1]=make8(result,0);
28F6:  MOVLW  01
28F8:  ADDWF  x8A,W
28FA:  ADDLW  6C
28FC:  MOVWF  FE9
28FE:  MOVLW  04
2900:  MOVWF  FEA
2902:  BTFSC  FD8.0
2904:  INCF   FEA,F
2906:  MOVFF  98B,FEF
.................... 	query.resultLength += 2;
290A:  MOVLW  02
290C:  MOVLB  5
290E:  ADDWF  x82,F
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u, result=%lu, query.resultLength=%u)\r\n",
.................... 		address,
.................... 		n,
.................... 		result,
.................... 		query.resultLength
.................... 	);
.................... #endif
.................... 
.................... 
.................... 	return 0;
2910:  MOVLW  00
2912:  MOVWF  01
2914:  MOVLB  9
2916:  MOVLB  0
2918:  GOTO   2976 (RETURN)
.................... }
.................... 
.................... exception query_self_read_registers(int16 address, int8 nRegisters) {
*
2946:  MOVLB  9
2948:  CLRF   x84
.................... 	int8 i;
.................... 	exception e=0;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers (address=%lu, nRegisters=%u)\r\n",address,nRegisters);
.................... #endif
.................... 
.................... 	for ( i=0 ; i<nRegisters && 0==e ; i++ ) {
294A:  CLRF   x83
294C:  MOVF   x82,W
294E:  SUBWF  x83,W
2950:  BC    2980
2952:  MOVF   x84,F
2954:  BNZ   2980
.................... 		e=query_self_read_register(address+i,i*2);
2956:  MOVF   x83,W
2958:  ADDWF  x80,W
295A:  MOVWF  x85
295C:  MOVLW  00
295E:  ADDWFC x81,W
2960:  MOVWF  x86
2962:  BCF    FD8.0
2964:  RLCF   x83,W
2966:  MOVWF  x87
2968:  MOVFF  986,989
296C:  MOVFF  985,988
2970:  MOVWF  x8A
2972:  MOVLB  0
2974:  BRA    2538
2976:  MOVFF  01,984
.................... 	}
.................... 
.................... 
.................... #if DEBUG_ASCII
297A:  MOVLB  9
297C:  INCF   x83,F
297E:  BRA    294C
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers returning e=%u\r\n",e);
.................... #endif
.................... 
.................... 
.................... 	return e;
2980:  MOVFF  984,01
2984:  MOVLB  0
2986:  GOTO   2D38 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void query_self(void) {
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self( query.function=%lu, query.start_address=%lu, query.n_words=%u)\r\n",
.................... 		query.function,
.................... 		query.start_address,
.................... 		query.n_words
.................... 	);
.................... #endif
.................... 
.................... 	query.resultLength=0;
*
2CE4:  MOVLB  5
2CE6:  CLRF   x82
.................... 
.................... 	switch ( query.function ) {
2CE8:  MOVF   x79,W
2CEA:  MOVWF  00
2CEC:  MOVF   x7A,W
2CEE:  MOVWF  03
2CF0:  MOVF   03,W
2CF2:  BNZ   2CFE
2CF4:  MOVLW  03
2CF6:  SUBWF  00,W
2CF8:  MOVLB  0
2CFA:  BZ    2D2A
2CFC:  MOVLB  5
2CFE:  MOVF   03,W
2D00:  BNZ   2D0C
2D02:  MOVLW  04
2D04:  SUBWF  00,W
2D06:  MOVLB  0
2D08:  BZ    2D2A
2D0A:  MOVLB  5
2D0C:  MOVF   03,W
2D0E:  BNZ   2D1A
2D10:  MOVLW  06
2D12:  SUBWF  00,W
2D14:  MOVLB  0
2D16:  BZ    2D3E
2D18:  MOVLB  5
2D1A:  MOVF   03,W
2D1C:  BNZ   2D28
2D1E:  MOVLW  07
2D20:  SUBWF  00,W
2D22:  MOVLB  0
2D24:  BZ    2D88
2D26:  MOVLB  5
2D28:  BRA    2D8C
.................... 		case DEV_TYPE_MODBUS_3:
.................... 		case DEV_TYPE_MODBUS_4:
.................... 			/* read registers */
.................... 			query.resultException=query_self_read_registers(query.start_address, query.n_words);
2D2A:  MOVFF  57C,981
2D2E:  MOVFF  57B,980
2D32:  MOVFF  57D,982
2D36:  BRA    2946
2D38:  MOVFF  01,581
.................... 			break;
2D3C:  BRA    2D92
.................... 		case DEV_TYPE_MODBUS_6:
.................... 			/* write single register */
.................... 			query.resultException=query_self_write_register(query.start_address, 
.................... 				make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
2D3E:  MOVLW  6C
2D40:  MOVLB  5
2D42:  ADDWF  x7E,W
2D44:  MOVWF  FE9
2D46:  MOVLW  04
2D48:  MOVWF  FEA
2D4A:  BTFSC  FD8.0
2D4C:  INCF   FEA,F
2D4E:  MOVFF  FEF,980
2D52:  MOVLW  01
2D54:  ADDWF  x7E,W
2D56:  ADDLW  6C
2D58:  MOVWF  FE9
2D5A:  MOVLW  04
2D5C:  MOVWF  FEA
2D5E:  BTFSC  FD8.0
2D60:  INCF   FEA,F
2D62:  MOVFF  FEF,981
2D66:  MOVFF  980,983
2D6A:  MOVFF  981,982
2D6E:  MOVFF  57C,985
2D72:  MOVFF  57B,984
2D76:  MOVFF  980,987
2D7A:  MOVFF  981,986
2D7E:  MOVLB  0
2D80:  BRA    298A
2D82:  MOVFF  01,581
.................... 			break;
2D86:  BRA    2D92
.................... 		case DEV_TYPE_MODBUS_16:
.................... 			/* write multiple registers */
.................... 			break;
2D88:  BRA    2D92
2D8A:  MOVLB  5
.................... 		default:
.................... 			query.resultException=ILLEGAL_FUNCTION;
2D8C:  MOVLW  01
2D8E:  MOVWF  x81
.................... 			query.resultLength=0;
2D90:  CLRF   x82
2D92:  MOVLB  0
.................... 	}
2D94:  GOTO   363E (RETURN)
.................... }
.................... 
.................... /*
.................... Remote query (from WorldData to us) syntax
.................... '#'                 0  STX
.................... RECV'R ID PREFIX    1  First character (A-Z) for gateway serial number
.................... RECV'R ID MSB       2  gateway serial number
.................... RECV'R ID LSB       3  
.................... PACKET LENGTH       4  
.................... PACKET TYPE         5  type of packet we are receiving (19)
.................... QUERY ID MSB        6  32 bit query id that we must answer with
.................... QUERY ID            7
.................... QUERY ID            8
.................... QUERY ID LSB        9
.................... QUERY DEV SN MSB    10 32 bit serial number of device to query
.................... QUERY DEV SN        11
.................... QUERY DEV SN        12
.................... QUERY DEV SN LSB    13
.................... Q NETWORK ADDR MSB  14 Network address of device to query, if SN not specified
.................... Q NETWORK ADDR LSB  15
.................... QUERY FUNCTION MSB  16 type of query to perform
.................... QUERY FUNCTION LSB  17
.................... QUERY ADDRESS MSB   18 start address for query
.................... QUERY ADDRESS LSB   19
.................... QUERY N WORDS       20 number of 16-bit words in query data
.................... QUERY DATA[0] MSB   [] first word of query data
.................... QUERY DATA[0] LSB   [+1]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... 
.................... Parse first four bytes for match to our serial number. If matched, receive rest 
.................... of packet and do checksum.
.................... 
.................... Send query to network one of two ways:
.................... if ( 0 != query_dev_sn ) then scan device table to determine network id
.................... else use network id
.................... 
.................... if ( 0==network id || our_serial_number==query_dev_sn ) then use local registers
.................... else perform network query
.................... */
.................... 
.................... void query_reset(void) {
.................... 	query.buff_pos=0;
*
05B8:  MOVLB  5
05BA:  CLRF   x6C
.................... 	
.................... 	/* !buff_ready causes serial receive interrupt to throw out data ... so clear last */
.................... 	query.buff_ready=0;
05BC:  CLRF   x6D
05BE:  MOVLB  0
05C0:  RETURN 0
.................... }
.................... 
.................... /* 
.................... response to remote query (from us to WorldData)
.................... '#'                 0  STX
.................... SERIAL PREFIX       1  First character (A-Z) for serial number
.................... SERIAL MSB          2  high byte of sending station ID
.................... SERIAL LSB          3  low byte of sending station ID
.................... PACKET LENGTH       4  always 0xff
.................... PACKET TYPE         5  type of packet we are sending (20)
.................... PACKET LENGTH MSB   6  number of byte for packet including STX through CRC
.................... PACKET LENGTH LSB   7
.................... QUERY ID MSB        8  32 bit query id that we are answering
.................... QUERY ID            9
.................... QUERY ID            10
.................... QUERY ID LSB        11
.................... QUERY EXCEPTION     12 exception encountered in performing query
.................... QUERY DATA[0] MSB [13] first word of query data
.................... QUERY DATA[0] LSB [14]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... */
.................... void query_response(void) {
.................... 	int8 buff[13];
.................... 	int16 l;
.................... 	int8 i;
.................... 
.................... 	buff[0]='#';
*
3428:  MOVLW  23
342A:  MOVLB  9
342C:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
342E:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
3432:  MOVFF  585,982
3436:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0);
3438:  MOVFF  584,983
343C:  MOVLB  9
.................... 	buff[4]=0xff;
343E:  SETF   x84
.................... 	buff[5]=20;
3440:  MOVLW  14
3442:  MOVWF  x85
.................... 	/* packet length */
.................... 	l=sizeof(buff)+query.resultLength+2;
3444:  MOVLW  0D
3446:  MOVLB  5
3448:  ADDWF  x82,W
344A:  ADDLW  02
344C:  MOVLB  9
344E:  MOVWF  x8D
3450:  CLRF   x8E
3452:  BTFSC  FD8.0
3454:  INCF   x8E,F
.................... 	buff[6]=make8(l,1);
3456:  MOVFF  98E,986
.................... 	buff[7]=make8(l,0);
345A:  MOVFF  98D,987
.................... 
.................... 	buff[8]=make8(query.query_id,3);
345E:  MOVFF  572,988
3462:  MOVLB  9
.................... 	buff[9]=make8(query.query_id,2);
3464:  MOVFF  571,989
3468:  MOVLB  9
.................... 	buff[10]=make8(query.query_id,1);
346A:  MOVFF  570,98A
346E:  MOVLB  9
.................... 	buff[11]=make8(query.query_id,0);
3470:  MOVFF  56F,98B
3474:  MOVLB  9
.................... 	buff[12]=query.resultException;
3476:  MOVFF  581,98C
.................... 
.................... 	/* compute CRC on header (skip STX) and result data */
.................... 	l=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
347A:  SETF   x94
347C:  SETF   x93
347E:  MOVLW  09
3480:  MOVWF  x96
3482:  MOVLW  81
3484:  MOVWF  x95
3486:  MOVLW  0C
3488:  MOVWF  x97
348A:  MOVLB  0
348C:  CALL   1980
3490:  MOVFF  02,98E
3494:  MOVFF  01,98D
.................... 	l=crc_chk_pass(l,query.buff,query.resultLength);
3498:  MOVFF  98E,994
349C:  MOVFF  98D,993
34A0:  MOVLW  04
34A2:  MOVLB  9
34A4:  MOVWF  x96
34A6:  MOVLW  6C
34A8:  MOVWF  x95
34AA:  MOVFF  582,997
34AE:  MOVLB  0
34B0:  CALL   1980
34B4:  MOVFF  02,98E
34B8:  MOVFF  01,98D
.................... 
.................... 	output_high(CTRL_0);
34BC:  BCF    F92.0
34BE:  BSF    F89.0
.................... 	/* send buff, result, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
34C0:  MOVLB  9
34C2:  CLRF   x8F
34C4:  MOVF   x8F,W
34C6:  SUBLW  0C
34C8:  BNC   34EA
.................... 		fputc(buff[i],STREAM_WORLD);
34CA:  CLRF   03
34CC:  MOVF   x8F,W
34CE:  ADDLW  80
34D0:  MOVWF  FE9
34D2:  MOVLW  09
34D4:  ADDWFC 03,W
34D6:  MOVWF  FEA
34D8:  MOVFF  FEF,990
34DC:  MOVF   x90,W
34DE:  MOVLB  0
34E0:  CALL   19DE
34E4:  MOVLB  9
34E6:  INCF   x8F,F
34E8:  BRA    34C4
.................... 	}	
.................... 	for ( i=0 ; i<query.resultLength ; i++ ) {
34EA:  CLRF   x8F
34EC:  MOVLB  5
34EE:  MOVF   x82,W
34F0:  MOVLB  9
34F2:  SUBWF  x8F,W
34F4:  BC    3516
.................... 		fputc(query.buff[i],STREAM_WORLD);
34F6:  MOVLW  6C
34F8:  ADDWF  x8F,W
34FA:  MOVWF  FE9
34FC:  MOVLW  04
34FE:  MOVWF  FEA
3500:  BTFSC  FD8.0
3502:  INCF   FEA,F
3504:  MOVFF  FEF,990
3508:  MOVF   x90,W
350A:  MOVLB  0
350C:  CALL   19DE
3510:  MOVLB  9
3512:  INCF   x8F,F
3514:  BRA    34EC
.................... 	}
.................... 	fputc(make8(l,1),STREAM_WORLD);
3516:  MOVFF  98E,990
351A:  MOVF   x90,W
351C:  MOVLB  0
351E:  CALL   19DE
.................... 	fputc(make8(l,0),STREAM_WORLD);
3522:  MOVFF  98D,990
3526:  MOVLB  9
3528:  MOVF   x90,W
352A:  MOVLB  0
352C:  CALL   19DE
.................... 
.................... 
.................... 	delay_ms(10);
3530:  MOVLW  0A
3532:  MOVLB  9
3534:  MOVWF  x90
3536:  MOVLB  0
3538:  CALL   068A
.................... 	output_low(CTRL_0);
353C:  BCF    F92.0
353E:  BCF    F89.0
.................... 
.................... #if 0
3540:  GOTO   3648 (RETURN)
.................... 	fprintf(STREAM_WORLD,"# query result (query.resultLength=%u query.resultException=%u):\r\n",query.resultLength,query.resultException);
.................... 	/* query.resultLength is in bytes  .... result is in 16-bit words */
.................... 	for ( i=0 ; i<query.resultLength ; i+=2 ) {
.................... 		fprintf(STREAM_WORLD,"# query.buff[%u]=%lu (0x%04lX)\r\n",
.................... 			i/2,
.................... 			make16(query.buff[i],query.buff[i+1]),
.................... 			make16(query.buff[i],query.buff[i+1])
.................... 		);
.................... 		query.buff[i]=0xff;
.................... 		query.buff[i+1]=0xff;
.................... 	}
.................... #endif
.................... }
.................... 
.................... /* we received a query addressed to us */
.................... void query_process(void) {
.................... 	int32 our_serial;
.................... //	int8 i;
.................... 	int16 lCRC;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# in query_process()\r\n");
.................... #endif
.................... 
.................... 	query.packet_length=query.buff[4];
3544:  MOVFF  470,56E
.................... 	query.crc=make16(query.buff[query.packet_length-2],query.buff[query.packet_length-1]);	
3548:  MOVLW  02
354A:  MOVLB  5
354C:  SUBWF  x6E,W
354E:  ADDLW  6C
3550:  MOVWF  FE9
3552:  MOVLW  04
3554:  MOVWF  FEA
3556:  BTFSC  FD8.0
3558:  INCF   FEA,F
355A:  MOVFF  FEF,580
355E:  MOVLW  01
3560:  SUBWF  x6E,W
3562:  ADDLW  6C
3564:  MOVWF  FE9
3566:  MOVLW  04
3568:  MOVWF  FEA
356A:  BTFSC  FD8.0
356C:  INCF   FEA,F
356E:  MOVFF  FEF,57F
.................... 	lCRC = crc_chk_pass(0xFFFF,query.buff+1,query.packet_length-3);
3572:  MOVLW  03
3574:  SUBWF  x6E,W
3576:  MOVLB  9
3578:  MOVWF  x80
357A:  SETF   x94
357C:  SETF   x93
357E:  MOVLW  04
3580:  MOVWF  x96
3582:  MOVLW  6D
3584:  MOVWF  x95
3586:  MOVFF  980,997
358A:  MOVLB  0
358C:  CALL   1980
3590:  MOVFF  02,97F
3594:  MOVFF  01,97E
.................... 
.................... 	if ( lCRC != query.crc ) {
3598:  MOVLB  5
359A:  MOVF   x7F,W
359C:  MOVLB  9
359E:  SUBWF  x7E,W
35A0:  BNZ   35AC
35A2:  MOVLB  5
35A4:  MOVF   x80,W
35A6:  MOVLB  9
35A8:  SUBWF  x7F,W
35AA:  BZ    35AE
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# CRC 0x%04lX != 0x%04lX (LOCAL)\r\n",query.crc,lCRC);
.................... #endif
.................... 		return;
35AC:  BRA    364A
.................... 	}
.................... 
.................... 
.................... 	if ( 19 != query.buff[5] ) {
35AE:  MOVLB  4
35B0:  MOVF   x71,W
35B2:  SUBLW  13
35B4:  BZ    35BC
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# not query type 19 ... don't know how to handle!\r\n");
.................... #endif
.................... 		return;
35B6:  MOVLB  9
35B8:  BRA    364A
35BA:  MOVLB  4
.................... 	}
.................... 
.................... 	
.................... 	query.query_id=make32(query.buff[6],query.buff[7],query.buff[8],query.buff[9]);
35BC:  MOVFF  472,572
35C0:  MOVFF  473,571
35C4:  MOVFF  474,570
35C8:  MOVFF  475,56F
.................... 	query.device_serial=make32(query.buff[10],query.buff[11],query.buff[12],query.buff[13]);
35CC:  MOVFF  476,576
35D0:  MOVFF  477,575
35D4:  MOVFF  478,574
35D8:  MOVFF  479,573
.................... 	query.network_address=make16(query.buff[14],query.buff[15]);
35DC:  MOVFF  47A,578
35E0:  MOVFF  47B,577
.................... 	query.function=make16(query.buff[16],query.buff[17]);
35E4:  MOVFF  47C,57A
35E8:  MOVFF  47D,579
.................... 	query.start_address=make16(query.buff[18],query.buff[19]);
35EC:  MOVFF  47E,57C
35F0:  MOVFF  47F,57B
.................... 	query.n_words=query.buff[20];
35F4:  MOVFF  480,57D
.................... 	query.data_start_offset=21;
35F8:  MOVLW  15
35FA:  MOVLB  5
35FC:  MOVWF  x7E
.................... 	
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# length=%u (query.buff_pos=%u)\r\n",query.packet_length,query.buff_pos);
.................... 	fprintf(STREAM_WORLD,"# query_id=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.query_id,3),
.................... 		make8(query.query_id,2),
.................... 		make8(query.query_id,1),
.................... 		make8(query.query_id,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# device serial=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.device_serial,3),
.................... 		make8(query.device_serial,2),
.................... 		make8(query.device_serial,1),
.................... 		make8(query.device_serial,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# network address=%lu\r\n",query.network_address);
.................... 	fprintf(STREAM_WORLD,"# function=%lu\r\n",query.function);
.................... 	fprintf(STREAM_WORLD,"# start address=%lu\r\n",query.start_address);
.................... 	fprintf(STREAM_WORLD,"# n_words=%u\r\n",query.n_words);
.................... 
.................... 	/* n words can be the number of query words, in which case we won't have any data besides the CRC */
.................... 	for ( i=0 ; i<query.n_words && i<query.packet_length-2 ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# word[%u]=%lu\r\n",i,make16(query.buff[21+i*2],query.buff[22+i*2]));
.................... 	}
.................... 
.................... 	fprintf(STREAM_WORLD,"# rCRC=%lu\r\n",query.crc);
.................... #endif
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# dump whole packet:\r\n");
.................... 	for ( i=0 ; i<query.packet_length ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# buff[%u]=0x%02X",i,query.buff[i]);
.................... 		if ( i==query.data_start_offset )
.................... 			fprintf(STREAM_WORLD," (start)");
.................... 		fprintf(STREAM_WORLD,"\r\n");
.................... 	}
.................... #endif
.................... 
.................... 	query.resultLength=0;
35FE:  CLRF   x82
.................... 	/* check to see who handles this query */
.................... 	our_serial=make32(0,config.serial_prefix,config.serial_number);
3600:  MOVLB  9
3602:  CLRF   x7D
3604:  MOVFF  583,97C
3608:  MOVFF  584,97A
360C:  MOVFF  585,97B
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"#   our serial=%c%lu\r\n",config.serial_prefix,config.serial_number);
.................... 	fprintf(STREAM_WORLD,"# query serial=%c%lu\r\n",make8(query.device_serial,2),(int16) query.device_serial);
.................... #endif
.................... 
.................... 	if ( our_serial == query.device_serial ) {
3610:  MOVLB  5
3612:  MOVF   x73,W
3614:  MOVLB  9
3616:  SUBWF  x7A,W
3618:  BNZ   3642
361A:  MOVLB  5
361C:  MOVF   x74,W
361E:  MOVLB  9
3620:  SUBWF  x7B,W
3622:  BNZ   3642
3624:  MOVLB  5
3626:  MOVF   x75,W
3628:  MOVLB  9
362A:  SUBWF  x7C,W
362C:  BNZ   3642
362E:  MOVLB  5
3630:  MOVF   x76,W
3632:  MOVLB  9
3634:  SUBWF  x7D,W
3636:  BNZ   3642
.................... 		query_self();
3638:  MOVLB  0
363A:  GOTO   2CE4
.................... 	} else {
363E:  BRA    3646
3640:  MOVLB  9
.................... 		query_other();
3642:  MOVLB  0
3644:  BRA    3104
.................... 		
.................... 	}	
.................... 
.................... 	query_response();
3646:  BRA    3428
3648:  MOVLB  9
364A:  MOVLB  0
364C:  GOTO   3830 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void deviceQuery(void) {
.................... 	static int16 measurementNumber=0;
.................... 	static int8  nCycles[DEV_MAX_N];
.................... 	int8 n;
.................... 	int16 l;
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... #endif
.................... 
.................... 	/* check if next cycle will be an SBD transmission. */
.................... 	if ( 1 == timers.sbd_cycle ) {
*
1D6C:  MOVLB  3
1D6E:  DECFSZ x65,W
1D70:  BRA    1D7E
1D72:  MOVF   x66,F
1D74:  BNZ   1D7E
.................... 		/* next cycle will be an Iridium transmit cycle, so turn on modem and clear outgoing buffer */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() next cycle will be SBD transmit cycle.\r\n");
.................... #endif
.................... //		iridium_on();
.................... 		iridium_mo_clear();
1D76:  MOVLB  0
1D78:  CALL   13A6
1D7C:  MOVLB  3
.................... 	}
.................... 
.................... 	/* check if we are going to be doing a SBD transmision */
.................... 	if ( 0 == timers.sbd_cycle ) {
1D7E:  MOVF   x65,F
1D80:  BNZ   1DD2
1D82:  MOVF   x66,F
1D84:  BNZ   1DD2
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() this cycle is an SBD transmit cycle.\r\n");
.................... #endif
.................... 		/* turn on modem in case it isn't already on */
.................... //		iridium_on();
.................... 		/* clear MO buffer */
.................... 		iridium_mo_clear();
1D86:  MOVLB  0
1D88:  CALL   13A6
.................... 
.................... 		/* build header */
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,1);
1D8C:  MOVLB  7
1D8E:  MOVFF  7DB,03
1D92:  MOVF   xDA,W
1D94:  INCF   xDA,F
1D96:  BTFSC  FD8.2
1D98:  INCF   xDB,F
1D9A:  MOVLB  9
1D9C:  MOVWF  x7D
1D9E:  MOVLW  CA
1DA0:  ADDWF  x7D,W
1DA2:  MOVWF  FE9
1DA4:  MOVLW  06
1DA6:  ADDWFC 03,W
1DA8:  MOVWF  FEA
1DAA:  MOVFF  938,FEF
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,0);
1DAE:  MOVLB  7
1DB0:  MOVFF  7DB,03
1DB4:  MOVF   xDA,W
1DB6:  INCF   xDA,F
1DB8:  BTFSC  FD8.2
1DBA:  INCF   xDB,F
1DBC:  MOVLB  9
1DBE:  MOVWF  x7D
1DC0:  MOVLW  CA
1DC2:  ADDWF  x7D,W
1DC4:  MOVWF  FE9
1DC6:  MOVLW  06
1DC8:  ADDWFC 03,W
1DCA:  MOVWF  FEA
1DCC:  MOVFF  937,FEF
1DD0:  MOVLB  3
.................... 	}
.................... 
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() querying all enabled devices:\r\n");
.................... #endif
.................... 
.................... 	for ( n=0 ; n<DEV_MAX_N ; n++ ) {
1DD2:  MOVLB  9
1DD4:  CLRF   x7A
1DD6:  MOVF   x7A,W
1DD8:  SUBLW  3F
1DDA:  BTFSS  FD8.0
1DDC:  BRA    24E0
.................... 		restart_wdt();
1DDE:  CLRWDT
.................... 		timers.led_on_green=100;
1DE0:  MOVLW  64
1DE2:  MOVLB  3
1DE4:  MOVWF  x64
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[n].type ) 
1DE6:  MOVLB  9
1DE8:  CLRF   x95
1DEA:  MOVFF  97A,994
1DEE:  CLRF   x97
1DF0:  MOVLW  0D
1DF2:  MOVWF  x96
1DF4:  MOVLB  0
1DF6:  CALL   084C
1DFA:  MOVFF  02,97E
1DFE:  MOVFF  01,97D
1E02:  MOVLW  21
1E04:  MOVLB  9
1E06:  ADDWF  01,W
1E08:  MOVWF  FE9
1E0A:  MOVLW  00
1E0C:  ADDWFC 02,W
1E0E:  MOVWF  FEA
1E10:  MOVF   FEF,W
1E12:  BNZ   1E16
.................... 			continue;
1E14:  BRA    24D8
.................... 
.................... 		nCycles[n]++;
1E16:  CLRF   03
1E18:  MOVF   x7A,W
1E1A:  ADDLW  39
1E1C:  MOVWF  FE9
1E1E:  MOVLW  09
1E20:  ADDWFC 03,W
1E22:  MOVWF  FEA
1E24:  INCF   FEF,F
.................... 		if ( nCycles[n] < device[n].transmitEvery ) {
1E26:  CLRF   03
1E28:  MOVF   x7A,W
1E2A:  ADDLW  39
1E2C:  MOVWF  FE9
1E2E:  MOVLW  09
1E30:  ADDWFC 03,W
1E32:  MOVWF  FEA
1E34:  MOVFF  FEF,97D
1E38:  CLRF   x95
1E3A:  MOVFF  97A,994
1E3E:  CLRF   x97
1E40:  MOVLW  0D
1E42:  MOVWF  x96
1E44:  MOVLB  0
1E46:  CALL   084C
1E4A:  MOVFF  02,97F
1E4E:  MOVFF  01,97E
1E52:  MOVLW  03
1E54:  MOVLB  9
1E56:  ADDWF  01,W
1E58:  MOVWF  01
1E5A:  MOVLW  00
1E5C:  ADDWFC 02,W
1E5E:  MOVWF  03
1E60:  MOVF   01,W
1E62:  ADDLW  21
1E64:  MOVWF  FE9
1E66:  MOVLW  00
1E68:  ADDWFC 03,W
1E6A:  MOVWF  FEA
1E6C:  MOVF   FEF,W
1E6E:  SUBWF  x7D,W
1E70:  BC    1E76
.................... 			continue;
1E72:  BRA    24D8
.................... 		} else {
1E74:  BRA    1E86
.................... 			nCycles[n]=0;
1E76:  CLRF   03
1E78:  MOVF   x7A,W
1E7A:  ADDLW  39
1E7C:  MOVWF  FE9
1E7E:  MOVLW  09
1E80:  ADDWFC 03,W
1E82:  MOVWF  FEA
1E84:  CLRF   FEF
.................... 		}
.................... 
.................... 
.................... 
.................... 		qbuff.deviceNumber=n;
1E86:  MOVFF  97A,469
.................... 		qbuff.measurementNumber=measurementNumber;
1E8A:  MOVFF  938,46B
1E8E:  MOVFF  937,46A
.................... 
.................... 
.................... 		if ( device[n].type <= DEV_TYPE_MODBUS_MAX ) {
1E92:  CLRF   x95
1E94:  MOVFF  97A,994
1E98:  CLRF   x97
1E9A:  MOVLW  0D
1E9C:  MOVWF  x96
1E9E:  MOVLB  0
1EA0:  CALL   084C
1EA4:  MOVFF  02,97E
1EA8:  MOVFF  01,97D
1EAC:  MOVLW  21
1EAE:  MOVLB  9
1EB0:  ADDWF  01,W
1EB2:  MOVWF  FE9
1EB4:  MOVLW  00
1EB6:  ADDWFC 02,W
1EB8:  MOVWF  FEA
1EBA:  MOVF   FEF,W
1EBC:  SUBLW  07
1EBE:  BTFSS  FD8.0
1EC0:  BRA    22D2
.................... 			/* modbus device type */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() MODBUS device\r\n");
.................... #endif
.................... 			/* set serial port speed */
.................... 			if ( DEV_SERIAL_19200 == device[n].serialSpeed ) {
1EC2:  CLRF   x95
1EC4:  MOVFF  97A,994
1EC8:  CLRF   x97
1ECA:  MOVLW  0D
1ECC:  MOVWF  x96
1ECE:  MOVLB  0
1ED0:  CALL   084C
1ED4:  MOVFF  02,97E
1ED8:  MOVFF  01,97D
1EDC:  MOVLW  0C
1EDE:  MOVLB  9
1EE0:  ADDWF  01,W
1EE2:  MOVWF  01
1EE4:  MOVLW  00
1EE6:  ADDWFC 02,W
1EE8:  MOVWF  03
1EEA:  MOVF   01,W
1EEC:  ADDLW  21
1EEE:  MOVWF  FE9
1EF0:  MOVLW  00
1EF2:  ADDWFC 03,W
1EF4:  MOVWF  FEA
1EF6:  MOVF   FEF,W
1EF8:  SUBLW  01
1EFA:  BNZ   1F0C
.................... 				set_uart_speed(19200,MODBUS_SERIAL);
1EFC:  BCF    FA7.3
1EFE:  MOVLW  19
1F00:  MOVWF  FAF
1F02:  MOVLW  A6
1F04:  MOVWF  FAC
1F06:  MOVLW  90
1F08:  MOVWF  FAB
.................... 			} else {
1F0A:  BRA    1F1A
.................... 				set_uart_speed(9600,MODBUS_SERIAL);
1F0C:  BCF    FA7.3
1F0E:  MOVLW  0C
1F10:  MOVWF  FAF
1F12:  MOVLW  A2
1F14:  MOVWF  FAC
1F16:  MOVLW  90
1F18:  MOVWF  FAB
.................... 			}
.................... 
.................... 			if ( DEV_TYPE_MODBUS_3 == device[n].type || DEV_TYPE_MODBUS_4 == device[n].type ) {
1F1A:  CLRF   x95
1F1C:  MOVFF  97A,994
1F20:  CLRF   x97
1F22:  MOVLW  0D
1F24:  MOVWF  x96
1F26:  MOVLB  0
1F28:  CALL   084C
1F2C:  MOVFF  02,97E
1F30:  MOVFF  01,97D
1F34:  MOVLW  21
1F36:  MOVLB  9
1F38:  ADDWF  01,W
1F3A:  MOVWF  FE9
1F3C:  MOVLW  00
1F3E:  ADDWFC 02,W
1F40:  MOVWF  FEA
1F42:  MOVF   FEF,W
1F44:  SUBLW  03
1F46:  BZ    1F78
1F48:  CLRF   x95
1F4A:  MOVFF  97A,994
1F4E:  CLRF   x97
1F50:  MOVLW  0D
1F52:  MOVWF  x96
1F54:  MOVLB  0
1F56:  CALL   084C
1F5A:  MOVFF  02,980
1F5E:  MOVFF  01,97F
1F62:  MOVLW  21
1F64:  MOVLB  9
1F66:  ADDWF  01,W
1F68:  MOVWF  FE9
1F6A:  MOVLW  00
1F6C:  ADDWFC 02,W
1F6E:  MOVWF  FEA
1F70:  MOVF   FEF,W
1F72:  SUBLW  04
1F74:  BTFSS  FD8.2
1F76:  BRA    2170
.................... 				/* Modbus read input or holding registers */
.................... 				if ( DEV_TYPE_MODBUS_4 == device[n].type ) {
1F78:  CLRF   x95
1F7A:  MOVFF  97A,994
1F7E:  CLRF   x97
1F80:  MOVLW  0D
1F82:  MOVWF  x96
1F84:  MOVLB  0
1F86:  CALL   084C
1F8A:  MOVFF  02,97E
1F8E:  MOVFF  01,97D
1F92:  MOVLW  21
1F94:  MOVLB  9
1F96:  ADDWF  01,W
1F98:  MOVWF  FE9
1F9A:  MOVLW  00
1F9C:  ADDWFC 02,W
1F9E:  MOVWF  FEA
1FA0:  MOVF   FEF,W
1FA2:  SUBLW  04
1FA4:  BNZ   206C
.................... 					qbuff.rException=modbus_read_input_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
1FA6:  CLRF   x95
1FA8:  MOVFF  97A,994
1FAC:  CLRF   x97
1FAE:  MOVLW  0D
1FB0:  MOVWF  x96
1FB2:  MOVLB  0
1FB4:  CALL   084C
1FB8:  MOVFF  02,97E
1FBC:  MOVFF  01,97D
1FC0:  MOVLW  04
1FC2:  MOVLB  9
1FC4:  ADDWF  01,W
1FC6:  MOVWF  01
1FC8:  MOVLW  00
1FCA:  ADDWFC 02,W
1FCC:  MOVWF  03
1FCE:  MOVF   01,W
1FD0:  ADDLW  21
1FD2:  MOVWF  FE9
1FD4:  MOVLW  00
1FD6:  ADDWFC 03,W
1FD8:  MOVWF  FEA
1FDA:  MOVFF  FEF,97D
1FDE:  CLRF   x95
1FE0:  MOVFF  97A,994
1FE4:  CLRF   x97
1FE6:  MOVLW  0D
1FE8:  MOVWF  x96
1FEA:  MOVLB  0
1FEC:  CALL   084C
1FF0:  MOVFF  01,97E
1FF4:  MOVLW  09
1FF6:  MOVLB  9
1FF8:  ADDWF  01,W
1FFA:  MOVWF  01
1FFC:  MOVLW  00
1FFE:  ADDWFC 02,W
2000:  MOVWF  03
2002:  MOVF   01,W
2004:  ADDLW  21
2006:  MOVWF  FE9
2008:  MOVLW  00
200A:  ADDWFC 03,W
200C:  MOVWF  FEA
200E:  MOVFF  FEC,97F
2012:  MOVF   FED,F
2014:  MOVFF  FEF,97E
2018:  CLRF   x95
201A:  MOVFF  97A,994
201E:  CLRF   x97
2020:  MOVLW  0D
2022:  MOVWF  x96
2024:  MOVLB  0
2026:  CALL   084C
202A:  MOVFF  02,981
202E:  MOVFF  01,980
2032:  MOVLW  0B
2034:  MOVLB  9
2036:  ADDWF  01,W
2038:  MOVWF  01
203A:  MOVLW  00
203C:  ADDWFC 02,W
203E:  MOVWF  03
2040:  MOVF   01,W
2042:  ADDLW  21
2044:  MOVWF  FE9
2046:  MOVLW  00
2048:  ADDWFC 03,W
204A:  MOVWF  FEA
204C:  MOVFF  FEF,985
2050:  MOVFF  97D,982
2054:  MOVFF  97F,984
2058:  MOVFF  97E,983
205C:  CLRF   x86
205E:  MOVLB  0
2060:  CALL   1850
2064:  MOVFF  01,367
.................... 				} else {
2068:  BRA    212E
206A:  MOVLB  9
.................... 					qbuff.rException=modbus_read_holding_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
206C:  CLRF   x95
206E:  MOVFF  97A,994
2072:  CLRF   x97
2074:  MOVLW  0D
2076:  MOVWF  x96
2078:  MOVLB  0
207A:  CALL   084C
207E:  MOVFF  02,97E
2082:  MOVFF  01,97D
2086:  MOVLW  04
2088:  MOVLB  9
208A:  ADDWF  01,W
208C:  MOVWF  01
208E:  MOVLW  00
2090:  ADDWFC 02,W
2092:  MOVWF  03
2094:  MOVF   01,W
2096:  ADDLW  21
2098:  MOVWF  FE9
209A:  MOVLW  00
209C:  ADDWFC 03,W
209E:  MOVWF  FEA
20A0:  MOVFF  FEF,97D
20A4:  CLRF   x95
20A6:  MOVFF  97A,994
20AA:  CLRF   x97
20AC:  MOVLW  0D
20AE:  MOVWF  x96
20B0:  MOVLB  0
20B2:  CALL   084C
20B6:  MOVFF  01,97E
20BA:  MOVLW  09
20BC:  MOVLB  9
20BE:  ADDWF  01,W
20C0:  MOVWF  01
20C2:  MOVLW  00
20C4:  ADDWFC 02,W
20C6:  MOVWF  03
20C8:  MOVF   01,W
20CA:  ADDLW  21
20CC:  MOVWF  FE9
20CE:  MOVLW  00
20D0:  ADDWFC 03,W
20D2:  MOVWF  FEA
20D4:  MOVFF  FEC,97F
20D8:  MOVF   FED,F
20DA:  MOVFF  FEF,97E
20DE:  CLRF   x95
20E0:  MOVFF  97A,994
20E4:  CLRF   x97
20E6:  MOVLW  0D
20E8:  MOVWF  x96
20EA:  MOVLB  0
20EC:  CALL   084C
20F0:  MOVFF  02,981
20F4:  MOVFF  01,980
20F8:  MOVLW  0B
20FA:  MOVLB  9
20FC:  ADDWF  01,W
20FE:  MOVWF  01
2100:  MOVLW  00
2102:  ADDWFC 02,W
2104:  MOVWF  03
2106:  MOVF   01,W
2108:  ADDLW  21
210A:  MOVWF  FE9
210C:  MOVLW  00
210E:  ADDWFC 03,W
2110:  MOVWF  FEA
2112:  MOVFF  FEF,985
2116:  MOVFF  97D,982
211A:  MOVFF  97F,984
211E:  MOVFF  97E,983
2122:  CLRF   x86
2124:  MOVLB  0
2126:  CALL   18E8
212A:  MOVFF  01,367
.................... 				}
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
212E:  MOVLB  3
2130:  MOVF   x67,F
2132:  BNZ   216C
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
2134:  MOVLW  01
2136:  MOVLB  5
2138:  SUBWF  x94,W
213A:  MOVLB  4
213C:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
213E:  MOVLW  01
2140:  MOVLB  5
2142:  SUBWF  x94,W
2144:  MOVLB  9
2146:  MOVWF  x7D
2148:  MOVLW  03
214A:  MOVWF  FEA
214C:  MOVLW  68
214E:  MOVWF  FE9
2150:  MOVLW  05
2152:  MOVWF  FE2
2154:  MOVLW  98
2156:  MOVWF  FE1
2158:  MOVF   x7D,W
215A:  MOVWF  01
215C:  BZ    2166
215E:  MOVFF  FE6,FEE
2162:  DECFSZ 01,F
2164:  BRA    215E
.................... 
.................... 					live_send();
2166:  MOVLB  0
2168:  RCALL  19E6
216A:  MOVLB  3
.................... 				}
.................... 			} else if ( DEV_TYPE_MODBUS_1==device[n].type || DEV_TYPE_MODBUS_2==device[n].type ) {
216C:  BRA    22CE
216E:  MOVLB  9
2170:  CLRF   x95
2172:  MOVFF  97A,994
2176:  CLRF   x97
2178:  MOVLW  0D
217A:  MOVWF  x96
217C:  MOVLB  0
217E:  CALL   084C
2182:  MOVFF  02,97E
2186:  MOVFF  01,97D
218A:  MOVLW  21
218C:  MOVLB  9
218E:  ADDWF  01,W
2190:  MOVWF  FE9
2192:  MOVLW  00
2194:  ADDWFC 02,W
2196:  MOVWF  FEA
2198:  MOVF   FEF,W
219A:  SUBLW  01
219C:  BZ    21CE
219E:  CLRF   x95
21A0:  MOVFF  97A,994
21A4:  CLRF   x97
21A6:  MOVLW  0D
21A8:  MOVWF  x96
21AA:  MOVLB  0
21AC:  CALL   084C
21B0:  MOVFF  02,980
21B4:  MOVFF  01,97F
21B8:  MOVLW  21
21BA:  MOVLB  9
21BC:  ADDWF  01,W
21BE:  MOVWF  FE9
21C0:  MOVLW  00
21C2:  ADDWFC 02,W
21C4:  MOVWF  FEA
21C6:  MOVF   FEF,W
21C8:  SUBLW  02
21CA:  BTFSS  FD8.2
21CC:  BRA    22D0
.................... 				/* Modbus read coil or discrete input */
.................... 				qbuff.rException=modbus_read_coils(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
21CE:  CLRF   x95
21D0:  MOVFF  97A,994
21D4:  CLRF   x97
21D6:  MOVLW  0D
21D8:  MOVWF  x96
21DA:  MOVLB  0
21DC:  CALL   084C
21E0:  MOVFF  02,97E
21E4:  MOVFF  01,97D
21E8:  MOVLW  04
21EA:  MOVLB  9
21EC:  ADDWF  01,W
21EE:  MOVWF  01
21F0:  MOVLW  00
21F2:  ADDWFC 02,W
21F4:  MOVWF  03
21F6:  MOVF   01,W
21F8:  ADDLW  21
21FA:  MOVWF  FE9
21FC:  MOVLW  00
21FE:  ADDWFC 03,W
2200:  MOVWF  FEA
2202:  MOVFF  FEF,97D
2206:  CLRF   x95
2208:  MOVFF  97A,994
220C:  CLRF   x97
220E:  MOVLW  0D
2210:  MOVWF  x96
2212:  MOVLB  0
2214:  CALL   084C
2218:  MOVFF  01,97E
221C:  MOVLW  09
221E:  MOVLB  9
2220:  ADDWF  01,W
2222:  MOVWF  01
2224:  MOVLW  00
2226:  ADDWFC 02,W
2228:  MOVWF  03
222A:  MOVF   01,W
222C:  ADDLW  21
222E:  MOVWF  FE9
2230:  MOVLW  00
2232:  ADDWFC 03,W
2234:  MOVWF  FEA
2236:  MOVFF  FEC,97F
223A:  MOVF   FED,F
223C:  MOVFF  FEF,97E
2240:  CLRF   x95
2242:  MOVFF  97A,994
2246:  CLRF   x97
2248:  MOVLW  0D
224A:  MOVWF  x96
224C:  MOVLB  0
224E:  CALL   084C
2252:  MOVFF  02,981
2256:  MOVFF  01,980
225A:  MOVLW  0B
225C:  MOVLB  9
225E:  ADDWF  01,W
2260:  MOVWF  01
2262:  MOVLW  00
2264:  ADDWFC 02,W
2266:  MOVWF  03
2268:  MOVF   01,W
226A:  ADDLW  21
226C:  MOVWF  FE9
226E:  MOVLW  00
2270:  ADDWFC 03,W
2272:  MOVWF  FEA
2274:  MOVFF  FEF,985
2278:  MOVFF  97D,982
227C:  MOVFF  97F,984
2280:  MOVFF  97E,983
2284:  CLRF   x86
2286:  MOVLB  0
2288:  RCALL  1C4A
228A:  MOVFF  01,367
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
228E:  MOVLB  3
2290:  MOVF   x67,F
2292:  BNZ   22CE
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
2294:  MOVLW  01
2296:  MOVLB  5
2298:  SUBWF  x94,W
229A:  MOVLB  4
229C:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
229E:  MOVLW  01
22A0:  MOVLB  5
22A2:  SUBWF  x94,W
22A4:  MOVLB  9
22A6:  MOVWF  x7D
22A8:  MOVLW  03
22AA:  MOVWF  FEA
22AC:  MOVLW  68
22AE:  MOVWF  FE9
22B0:  MOVLW  05
22B2:  MOVWF  FE2
22B4:  MOVLW  98
22B6:  MOVWF  FE1
22B8:  MOVF   x7D,W
22BA:  MOVWF  01
22BC:  BZ    22C6
22BE:  MOVFF  FE6,FEE
22C2:  DECFSZ 01,F
22C4:  BRA    22BE
.................... 
.................... 					live_send();
22C6:  MOVLB  0
22C8:  CALL   19E6
22CC:  MOVLB  3
22CE:  MOVLB  9
.................... 				}
.................... 			}
.................... 		} else if ( device[n].type <= DEV_TYPE_I2C_MAX ) {
22D0:  BRA    2432
22D2:  CLRF   x95
22D4:  MOVFF  97A,994
22D8:  CLRF   x97
22DA:  MOVLW  0D
22DC:  MOVWF  x96
22DE:  MOVLB  0
22E0:  CALL   084C
22E4:  MOVFF  02,97E
22E8:  MOVFF  01,97D
22EC:  MOVLW  21
22EE:  MOVLB  9
22F0:  ADDWF  01,W
22F2:  MOVWF  FE9
22F4:  MOVLW  00
22F6:  ADDWFC 02,W
22F8:  MOVWF  FEA
22FA:  MOVF   FEF,W
22FC:  SUBLW  17
22FE:  BTFSS  FD8.0
2300:  BRA    2432
.................... 			/* I2C device */
.................... 
.................... #if DEBUG_ASCII
.................... 			restart_wdt();
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() I2C device\r\n");
.................... 			fprintf(STREAM_WORLD,"device[%u]\r\n",n);
.................... 			fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[n].type);
.................... 			fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[n].transmitEvery);
.................... 			fprintf(STREAM_WORLD,"\tnetworkAddress=0x%02x\r\n",device[n].networkAddress);
.................... 			fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 				make8(device[n].serialNumber,3),
.................... 				make8(device[n].serialNumber,2),
.................... 				make8(device[n].serialNumber,1),
.................... 				make8(device[n].serialNumber,0)
.................... 			);
.................... 			fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[n].startRegister);
.................... 			fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[n].nRegisters);
.................... #endif
.................... 
.................... 			if ( DEV_TYPE_I2C_READ_8 == device[n].type ) {
2302:  CLRF   x95
2304:  MOVFF  97A,994
2308:  CLRF   x97
230A:  MOVLW  0D
230C:  MOVWF  x96
230E:  MOVLB  0
2310:  CALL   084C
2314:  MOVFF  02,97E
2318:  MOVFF  01,97D
231C:  MOVLW  21
231E:  MOVLB  9
2320:  ADDWF  01,W
2322:  MOVWF  FE9
2324:  MOVLW  00
2326:  ADDWFC 02,W
2328:  MOVWF  FEA
232A:  MOVF   FEF,W
232C:  SUBLW  10
232E:  BTFSS  FD8.2
2330:  BRA    2432
.................... 				/* start a read at start address then just read a byte at a time. nRegisters is bytes */
.................... //fprintf(STREAM_WORLD,"z");
.................... 				i2c_buff_read(device[n].networkAddress, device[n].startRegister, qbuff.rResult, device[n].nRegisters);
2332:  CLRF   x95
2334:  MOVFF  97A,994
2338:  CLRF   x97
233A:  MOVLW  0D
233C:  MOVWF  x96
233E:  MOVLB  0
2340:  CALL   084C
2344:  MOVFF  02,97E
2348:  MOVFF  01,97D
234C:  MOVLW  04
234E:  MOVLB  9
2350:  ADDWF  01,W
2352:  MOVWF  01
2354:  MOVLW  00
2356:  ADDWFC 02,W
2358:  MOVWF  03
235A:  MOVF   01,W
235C:  ADDLW  21
235E:  MOVWF  FE9
2360:  MOVLW  00
2362:  ADDWFC 03,W
2364:  MOVWF  FEA
2366:  MOVFF  FEF,97D
236A:  CLRF   x95
236C:  MOVFF  97A,994
2370:  CLRF   x97
2372:  MOVLW  0D
2374:  MOVWF  x96
2376:  MOVLB  0
2378:  CALL   084C
237C:  MOVFF  01,97E
2380:  MOVLW  09
2382:  MOVLB  9
2384:  ADDWF  01,W
2386:  MOVWF  01
2388:  MOVLW  00
238A:  ADDWFC 02,W
238C:  MOVWF  03
238E:  MOVF   01,W
2390:  ADDLW  21
2392:  MOVWF  FE9
2394:  MOVLW  00
2396:  ADDWFC 03,W
2398:  MOVWF  FEA
239A:  MOVFF  FEC,97F
239E:  MOVF   FED,F
23A0:  MOVFF  FEF,97E
23A4:  CLRF   x95
23A6:  MOVFF  97A,994
23AA:  CLRF   x97
23AC:  MOVLW  0D
23AE:  MOVWF  x96
23B0:  MOVLB  0
23B2:  CALL   084C
23B6:  MOVFF  02,981
23BA:  MOVFF  01,980
23BE:  MOVLW  0B
23C0:  MOVLB  9
23C2:  ADDWF  01,W
23C4:  MOVWF  01
23C6:  MOVLW  00
23C8:  ADDWFC 02,W
23CA:  MOVWF  03
23CC:  MOVF   01,W
23CE:  ADDLW  21
23D0:  MOVWF  FE9
23D2:  MOVLW  00
23D4:  ADDWFC 03,W
23D6:  MOVWF  FEA
23D8:  MOVFF  FEF,986
23DC:  MOVFF  97D,982
23E0:  MOVFF  97E,983
23E4:  MOVLW  03
23E6:  MOVWF  x85
23E8:  MOVLW  68
23EA:  MOVWF  x84
23EC:  MOVLB  0
23EE:  RCALL  1CE2
.................... 
.................... 				qbuff.rException=0;
23F0:  MOVLB  3
23F2:  CLRF   x67
.................... 				qbuff.rResultLength=device[n].nRegisters;
23F4:  MOVLB  9
23F6:  CLRF   x95
23F8:  MOVFF  97A,994
23FC:  CLRF   x97
23FE:  MOVLW  0D
2400:  MOVWF  x96
2402:  MOVLB  0
2404:  CALL   084C
2408:  MOVFF  01,97D
240C:  MOVLW  0B
240E:  MOVLB  9
2410:  ADDWF  01,W
2412:  MOVWF  01
2414:  MOVLW  00
2416:  ADDWFC 02,W
2418:  MOVWF  03
241A:  MOVF   01,W
241C:  ADDLW  21
241E:  MOVWF  FE9
2420:  MOVLW  00
2422:  ADDWFC 03,W
2424:  MOVWF  FEA
2426:  MOVFF  FEF,468
.................... //fprintf(STREAM_WORLD,"Z");
.................... #if DEBUG_ASCII
.................... 				/* debug dump */
.................... 				restart_wdt();
.................... 				for ( i=0 ; i<device[n].nRegisters ; i++ ) {
.................... 					fprintf(STREAM_WORLD,"# reg addr[0x%02x]=0x%02x (%u)\r\n",i+device[n].startRegister,qbuff.rResult[i],qbuff.rResult[i]);
.................... 				}
.................... #endif
.................... 
.................... 				live_send();
242A:  MOVLB  0
242C:  CALL   19E6
2430:  MOVLB  9
.................... 
.................... 			}
.................... 
.................... 		} else {
.................... 			/* local */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() local (not implemented) device\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* Add data to SBD if this is an SBD cycle and we have valid data */
.................... 		if ( 0 == timers.sbd_cycle && 0 == qbuff.rException ) {
2432:  MOVLB  3
2434:  MOVF   x65,F
2436:  BNZ   24DA
2438:  MOVF   x66,F
243A:  BNZ   24DA
243C:  MOVF   x67,F
243E:  BNZ   24DA
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() adding to sbd.mo_buff since qbuff.rException=0\r\n");
.................... #endif
.................... 			/* sub-header, 2 bytes, device number, and data length */
.................... 			sbd.mo_buff[sbd.mo_length++]=n;
2440:  MOVLB  7
2442:  MOVFF  7DB,03
2446:  MOVF   xDA,W
2448:  INCF   xDA,F
244A:  BTFSC  FD8.2
244C:  INCF   xDB,F
244E:  MOVLB  9
2450:  MOVWF  x7D
2452:  MOVLW  CA
2454:  ADDWF  x7D,W
2456:  MOVWF  FE9
2458:  MOVLW  06
245A:  ADDWFC 03,W
245C:  MOVWF  FEA
245E:  MOVFF  97A,FEF
.................... 			sbd.mo_buff[sbd.mo_length++]=qbuff.rResultLength;
2462:  MOVLB  7
2464:  MOVFF  7DB,03
2468:  MOVF   xDA,W
246A:  INCF   xDA,F
246C:  BTFSC  FD8.2
246E:  INCF   xDB,F
2470:  MOVLB  9
2472:  MOVWF  x7D
2474:  MOVLW  CA
2476:  ADDWF  x7D,W
2478:  MOVWF  FE9
247A:  MOVLW  06
247C:  ADDWFC 03,W
247E:  MOVWF  FEA
2480:  MOVFF  468,FEF
.................... 		
.................... 			/* sub-message */
.................... 			for ( l=0 ; l<qbuff.rResultLength ; l++ ) {
2484:  CLRF   x7C
2486:  CLRF   x7B
2488:  MOVF   x7C,F
248A:  BNZ   24D8
248C:  MOVLB  4
248E:  MOVF   x68,W
2490:  MOVLB  9
2492:  SUBWF  x7B,W
2494:  BC    24D8
.................... 				sbd.mo_buff[sbd.mo_length++]=qBuff.rResult[l];
2496:  MOVLB  7
2498:  MOVFF  7DB,97E
249C:  MOVF   xDA,W
249E:  INCF   xDA,F
24A0:  BTFSC  FD8.2
24A2:  INCF   xDB,F
24A4:  MOVLB  9
24A6:  MOVWF  x7D
24A8:  MOVLW  CA
24AA:  ADDWF  x7D,W
24AC:  MOVWF  01
24AE:  MOVLW  06
24B0:  ADDWFC x7E,W
24B2:  MOVWF  03
24B4:  MOVLW  68
24B6:  ADDWF  x7B,W
24B8:  MOVWF  FE9
24BA:  MOVLW  03
24BC:  ADDWFC x7C,W
24BE:  MOVWF  FEA
24C0:  MOVFF  FEF,981
24C4:  MOVFF  03,FEA
24C8:  MOVFF  01,FE9
24CC:  MOVFF  981,FEF
24D0:  INCF   x7B,F
24D2:  BTFSC  FD8.2
24D4:  INCF   x7C,F
24D6:  BRA    2488
24D8:  MOVLB  3
.................... 			}
.................... 		}
24DA:  MOVLB  9
24DC:  INCF   x7A,F
24DE:  BRA    1DD6
.................... 
.................... 	}
.................... 
.................... 	/* if we have data to send, then we sent it */
.................... 	if ( 0 == timers.sbd_cycle && sbd.mo_length > 0 ) {
24E0:  MOVLB  3
24E2:  MOVF   x65,F
24E4:  BNZ   2502
24E6:  MOVF   x66,F
24E8:  BNZ   2502
24EA:  MOVLB  7
24EC:  MOVF   xDA,F
24EE:  BNZ   24FA
24F0:  MOVF   xDB,F
24F2:  BTFSS  FD8.2
24F4:  BRA    24FA
24F6:  MOVLB  3
24F8:  BRA    2502
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() setting sbd.mo_state=1\r\n");
.................... #endif
.................... 		sbd.mo_state=1;
24FA:  MOVLW  01
24FC:  MOVLB  6
24FE:  MOVWF  xC9
2500:  MOVLB  3
.................... 	}
.................... 
.................... 	measurementNumber++;
2502:  MOVLB  9
2504:  INCF   x37,F
2506:  BTFSC  FD8.2
2508:  INCF   x38,F
.................... 
.................... 	if ( 0 == timers.sbd_cycle ) {
250A:  MOVLB  3
250C:  MOVF   x65,F
250E:  BNZ   252A
2510:  MOVF   x66,F
2512:  BNZ   252A
.................... 		timers.sbd_cycle=(config.sbd_every-1);
2514:  MOVLW  01
2516:  MOVLB  5
2518:  SUBWF  x89,W
251A:  MOVLB  3
251C:  MOVWF  x65
251E:  MOVLW  00
2520:  MOVLB  5
2522:  SUBWFB x8A,W
2524:  MOVLB  3
2526:  MOVWF  x66
.................... 	} else {
2528:  BRA    2532
.................... 		timers.sbd_cycle--;
252A:  MOVF   x65,W
252C:  BTFSC  FD8.2
252E:  DECF   x66,F
2530:  DECF   x65,F
.................... 	}
2532:  MOVLB  0
2534:  GOTO   3824 (RETURN)
.................... }
.................... 
.................... void init() {
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
06BA:  MOVLW  62
06BC:  MOVWF  FD3
06BE:  CLRF   F9B
06C0:  CLRF   F64
.................... 	setup_adc_ports(NO_ANALOGS);
06C2:  MOVLB  F
06C4:  MOVF   x5C,W
06C6:  ANDLW  80
06C8:  MOVWF  x5C
06CA:  MOVLW  00
06CC:  MOVWF  x5D
06CE:  BCF    FC1.3
06D0:  BCF    FC1.4
06D2:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
06D4:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
06D6:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
06D8:  MOVLW  1F
06DA:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
06DC:  MOVLW  F0
06DE:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
06E0:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
06E2:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
06E4:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
06E6:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
06E8:  BCF    F94.5
06EA:  BCF    F8B.5
.................... 
.................... 	setup_timer_4(T4_DIV_BY_16,77,16); 
06EC:  MOVLW  78
06EE:  IORLW  06
06F0:  MOVWF  F88
06F2:  MOVLW  4D
06F4:  MOVWF  FA9
.................... 	enable_interrupts(INT_TIMER4);	
06F6:  BSF    FB6.7
.................... 
.................... 	/* global structures initialized to 0, set something else below if needed */
.................... 	timers.now_poll=1;
06F8:  MOVLW  01
06FA:  MOVLB  3
06FC:  MOVWF  x61
.................... 	timers.sbd_cycle=1; /* next packet will be an SBD packet */
06FE:  CLRF   x66
0700:  MOVWF  x65
.................... 	timers.world_timeout=255;
0702:  SETF   x62
.................... 	timers.factory_unlocked=0;
0704:  CLRF   x63
.................... 	timers.led_on_green=0;
0706:  CLRF   x64
.................... 
.................... 	query_reset();
0708:  MOVLB  0
070A:  RCALL  05B8
.................... 
.................... 	/* receive data from serial ports */
.................... 	enable_interrupts(INT_RDA2);
070C:  BSF    FA3.5
.................... 
.................... #if MCP3208_ENABLED
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
.................... #endif
.................... 
.................... 
.................... 	if ( config.sbd_config ) {
070E:  MOVLB  5
0710:  MOVF   x88,F
0712:  BZ    0720
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# init() initializing I2C Uart for SBD @ 19200\r\n");
.................... #endif
.................... 		/* initialize I2C UART for Iridium @ 19200 */
.................... 		uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
0714:  MOVLW  06
0716:  MOVLB  9
0718:  MOVWF  x7A
071A:  MOVLB  0
071C:  BRA    061E
071E:  MOVLB  5
.................... 	}
.................... 
.................... 	delay_ms(14);
0720:  MOVLW  0E
0722:  MOVLB  9
0724:  MOVWF  x90
0726:  MOVLB  0
0728:  RCALL  068A
072A:  GOTO   371A (RETURN)
.................... }
.................... 
.................... void main(void) {
*
3650:  CLRF   FF8
3652:  BCF    FD0.7
3654:  BSF    07.7
3656:  MOVLW  62
3658:  MOVWF  FD3
365A:  CLRF   F9B
365C:  CLRF   F64
365E:  CLRF   20
3660:  BSF    FB9.3
3662:  MOVLW  22
3664:  MOVWF  F7B
3666:  MOVLW  00
3668:  MOVWF  F7C
366A:  MOVLW  A6
366C:  MOVWF  FBA
366E:  MOVLW  90
3670:  MOVWF  FA6
3672:  BSF    F94.3
3674:  BSF    F94.4
3676:  MOVLW  04
3678:  MOVWF  FC8
367A:  MOVLW  28
367C:  MOVWF  FC6
367E:  BCF    FC7.7
3680:  BCF    FC7.6
3682:  BCF    FA7.3
3684:  MOVLW  0C
3686:  MOVWF  FAF
3688:  MOVLW  A2
368A:  MOVWF  FAC
368C:  MOVLW  90
368E:  MOVWF  FAB
3690:  MOVLB  5
3692:  CLRF   x8E
3694:  MOVLW  01
3696:  MOVWF  x8D
3698:  MOVLW  86
369A:  MOVWF  x8C
369C:  MOVLW  A0
369E:  MOVWF  x8B
36A0:  BCF    x8F.0
36A2:  CLRF   x90
36A4:  MOVLB  9
36A6:  CLRF   x2A
36A8:  CLRF   x29
36AA:  MOVLB  F
36AC:  MOVF   x5C,W
36AE:  ANDLW  80
36B0:  MOVWF  x5C
36B2:  MOVLW  00
36B4:  MOVWF  x5D
36B6:  BCF    FC1.3
36B8:  BCF    FC1.4
36BA:  BCF    FC1.5
36BC:  CLRF   x5E
36BE:  CLRF   x5F
36C0:  BRA    36D6
36C2:  DATA 02,00
36C4:  DATA 1A,00
36C6:  DATA 00,FF
36C8:  DATA 46,96
36CA:  DATA 00,FF
36CC:  DATA C0,00
36CE:  DATA 95,C0
36D0:  DATA 00,4E
36D2:  DATA 49,2B
36D4:  DATA 00,00
36D6:  MOVLW  00
36D8:  MOVWF  FF8
36DA:  MOVLW  36
36DC:  MOVWF  FF7
36DE:  MOVLW  C2
36E0:  MOVWF  FF6
36E2:  TBLRD*+
36E4:  MOVF   FF5,W
36E6:  MOVWF  00
36E8:  XORLW  00
36EA:  BZ    3712
36EC:  TBLRD*+
36EE:  MOVF   FF5,W
36F0:  MOVWF  01
36F2:  BTFSC  FE8.7
36F4:  BRA    3700
36F6:  ANDLW  3F
36F8:  MOVWF  FEA
36FA:  TBLRD*+
36FC:  MOVFF  FF5,FE9
3700:  BTFSC  01.6
3702:  TBLRD*+
3704:  BTFSS  01.6
3706:  TBLRD*+
3708:  MOVFF  FF5,FEE
370C:  DCFSNZ 00,F
370E:  BRA    36E2
3710:  BRA    3704
3712:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	/* normal device startup */
.................... 	init();
3714:  MOVLB  0
3716:  GOTO   06BA
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking wait\r\n");
.................... #endif
.................... 	for ( i=0 ; i<STARTUP_BLINKS ; i++ ) {
371A:  MOVLB  9
371C:  CLRF   x79
371E:  MOVF   x79,W
3720:  SUBLW  95
3722:  BNC   374A
.................... 		restart_wdt();
3724:  CLRWDT
.................... 
.................... 		output_high(LED_GREEN);
3726:  BCF    F93.5
3728:  BSF    F8A.5
.................... 		delay_ms(100);
372A:  MOVLW  64
372C:  MOVWF  x90
372E:  MOVLB  0
3730:  CALL   068A
.................... 		output_low(LED_GREEN);
3734:  BCF    F93.5
3736:  BCF    F8A.5
.................... 		delay_ms(100);
3738:  MOVLW  64
373A:  MOVLB  9
373C:  MOVWF  x90
373E:  MOVLB  0
3740:  CALL   068A
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# main() blink=%u\r\n",i);
.................... #endif
.................... 	}
.................... 
.................... #if DEBUG_ASCII
3744:  MOVLB  9
3746:  INCF   x79,F
3748:  BRA    371E
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking done\r\n");
.................... 
.................... 	fprintf(STREAM_WORLD,"# rdTap %s %s\r\n",__DATE__,__TIME__);
.................... 
.................... 	fprintf(STREAM_WORLD,"# restart cause: ");
.................... 	switch ( restart_cause ) {
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_WORLD,"WDT TIMEOUT"); break;
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_WORLD,"MCLR FROM SLEEP"); break;
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_WORLD,"MCLR FROM RUN"); break;
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_WORLD,"NORMAL POWER UP"); break;
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_WORLD,"BROWNOUT RESTART"); break;
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_WORLD,"WDT FROM SLEEP"); break;
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_WORLD,"RESET INSTRUCTION"); break;
.................... 		default:                fprintf(STREAM_WORLD,"UNKNOWN!");
.................... 	}
.................... 	fprintf(STREAM_WORLD,"\r\n");
.................... #endif
.................... 
.................... 	restart_wdt();
374A:  CLRWDT
.................... 	enable_interrupts(GLOBAL);
374C:  MOVLW  C0
374E:  IORWF  FF2,F
.................... 
.................... 	write_default_param_file();
3750:  MOVLB  0
3752:  CALL   0822
.................... 	write_default_device_file();
3756:  CALL   08C0
.................... 
.................... 	read_param_file();
375A:  GOTO   0A48
.................... 	read_device_file();
375E:  GOTO   0A96
.................... 
.................... 	restart_wdt();
3762:  CLRWDT
.................... 	modbus_init();
3764:  GOTO   0AF4
.................... 
.................... #if DEBUG_ASCII
.................... 	devicesDump();
.................... #endif
.................... 
.................... 	iridium_mr_clear();
3768:  CALL   0B0C
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() starting for ( ; ; ) loop\r\n");
.................... #endif
.................... 
.................... 
.................... 	/* main loop */
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
376C:  CLRWDT
.................... 
.................... 		if ( config.sbd_config ) {
376E:  MOVLB  5
3770:  MOVF   x88,F
3772:  BZ    3812
.................... 			/* iridium enabled */
.................... 
.................... 			/* act on flag set by SBDRING in UART character processor or RING ALERT line */
.................... 			if ( sbd.ring_flag ) {
3774:  MOVLB  8
3776:  MOVF   xE4,F
3778:  BZ    3786
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# main() sbd.ring_flag=1\r\n");
.................... #endif
.................... 				/* our easiest way to get the ringing message is to send another message. This also
.................... 				would help capture the results from a query */
.................... 				timers.sbd_cycle=1; /* next packet will be an SBD packet */
377A:  MOVLB  3
377C:  CLRF   x66
377E:  MOVLW  01
3780:  MOVWF  x65
.................... 
.................... 				sbd.ring_flag=0;
3782:  MOVLB  8
3784:  CLRF   xE4
.................... 			}
.................... 
.................... 			if ( '\0' != sbd.sbdix_response[0] && 0 == sbd.mo_state ) {
3786:  MOVLB  6
3788:  MOVF   x96,F
378A:  BZ    37A8
378C:  MOVF   xC9,F
378E:  BNZ   37A8
.................... 				/* 
.................... 				if there is something in our +SBDIX response we should check if we have a message or need to 
.................... 				get a message. But wait until MO sending is done (state machine idle).
.................... 				*/
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_response='%s'\r\n",sbd.sbdix_response);
.................... #endif
.................... 
....................  				iridium_sbdix_parse();
3790:  MOVLB  0
3792:  GOTO   0C60
.................... 
.................... 				/* clear the unparsed buffer so we don't get back here */
.................... 				sbd.sbdix_response[0]='\0';
3796:  MOVLB  6
3798:  CLRF   x96
.................... 
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
379A:  MOVF   xC8,F
379C:  BZ    37A8
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
379E:  MOVLB  3
37A0:  CLRF   x66
37A2:  MOVLW  01
37A4:  MOVWF  x65
37A6:  MOVLB  6
.................... 					
.................... #if DEBUG_SBD
.................... 					fprintf(STREAM_WORLD,"# sbd.sbdix_mt_queued > 0 (is %u)\r\n",sbd.sbdix_mt_queued);
.................... #endif
.................... 				}
.................... 			}
.................... 
.................... 			/* read character into MR if we don't have an unprocessed message and there is a character available */
.................... 			if ( 0==sbd.mr_ready && ! sbd.mr_disable && uart_kbhit() ) {
37A8:  MOVLB  8
37AA:  MOVF   xE6,F
37AC:  BNZ   37D0
37AE:  MOVLB  9
37B0:  MOVF   x28,F
37B2:  BTFSC  FD8.2
37B4:  BRA    37BA
37B6:  MOVLB  8
37B8:  BRA    37D0
37BA:  MOVLB  0
37BC:  CALL   0E9E
37C0:  MOVF   01,F
37C2:  BTFSS  FD8.2
37C4:  BRA    37CA
37C6:  MOVLB  8
37C8:  BRA    37D0
.................... 				iridium_getc();
37CA:  GOTO   0EB0
37CE:  MOVLB  8
.................... 			}
.................... 
.................... 			/* download message from SBD modem */
.................... 			if ( 1 == sbd.sbdix_mt_status ) {
37D0:  MOVLB  6
37D2:  DECFSZ xC3,W
37D4:  BRA    37DE
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_mt_status=1\r\n");
.................... #endif
.................... 				iridium_mt_receive();
37D6:  MOVLB  0
37D8:  GOTO   0F94
37DC:  MOVLB  6
.................... 			}
.................... 
.................... 			/* send messages to SBD modem */
.................... 			if ( 0 != sbd.mo_state && 0 == sbd.mt_state ) {
37DE:  MOVF   xC9,F
37E0:  BZ    37F6
37E2:  MOVLB  7
37E4:  MOVF   xDF,F
37E6:  BTFSC  FD8.2
37E8:  BRA    37EE
37EA:  MOVLB  6
37EC:  BRA    37F6
.................... 				iridium_mo_send();
37EE:  MOVLB  0
37F0:  GOTO   13B4
37F4:  MOVLB  6
.................... 			}
.................... 
.................... 			if ( 1 == sbd.mt_ready ) {
37F6:  MOVLB  7
37F8:  DECFSZ xDE,W
37FA:  BRA    3810
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.mt_ready=1\r\n");
.................... #endif
.................... 				/* TODO: send to message parser */
.................... 				sbd.mt_ready=0;
37FC:  CLRF   xDE
.................... 
.................... 				/* do another SBDIX if we have sbd.mt_queued > 0 */
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
37FE:  MOVLB  6
3800:  MOVF   xC8,F
3802:  BZ    380E
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
3804:  MOVLB  3
3806:  CLRF   x66
3808:  MOVLW  01
380A:  MOVWF  x65
380C:  MOVLB  6
380E:  MOVLB  7
3810:  MOVLB  5
.................... 				}
.................... 			} 
.................... 		}
.................... 
.................... 
.................... 		if ( timers.now_poll ) {
3812:  MOVLB  3
3814:  MOVF   x61,F
3816:  BZ    3826
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll\r\n");
.................... #endif
.................... 			timers.now_poll=0;
3818:  CLRF   x61
.................... 			timers.led_on_green=200;
381A:  MOVLW  C8
381C:  MOVWF  x64
.................... 			deviceQuery();
381E:  MOVLB  0
3820:  GOTO   1D6C
3824:  MOVLB  3
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll done\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* queries are messages send to us that we respond to */
.................... 		if ( query.buff_ready ) {
3826:  MOVLB  5
3828:  MOVF   x6D,F
382A:  BZ    3836
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_process()\r\n");
.................... #endif
.................... 
.................... 			query_process();
382C:  MOVLB  0
382E:  BRA    3544
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_reset()\r\n");
.................... #endif
.................... 	
.................... 			query_reset();
3830:  CALL   05B8
3834:  MOVLB  5
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() done with query.buff_ready()\r\n");
.................... #endif
.................... 		}
3836:  MOVLB  0
3838:  BRA    376C
.................... 	}
.................... }
.................... 
383A:  SLEEP 

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 2B67   NOPUT BROWNOUT BORV30 ZPBORM WDT WDT1024
   Word  3: 0900   CANB MSSPMSK7 NOMCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
