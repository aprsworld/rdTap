CCS PCH C Compiler, Version 5.117, 2295               09-Apr-24 18:31

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\rdTap\rdTap.lst

               ROM used:   17172 bytes (52%)
                           Largest free fragment is 15592
               RAM used:   2426 (67%) at main() level
                           2463 (68%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   3F92
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   0304
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0378
006C:  BTFSS  FA3.5
006E:  GOTO   0078
0072:  BTFSC  FA4.5
0074:  GOTO   06B4
0078:  BTFSS  FB6.7
007A:  GOTO   0084
007E:  BTFSC  FB7.7
0080:  GOTO   063E
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #define DEBUG_ASCII     0
.................... #define DEBUG_SBD       1
.................... #define MCP3208_ENABLED 0
.................... #define STARTUP_BLINKS  50
.................... 
.................... 
.................... #include "rdTap.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 01,C0
00F4:  DATA 80,41
00F6:  DATA 00,C1
00F8:  DATA 81,40
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 00,C1
010C:  DATA 81,40
010E:  DATA 01,C0
0110:  DATA 80,41
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 01,C0
011C:  DATA 80,41
011E:  DATA 00,C1
0120:  DATA 81,40
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 00,C1
0134:  DATA 81,40
0136:  DATA 01,C0
0138:  DATA 80,41
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 01,C0
0154:  DATA 80,41
0156:  DATA 00,C1
0158:  DATA 81,40
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 00,C1
0174:  DATA 81,40
0176:  DATA 01,C0
0178:  DATA 80,41
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 01,C0
018C:  DATA 80,41
018E:  DATA 00,C1
0190:  DATA 81,40
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 00,C1
019C:  DATA 81,40
019E:  DATA 01,C0
01A0:  DATA 80,41
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 01,C0
01B4:  DATA 80,41
01B6:  DATA 00,C1
01B8:  DATA 81,40
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  DATA 00,C1
01CC:  DATA 81,40
01CE:  DATA 01,C0
01D0:  DATA 80,41
01D2:  DATA 00,C1
01D4:  DATA 81,40
01D6:  DATA 01,C0
01D8:  DATA 80,41
01DA:  DATA 01,C0
01DC:  DATA 80,41
01DE:  DATA 00,C1
01E0:  DATA 81,40
01E2:  CLRF   FF7
01E4:  ADDLW  F2
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  RETURN 0
01F2:  DATA 00,C0
01F4:  DATA C1,01
01F6:  DATA C3,03
01F8:  DATA 02,C2
01FA:  DATA C6,06
01FC:  DATA 07,C7
01FE:  DATA 05,C5
0200:  DATA C4,04
0202:  DATA CC,0C
0204:  DATA 0D,CD
0206:  DATA 0F,CF
0208:  DATA CE,0E
020A:  DATA 0A,CA
020C:  DATA CB,0B
020E:  DATA C9,09
0210:  DATA 08,C8
0212:  DATA D8,18
0214:  DATA 19,D9
0216:  DATA 1B,DB
0218:  DATA DA,1A
021A:  DATA 1E,DE
021C:  DATA DF,1F
021E:  DATA DD,1D
0220:  DATA 1C,DC
0222:  DATA 14,D4
0224:  DATA D5,15
0226:  DATA D7,17
0228:  DATA 16,D6
022A:  DATA D2,12
022C:  DATA 13,D3
022E:  DATA 11,D1
0230:  DATA D0,10
0232:  DATA F0,30
0234:  DATA 31,F1
0236:  DATA 33,F3
0238:  DATA F2,32
023A:  DATA 36,F6
023C:  DATA F7,37
023E:  DATA F5,35
0240:  DATA 34,F4
0242:  DATA 3C,FC
0244:  DATA FD,3D
0246:  DATA FF,3F
0248:  DATA 3E,FE
024A:  DATA FA,3A
024C:  DATA 3B,FB
024E:  DATA 39,F9
0250:  DATA F8,38
0252:  DATA 28,E8
0254:  DATA E9,29
0256:  DATA EB,2B
0258:  DATA 2A,EA
025A:  DATA EE,2E
025C:  DATA 2F,EF
025E:  DATA 2D,ED
0260:  DATA EC,2C
0262:  DATA E4,24
0264:  DATA 25,E5
0266:  DATA 27,E7
0268:  DATA E6,26
026A:  DATA 22,E2
026C:  DATA E3,23
026E:  DATA E1,21
0270:  DATA 20,E0
0272:  DATA A0,60
0274:  DATA 61,A1
0276:  DATA 63,A3
0278:  DATA A2,62
027A:  DATA 66,A6
027C:  DATA A7,67
027E:  DATA A5,65
0280:  DATA 64,A4
0282:  DATA 6C,AC
0284:  DATA AD,6D
0286:  DATA AF,6F
0288:  DATA 6E,AE
028A:  DATA AA,6A
028C:  DATA 6B,AB
028E:  DATA 69,A9
0290:  DATA A8,68
0292:  DATA 78,B8
0294:  DATA B9,79
0296:  DATA BB,7B
0298:  DATA 7A,BA
029A:  DATA BE,7E
029C:  DATA 7F,BF
029E:  DATA 7D,BD
02A0:  DATA BC,7C
02A2:  DATA B4,74
02A4:  DATA 75,B5
02A6:  DATA 77,B7
02A8:  DATA B6,76
02AA:  DATA 72,B2
02AC:  DATA B3,73
02AE:  DATA B1,71
02B0:  DATA 70,B0
02B2:  DATA 50,90
02B4:  DATA 91,51
02B6:  DATA 93,53
02B8:  DATA 52,92
02BA:  DATA 96,56
02BC:  DATA 57,97
02BE:  DATA 55,95
02C0:  DATA 94,54
02C2:  DATA 9C,5C
02C4:  DATA 5D,9D
02C6:  DATA 5F,9F
02C8:  DATA 9E,5E
02CA:  DATA 5A,9A
02CC:  DATA 9B,5B
02CE:  DATA 99,59
02D0:  DATA 58,98
02D2:  DATA 88,48
02D4:  DATA 49,89
02D6:  DATA 4B,8B
02D8:  DATA 8A,4A
02DA:  DATA 4E,8E
02DC:  DATA 8F,4F
02DE:  DATA 8D,4D
02E0:  DATA 4C,8C
02E2:  DATA 44,84
02E4:  DATA 85,45
02E6:  DATA 87,47
02E8:  DATA 46,86
02EA:  DATA 82,42
02EC:  DATA 43,83
02EE:  DATA 41,81
02F0:  DATA 80,40
*
03E2:  DATA 23,20
03E4:  DATA 69,72
03E6:  DATA 69,64
03E8:  DATA 69,75
03EA:  DATA 6D,5F
03EC:  DATA 73,62
03EE:  DATA 64,69
03F0:  DATA 78,5F
03F2:  DATA 70,61
03F4:  DATA 72,73
03F6:  DATA 65,28
03F8:  DATA 29,3A
03FA:  DATA 0D,0A
03FC:  DATA 00,00
03FE:  DATA 23,20
0400:  DATA 20,20
0402:  DATA 73,62
0404:  DATA 64,69
0406:  DATA 78,5F
0408:  DATA 6D,6F
040A:  DATA 5F,73
040C:  DATA 74,61
040E:  DATA 74,75
0410:  DATA 73,20
0412:  DATA 20,20
0414:  DATA 3D,20
0416:  DATA 25,64
0418:  DATA 0A,00
041A:  DATA 23,20
041C:  DATA 20,20
041E:  DATA 73,62
0420:  DATA 64,69
0422:  DATA 78,5F
0424:  DATA 6D,6F
0426:  DATA 5F,6D
0428:  DATA 73,6E
042A:  DATA 20,20
042C:  DATA 20,20
042E:  DATA 20,20
0430:  DATA 3D,20
0432:  DATA 25,6C
0434:  DATA 75,0A
0436:  DATA 00,00
0438:  DATA 23,20
043A:  DATA 20,20
043C:  DATA 73,62
043E:  DATA 64,69
0440:  DATA 78,5F
0442:  DATA 6D,74
0444:  DATA 5F,73
0446:  DATA 74,61
0448:  DATA 74,75
044A:  DATA 73,20
044C:  DATA 20,20
044E:  DATA 3D,20
0450:  DATA 25,64
0452:  DATA 0A,00
0454:  DATA 23,20
0456:  DATA 20,20
0458:  DATA 73,62
045A:  DATA 64,69
045C:  DATA 78,5F
045E:  DATA 6D,74
0460:  DATA 5F,6D
0462:  DATA 73,6E
0464:  DATA 20,20
0466:  DATA 20,20
0468:  DATA 20,20
046A:  DATA 3D,20
046C:  DATA 25,6C
046E:  DATA 75,0A
0470:  DATA 00,00
0472:  DATA 23,20
0474:  DATA 20,20
0476:  DATA 73,62
0478:  DATA 64,69
047A:  DATA 78,5F
047C:  DATA 6D,74
047E:  DATA 5F,6C
0480:  DATA 65,6E
0482:  DATA 67,74
0484:  DATA 68,20
0486:  DATA 20,20
0488:  DATA 3D,20
048A:  DATA 25,6C
048C:  DATA 75,0A
048E:  DATA 00,00
0490:  DATA 23,20
0492:  DATA 20,20
0494:  DATA 73,62
0496:  DATA 64,69
0498:  DATA 78,5F
049A:  DATA 6D,74
049C:  DATA 5F,71
049E:  DATA 75,65
04A0:  DATA 75,65
04A2:  DATA 64,20
04A4:  DATA 20,20
04A6:  DATA 3D,20
04A8:  DATA 25,64
04AA:  DATA 0A,00
04AC:  DATA 23,20
04AE:  DATA 75,61
04B0:  DATA 72,74
04B2:  DATA 5F,67
04B4:  DATA 65,74
04B6:  DATA 63,3D
04B8:  DATA 25,30
04BA:  DATA 32,78
04BC:  DATA 0D,0A
04BE:  DATA 00,00
04C0:  DATA 23,20
04C2:  DATA 69,72
04C4:  DATA 69,64
04C6:  DATA 69,75
04C8:  DATA 6D,5F
04CA:  DATA 72,69
04CC:  DATA 6E,67
04CE:  DATA 69,6E
04D0:  DATA 67,28
04D2:  DATA 29,20
04D4:  DATA 73,62
04D6:  DATA 64,2E
04D8:  DATA 72,69
04DA:  DATA 6E,67
04DC:  DATA 5F,73
04DE:  DATA 74,61
04E0:  DATA 74,65
04E2:  DATA 3D,25
04E4:  DATA 75,0D
04E6:  DATA 0A,00
04E8:  DATA 41,54
04EA:  DATA 45,30
04EC:  DATA 0D,00
04EE:  DATA 41,54
04F0:  DATA 26,4B
04F2:  DATA 30,0D
04F4:  DATA 00,00
04F6:  DATA 41,54
04F8:  DATA 2B,53
04FA:  DATA 42,44
04FC:  DATA 4D,54
04FE:  DATA 41,3D
0500:  DATA 31,0D
0502:  DATA 00,00
0504:  DATA 41,54
0506:  DATA 2B,43
0508:  DATA 52,49
050A:  DATA 53,0D
050C:  DATA 00,00
050E:  DATA 41,54
0510:  DATA 45,30
0512:  DATA 0D,00
0514:  DATA 41,54
0516:  DATA 26,4B
0518:  DATA 30,0D
051A:  DATA 00,00
051C:  DATA 41,54
051E:  DATA 2B,53
0520:  DATA 42,44
0522:  DATA 4D,54
0524:  DATA 41,3D
0526:  DATA 31,0D
0528:  DATA 00,00
052A:  DATA 41,54
052C:  DATA 2B,53
052E:  DATA 42,44
0530:  DATA 57,42
0532:  DATA 3D,25
0534:  DATA 6C,75
0536:  DATA 0D,00
0538:  DATA 41,54
053A:  DATA 2B,53
053C:  DATA 42,44
053E:  DATA 49,58
0540:  DATA 0D,00
0542:  DATA 41,54
0544:  DATA 2B,53
0546:  DATA 42,44
0548:  DATA 44,30
054A:  DATA 0D,00
054C:  DATA 23,20
054E:  DATA 69,72
0550:  DATA 69,64
0552:  DATA 69,75
0554:  DATA 6D,5F
0556:  DATA 6D,74
0558:  DATA 5F,72
055A:  DATA 65,63
055C:  DATA 65,69
055E:  DATA 76,65
0560:  DATA 28,29
0562:  DATA 20,73
0564:  DATA 62,64
0566:  DATA 2E,6D
0568:  DATA 74,5F
056A:  DATA 73,74
056C:  DATA 61,74
056E:  DATA 65,3D
0570:  DATA 25,75
0572:  DATA 0D,0A
0574:  DATA 00,00
0576:  DATA 41,54
0578:  DATA 45,30
057A:  DATA 0D,00
057C:  DATA 41,54
057E:  DATA 26,4B
0580:  DATA 30,0D
0582:  DATA 00,00
0584:  DATA 41,54
0586:  DATA 2B,53
0588:  DATA 42,44
058A:  DATA 4D,54
058C:  DATA 41,3D
058E:  DATA 31,0D
0590:  DATA 00,00
0592:  DATA 41,54
0594:  DATA 2B,53
0596:  DATA 42,44
0598:  DATA 52,42
059A:  DATA 0D,00
059C:  DATA 23,20
059E:  DATA 69,72
05A0:  DATA 69,64
05A2:  DATA 69,75
05A4:  DATA 6D,5F
05A6:  DATA 6D,74
05A8:  DATA 5F,72
05AA:  DATA 65,63
05AC:  DATA 65,69
05AE:  DATA 76,65
05B0:  DATA 28,29
05B2:  DATA 20,63
05B4:  DATA 68,65
05B6:  DATA 63,6B
05B8:  DATA 73,75
05BA:  DATA 6D,20
05BC:  DATA 6C,3D
05BE:  DATA 25,6C
05C0:  DATA 75,20
05C2:  DATA 72,3D
05C4:  DATA 25,6C
05C6:  DATA 75,0D
05C8:  DATA 0A,00
05CA:  DATA 23,20
05CC:  DATA 69,72
05CE:  DATA 69,64
05D0:  DATA 69,75
05D2:  DATA 6D,5F
05D4:  DATA 6D,74
05D6:  DATA 5F,72
05D8:  DATA 65,63
05DA:  DATA 65,69
05DC:  DATA 76,65
05DE:  DATA 28,29
05E0:  DATA 20,6D
05E2:  DATA 74,5F
05E4:  DATA 72,65
05E6:  DATA 61,64
05E8:  DATA 79,3D
05EA:  DATA 31,2C
05EC:  DATA 20,68
05EE:  DATA 65,72
05F0:  DATA 65,20
05F2:  DATA 69,73
05F4:  DATA 20,6F
05F6:  DATA 75,72
05F8:  DATA 20,6D
05FA:  DATA 65,73
05FC:  DATA 73,61
05FE:  DATA 67,65
0600:  DATA 3A,0D
0602:  DATA 0A,00
0604:  DATA 23,20
0606:  DATA 6D,74
0608:  DATA 5F,62
060A:  DATA 75,66
060C:  DATA 66,5B
060E:  DATA 25,6C
0610:  DATA 75,5D
0612:  DATA 3D,25
0614:  DATA 63,0D
0616:  DATA 0A,00
0618:  DATA 23,20
061A:  DATA 69,72
061C:  DATA 69,64
061E:  DATA 69,75
0620:  DATA 6D,5F
0622:  DATA 6D,74
0624:  DATA 5F,72
0626:  DATA 65,63
0628:  DATA 65,69
062A:  DATA 76,65
062C:  DATA 28,29
062E:  DATA 20,67
0630:  DATA 6F,74
0632:  DATA 20,66
0634:  DATA 69,6E
0636:  DATA 61,6C
0638:  DATA 20,4F
063A:  DATA 4B,0D
063C:  DATA 0A,00
*
078A:  DATA 23,20
078C:  DATA 64,65
078E:  DATA 76,69
0790:  DATA 63,65
0792:  DATA 51,75
0794:  DATA 65,72
0796:  DATA 79,28
0798:  DATA 29,20
079A:  DATA 6E,65
079C:  DATA 78,74
079E:  DATA 20,63
07A0:  DATA 79,63
07A2:  DATA 6C,65
07A4:  DATA 20,77
07A6:  DATA 69,6C
07A8:  DATA 6C,20
07AA:  DATA 62,65
07AC:  DATA 20,53
07AE:  DATA 42,44
07B0:  DATA 20,74
07B2:  DATA 72,61
07B4:  DATA 6E,73
07B6:  DATA 6D,69
07B8:  DATA 74,20
07BA:  DATA 63,79
07BC:  DATA 63,6C
07BE:  DATA 65,2E
07C0:  DATA 0D,0A
07C2:  DATA 00,00
07C4:  DATA 23,20
07C6:  DATA 64,65
07C8:  DATA 76,69
07CA:  DATA 63,65
07CC:  DATA 51,75
07CE:  DATA 65,72
07D0:  DATA 79,28
07D2:  DATA 29,20
07D4:  DATA 74,68
07D6:  DATA 69,73
07D8:  DATA 20,63
07DA:  DATA 79,63
07DC:  DATA 6C,65
07DE:  DATA 20,69
07E0:  DATA 73,20
07E2:  DATA 61,6E
07E4:  DATA 20,53
07E6:  DATA 42,44
07E8:  DATA 20,74
07EA:  DATA 72,61
07EC:  DATA 6E,73
07EE:  DATA 6D,69
07F0:  DATA 74,20
07F2:  DATA 63,79
07F4:  DATA 63,6C
07F6:  DATA 65,2E
07F8:  DATA 0D,0A
07FA:  DATA 00,00
07FC:  DATA 23,20
07FE:  DATA 64,65
0800:  DATA 76,69
0802:  DATA 63,65
0804:  DATA 51,75
0806:  DATA 65,72
0808:  DATA 79,28
080A:  DATA 29,20
080C:  DATA 61,64
080E:  DATA 64,69
0810:  DATA 6E,67
0812:  DATA 20,74
0814:  DATA 6F,20
0816:  DATA 73,62
0818:  DATA 64,2E
081A:  DATA 6D,6F
081C:  DATA 5F,62
081E:  DATA 75,66
0820:  DATA 66,20
0822:  DATA 73,69
0824:  DATA 6E,63
0826:  DATA 65,20
0828:  DATA 71,62
082A:  DATA 75,66
082C:  DATA 66,2E
082E:  DATA 72,45
0830:  DATA 78,63
0832:  DATA 65,70
0834:  DATA 74,69
0836:  DATA 6F,6E
0838:  DATA 3D,30
083A:  DATA 0D,0A
083C:  DATA 00,00
083E:  DATA 23,20
0840:  DATA 64,65
0842:  DATA 76,69
0844:  DATA 63,65
0846:  DATA 51,75
0848:  DATA 65,72
084A:  DATA 79,28
084C:  DATA 29,20
084E:  DATA 73,65
0850:  DATA 74,74
0852:  DATA 69,6E
0854:  DATA 67,20
0856:  DATA 73,62
0858:  DATA 64,2E
085A:  DATA 6D,6F
085C:  DATA 5F,73
085E:  DATA 74,61
0860:  DATA 74,65
0862:  DATA 3D,31
0864:  DATA 0D,0A
0866:  DATA 00,00
0868:  DATA 23,20
086A:  DATA 6D,61
086C:  DATA 69,6E
086E:  DATA 28,29
0870:  DATA 20,73
0872:  DATA 74,61
0874:  DATA 72,74
0876:  DATA 75,70
0878:  DATA 20,62
087A:  DATA 6C,69
087C:  DATA 6E,6B
087E:  DATA 69,6E
0880:  DATA 67,20
0882:  DATA 64,6F
0884:  DATA 6E,65
0886:  DATA 0D,0A
0888:  DATA 00,00
088A:  DATA 23,20
088C:  DATA 72,64
088E:  DATA 54,61
0890:  DATA 70,20
0892:  DATA 25,73
0894:  DATA 20,25
0896:  DATA 73,72
0898:  DATA 0A,00
089A:  DATA 30,39
089C:  DATA 2D,41
089E:  DATA 70,72
08A0:  DATA 2D,32
08A2:  DATA 34,00
08A4:  DATA 31,38
08A6:  DATA 3A,33
08A8:  DATA 31,3A
08AA:  DATA 30,38
08AC:  DATA 00,00
08AE:  DATA 23,20
08B0:  DATA 72,65
08B2:  DATA 73,74
08B4:  DATA 61,72
08B6:  DATA 74,20
08B8:  DATA 63,61
08BA:  DATA 75,73
08BC:  DATA 65,3A
08BE:  DATA 20,00
08C0:  DATA 57,44
08C2:  DATA 54,20
08C4:  DATA 54,49
08C6:  DATA 4D,45
08C8:  DATA 4F,55
08CA:  DATA 54,00
08CC:  DATA 4D,43
08CE:  DATA 4C,52
08D0:  DATA 20,46
08D2:  DATA 52,4F
08D4:  DATA 4D,20
08D6:  DATA 53,4C
08D8:  DATA 45,45
08DA:  DATA 50,00
08DC:  DATA 4D,43
08DE:  DATA 4C,52
08E0:  DATA 20,46
08E2:  DATA 52,4F
08E4:  DATA 4D,20
08E6:  DATA 52,55
08E8:  DATA 4E,00
08EA:  DATA 4E,4F
08EC:  DATA 52,4D
08EE:  DATA 41,4C
08F0:  DATA 20,50
08F2:  DATA 4F,57
08F4:  DATA 45,52
08F6:  DATA 20,55
08F8:  DATA 50,00
08FA:  DATA 42,52
08FC:  DATA 4F,57
08FE:  DATA 4E,4F
0900:  DATA 55,54
0902:  DATA 20,52
0904:  DATA 45,53
0906:  DATA 54,41
0908:  DATA 52,54
090A:  DATA 00,00
090C:  DATA 57,44
090E:  DATA 54,20
0910:  DATA 46,52
0912:  DATA 4F,4D
0914:  DATA 20,53
0916:  DATA 4C,45
0918:  DATA 45,50
091A:  DATA 00,00
091C:  DATA 52,45
091E:  DATA 53,45
0920:  DATA 54,20
0922:  DATA 49,4E
0924:  DATA 53,54
0926:  DATA 52,55
0928:  DATA 43,54
092A:  DATA 49,4F
092C:  DATA 4E,00
092E:  DATA 55,4E
0930:  DATA 4B,4E
0932:  DATA 4F,57
0934:  DATA 4E,21
0936:  DATA 00,00
0938:  DATA 23,20
093A:  DATA 6D,61
093C:  DATA 69,6E
093E:  DATA 28,29
0940:  DATA 20,73
0942:  DATA 62,64
0944:  DATA 2E,72
0946:  DATA 69,6E
0948:  DATA 67,5F
094A:  DATA 66,6C
094C:  DATA 61,67
094E:  DATA 3D,31
0950:  DATA 0D,0A
0952:  DATA 00,00
0954:  DATA 23,20
0956:  DATA 73,62
0958:  DATA 64,2E
095A:  DATA 73,62
095C:  DATA 64,69
095E:  DATA 78,5F
0960:  DATA 72,65
0962:  DATA 73,70
0964:  DATA 6F,6E
0966:  DATA 73,65
0968:  DATA 3D,27
096A:  DATA 25,73
096C:  DATA 27,0D
096E:  DATA 0A,00
0970:  DATA 23,20
0972:  DATA 73,62
0974:  DATA 64,2E
0976:  DATA 73,62
0978:  DATA 64,69
097A:  DATA 78,5F
097C:  DATA 6D,74
097E:  DATA 5F,71
0980:  DATA 75,65
0982:  DATA 75,65
0984:  DATA 64,20
0986:  DATA 3E,20
0988:  DATA 30,20
098A:  DATA 28,69
098C:  DATA 73,20
098E:  DATA 25,75
0990:  DATA 29,0D
0992:  DATA 0A,00
0994:  DATA 23,20
0996:  DATA 73,62
0998:  DATA 64,2E
099A:  DATA 73,62
099C:  DATA 64,69
099E:  DATA 78,5F
09A0:  DATA 6D,74
09A2:  DATA 5F,73
09A4:  DATA 74,61
09A6:  DATA 74,75
09A8:  DATA 73,3D
09AA:  DATA 31,0D
09AC:  DATA 0A,00
09AE:  DATA 23,20
09B0:  DATA 73,62
09B2:  DATA 64,2E
09B4:  DATA 6D,74
09B6:  DATA 5F,72
09B8:  DATA 65,61
09BA:  DATA 64,79
09BC:  DATA 3D,31
09BE:  DATA 0D,0A
09C0:  DATA 00,00
*
0B38:  TBLRD*+
0B3A:  MOVF   FF5,F
0B3C:  BZ    0B58
0B3E:  MOVFF  FF6,97D
0B42:  MOVFF  FF7,97E
0B46:  MOVF   FF5,W
0B48:  BTFSS  FA4.4
0B4A:  BRA    0B48
0B4C:  MOVWF  F79
0B4E:  MOVFF  97D,FF6
0B52:  MOVFF  97E,FF7
0B56:  BRA    0B38
0B58:  RETURN 0
0B5A:  TBLRD*+
0B5C:  MOVFF  FF6,97D
0B60:  MOVFF  FF7,97E
0B64:  MOVF   FF5,W
0B66:  BTFSS  FA4.4
0B68:  BRA    0B66
0B6A:  MOVWF  F79
0B6C:  MOVFF  97D,FF6
0B70:  MOVFF  97E,FF7
0B74:  MOVLB  9
0B76:  DECFSZ x7C,F
0B78:  BRA    0B7C
0B7A:  BRA    0B80
0B7C:  MOVLB  0
0B7E:  BRA    0B5A
0B80:  MOVLB  0
0B82:  RETURN 0
*
0CA2:  MOVLB  9
0CA4:  MOVF   x94,W
0CA6:  MULWF  x96
0CA8:  MOVFF  FF3,01
0CAC:  MOVFF  FF4,00
0CB0:  MULWF  x97
0CB2:  MOVF   FF3,W
0CB4:  ADDWF  00,F
0CB6:  MOVF   x95,W
0CB8:  MULWF  x96
0CBA:  MOVF   FF3,W
0CBC:  ADDWFC 00,W
0CBE:  MOVWF  02
0CC0:  MOVLB  0
0CC2:  RETURN 0
*
0F20:  MOVF   FEF,F
0F22:  BZ    0F44
0F24:  MOVFF  FEA,97B
0F28:  MOVFF  FE9,97A
0F2C:  MOVF   FEF,W
0F2E:  BTFSS  FA4.4
0F30:  BRA    0F2E
0F32:  MOVWF  F79
0F34:  MOVFF  97B,FEA
0F38:  MOVFF  97A,FE9
0F3C:  INCF   FE9,F
0F3E:  BTFSC  FD8.2
0F40:  INCF   FEA,F
0F42:  BRA    0F20
0F44:  GOTO   4206 (RETURN)
*
1090:  MOVLB  9
1092:  MOVF   x83,W
1094:  CLRF   01
1096:  SUBWF  x82,W
1098:  BC    10A0
109A:  MOVFF  982,00
109E:  BRA    10B8
10A0:  CLRF   00
10A2:  MOVLW  08
10A4:  MOVWF  x84
10A6:  RLCF   x82,F
10A8:  RLCF   00,F
10AA:  MOVF   x83,W
10AC:  SUBWF  00,W
10AE:  BTFSC  FD8.0
10B0:  MOVWF  00
10B2:  RLCF   01,F
10B4:  DECFSZ x84,F
10B6:  BRA    10A6
10B8:  MOVLB  0
10BA:  RETURN 0
10BC:  MOVLW  20
10BE:  MOVLB  9
10C0:  BTFSS  x7D.4
10C2:  MOVLW  30
10C4:  MOVWF  x7E
10C6:  MOVFF  97C,00
10CA:  BTFSS  00.7
10CC:  BRA    10DE
10CE:  COMF   00,F
10D0:  INCF   00,F
10D2:  MOVFF  00,97C
10D6:  MOVLW  2D
10D8:  MOVWF  x7E
10DA:  BSF    x7D.7
10DC:  BSF    x7D.0
10DE:  MOVF   01,W
10E0:  MOVFF  97C,982
10E4:  MOVLW  64
10E6:  MOVWF  x83
10E8:  MOVLB  0
10EA:  RCALL  1090
10EC:  MOVFF  00,97C
10F0:  MOVLW  30
10F2:  ADDWF  01,W
10F4:  MOVLB  9
10F6:  MOVWF  x7F
10F8:  MOVFF  97C,982
10FC:  MOVLW  0A
10FE:  MOVWF  x83
1100:  MOVLB  0
1102:  RCALL  1090
1104:  MOVLW  30
1106:  ADDWF  00,W
1108:  MOVLB  9
110A:  MOVWF  x81
110C:  MOVLW  30
110E:  ADDWF  01,W
1110:  MOVWF  x80
1112:  MOVFF  97E,00
1116:  MOVLW  30
1118:  SUBWF  x7F,W
111A:  BZ    1124
111C:  BSF    x7D.1
111E:  BTFSC  x7D.7
1120:  BSF    x7D.2
1122:  BRA    1148
1124:  MOVFF  97E,97F
1128:  MOVLW  20
112A:  MOVWF  x7E
112C:  MOVLW  30
112E:  SUBWF  x80,W
1130:  BZ    113A
1132:  BSF    x7D.0
1134:  BTFSC  x7D.7
1136:  BSF    x7D.1
1138:  BRA    1148
113A:  BTFSS  FD8.2
113C:  BSF    x7D.0
113E:  BNZ   1148
1140:  MOVFF  97F,980
1144:  MOVLW  20
1146:  MOVWF  x7F
1148:  BTFSC  x7D.2
114A:  BRA    1156
114C:  BTFSC  x7D.1
114E:  BRA    115E
1150:  BTFSC  x7D.0
1152:  BRA    1166
1154:  BRA    116E
1156:  MOVF   x7E,W
1158:  BTFSS  FA4.4
115A:  BRA    1158
115C:  MOVWF  F79
115E:  MOVF   x7F,W
1160:  BTFSS  FA4.4
1162:  BRA    1160
1164:  MOVWF  F79
1166:  MOVF   x80,W
1168:  BTFSS  FA4.4
116A:  BRA    1168
116C:  MOVWF  F79
116E:  MOVF   x81,W
1170:  BTFSS  FA4.4
1172:  BRA    1170
1174:  MOVWF  F79
1176:  MOVLB  0
1178:  RETURN 0
117A:  MOVFF  FEA,984
117E:  MOVFF  FE9,983
1182:  MOVLB  9
1184:  SWAPF  x7D,W
1186:  IORLW  F0
1188:  MOVWF  x7F
118A:  ADDWF  x7F,F
118C:  ADDLW  E2
118E:  MOVWF  x80
1190:  ADDLW  32
1192:  MOVWF  x82
1194:  MOVF   x7D,W
1196:  ANDLW  0F
1198:  ADDWF  x80,F
119A:  ADDWF  x80,F
119C:  ADDWF  x82,F
119E:  ADDLW  E9
11A0:  MOVWF  x81
11A2:  ADDWF  x81,F
11A4:  ADDWF  x81,F
11A6:  SWAPF  x7C,W
11A8:  ANDLW  0F
11AA:  ADDWF  x81,F
11AC:  ADDWF  x82,F
11AE:  RLCF   x81,F
11B0:  RLCF   x82,F
11B2:  COMF   x82,F
11B4:  RLCF   x82,F
11B6:  MOVF   x7C,W
11B8:  ANDLW  0F
11BA:  ADDWF  x82,F
11BC:  RLCF   x7F,F
11BE:  MOVLW  07
11C0:  MOVWF  x7E
11C2:  MOVLW  0A
11C4:  DECF   x81,F
11C6:  ADDWF  x82,F
11C8:  BNC   11C4
11CA:  DECF   x80,F
11CC:  ADDWF  x81,F
11CE:  BNC   11CA
11D0:  DECF   x7F,F
11D2:  ADDWF  x80,F
11D4:  BNC   11D0
11D6:  DECF   x7E,F
11D8:  ADDWF  x7F,F
11DA:  BNC   11D6
11DC:  MOVLW  09
11DE:  MOVWF  FEA
11E0:  MOVLW  7E
11E2:  MOVWF  FE9
11E4:  MOVLW  07
11E6:  ANDWF  x83,W
11E8:  BCF    x83.6
11EA:  ADDWF  FE9,F
11EC:  MOVLW  00
11EE:  ADDWFC FEA,F
11F0:  MOVF   FE9,W
11F2:  SUBLW  82
11F4:  BNZ   11FE
11F6:  MOVF   FEA,W
11F8:  SUBLW  09
11FA:  BNZ   11FE
11FC:  BSF    x83.6
11FE:  MOVF   FEF,W
1200:  MOVWF  00
1202:  BNZ   1214
1204:  BTFSC  x83.6
1206:  BRA    1214
1208:  BTFSC  x83.4
120A:  BRA    1224
120C:  BTFSC  x83.3
120E:  BRA    1214
1210:  MOVLW  20
1212:  BRA    121A
1214:  BSF    x83.3
1216:  BCF    x83.4
1218:  MOVLW  30
121A:  ADDWF  00,F
121C:  MOVF   00,W
121E:  BTFSS  FA4.4
1220:  BRA    121E
1222:  MOVWF  F79
1224:  MOVF   FEE,W
1226:  BTFSS  x83.6
1228:  BRA    11F0
122A:  MOVLB  0
122C:  RETURN 0
*
14EC:  MOVF   01,W
14EE:  MOVFF  97B,982
14F2:  MOVLW  64
14F4:  MOVLB  9
14F6:  MOVWF  x83
14F8:  MOVLB  0
14FA:  RCALL  1090
14FC:  MOVFF  00,97B
1500:  MOVF   01,W
1502:  MOVLW  30
1504:  BNZ   1516
1506:  MOVLB  9
1508:  BTFSS  x7C.1
150A:  BRA    1528
150C:  BTFSC  x7C.3
150E:  BRA    1528
1510:  BTFSC  x7C.4
1512:  MOVLW  20
1514:  BRA    151E
1516:  MOVLB  9
1518:  BCF    x7C.3
151A:  BCF    x7C.4
151C:  BSF    x7C.0
151E:  ADDWF  01,F
1520:  MOVF   01,W
1522:  BTFSS  FA4.4
1524:  BRA    1522
1526:  MOVWF  F79
1528:  MOVFF  97B,982
152C:  MOVLW  0A
152E:  MOVWF  x83
1530:  MOVLB  0
1532:  RCALL  1090
1534:  MOVFF  00,97B
1538:  MOVF   01,W
153A:  MOVLW  30
153C:  BNZ   154E
153E:  MOVLB  9
1540:  BTFSC  x7C.3
1542:  BRA    155A
1544:  BTFSS  x7C.0
1546:  BRA    155A
1548:  BTFSC  x7C.4
154A:  MOVLW  20
154C:  MOVLB  0
154E:  ADDWF  01,F
1550:  MOVF   01,W
1552:  BTFSS  FA4.4
1554:  BRA    1552
1556:  MOVWF  F79
1558:  MOVLB  9
155A:  MOVLW  30
155C:  ADDWF  x7B,F
155E:  MOVF   x7B,W
1560:  BTFSS  FA4.4
1562:  BRA    1560
1564:  MOVWF  F79
1566:  MOVLB  0
1568:  RETURN 0
*
1604:  MOVLB  9
1606:  BTFSC  x7C.7
1608:  BRA    162A
160A:  MOVLW  0F
160C:  MOVWF  00
160E:  SWAPF  x7B,W
1610:  ANDWF  00,F
1612:  MOVLW  0A
1614:  SUBWF  00,W
1616:  BC    161E
1618:  MOVLW  30
161A:  ADDWF  00,F
161C:  BRA    1622
161E:  MOVF   x7C,W
1620:  ADDWF  00,F
1622:  MOVF   00,W
1624:  BTFSS  FA4.4
1626:  BRA    1624
1628:  MOVWF  F79
162A:  MOVLW  0F
162C:  ANDWF  x7B,F
162E:  MOVLW  0A
1630:  SUBWF  x7B,W
1632:  BC    1638
1634:  MOVLW  30
1636:  BRA    163C
1638:  BCF    x7C.7
163A:  MOVF   x7C,W
163C:  ADDWF  x7B,F
163E:  MOVF   x7B,W
1640:  BTFSS  FA4.4
1642:  BRA    1640
1644:  MOVWF  F79
1646:  MOVLB  0
1648:  GOTO   167C (RETURN)
*
1742:  TBLRD*+
1744:  MOVF   FF5,F
1746:  BZ    1760
1748:  MOVFF  FF6,97E
174C:  MOVFF  FF7,97F
1750:  MOVFF  FF5,987
1754:  RCALL  1732
1756:  MOVFF  97E,FF6
175A:  MOVFF  97F,FF7
175E:  BRA    1742
1760:  RETURN 0
*
1B12:  TBLRD*+
1B14:  MOVFF  FF6,97F
1B18:  MOVFF  FF7,980
1B1C:  MOVFF  FF5,987
1B20:  RCALL  1732
1B22:  MOVFF  97F,FF6
1B26:  MOVFF  980,FF7
1B2A:  MOVLB  9
1B2C:  DECFSZ x7E,F
1B2E:  BRA    1B32
1B30:  BRA    1B36
1B32:  MOVLB  0
1B34:  BRA    1B12
1B36:  MOVLB  0
1B38:  GOTO   1DB8 (RETURN)
1B3C:  MOVFF  FEA,986
1B40:  MOVFF  FE9,985
1B44:  MOVLB  9
1B46:  SWAPF  x7F,W
1B48:  IORLW  F0
1B4A:  MOVWF  x81
1B4C:  ADDWF  x81,F
1B4E:  ADDLW  E2
1B50:  MOVWF  x82
1B52:  ADDLW  32
1B54:  MOVWF  x84
1B56:  MOVF   x7F,W
1B58:  ANDLW  0F
1B5A:  ADDWF  x82,F
1B5C:  ADDWF  x82,F
1B5E:  ADDWF  x84,F
1B60:  ADDLW  E9
1B62:  MOVWF  x83
1B64:  ADDWF  x83,F
1B66:  ADDWF  x83,F
1B68:  SWAPF  x7E,W
1B6A:  ANDLW  0F
1B6C:  ADDWF  x83,F
1B6E:  ADDWF  x84,F
1B70:  RLCF   x83,F
1B72:  RLCF   x84,F
1B74:  COMF   x84,F
1B76:  RLCF   x84,F
1B78:  MOVF   x7E,W
1B7A:  ANDLW  0F
1B7C:  ADDWF  x84,F
1B7E:  RLCF   x81,F
1B80:  MOVLW  07
1B82:  MOVWF  x80
1B84:  MOVLW  0A
1B86:  DECF   x83,F
1B88:  ADDWF  x84,F
1B8A:  BNC   1B86
1B8C:  DECF   x82,F
1B8E:  ADDWF  x83,F
1B90:  BNC   1B8C
1B92:  DECF   x81,F
1B94:  ADDWF  x82,F
1B96:  BNC   1B92
1B98:  DECF   x80,F
1B9A:  ADDWF  x81,F
1B9C:  BNC   1B98
1B9E:  MOVLW  09
1BA0:  MOVWF  FEA
1BA2:  MOVLW  80
1BA4:  MOVWF  FE9
1BA6:  MOVLW  07
1BA8:  ANDWF  x85,W
1BAA:  BCF    x85.6
1BAC:  ADDWF  FE9,F
1BAE:  MOVLW  00
1BB0:  ADDWFC FEA,F
1BB2:  MOVF   FE9,W
1BB4:  SUBLW  84
1BB6:  BNZ   1BC0
1BB8:  MOVF   FEA,W
1BBA:  SUBLW  09
1BBC:  BNZ   1BC0
1BBE:  BSF    x85.6
1BC0:  MOVF   FEF,W
1BC2:  MOVWF  00
1BC4:  BNZ   1BD6
1BC6:  BTFSC  x85.6
1BC8:  BRA    1BD6
1BCA:  BTFSC  x85.4
1BCC:  BRA    1BF8
1BCE:  BTFSC  x85.3
1BD0:  BRA    1BD6
1BD2:  MOVLW  20
1BD4:  BRA    1BDC
1BD6:  BSF    x85.3
1BD8:  BCF    x85.4
1BDA:  MOVLW  30
1BDC:  ADDWF  00,F
1BDE:  MOVFF  FEA,97F
1BE2:  MOVFF  FE9,97E
1BE6:  MOVFF  00,987
1BEA:  MOVLB  0
1BEC:  RCALL  1732
1BEE:  MOVFF  97F,FEA
1BF2:  MOVFF  97E,FE9
1BF6:  MOVLB  9
1BF8:  MOVF   FEE,W
1BFA:  BTFSS  x85.6
1BFC:  BRA    1BB2
1BFE:  MOVLB  0
1C00:  GOTO   1DC6 (RETURN)
*
325E:  ADDWF  FE8,W
3260:  CLRF   FF7
3262:  RLCF   FF7,F
3264:  ADDLW  79
3266:  MOVWF  FF6
3268:  MOVLW  32
326A:  ADDWFC FF7,F
326C:  TBLRD*-
326E:  MOVF   FF5,W
3270:  MOVWF  FFA
3272:  TBLRD*
3274:  MOVF   FF5,W
3276:  MOVWF  FF9
3278:  DATA C4,2E
327A:  DATA F6,2E
327C:  DATA 38,2F
327E:  DATA 76,2F
3280:  DATA B4,2F
3282:  DATA 48,30
3284:  DATA DC,30
3286:  DATA 1E,31
*
35FC:  ADDWF  FE8,W
35FE:  CLRF   FF7
3600:  RLCF   FF7,F
3602:  ADDLW  17
3604:  MOVWF  FF6
3606:  MOVLW  36
3608:  ADDWFC FF7,F
360A:  TBLRD*-
360C:  MOVF   FF5,W
360E:  MOVWF  FFA
3610:  TBLRD*
3612:  MOVF   FF5,W
3614:  MOVWF  FF9
3616:  DATA 52,33
3618:  DATA 82,33
361A:  DATA C4,33
361C:  DATA 00,34
361E:  DATA 3C,34
3620:  DATA 48,34
3622:  DATA 98,34
3624:  DATA DA,34
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses NOPUT
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... //#fuses WDT512
.................... #fuses WDT1024
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... 
.................... 
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
*
1C2A:  MOVFF  97F,985
1C2E:  MOVFF  97E,984
1C32:  MOVLB  9
1C34:  MOVF   x82,F
1C36:  BNZ   1C3C
1C38:  MOVF   x83,F
1C3A:  BZ    1C82
1C3C:  MOVFF  981,FEA
1C40:  MOVFF  980,FE9
1C44:  MOVF   FEF,F
1C46:  BZ    1C82
....................      *s++ = *s2++;
1C48:  MOVFF  985,03
1C4C:  MOVF   x84,W
1C4E:  INCF   x84,F
1C50:  BTFSC  FD8.2
1C52:  INCF   x85,F
1C54:  MOVWF  x86
1C56:  MOVFF  03,987
1C5A:  MOVFF  981,FEA
1C5E:  MOVF   x80,W
1C60:  INCF   x80,F
1C62:  BTFSC  FD8.2
1C64:  INCF   x81,F
1C66:  MOVWF  FE9
1C68:  MOVFF  FEF,988
1C6C:  MOVFF  03,FEA
1C70:  MOVFF  986,FE9
1C74:  MOVFF  988,FEF
1C78:  MOVF   x82,W
1C7A:  BTFSC  FD8.2
1C7C:  DECF   x83,F
1C7E:  DECF   x82,F
1C80:  BRA    1C34
....................   for (; n > 0; n--)
1C82:  MOVF   x82,F
1C84:  BNZ   1C8A
1C86:  MOVF   x83,F
1C88:  BZ    1CA4
....................      *s++ = '\0';
1C8A:  MOVFF  985,FEA
1C8E:  MOVF   x84,W
1C90:  INCF   x84,F
1C92:  BTFSC  FD8.2
1C94:  INCF   x85,F
1C96:  MOVWF  FE9
1C98:  CLRF   FEF
1C9A:  MOVF   x82,W
1C9C:  BTFSC  FD8.2
1C9E:  DECF   x83,F
1CA0:  DECF   x82,F
1CA2:  BRA    1C82
.................... 
....................   return(s1);
1CA4:  MOVFF  97E,01
1CA8:  MOVFF  97F,02
1CAC:  MOVLB  0
1CAE:  GOTO   1F70 (RETURN)
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
*
0FDA:  MOVFF  97F,FEA
0FDE:  MOVLB  9
0FE0:  MOVFF  97E,FE9
0FE4:  MOVF   x80,W
0FE6:  SUBWF  FEF,W
0FE8:  BZ    100E
....................       if (*s == '\0')
0FEA:  MOVFF  97F,03
0FEE:  MOVFF  97E,FE9
0FF2:  MOVFF  03,FEA
0FF6:  MOVF   FEF,F
0FF8:  BNZ   1002
....................          return(0);
0FFA:  MOVLW  00
0FFC:  MOVWF  01
0FFE:  MOVWF  02
1000:  BRA    1016
1002:  INCF   x7E,F
1004:  BTFSC  FD8.2
1006:  INCF   x7F,F
1008:  MOVLB  0
100A:  BRA    0FDA
100C:  MOVLB  9
....................    return(s);
100E:  MOVFF  97E,01
1012:  MOVFF  97F,02
1016:  MOVLB  0
1018:  RETURN 0
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0F48:  MOVFF  97D,97F
0F4C:  MOVFF  97C,97E
0F50:  MOVFF  97F,FEA
0F54:  MOVLB  9
0F56:  MOVFF  97E,FE9
0F5A:  MOVF   FEF,F
0F5C:  BZ    0F6A
0F5E:  INCF   x7E,F
0F60:  BTFSC  FD8.2
0F62:  INCF   x7F,F
0F64:  MOVLB  0
0F66:  BRA    0F50
0F68:  MOVLB  9
....................    return(sc - s);
0F6A:  MOVF   x7C,W
0F6C:  SUBWF  x7E,W
0F6E:  MOVWF  00
0F70:  MOVF   x7D,W
0F72:  SUBWFB x7F,W
0F74:  MOVWF  03
0F76:  MOVFF  00,01
0F7A:  MOVWF  02
0F7C:  MOVLB  0
0F7E:  GOTO   123C (RETURN)
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
0A94:  MOVLW  09
0A96:  MOVWF  FEA
0A98:  MOVLW  90
0A9A:  MOVWF  FE9
0A9C:  MOVF   FEF,W
0A9E:  BZ    0AC2
0AA0:  MOVLW  02
0AA2:  MOVWF  01
0AA4:  MOVLW  BF
0AA6:  MOVWF  00
0AA8:  CLRWDT
0AAA:  DECFSZ 00,F
0AAC:  BRA    0AA8
0AAE:  DECFSZ 01,F
0AB0:  BRA    0AA4
0AB2:  MOVLW  96
0AB4:  MOVWF  00
0AB6:  DECFSZ 00,F
0AB8:  BRA    0AB6
0ABA:  BRA    0ABC
0ABC:  CLRWDT
0ABE:  DECFSZ FEF,F
0AC0:  BRA    0AA0
0AC2:  RETURN 0
*
1C04:  MOVLW  09
1C06:  MOVLB  9
1C08:  SUBWF  x7F,F
1C0A:  BNC   1C24
1C0C:  MOVLW  09
1C0E:  MOVWF  FEA
1C10:  MOVLW  7F
1C12:  MOVWF  FE9
1C14:  BCF    FD8.0
1C16:  RRCF   FEF,F
1C18:  MOVF   FEF,W
1C1A:  BZ    1C24
1C1C:  BRA    1C20
1C1E:  CLRWDT
1C20:  DECFSZ FEF,F
1C22:  BRA    1C1E
1C24:  MOVLB  0
1C26:  GOTO   1E68 (RETURN)
.................... 
.................... /* 
.................... Parameters and devices are stored in 1024 byte EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x0000
.................... #define DEVICE_CRC_ADDRESS 0x0002
.................... 
.................... #define PARAM_ADDRESS      0x0004 /* parameters go from 4 to 127 ... 123 bytes max */ 
.................... #define DEVICE_ADDRESS     0x0080 /* devices go from 128 to 1024 ... 896 bytes max */
.................... 
.................... 
.................... /* uart1 is for modbus and set in modbus_int_uart */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600, errors)	
*
069E:  BTFSS  FA4.5
06A0:  BRA    069E
06A2:  MOVFF  FA6,20
06A6:  MOVFF  F7A,01
06AA:  BTFSS  20.1
06AC:  BRA    06B2
06AE:  BCF    FA6.4
06B0:  BSF    FA6.4
06B2:  RETURN 0
*
22EC:  BTFSS  FA4.4
22EE:  BRA    22EC
22F0:  MOVWF  F79
22F2:  RETURN 0
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
09CC:  BCF    FC6.7
09CE:  BCF    F9E.3
09D0:  MOVFF  98D,FC9
09D4:  MOVLW  02
09D6:  BTFSC  FC6.7
09D8:  BRA    09E4
09DA:  BTFSC  FC7.2
09DC:  BRA    09DA
09DE:  MOVLW  00
09E0:  BTFSC  FC5.6
09E2:  MOVLW  01
09E4:  MOVWF  01
09E6:  RETURN 0
*
156A:  BCF    FC6.6
156C:  BSF    FC5.3
156E:  BTFSC  FC5.3
1570:  BRA    156E
1572:  BTFSC  00.0
1574:  BCF    FC5.5
1576:  BTFSS  00.0
1578:  BSF    FC5.5
157A:  BSF    FC5.4
157C:  BTFSC  FC5.4
157E:  BRA    157C
1580:  MOVFF  FC9,01
1584:  RETURN 0
.................... 
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /* device types for struct_device */
.................... #define DEV_TYPE_DISABLED       0
.................... 
.................... /* modbus slave on RS-485 bus */
.................... #define DEV_TYPE_MODBUS_1       1
.................... #define DEV_TYPE_MODBUS_2       2
.................... #define DEV_TYPE_MODBUS_3       3
.................... #define DEV_TYPE_MODBUS_4       4
.................... #define DEV_TYPE_MODBUS_5       5
.................... #define DEV_TYPE_MODBUS_6       6
.................... #define DEV_TYPE_MODBUS_16      7
.................... #define DEV_TYPE_MODBUS_MAX     7
.................... 
.................... /* I2C slave on I2C bus */
.................... #define DEV_TYPE_I2C_READ_8     16
.................... #define DEV_TYPE_I2C_READ_16    17
.................... #define DEV_TYPE_I2C_READ_24    18
.................... #define DEV_TYPE_I2C_READ_32    19
.................... #define DEV_TYPE_I2C_WRITE_8    20
.................... #define DEV_TYPE_I2C_WRITE_16   21
.................... #define DEV_TYPE_I2C_WRITE_24   22
.................... #define DEV_TYPE_I2C_WRITE_32   23
.................... #define DEV_TYPE_I2C_MAX        23
.................... 
.................... /* local registers on this device */
.................... #define DEV_TYPE_LOCAL_READ_16  32
.................... #define DEV_TYPE_LOCAL_WRITE_16 33
.................... #define DEV_TYPE_LOCAL_MAX      33
.................... 
.................... 
.................... 
.................... /* serial port speeds */
.................... #define DEV_SERIAL_9600  0
.................... #define DEV_SERIAL_19200 1
.................... 
.................... 
.................... #define DEV_MAX_N 64
.................... 
.................... #include "worldDeviceTypes.h"
.................... /* Continental Control Systems, Watt Node Modbus */
.................... #define DEVICE_TYPE_WORLD_WNC_BASIC           1  /* 1000, 34 */
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED        2
.................... #define DEVICE_TYPE_WORLD_WNC_CONFIGURATION   3
.................... #define DEVICE_TYPE_WORLD_WNC_DIAGNOSTIC      4
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED_ENERGY 5  /* 1100, 38 */
.................... 
.................... /* APRS World, XRW2G */
.................... #define DEVICE_TYPE_WORLD_XRW2G_BASIC         100 /* 0, 46 */
.................... #define DEVICE_TYPE_WORLD_XRW2G_DIAGNOSTIC    101
.................... #define DEVICE_TYPE_WORLD_XRW2G_CONFIGURATION 102
.................... 
.................... /* Morningstar, Relay Driver */
.................... #define DEVICE_TYPE_WORLD_RD1_RAM             200 /* 0, 18 */
.................... #define DEVICE_TYPE_WORLD_RD1_COILS           201 /* 0, 4 */
.................... 
.................... /* Morningstar, Tri-Star */
.................... #define DEVICE_TYPE_WORLD_TS_RAM              300 /* 8, 21 */
.................... #define DEVICE_TYPE_WORLD_TS_COILS            301
.................... #define DEVICE_TYPE_WORLD_TS_EEPROM           302
.................... #define DEVICE_TYPE_WORLD_TS_KWH              303 /* 57388, 3 */
.................... 
.................... /* Morningstar, Tri-Star MPPT */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_SCALING                  320 /* 0, 4 */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_FILTERED_ADC             321 /* 24, 38 */
.................... 
.................... /* Advancetech, Adam 4xxx MODBUS */
.................... #define ADAM_4XXX_ANALOG_CURRENT                          400 /* 0, 8 */
.................... 
.................... /* smaller block definitions for SatCon PVS50 ... not implemented or seen in the wild. Do not use */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_SOFTWARE           500 /* 30009, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_ACTIVE_FAULTS      501 /* 30017, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_DC                 502 /* 30020, 4 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_CURRENT    503 /* 30035, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_VOLTAGE    504 /* 30040, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_POWER           505 /* 30043, 5 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_GROUND_IMPEDANCE   506 /* 30049, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT     507 /* 30050, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT_AVG 508 /* 30089, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH         509 /* 30090, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH_AVG     510 /* 30129, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_KWH                511 /* 30131, 8 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_TIMERS             512 /* 30275, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STATE              513 /* 30279, 2 */
.................... 
.................... /* SatCon PVS50 inverter. Manual has +30001 offset. */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_0      520 /* 9, 40 registers ... error, should be 41 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_1      521 /* 50, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_2      522 /* 90, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_3      523 /* 131, 8 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_4      524 /* 175, 2 registers ... not programmed at west point! */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_5      525 /* 275, 6 registers ... */
.................... 
.................... 
.................... /* PC&S Multitek MP850MPDV19PE CUSTOM 1 */
.................... /* Registers re-arranged to be consecutive, starting with reg 0 */
.................... /* Values are 32-bit Floating Point */
.................... /* Register list: */
.................... /* 0 - V 1 ... Voltage */
.................... /* 2 - I 1 ... Current */
.................... /* 4 - kW Sum */
.................... /* 6 - kWHr (Import) */
.................... /* 8 - kWd  (Import) ... Demand over last 3 minutes */
.................... /* 10 - Ad ... Demand current over last 3 minutes*/
.................... /* 12 - kWHr (Export) */
.................... /* 14 - A.h */
.................... /* 16 - Max kWd (Import) */
.................... /* 18 - Max Ad */
.................... 
.................... #define DEVICE_TYPE_WORLD_M850MPD_CUSTOM_1	 600 /* 0, 20 registers */
.................... 
.................... 
.................... #define DEVICE_TYPE_WORLD_SHUNTMONITOR_BASIC  700 /* 0, 32 registers */
.................... 
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_BASIC      800 /* 0, 39 registers */
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_CONFIG     801 /* 1000, 15 registers */
.................... 
.................... /* Midnite Solar Classic - based on 2011-05-21 specification */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_BASIC       900 /* 4113, 31 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_WIND_CURVE  901 /* 4300, 16 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_RESTING     902 /* 4274, 3  registers */
.................... 
.................... /* APRS World POE Monitor */
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_BASIC    1000 
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_CONFIG   1001
.................... 
.................... /* APRS World watchdog Arlo */
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_BASIC  1100
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_CONFIG 1101
.................... 
.................... /* China HUM temperature and relative humidity sensor */
.................... #define DEVICE_TYPE_WORLD_HUM_TEMPERATURE      1200
.................... #define DEVICE_TYPE_WORLD_HUM_RELATIVEHUMIDITY 1201
.................... 
.................... /* "Center" brand soundmeter */
.................... #define TYPE_TYPE_WORLD_SOUNDMETER_CENTER      1300
.................... 
.................... /* PS2Tap */
.................... #define DEVICE_TYPE_WORLD_PS2TAP_BASIC         1400 /* 0, 19 registers */
.................... 
.................... /* Veris E50 Series Power Meter */
.................... #define DEVICE_TYPE_WORLD_VERISE50_BASIC       1500 /* 256, 54 registers */
.................... 
.................... 
.................... /* Note: List not complete.  Reference master list in WorldDataCollector. */
.................... 
.................... 
.................... /* generic rsdata */
.................... #define DEVICE_TYPE_WORLD_RSDATA               32000 /* Integer */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT         32001 /* IEEE-754 single precision floating point (32-bit) data */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT_LITTLE  32002 
.................... 
.................... 
.................... typedef struct {
.................... 	int8  type;           /* device query type */
.................... 	int16 typeWorld;      /* see worldDeviceTypes.h for defines */
.................... 	int8  transmitEvery;
.................... 	int8  networkAddress; /* modbus or I2C address */
.................... 	int32 serialNumber;   /* APRS World or other serial number */
.................... 	int16 startRegister;
.................... 	int8  nRegisters;
.................... 	int8  serialSpeed;    /* see rsTap.h for defines */
.................... } struct_device;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  now_poll;
.................... 	int8  world_timeout;
.................... 	int8  factory_unlocked;
.................... 	int8  led_on_green;
.................... 	int16 sbd_cycle;
.................... } struct_timer;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  rException;
.................... 	int8  rResult[256];
.................... 	int8  rResultLength;
.................... 	int8  deviceNumber;
.................... 	int16 measurementNumber;
.................... } struct_qbuff;
.................... 
.................... typedef struct {
.................... 	int8 buff[256];
.................... 	int8 buff_pos;
.................... 	int8 buff_ready;
.................... 
.................... 	int8  packet_length;
.................... 	int32 query_id;
.................... 	int32 device_serial;
.................... 	int16 network_address;
.................... 	int16 function;
.................... 	int16 start_address;
.................... 	int8  n_words;
.................... 	int8  data_start_offset;
.................... 	int16 crc;
.................... 
.................... 	int8  resultException;
.................... 	int8  resultLength;
.................... } struct_query;
.................... 
.................... typedef struct {
.................... 	int8  serial_prefix;
.................... 	int16 serial_number;
.................... 	
.................... 	int16 live_interval;
.................... 
.................... 	/* Iridium SBD or other limited bandwidth transmission */
.................... 	/* 0 is no SBD, 1...5 is SBD modem with power switch on CONTROL pin 1...5 */
.................... 	int8  sbd_config;
.................... 
.................... 	/*	
.................... 	every n'th live transmission we transmit the SBD data
.................... 	Interval should be at least 10 minutes to allow for full retry cycle	
.................... 	on cycle before transmit, we clear previous buffer and turn on modem 
.................... 	*/
.................... 	int16 sbd_every;
.................... 
.................... } struct_config;
.................... 
.................... /* global structures */
.................... struct_device device[DEV_MAX_N];
.................... struct_timer  timers;
.................... struct_qbuff  qbuff;
.................... struct_query  query;
.................... struct_config config;
.................... 
.................... #include "i2c_access_rdTap.c"
.................... int16 i2c_register_read16(int8 i2c_address, int8 regaddr) {
.................... 	int8 msb, lsb;
.................... 
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address);
.................... 	i2c_write(regaddr);
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address | 1);  // read cycle
.................... 	msb=i2c_read(1);
.................... 	lsb=i2c_read(0);                                
.................... 	i2c_stop();
.................... 
.................... 	return make16(msb,lsb);
.................... }
.................... 
.................... void i2c_buff_read(int8 i2c_address, int8 regaddr, int8 *data, int8 count) {
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
*
25F0:  BSF    FC5.0
25F2:  BTFSC  FC5.0
25F4:  BRA    25F2
.................... 	delay_us(15);
25F6:  CLRWDT
25F8:  MOVLW  09
25FA:  MOVWF  00
25FC:  DECFSZ 00,F
25FE:  BRA    25FC
2600:  NOP   
.................... 	i2c_write(i2c_address);
2602:  MOVFF  982,98D
2606:  CALL   09CC
.................... 	i2c_write(regaddr);
260A:  MOVFF  983,98D
260E:  CALL   09CC
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
2612:  BSF    FC5.1
2614:  BTFSC  FC5.1
2616:  BRA    2614
.................... 	delay_us(15);
2618:  CLRWDT
261A:  MOVLW  09
261C:  MOVWF  00
261E:  DECFSZ 00,F
2620:  BRA    261E
2622:  NOP   
.................... 	i2c_write(i2c_address | 1);  // read cycle
2624:  MOVLB  9
2626:  MOVF   x82,W
2628:  IORLW  01
262A:  MOVWF  x87
262C:  MOVWF  x8D
262E:  MOVLB  0
2630:  CALL   09CC
.................... 
.................... 	/* stop reading before last byte */	
.................... 	while ( count-- != 1 ) {
2634:  MOVLB  9
2636:  MOVF   x86,W
2638:  DECF   x86,F
263A:  SUBLW  01
263C:  BZ    265E
.................... 		*data=i2c_read(1);
263E:  MOVFF  985,FEA
2642:  MOVFF  984,FE9
2646:  MOVLW  01
2648:  MOVWF  00
264A:  MOVLB  0
264C:  CALL   156A
2650:  MOVFF  01,FEF
.................... 		data++;
2654:  MOVLB  9
2656:  INCF   x84,F
2658:  BTFSC  FD8.2
265A:  INCF   x85,F
265C:  BRA    2636
.................... 	}
.................... 
.................... 	/* send last byte with a NAK */
.................... 	*data=i2c_read(0);                                
265E:  MOVFF  985,FEA
2662:  MOVFF  984,FE9
2666:  CLRF   00
2668:  MOVLB  0
266A:  CALL   156A
266E:  MOVFF  01,FEF
.................... 	i2c_stop();
2672:  BSF    FC5.2
2674:  BTFSC  FC5.2
2676:  BRA    2674
2678:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void i2c_register_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start();
*
3A0A:  BSF    FC5.0
3A0C:  BTFSC  FC5.0
3A0E:  BRA    3A0C
.................... 	delay_us(15);                                                 
3A10:  CLRWDT
3A12:  MOVLW  09
3A14:  MOVWF  00
3A16:  DECFSZ 00,F
3A18:  BRA    3A16
3A1A:  NOP   
.................... 	i2c_write(i2c_address); // write cycle                       
3A1C:  MOVFF  988,98D
3A20:  CALL   09CC
.................... 	i2c_write(regaddr);  // write cycle         
3A24:  MOVFF  989,98D
3A28:  CALL   09CC
.................... 	i2c_write(make8(value,1));
3A2C:  MOVFF  98B,98D
3A30:  CALL   09CC
.................... 	i2c_write(make8(value,0));
3A34:  MOVFF  98A,98D
3A38:  CALL   09CC
.................... 	i2c_stop();
3A3C:  BSF    FC5.2
3A3E:  BTFSC  FC5.2
3A40:  BRA    3A3E
3A42:  GOTO   3D56 (RETURN)
.................... }
.................... 
.................... void i2c_register_write32(int8 i2c_address, int8 regaddr, int32 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle     
.................... 	i2c_write(make8(value,3));
.................... 	i2c_write(make8(value,2));    
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... #include "mcp3208_rdTap.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
.................... 	output_high(CS_ADC0);
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
.................... 	output_high(MCP3208_DIN);
.................... 
.................... 
.................... 	if ( ch<8 ) {
.................... 		output_low(CS_ADC0);
.................... 	} else {
.................... 		output_low(CS_ADC1);
.................... 		ch-=8;
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
.................... 		c=0b00011;
.................... 	else if ( 1 == ch ) 
.................... 		c=0b10011;
.................... 	else if ( 2 == ch ) 
.................... 		c=0b01011;
.................... 	else if ( 3 == ch ) 
.................... 		c=0b11011;
.................... 	else if ( 4 == ch )
.................... 		c=0b00111;
.................... 	else if ( 5 == ch ) 
.................... 		c=0b10111;
.................... 	else if ( 6 == ch )
.................... 		c=0b01111;
.................... 	else
.................... 		c=0b11111;
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		output_bit(MCP3208_DIN,c&1);
.................... 		c=c>>1;
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 
.................... 	value=0;
.................... 	for ( i=0 ; i<14 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 	bit_clear(value,13);
.................... 	bit_clear(value,12);
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
.................... 
.................... 	return value;
.................... }
.................... 
.................... #include "uart_sc16is740_rdTap.c"
.................... /* register map for SC16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
*
1586:  BSF    FC5.0
1588:  BTFSC  FC5.0
158A:  BRA    1588
.................... 	delay_us(15);
158C:  CLRWDT
158E:  MOVLW  09
1590:  MOVWF  00
1592:  DECFSZ 00,F
1594:  BRA    1592
1596:  NOP   
.................... 	i2c_write(UART_ADDR);
1598:  MOVLW  9A
159A:  MOVLB  9
159C:  MOVWF  x8D
159E:  MOVLB  0
15A0:  CALL   09CC
.................... 	i2c_write(regaddr<<3);
15A4:  MOVLB  9
15A6:  RLCF   x7B,W
15A8:  MOVWF  x7D
15AA:  RLCF   x7D,F
15AC:  RLCF   x7D,F
15AE:  MOVLW  F8
15B0:  ANDWF  x7D,F
15B2:  MOVFF  97D,98D
15B6:  MOVLB  0
15B8:  CALL   09CC
.................... 	i2c_start();
15BC:  BSF    FC5.1
15BE:  BTFSC  FC5.1
15C0:  BRA    15BE
.................... 	delay_us(15);
15C2:  CLRWDT
15C4:  MOVLW  09
15C6:  MOVWF  00
15C8:  DECFSZ 00,F
15CA:  BRA    15C8
15CC:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
15CE:  MOVLW  9B
15D0:  MOVLB  9
15D2:  MOVWF  x8D
15D4:  MOVLB  0
15D6:  CALL   09CC
.................... 	data=i2c_read(0);
15DA:  CLRF   00
15DC:  RCALL  156A
15DE:  MOVFF  01,97C
.................... 	i2c_stop();
15E2:  BSF    FC5.2
15E4:  BTFSC  FC5.2
15E6:  BRA    15E4
.................... 
.................... 	return data;
15E8:  MOVLB  9
15EA:  MOVFF  97C,01
15EE:  MOVLB  0
15F0:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
09E8:  BSF    FC5.0
09EA:  BTFSC  FC5.0
09EC:  BRA    09EA
.................... 	delay_us(15);                                                 
09EE:  CLRWDT
09F0:  MOVLW  09
09F2:  MOVWF  00
09F4:  DECFSZ 00,F
09F6:  BRA    09F4
09F8:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
09FA:  MOVLW  9A
09FC:  MOVLB  9
09FE:  MOVWF  x8D
0A00:  MOVLB  0
0A02:  RCALL  09CC
.................... 	i2c_write(regaddr<< 3);  // write cycle         
0A04:  MOVLB  9
0A06:  RLCF   x88,W
0A08:  MOVWF  x8A
0A0A:  RLCF   x8A,F
0A0C:  RLCF   x8A,F
0A0E:  MOVLW  F8
0A10:  ANDWF  x8A,F
0A12:  MOVFF  98A,98D
0A16:  MOVLB  0
0A18:  RCALL  09CC
.................... 	i2c_write(data);
0A1A:  MOVFF  989,98D
0A1E:  RCALL  09CC
.................... 	i2c_stop();
0A20:  BSF    FC5.2
0A22:  BTFSC  FC5.2
0A24:  BRA    0A22
0A26:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
1732:  MOVLB  9
1734:  CLRF   x88
1736:  MOVFF  987,989
173A:  MOVLB  0
173C:  CALL   09E8
1740:  RETURN 0
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
15F2:  MOVLW  05
15F4:  MOVLB  9
15F6:  MOVWF  x7B
15F8:  MOVLB  0
15FA:  RCALL  1586
15FC:  MOVF   01,W
15FE:  ANDLW  01
1600:  MOVWF  01
1602:  RETURN 0
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
*
164C:  MOVLB  9
164E:  CLRF   x7B
1650:  MOVLB  0
1652:  RCALL  1586
1654:  MOVF   01,W
*
189E:  MOVLB  9
18A0:  CLRF   x7B
18A2:  MOVLB  0
18A4:  RCALL  1586
18A6:  MOVF   01,W
*
18C6:  MOVLB  9
18C8:  CLRF   x7B
18CA:  MOVLB  0
18CC:  RCALL  1586
18CE:  MOVF   01,W
*
1910:  MOVLB  9
1912:  CLRF   x7B
1914:  MOVLB  0
1916:  RCALL  1586
1918:  MOVF   01,W
*
196C:  MOVLB  9
196E:  CLRF   x7B
1970:  MOVLB  0
1972:  RCALL  1586
1974:  MOVF   01,W
*
1994:  MOVLB  9
1996:  CLRF   x7B
1998:  MOVLB  0
199A:  RCALL  1586
199C:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
0A28:  MOVLW  03
0A2A:  MOVLB  9
0A2C:  MOVWF  x88
0A2E:  MOVLW  80
0A30:  MOVWF  x89
0A32:  MOVLB  0
0A34:  RCALL  09E8
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
0A36:  MOVLB  9
0A38:  CLRF   x88
0A3A:  MOVFF  97A,989
0A3E:  MOVLB  0
0A40:  RCALL  09E8
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
0A42:  MOVLW  01
0A44:  MOVLB  9
0A46:  MOVWF  x88
0A48:  CLRF   x89
0A4A:  MOVLB  0
0A4C:  RCALL  09E8
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
0A4E:  MOVLW  03
0A50:  MOVLB  9
0A52:  MOVWF  x88
0A54:  MOVLW  BF
0A56:  MOVWF  x89
0A58:  MOVLB  0
0A5A:  RCALL  09E8
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
0A5C:  MOVLW  02
0A5E:  MOVLB  9
0A60:  MOVWF  x88
0A62:  MOVLW  10
0A64:  MOVWF  x89
0A66:  MOVLB  0
0A68:  RCALL  09E8
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
0A6A:  MOVLW  03
0A6C:  MOVLB  9
0A6E:  MOVWF  x88
0A70:  MOVWF  x89
0A72:  MOVLB  0
0A74:  RCALL  09E8
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
0A76:  MOVLW  01
0A78:  MOVLB  9
0A7A:  MOVWF  x88
0A7C:  CLRF   x89
0A7E:  MOVLB  0
0A80:  RCALL  09E8
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
0A82:  MOVLW  02
0A84:  MOVLB  9
0A86:  MOVWF  x88
0A88:  MOVLW  07
0A8A:  MOVWF  x89
0A8C:  MOVLB  0
0A8E:  RCALL  09E8
0A90:  GOTO   0B28 (RETURN)
.................... }
.................... 
.................... 
.................... #include "param_rdTap.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0BB8:  MOVF   x98,W
0BBA:  XORWF  x99,W
0BBC:  MOVWF  01
*
0E34:  MOVF   x98,W
0E36:  XORWF  x99,W
0E38:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
0DC8:  MOVLB  9
0DCA:  CLRF   x83
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0DCC:  MOVFF  982,985
0DD0:  MOVF   x81,W
0DD2:  BTFSC  FD8.2
0DD4:  DECF   x82,F
0DD6:  DECF   x81,F
0DD8:  MOVWF  x84
0DDA:  MOVF   x84,F
0DDC:  BNZ   0DE2
0DDE:  MOVF   x85,F
0DE0:  BZ    0E46
.................... 		*data = read_eeprom( address++ );
0DE2:  MOVFF  980,03
0DE6:  MOVF   x7F,W
0DE8:  MOVWF  FE9
0DEA:  MOVFF  03,FEA
0DEE:  MOVF   x7E,W
0DF0:  MOVWF  03
0DF2:  MOVF   x7D,W
0DF4:  INCF   x7D,F
0DF6:  BTFSC  FD8.2
0DF8:  INCF   x7E,F
0DFA:  MOVWF  x86
0DFC:  MOVFF  03,987
0E00:  MOVFF  FF2,988
0E04:  BCF    FF2.7
0E06:  MOVFF  987,F75
0E0A:  MOVFF  986,F74
0E0E:  BCF    F7F.6
0E10:  BCF    F7F.7
0E12:  BSF    F7F.0
0E14:  MOVF   F73,W
0E16:  BTFSC  x88.7
0E18:  BSF    FF2.7
0E1A:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
0E1C:  MOVFF  980,03
0E20:  MOVF   x7F,W
0E22:  MOVWF  FE9
0E24:  MOVFF  03,FEA
0E28:  MOVFF  FEF,984
0E2C:  MOVFF  983,998
0E30:  MOVFF  984,999
*
0E3A:  MOVFF  01,983
.................... 		data++;
0E3E:  INCF   x7F,F
0E40:  BTFSC  FD8.2
0E42:  INCF   x80,F
0E44:  BRA    0DCC
.................... 	}
.................... 	return crc;
0E46:  MOVFF  983,01
0E4A:  MOVLB  0
0E4C:  RETURN 0
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
*
0B84:  MOVLB  9
0B86:  CLRF   x96
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0B88:  MOVFF  995,998
0B8C:  MOVF   x94,W
0B8E:  BTFSC  FD8.2
0B90:  DECF   x95,F
0B92:  DECF   x94,F
0B94:  MOVWF  x97
0B96:  MOVF   x97,F
0B98:  BNZ   0B9E
0B9A:  MOVF   x98,F
0B9C:  BZ    0C1C
.................... 		restart_wdt();
0B9E:  CLRWDT
.................... 		crc = xor_crc(crc,*data);
0BA0:  MOVFF  993,03
0BA4:  MOVF   x92,W
0BA6:  MOVWF  FE9
0BA8:  MOVFF  03,FEA
0BAC:  MOVFF  FEF,997
0BB0:  MOVFF  996,998
0BB4:  MOVFF  997,999
*
0BBE:  MOVFF  01,996
.................... 		write_eeprom( address++, *data++ );
0BC2:  MOVF   x91,W
0BC4:  MOVWF  03
0BC6:  MOVF   x90,W
0BC8:  INCF   x90,F
0BCA:  BTFSC  FD8.2
0BCC:  INCF   x91,F
0BCE:  MOVWF  x97
0BD0:  MOVFF  03,998
0BD4:  MOVF   x93,W
0BD6:  MOVWF  03
0BD8:  MOVF   x92,W
0BDA:  INCF   x92,F
0BDC:  BTFSC  FD8.2
0BDE:  INCF   x93,F
0BE0:  MOVWF  FE9
0BE2:  MOVFF  03,FEA
0BE6:  MOVFF  FEF,999
0BEA:  MOVF   FF2,W
0BEC:  MOVWF  00
0BEE:  BCF    FF2.7
0BF0:  MOVFF  998,F75
0BF4:  MOVFF  997,F74
0BF8:  MOVFF  999,F73
0BFC:  BCF    F7F.6
0BFE:  BCF    F7F.7
0C00:  BSF    F7F.2
0C02:  MOVLB  F
0C04:  MOVLW  55
0C06:  MOVWF  F7E
0C08:  MOVLW  AA
0C0A:  MOVWF  F7E
0C0C:  BSF    F7F.1
0C0E:  BTFSC  F7F.1
0C10:  BRA    0C0E
0C12:  BCF    F7F.2
0C14:  MOVF   00,W
0C16:  IORWF  FF2,F
0C18:  MOVLB  9
0C1A:  BRA    0B88
.................... 	}
.................... 
.................... 	return crc;
0C1C:  MOVFF  996,01
0C20:  MOVLB  0
0C22:  RETURN 0
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
0C24:  MOVLW  05
0C26:  MOVLB  9
0C28:  MOVWF  x8E
0C2A:  MOVLW  83
0C2C:  MOVWF  x8D
0C2E:  CLRF   x91
0C30:  MOVLW  04
0C32:  MOVWF  x90
0C34:  MOVFF  98E,993
0C38:  MOVFF  98D,992
0C3C:  CLRF   x95
0C3E:  MOVLW  08
0C40:  MOVWF  x94
0C42:  MOVLB  0
0C44:  RCALL  0B84
0C46:  MOVFF  01,98C
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
0C4A:  MOVF   FF2,W
0C4C:  MOVWF  00
0C4E:  BCF    FF2.7
0C50:  CLRF   F75
0C52:  CLRF   F74
0C54:  MOVFF  98C,F73
0C58:  BCF    F7F.6
0C5A:  BCF    F7F.7
0C5C:  BSF    F7F.2
0C5E:  MOVLB  F
0C60:  MOVLW  55
0C62:  MOVWF  F7E
0C64:  MOVLW  AA
0C66:  MOVWF  F7E
0C68:  BSF    F7F.1
0C6A:  BTFSC  F7F.1
0C6C:  BRA    0C6A
0C6E:  BCF    F7F.2
0C70:  MOVF   00,W
0C72:  IORWF  FF2,F
0C74:  MOVLB  0
0C76:  RETURN 0
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0C78:  MOVLW  96
0C7A:  MOVLB  3
0C7C:  MOVWF  x64
.................... //	fprintf(world,"# writing default parameters\r\n");
.................... 
.................... 	config.serial_prefix='A';
0C7E:  MOVLW  41
0C80:  MOVLB  5
0C82:  MOVWF  x83
.................... 	config.serial_number=4820;
0C84:  MOVLW  12
0C86:  MOVWF  x85
0C88:  MOVLW  D4
0C8A:  MOVWF  x84
.................... 		/* 
.................... 			A4797 Fairway UAF (SBD in slot 5 closest to power connector)
.................... 			A4800 Fairway UVic (SBD in slot 1)
.................... 			A4810 Uvic Spare Fairway panel (SBD in slot 1)
.................... 			A4820 JJJ Bench (SBD in slot 1)
.................... 		*/
.................... 
.................... 	/* data to internet on STREAM_WORLD port */
.................... 	config.live_interval=10; 
0C8C:  CLRF   x87
0C8E:  MOVLW  0A
0C90:  MOVWF  x86
.................... 
.................... 	/* Iridium SBD requires dcswc_module_rockblock which provides an I2C UART */
.................... 	config.sbd_config=1;   /* physical slot for module. Used for power control */
0C92:  MOVLW  01
0C94:  MOVWF  x88
.................... 	config.sbd_every=90; /* send SBD message every this number of live_interval */
0C96:  CLRF   x8A
0C98:  MOVLW  5A
0C9A:  MOVWF  x89
....................                            /* with 10 second live interval, 4320 => SBD every 12 hours */
....................                            /* with 10 second live interval, 1080 => SBD every 3 hours */			
....................                            /* with 10 second live interval, 90 => SBD every 15 minutes */
.................... 				
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0C9C:  MOVLB  0
0C9E:  RCALL  0C24
0CA0:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS,(void *)&config, sizeof(config)); 
*
0E4E:  MOVLW  05
0E50:  MOVLB  9
0E52:  MOVWF  x7C
0E54:  MOVLW  83
0E56:  MOVWF  x7B
0E58:  CLRF   x7E
0E5A:  MOVLW  04
0E5C:  MOVWF  x7D
0E5E:  MOVFF  97C,980
0E62:  MOVFF  97B,97F
0E66:  CLRF   x82
0E68:  MOVLW  08
0E6A:  MOVWF  x81
0E6C:  MOVLB  0
0E6E:  RCALL  0DC8
0E70:  MOVFF  01,97A
.................... 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
0E74:  MOVFF  FF2,97B
0E78:  BCF    FF2.7
0E7A:  CLRF   F75
0E7C:  CLRF   F74
0E7E:  BCF    F7F.6
0E80:  BCF    F7F.7
0E82:  BSF    F7F.0
0E84:  MOVF   F73,W
0E86:  MOVLB  9
0E88:  BTFSC  x7B.7
0E8A:  BSF    FF2.7
0E8C:  SUBWF  x7A,W
0E8E:  BZ    0E96
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_param_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_param_file();
0E90:  MOVLB  0
0E92:  RCALL  0C78
0E94:  MOVLB  9
.................... 	}
0E96:  MOVLB  0
0E98:  GOTO   41A4 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "paramDevice_rdTap.c"
.................... void write_device_file() {
.................... 	int8 crc;
.................... 
.................... 
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(DEVICE_ADDRESS,(void *)&device,sizeof(device));
*
0CC4:  MOVLB  9
0CC6:  MOVLW  21
0CC8:  MOVWF  x8E
0CCA:  CLRF   x91
0CCC:  MOVLW  80
0CCE:  MOVWF  x90
0CD0:  CLRF   x93
0CD2:  MOVFF  98E,992
0CD6:  MOVLW  03
0CD8:  MOVWF  x95
0CDA:  MOVLW  40
0CDC:  MOVWF  x94
0CDE:  MOVLB  0
0CE0:  RCALL  0B84
0CE2:  MOVFF  01,98D
.................... 	/* write the CRC that was calculated on the structure */
.................... 	write_eeprom(DEVICE_CRC_ADDRESS,crc);
0CE6:  MOVF   FF2,W
0CE8:  MOVWF  00
0CEA:  BCF    FF2.7
0CEC:  CLRF   F75
0CEE:  MOVLW  02
0CF0:  MOVWF  F74
0CF2:  MOVFF  98D,F73
0CF6:  BCF    F7F.6
0CF8:  BCF    F7F.7
0CFA:  BSF    F7F.2
0CFC:  MOVLB  F
0CFE:  MOVLW  55
0D00:  MOVWF  F7E
0D02:  MOVLW  AA
0D04:  MOVWF  F7E
0D06:  BSF    F7F.1
0D08:  BTFSC  F7F.1
0D0A:  BRA    0D08
0D0C:  BCF    F7F.2
0D0E:  MOVF   00,W
0D10:  IORWF  FF2,F
0D12:  MOVLB  0
0D14:  RETURN 0
.................... 
.................... //	fprintf(STREAM_WORLD,"# write_device_file crc=%u\r\n",crc);
.................... }
.................... 
.................... /* load device configuration from program memory */
.................... void write_default_device_file(void) {
.................... 	int8 i;
.................... 
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0D16:  MOVLW  96
0D18:  MOVLB  3
0D1A:  MOVWF  x64
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# disabling all devices\r\n");
.................... #endif
.................... 
.................... 	/* disable all devices */
.................... 	for ( i=0 ; i<DEV_MAX_N ; i++ ) {
0D1C:  MOVLB  9
0D1E:  CLRF   x8C
0D20:  MOVF   x8C,W
0D22:  SUBLW  3F
0D24:  BNC   0D4A
.................... 		device[i].type=DEV_TYPE_DISABLED;	
0D26:  CLRF   x95
0D28:  MOVFF  98C,994
0D2C:  CLRF   x97
0D2E:  MOVLW  0D
0D30:  MOVWF  x96
0D32:  MOVLB  0
0D34:  RCALL  0CA2
0D36:  MOVLW  21
0D38:  MOVLB  9
0D3A:  ADDWF  01,W
0D3C:  MOVWF  FE9
0D3E:  MOVLW  00
0D40:  ADDWFC 02,W
0D42:  MOVWF  FEA
0D44:  CLRF   FEF
.................... 	}
.................... 
.................... #if 0
.................... 	/* UAF Fairway */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4790; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4791; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4792; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Fairway on A4800 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4806; /*  4264646 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4808; /* 4264648 */
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4807; /* 4264647 */ 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Spare Panel on A4810 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4801; /* 4264641 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4802; /* 4264642 */ 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38; 
.................... 	device[2].serialNumber=('A'<<16) + 4803; /* 4264643 */
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 1
0D46:  INCF   x8C,F
0D48:  BRA    0D20
.................... 	/* JJJ Test board on A4820 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
0D4A:  MOVLW  10
0D4C:  MOVWF  21
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0D4E:  MOVLW  7D
0D50:  MOVWF  23
0D52:  CLRF   22
.................... 	device[0].transmitEvery=1;
0D54:  MOVLW  01
0D56:  MOVWF  24
.................... 	device[0].networkAddress=0x3e;
0D58:  MOVLW  3E
0D5A:  MOVWF  25
.................... 	device[0].serialNumber=('A'<<16) + 4821; 
0D5C:  CLRF   29
0D5E:  MOVLW  41
0D60:  MOVWF  28
0D62:  MOVLW  12
0D64:  MOVWF  27
0D66:  MOVLW  D5
0D68:  MOVWF  26
.................... 	device[0].startRegister=0;
0D6A:  CLRF   2B
0D6C:  CLRF   2A
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
0D6E:  MOVLW  06
0D70:  MOVWF  2C
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
0D72:  MOVLW  10
0D74:  MOVWF  2E
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0D76:  MOVLW  7D
0D78:  MOVWF  30
0D7A:  CLRF   2F
.................... 	device[1].transmitEvery=1;
0D7C:  MOVLW  01
0D7E:  MOVWF  31
.................... 	device[1].networkAddress=0x36;
0D80:  MOVLW  36
0D82:  MOVWF  32
.................... 	device[1].serialNumber=('A'<<16) + 4822; 
0D84:  CLRF   36
0D86:  MOVLW  41
0D88:  MOVWF  35
0D8A:  MOVLW  12
0D8C:  MOVWF  34
0D8E:  MOVLW  D6
0D90:  MOVWF  33
.................... 	device[1].startRegister=0;
0D92:  CLRF   38
0D94:  CLRF   37
.................... 	device[1].nRegisters=32;
0D96:  MOVLW  20
0D98:  MOVWF  39
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
0D9A:  MOVLW  10
0D9C:  MOVWF  3B
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0D9E:  MOVLW  7D
0DA0:  MOVWF  3D
0DA2:  CLRF   3C
.................... 	device[2].transmitEvery=1;
0DA4:  MOVLW  01
0DA6:  MOVWF  3E
.................... 	device[2].networkAddress=0x38;
0DA8:  MOVLW  38
0DAA:  MOVWF  3F
.................... 	device[2].serialNumber=('A'<<16) + 4823; 
0DAC:  CLRF   43
0DAE:  MOVLW  41
0DB0:  MOVWF  42
0DB2:  MOVLW  12
0DB4:  MOVWF  41
0DB6:  MOVLW  D7
0DB8:  MOVWF  40
.................... 	device[2].startRegister=0;
0DBA:  CLRF   45
0DBC:  CLRF   44
.................... 	device[2].nRegisters=32;
0DBE:  MOVLW  20
0DC0:  MOVWF  46
.................... #endif
.................... 
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# write_device_file()\r\n");
.................... #endif
.................... 
.................... 	write_device_file();
0DC2:  MOVLB  0
0DC4:  RCALL  0CC4
0DC6:  RETURN 0
.................... }
.................... 
.................... void read_device_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(DEVICE_ADDRESS,(void *)&device, sizeof(device)); 
*
0E9C:  MOVLB  9
0E9E:  MOVLW  21
0EA0:  MOVWF  x7B
0EA2:  CLRF   x7E
0EA4:  MOVLW  80
0EA6:  MOVWF  x7D
0EA8:  CLRF   x80
0EAA:  MOVFF  97B,97F
0EAE:  MOVLW  03
0EB0:  MOVWF  x82
0EB2:  MOVLW  40
0EB4:  MOVWF  x81
0EB6:  MOVLB  0
0EB8:  RCALL  0DC8
0EBA:  MOVFF  01,97A
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# read_device_file crc=%u\r\n",crc);
.................... #endif
.................... 
.................... 	if ( crc != read_eeprom(DEVICE_CRC_ADDRESS) ) {
0EBE:  MOVFF  FF2,97B
0EC2:  BCF    FF2.7
0EC4:  CLRF   F75
0EC6:  MOVLW  02
0EC8:  MOVWF  F74
0ECA:  BCF    F7F.6
0ECC:  BCF    F7F.7
0ECE:  BSF    F7F.0
0ED0:  MOVF   F73,W
0ED2:  MOVLB  9
0ED4:  BTFSC  x7B.7
0ED6:  BSF    FF2.7
0ED8:  SUBWF  x7A,W
0EDA:  BZ    0EE2
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_device_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_device_file();
0EDC:  MOVLB  0
0EDE:  RCALL  0D16
0EE0:  MOVLB  9
.................... 	}
0EE2:  MOVLB  0
0EE4:  GOTO   41A8 (RETURN)
.................... }
.................... 
.................... void devicesDump(void) {
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... 
.................... 	fprintf(STREAM_WORLD,"# dumping all enabled devices:\r\n");
.................... 	for ( i=0 ; i<16 ; i++ ) {
.................... 		restart_wdt();
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[i].type ) 
.................... 			continue;
.................... 
.................... 		fprintf(STREAM_WORLD,"device[%u]\r\n",i);
.................... 		fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[i].type);
.................... 		fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[i].transmitEvery);
.................... 		fprintf(STREAM_WORLD,"\tnetworkAddress=%u\r\n",device[i].networkAddress);
.................... 		fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 			make8(device[i].serialNumber,3),
.................... 			make8(device[i].serialNumber,2),
.................... 			make8(device[i].serialNumber,1),
.................... 			make8(device[i].serialNumber,0)
.................... 		);
.................... 		fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[i].startRegister);
.................... 		fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[i].nRegisters);
.................... 	}
.................... 	fprintf(STREAM_WORLD,"# done\r\n");
.................... #endif
.................... }
.................... 
.................... #include "modbus_int_uart_rdTap.c"
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //// MASTER API:                                                                      ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /*Some defines so we can use identifiers to set things up*/
.................... #define MODBUS_TYPE_MASTER 99999
.................... #define MODBUS_TYPE_SLAVE 88888
.................... #define MODBUS_INT_RDA 77777
.................... #define MODBUS_INT_RDA2 66666
.................... #define MODBUS_INT_EXT 55555
.................... 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER
.................... 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA  // Select between external interrupt
.................... #define MODBUS_SERIAL_BAUD 9600
.................... #define MODBUS_SERIAL_RX_PIN       NET_RX   // Data receive pin
.................... #define MODBUS_SERIAL_TX_PIN       NET_TX   // Data transmit pin
.................... #define MODBUS_SERIAL_ENABLE_PIN   RS485_DE   // Controls DE pin.  RX low, TX high.
.................... #define MODBUS_SERIAL_RX_ENABLE    RS485_NOT_RE   // Controls RE pin.  Should keep low.
.................... #define MODBUS_SERIAL_TIMEOUT      100000     //in us
.................... 
.................... 
.................... #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, parity=N, stream=MODBUS_SERIAL, errors)
*
0336:  BTFSS  F9E.5
0338:  BRA    0336
033A:  MOVFF  FAB,20
033E:  MOVFF  FAE,01
0342:  BTFSS  20.1
0344:  BRA    034A
0346:  BCF    FAB.4
0348:  BSF    FAB.4
034A:  RETURN 0
*
20AA:  BTFSS  F9E.4
20AC:  BRA    20AA
20AE:  MOVWF  FAD
20B0:  GOTO   20BC (RETURN)
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);}
.................... 
.................... 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer
.................... 
.................... 
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
.................... 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................     if(address)\
....................     {\
....................         while(!modbus_kbhit() && --modbus_serial_wait)\
....................             delay_us(1);\
....................         if(!modbus_serial_wait)\
....................             modbus_rx.error=TIMEOUT;\
....................     }\
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... //#byte TXSTA=getenv("sfr:TXSTA")
.................... #byte TXSTA=0xfad
.................... #bit TRMT=TXSTA.1
.................... 
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }   
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    int8 b[2];
....................    int16 d;
.................... } modbus_serial_crc;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void rcv_on(void) {
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
.................... 	while(kbhit(MODBUS_SERIAL)) {
*
0EE8:  BTFSS  F9E.5
0EEA:  BRA    0EF2
.................... 		fgetc(MODBUS_SERIAL);
0EEC:  CALL   0336
0EF0:  BRA    0EE8
.................... 	}  
.................... 	
.................... 	clear_interrupt(INT_RDA);
0EF2:  MOVF   FAE,W
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE);
.................... 	output_low(RS485_DE);
0EF4:  BCF    F94.5
0EF6:  BCF    F8B.5
.................... 	enable_interrupts(INT_RDA);
0EF8:  BSF    F9D.5
0EFA:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init()
.................... {
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
0EFC:  BCF    F94.5
0EFE:  BCF    F8B.5
.................... 
....................    RCV_ON();
0F00:  RCALL  0EE8
.................... 
.................... //   setup_timer_2(T2_DIV_BY_16,249,5);   //10ms interrupts
....................    setup_timer_2(T2_DIV_BY_16,249,10);   //20ms interrupts
0F02:  MOVLW  48
0F04:  IORLW  06
0F06:  MOVWF  FCA
0F08:  MOVLW  F9
0F0A:  MOVWF  FCB
.................... 
....................    enable_interrupts(GLOBAL);
0F0C:  MOVLW  C0
0F0E:  IORWF  FF2,F
0F10:  GOTO   41AE (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... void modbus_enable_timeout(int1 enable)
.................... {
....................    disable_interrupts(INT_TIMER2);
*
02F2:  BCF    F9D.1
....................    if (enable) {
02F4:  MOVLB  9
02F6:  MOVF   x9C,F
02F8:  BZ    0300
....................       set_timer2(0);
02FA:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2);
02FC:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2);
02FE:  BSF    F9D.1
....................    }
0300:  MOVLB  0
0302:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... #int_timer2
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
0304:  MOVLB  5
0306:  MOVF   x90,W
0308:  SUBLW  02
030A:  BNZ   0320
030C:  MOVF   x91,F
030E:  BNZ   0320
0310:  MOVF   x92,F
0312:  BNZ   0320
0314:  BTFSC  x8F.0
0316:  BRA    0320
....................    {
....................       modbus_rx.len-=2;
0318:  MOVLW  02
031A:  SUBWF  x94,F
....................       modbus_serial_new=TRUE;
031C:  BSF    x8F.0
....................    }
031E:  BRA    0322
....................    else
....................       modbus_serial_new=FALSE;
0320:  BCF    x8F.0
.................... 
....................    modbus_serial_crc.d=0xFFFF;
0322:  SETF   x92
0324:  SETF   x91
....................    modbus_serial_state=MODBUS_GETADDY;
0326:  CLRF   x90
....................    modbus_enable_timeout(FALSE);
0328:  MOVLB  9
032A:  CLRF   x9C
032C:  MOVLB  0
032E:  RCALL  02F2
0330:  BCF    F9E.1
0332:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................   int8 uIndex ; // will index into CRC lookup table
.................... 
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
034C:  MOVLB  5
034E:  MOVF   x92,W
0350:  MOVLB  9
0352:  XORWF  x9C,W
0354:  MOVWF  x9D
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
0356:  CLRF   03
0358:  MOVF   x9D,W
035A:  MOVLB  0
035C:  RCALL  00D2
035E:  MOVWF  01
0360:  MOVLB  5
0362:  MOVF   x91,W
0364:  XORWF  01,W
0366:  MOVWF  x92
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0368:  CLRF   03
036A:  MOVLB  9
036C:  MOVF   x9D,W
036E:  MOVLB  0
0370:  RCALL  01E2
0372:  MOVFF  FE8,591
0376:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c)
.................... {
....................    fputc(c, MODBUS_SERIAL);
*
20B4:  MOVLB  9
20B6:  MOVF   x90,W
20B8:  MOVLB  0
20BA:  BRA    20AA
20BC:  CLRF   19
20BE:  BTFSC  FF2.7
20C0:  BSF    19.7
20C2:  BCF    FF2.7
....................    modbus_calc_crc(c);
20C4:  MOVFF  990,99C
20C8:  CALL   034C
20CC:  BTFSC  19.7
20CE:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
20D0:  CLRWDT
20D2:  MOVLW  44
20D4:  MOVWF  00
20D6:  DECFSZ 00,F
20D8:  BRA    20D6
20DA:  BRA    20DC
20DC:  RETURN 0
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
.................... #int_rda
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
.................... #int_rda2
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT)
.................... #int_ext
.................... #else
.................... #error Please define a correct interrupt source
.................... #endif
.................... void incomming_modbus_serial() {
....................    char c;
.................... 
....................    c=fgetc(MODBUS_SERIAL);
*
0378:  RCALL  0336
037A:  MOVFF  01,99B
.................... 
....................    if (!modbus_serial_new)
037E:  MOVLB  5
0380:  BTFSC  x8F.0
0382:  BRA    03DA
....................    {
....................       if(modbus_serial_state == MODBUS_GETADDY)
0384:  MOVF   x90,F
0386:  BNZ   0398
....................       {
....................          modbus_serial_crc.d = 0xFFFF;
0388:  SETF   x92
038A:  SETF   x91
....................          modbus_rx.address = c;
038C:  MOVFF  99B,593
....................          modbus_serial_state++;
0390:  INCF   x90,F
....................          modbus_rx.len = 0;
0392:  CLRF   x94
....................          modbus_rx.error=0;
0394:  CLRF   x96
....................       }
0396:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETFUNC)
0398:  DECFSZ x90,W
039A:  BRA    03A4
....................       {
....................          modbus_rx.func = c;
039C:  MOVFF  99B,595
....................          modbus_serial_state++;
03A0:  INCF   x90,F
....................       }
03A2:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETDATA)
03A4:  MOVF   x90,W
03A6:  SUBLW  02
03A8:  BNZ   03C6
....................       {
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;}
03AA:  INCFSZ x94,W
03AC:  BRA    03B2
03AE:  MOVLW  FE
03B0:  MOVWF  x94
....................          modbus_rx.data[modbus_rx.len]=c;
03B2:  MOVLW  97
03B4:  ADDWF  x94,W
03B6:  MOVWF  FE9
03B8:  MOVLW  05
03BA:  MOVWF  FEA
03BC:  BTFSC  FD8.0
03BE:  INCF   FEA,F
03C0:  MOVFF  99B,FEF
....................          modbus_rx.len++;
03C4:  INCF   x94,F
....................       }
.................... 
....................       modbus_calc_crc(c);
03C6:  MOVFF  99B,99C
03CA:  MOVLB  0
03CC:  RCALL  034C
....................       modbus_enable_timeout(TRUE);
03CE:  MOVLW  01
03D0:  MOVLB  9
03D2:  MOVWF  x9C
03D4:  MOVLB  0
03D6:  RCALL  02F2
03D8:  MOVLB  5
....................    }
03DA:  BCF    F9E.5
03DC:  MOVLB  0
03DE:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func)
.................... {
....................    modbus_serial_crc.d=0xFFFF;
*
20DE:  MOVLB  5
20E0:  SETF   x92
20E2:  SETF   x91
....................    modbus_serial_new=FALSE;
20E4:  BCF    x8F.0
.................... 
....................    RCV_OFF();
20E6:  BCF    F9D.5
....................    
....................    output_high(MODBUS_SERIAL_ENABLE_PIN);
20E8:  BCF    F94.5
20EA:  BSF    F8B.5
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
20EC:  CLRWDT
20EE:  MOVLW  F2
20F0:  MOVWF  00
20F2:  DECFSZ 00,F
20F4:  BRA    20F2
.................... 
....................    modbus_serial_putc(to);
20F6:  MOVFF  98D,990
20FA:  MOVLB  0
20FC:  RCALL  20B4
....................    modbus_serial_putc(func);
20FE:  MOVFF  98E,990
2102:  RCALL  20B4
2104:  RETURN 0
.................... }
.................... 
.................... void modbus_serial_send_stop()
.................... {
....................    int8 crc_low, crc_high;
.................... 
.................... 
....................    crc_high=modbus_serial_crc.b[1];
2106:  MOVFF  592,98E
....................    crc_low=modbus_serial_crc.b[0];
210A:  MOVFF  591,98D
.................... 
....................    modbus_serial_putc(crc_high);
210E:  MOVFF  98E,990
2112:  RCALL  20B4
....................    modbus_serial_putc(crc_low);
2114:  MOVFF  98D,990
2118:  RCALL  20B4
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................    WAIT_FOR_HW_BUFFER();
211A:  BTFSS  FAD.1
211C:  BRA    211A
.................... #endif
....................     
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
211E:  CLRWDT
2120:  MOVLW  F2
2122:  MOVWF  00
2124:  DECFSZ 00,F
2126:  BRA    2124
.................... 
.................... 
....................    RCV_ON();
2128:  CALL   0EE8
.................... 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
212C:  BCF    F94.5
212E:  BCF    F8B.5
.................... 
....................    modbus_serial_crc.d=0xFFFF;
2130:  MOVLB  5
2132:  SETF   x92
2134:  SETF   x91
2136:  MOVLB  0
2138:  RETURN 0
.................... 
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
213A:  MOVLB  5
213C:  BTFSC  x8F.0
213E:  BRA    2148
....................       return FALSE;
2140:  MOVLW  00
2142:  MOVWF  01
2144:  BRA    215A
2146:  BRA    2154
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
2148:  BTFSS  x95.7
214A:  BRA    2154
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
214C:  MOVFF  597,596
....................       modbus_rx.len = 1;
2150:  MOVLW  01
2152:  MOVWF  x94
....................    }
....................    modbus_serial_new=FALSE;
2154:  BCF    x8F.0
....................    return TRUE;
2156:  MOVLW  01
2158:  MOVWF  01
215A:  MOVLB  0
215C:  RETURN 0
.................... }
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... /*MODBUS Master Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
*
2558:  MOVFF  982,98D
255C:  MOVLW  01
255E:  MOVLB  9
2560:  MOVWF  x8E
2562:  MOVLB  0
2564:  RCALL  20DE
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2566:  MOVFF  984,990
256A:  RCALL  20B4
....................    modbus_serial_putc(make8(start_address,0));
256C:  MOVFF  983,990
2570:  RCALL  20B4
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2572:  MOVFF  986,990
2576:  RCALL  20B4
....................    modbus_serial_putc(make8(quantity,0));
2578:  MOVFF  985,990
257C:  RCALL  20B4
.................... 
....................    modbus_serial_send_stop();
257E:  RCALL  2106
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2580:  MOVLB  9
2582:  MOVF   x82,F
2584:  BZ    25D8
2586:  MOVLB  0
2588:  RCALL  213A
258A:  MOVF   01,F
258C:  BNZ   25C0
258E:  MOVLW  FF
2590:  MOVLB  5
2592:  ADDWF  x8B,F
2594:  BTFSS  FD8.0
2596:  ADDWF  x8C,F
2598:  BTFSS  FD8.0
259A:  ADDWF  x8D,F
259C:  BTFSS  FD8.0
259E:  ADDWF  x8E,F
25A0:  MOVF   x8B,F
25A2:  BNZ   25B6
25A4:  MOVF   x8C,F
25A6:  BNZ   25B6
25A8:  MOVF   x8D,F
25AA:  BNZ   25B6
25AC:  MOVF   x8E,F
25AE:  BTFSS  FD8.2
25B0:  BRA    25B6
25B2:  MOVLB  0
25B4:  BRA    25C0
25B6:  CLRWDT
25B8:  NOP   
25BA:  MOVLB  9
25BC:  BRA    2586
25BE:  MOVLB  0
25C0:  MOVLB  5
25C2:  MOVF   x8B,F
25C4:  BNZ   25D6
25C6:  MOVF   x8C,F
25C8:  BNZ   25D6
25CA:  MOVF   x8D,F
25CC:  BNZ   25D6
25CE:  MOVF   x8E,F
25D0:  BNZ   25D6
25D2:  MOVLW  0C
25D4:  MOVWF  x96
25D6:  MOVLB  9
25D8:  MOVLB  5
25DA:  CLRF   x8E
25DC:  MOVLW  01
25DE:  MOVWF  x8D
25E0:  MOVLW  86
25E2:  MOVWF  x8C
25E4:  MOVLW  A0
25E6:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
25E8:  MOVFF  596,01
25EC:  MOVLB  0
25EE:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
*
36DA:  MOVFF  982,98D
36DE:  MOVLW  02
36E0:  MOVLB  9
36E2:  MOVWF  x8E
36E4:  MOVLB  0
36E6:  CALL   20DE
.................... 
....................    modbus_serial_putc(make8(start_address,1));
36EA:  MOVFF  984,990
36EE:  CALL   20B4
....................    modbus_serial_putc(make8(start_address,0));
36F2:  MOVFF  983,990
36F6:  CALL   20B4
.................... 
....................    modbus_serial_putc(make8(quantity,1));
36FA:  MOVFF  986,990
36FE:  CALL   20B4
....................    modbus_serial_putc(make8(quantity,0));
3702:  MOVFF  985,990
3706:  CALL   20B4
.................... 
....................    modbus_serial_send_stop();
370A:  CALL   2106
....................       
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
370E:  MOVLB  9
3710:  MOVF   x82,F
3712:  BZ    3768
3714:  MOVLB  0
3716:  CALL   213A
371A:  MOVF   01,F
371C:  BNZ   3750
371E:  MOVLW  FF
3720:  MOVLB  5
3722:  ADDWF  x8B,F
3724:  BTFSS  FD8.0
3726:  ADDWF  x8C,F
3728:  BTFSS  FD8.0
372A:  ADDWF  x8D,F
372C:  BTFSS  FD8.0
372E:  ADDWF  x8E,F
3730:  MOVF   x8B,F
3732:  BNZ   3746
3734:  MOVF   x8C,F
3736:  BNZ   3746
3738:  MOVF   x8D,F
373A:  BNZ   3746
373C:  MOVF   x8E,F
373E:  BTFSS  FD8.2
3740:  BRA    3746
3742:  MOVLB  0
3744:  BRA    3750
3746:  CLRWDT
3748:  NOP   
374A:  MOVLB  9
374C:  BRA    3714
374E:  MOVLB  0
3750:  MOVLB  5
3752:  MOVF   x8B,F
3754:  BNZ   3766
3756:  MOVF   x8C,F
3758:  BNZ   3766
375A:  MOVF   x8D,F
375C:  BNZ   3766
375E:  MOVF   x8E,F
3760:  BNZ   3766
3762:  MOVLW  0C
3764:  MOVWF  x96
3766:  MOVLB  9
3768:  MOVLB  5
376A:  CLRF   x8E
376C:  MOVLW  01
376E:  MOVWF  x8D
3770:  MOVLW  86
3772:  MOVWF  x8C
3774:  MOVLW  A0
3776:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
3778:  MOVFF  596,01
377C:  MOVLB  0
377E:  GOTO   3B14 (RETURN)
.................... }
.................... 
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
*
21F6:  MOVFF  982,98D
21FA:  MOVLW  03
21FC:  MOVLB  9
21FE:  MOVWF  x8E
2200:  MOVLB  0
2202:  RCALL  20DE
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2204:  MOVFF  984,990
2208:  RCALL  20B4
....................    modbus_serial_putc(make8(start_address,0));
220A:  MOVFF  983,990
220E:  RCALL  20B4
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2210:  MOVFF  986,990
2214:  RCALL  20B4
....................    modbus_serial_putc(make8(quantity,0));
2216:  MOVFF  985,990
221A:  RCALL  20B4
.................... 
....................    modbus_serial_send_stop();
221C:  RCALL  2106
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
221E:  MOVLB  9
2220:  MOVF   x82,F
2222:  BZ    2276
2224:  MOVLB  0
2226:  RCALL  213A
2228:  MOVF   01,F
222A:  BNZ   225E
222C:  MOVLW  FF
222E:  MOVLB  5
2230:  ADDWF  x8B,F
2232:  BTFSS  FD8.0
2234:  ADDWF  x8C,F
2236:  BTFSS  FD8.0
2238:  ADDWF  x8D,F
223A:  BTFSS  FD8.0
223C:  ADDWF  x8E,F
223E:  MOVF   x8B,F
2240:  BNZ   2254
2242:  MOVF   x8C,F
2244:  BNZ   2254
2246:  MOVF   x8D,F
2248:  BNZ   2254
224A:  MOVF   x8E,F
224C:  BTFSS  FD8.2
224E:  BRA    2254
2250:  MOVLB  0
2252:  BRA    225E
2254:  CLRWDT
2256:  NOP   
2258:  MOVLB  9
225A:  BRA    2224
225C:  MOVLB  0
225E:  MOVLB  5
2260:  MOVF   x8B,F
2262:  BNZ   2274
2264:  MOVF   x8C,F
2266:  BNZ   2274
2268:  MOVF   x8D,F
226A:  BNZ   2274
226C:  MOVF   x8E,F
226E:  BNZ   2274
2270:  MOVLW  0C
2272:  MOVWF  x96
2274:  MOVLB  9
2276:  MOVLB  5
2278:  CLRF   x8E
227A:  MOVLW  01
227C:  MOVWF  x8D
227E:  MOVLW  86
2280:  MOVWF  x8C
2282:  MOVLW  A0
2284:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2286:  MOVFF  596,01
228A:  MOVLB  0
228C:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
*
215E:  MOVFF  982,98D
2162:  MOVLW  04
2164:  MOVLB  9
2166:  MOVWF  x8E
2168:  MOVLB  0
216A:  RCALL  20DE
.................... 
....................    modbus_serial_putc(make8(start_address,1));
216C:  MOVFF  984,990
2170:  RCALL  20B4
....................    modbus_serial_putc(make8(start_address,0));
2172:  MOVFF  983,990
2176:  RCALL  20B4
.................... 
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2178:  MOVFF  986,990
217C:  RCALL  20B4
....................    modbus_serial_putc(make8(quantity,0));
217E:  MOVFF  985,990
2182:  RCALL  20B4
.................... 
....................    modbus_serial_send_stop();
2184:  RCALL  2106
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2186:  MOVLB  9
2188:  MOVF   x82,F
218A:  BZ    21DE
218C:  MOVLB  0
218E:  RCALL  213A
2190:  MOVF   01,F
2192:  BNZ   21C6
2194:  MOVLW  FF
2196:  MOVLB  5
2198:  ADDWF  x8B,F
219A:  BTFSS  FD8.0
219C:  ADDWF  x8C,F
219E:  BTFSS  FD8.0
21A0:  ADDWF  x8D,F
21A2:  BTFSS  FD8.0
21A4:  ADDWF  x8E,F
21A6:  MOVF   x8B,F
21A8:  BNZ   21BC
21AA:  MOVF   x8C,F
21AC:  BNZ   21BC
21AE:  MOVF   x8D,F
21B0:  BNZ   21BC
21B2:  MOVF   x8E,F
21B4:  BTFSS  FD8.2
21B6:  BRA    21BC
21B8:  MOVLB  0
21BA:  BRA    21C6
21BC:  CLRWDT
21BE:  NOP   
21C0:  MOVLB  9
21C2:  BRA    218C
21C4:  MOVLB  0
21C6:  MOVLB  5
21C8:  MOVF   x8B,F
21CA:  BNZ   21DC
21CC:  MOVF   x8C,F
21CE:  BNZ   21DC
21D0:  MOVF   x8D,F
21D2:  BNZ   21DC
21D4:  MOVF   x8E,F
21D6:  BNZ   21DC
21D8:  MOVLW  0C
21DA:  MOVWF  x96
21DC:  MOVLB  9
21DE:  MOVLB  5
21E0:  CLRF   x8E
21E2:  MOVLW  01
21E4:  MOVWF  x8D
21E6:  MOVLW  86
21E8:  MOVWF  x8C
21EA:  MOVLW  A0
21EC:  MOVWF  x8B
.................... 
.................... 
.................... 
....................    return modbus_rx.error;
21EE:  MOVFF  596,01
21F2:  MOVLB  0
21F4:  RETURN 0
.................... }
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
*
3782:  MOVFF  983,98D
3786:  MOVLW  05
3788:  MOVLB  9
378A:  MOVWF  x8E
378C:  MOVLB  0
378E:  CALL   20DE
.................... 
....................    modbus_serial_putc(make8(output_address,1));
3792:  MOVFF  985,990
3796:  CALL   20B4
....................    modbus_serial_putc(make8(output_address,0));
379A:  MOVFF  984,990
379E:  CALL   20B4
.................... 
....................    if(on)
37A2:  MOVLB  9
37A4:  MOVF   x86,F
37A6:  BZ    37B4
....................        modbus_serial_putc(0xFF);
37A8:  SETF   x90
37AA:  MOVLB  0
37AC:  CALL   20B4
37B0:  BRA    37BC
37B2:  MOVLB  9
....................    else
....................        modbus_serial_putc(0x00);
37B4:  CLRF   x90
37B6:  MOVLB  0
37B8:  CALL   20B4
....................    
....................    modbus_serial_putc(0x00);
37BC:  MOVLB  9
37BE:  CLRF   x90
37C0:  MOVLB  0
37C2:  CALL   20B4
.................... 
....................    modbus_serial_send_stop();
37C6:  CALL   2106
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
37CA:  MOVLB  9
37CC:  MOVF   x83,F
37CE:  BZ    3824
37D0:  MOVLB  0
37D2:  CALL   213A
37D6:  MOVF   01,F
37D8:  BNZ   380C
37DA:  MOVLW  FF
37DC:  MOVLB  5
37DE:  ADDWF  x8B,F
37E0:  BTFSS  FD8.0
37E2:  ADDWF  x8C,F
37E4:  BTFSS  FD8.0
37E6:  ADDWF  x8D,F
37E8:  BTFSS  FD8.0
37EA:  ADDWF  x8E,F
37EC:  MOVF   x8B,F
37EE:  BNZ   3802
37F0:  MOVF   x8C,F
37F2:  BNZ   3802
37F4:  MOVF   x8D,F
37F6:  BNZ   3802
37F8:  MOVF   x8E,F
37FA:  BTFSS  FD8.2
37FC:  BRA    3802
37FE:  MOVLB  0
3800:  BRA    380C
3802:  CLRWDT
3804:  NOP   
3806:  MOVLB  9
3808:  BRA    37D0
380A:  MOVLB  0
380C:  MOVLB  5
380E:  MOVF   x8B,F
3810:  BNZ   3822
3812:  MOVF   x8C,F
3814:  BNZ   3822
3816:  MOVF   x8D,F
3818:  BNZ   3822
381A:  MOVF   x8E,F
381C:  BNZ   3822
381E:  MOVLW  0C
3820:  MOVWF  x96
3822:  MOVLB  9
3824:  MOVLB  5
3826:  CLRF   x8E
3828:  MOVLW  01
382A:  MOVWF  x8D
382C:  MOVLW  86
382E:  MOVWF  x8C
3830:  MOVLW  A0
3832:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
3834:  MOVFF  596,01
3838:  MOVLB  0
383A:  GOTO   3B96 (RETURN)
.................... }
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
383E:  MOVFF  986,98D
3842:  MOVLW  06
3844:  MOVLB  9
3846:  MOVWF  x8E
3848:  MOVLB  0
384A:  CALL   20DE
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
384E:  MOVFF  988,990
3852:  CALL   20B4
....................    modbus_serial_putc(make8(reg_address,0));
3856:  MOVFF  987,990
385A:  CALL   20B4
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
385E:  MOVFF  98A,990
3862:  CALL   20B4
....................    modbus_serial_putc(make8(reg_value,0));
3866:  MOVFF  989,990
386A:  CALL   20B4
.................... 
....................    modbus_serial_send_stop();
386E:  CALL   2106
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
3872:  MOVLB  9
3874:  MOVF   x86,F
3876:  BZ    38CC
3878:  MOVLB  0
387A:  CALL   213A
387E:  MOVF   01,F
3880:  BNZ   38B4
3882:  MOVLW  FF
3884:  MOVLB  5
3886:  ADDWF  x8B,F
3888:  BTFSS  FD8.0
388A:  ADDWF  x8C,F
388C:  BTFSS  FD8.0
388E:  ADDWF  x8D,F
3890:  BTFSS  FD8.0
3892:  ADDWF  x8E,F
3894:  MOVF   x8B,F
3896:  BNZ   38AA
3898:  MOVF   x8C,F
389A:  BNZ   38AA
389C:  MOVF   x8D,F
389E:  BNZ   38AA
38A0:  MOVF   x8E,F
38A2:  BTFSS  FD8.2
38A4:  BRA    38AA
38A6:  MOVLB  0
38A8:  BRA    38B4
38AA:  CLRWDT
38AC:  NOP   
38AE:  MOVLB  9
38B0:  BRA    3878
38B2:  MOVLB  0
38B4:  MOVLB  5
38B6:  MOVF   x8B,F
38B8:  BNZ   38CA
38BA:  MOVF   x8C,F
38BC:  BNZ   38CA
38BE:  MOVF   x8D,F
38C0:  BNZ   38CA
38C2:  MOVF   x8E,F
38C4:  BNZ   38CA
38C6:  MOVLW  0C
38C8:  MOVWF  x96
38CA:  MOVLB  9
38CC:  MOVLB  5
38CE:  CLRF   x8E
38D0:  MOVLW  01
38D2:  MOVWF  x8D
38D4:  MOVLW  86
38D6:  MOVWF  x8C
38D8:  MOVLW  A0
38DA:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
38DC:  MOVFF  596,01
38E0:  MOVLB  0
38E2:  GOTO   3BEC (RETURN)
.................... }
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity,
....................                            int8 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = (int8)((quantity/8));
....................    
....................    if(quantity%8)
....................       count++;      
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
....................    
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < quantity; ++i)
....................    {
....................       modbus_serial_putc(make8(values[i],1));
....................       modbus_serial_putc(make8(values[i],0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... exception modbus_write_multiple_registers_flip(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
38E6:  BCF    FD8.0
38E8:  MOVLB  9
38EA:  RLCF   x87,W
38EC:  MOVWF  02
38EE:  RLCF   x88,W
38F0:  MOVFF  02,98C
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
38F4:  MOVFF  984,98D
38F8:  MOVLW  10
38FA:  MOVWF  x8E
38FC:  MOVLB  0
38FE:  CALL   20DE
.................... 
....................    modbus_serial_putc(make8(start_address,1));
3902:  MOVFF  986,990
3906:  CALL   20B4
....................    modbus_serial_putc(make8(start_address,0));
390A:  MOVFF  985,990
390E:  CALL   20B4
.................... 
....................    modbus_serial_putc(make8(quantity,1));
3912:  MOVFF  988,990
3916:  CALL   20B4
....................    modbus_serial_putc(make8(quantity,0));
391A:  MOVFF  987,990
391E:  CALL   20B4
....................    
....................    modbus_serial_putc(count);
3922:  MOVFF  98C,990
3926:  CALL   20B4
.................... 
....................    for(i=0; i < quantity; ++i)
392A:  MOVLB  9
392C:  CLRF   x8B
392E:  MOVF   x88,F
3930:  BNZ   3938
3932:  MOVF   x87,W
3934:  SUBWF  x8B,W
3936:  BC    3990
....................    {
....................       modbus_serial_putc(make8(values[i],0));
3938:  CLRF   03
393A:  MOVFF  98B,02
393E:  BCF    FD8.0
3940:  RLCF   02,F
3942:  RLCF   03,F
3944:  MOVF   02,W
3946:  ADDWF  x89,W
3948:  MOVWF  FE9
394A:  MOVF   x8A,W
394C:  ADDWFC 03,W
394E:  MOVWF  FEA
3950:  MOVFF  FEC,98E
3954:  MOVF   FED,F
3956:  MOVFF  FEF,990
395A:  MOVLB  0
395C:  CALL   20B4
....................       modbus_serial_putc(make8(values[i],1));
3960:  CLRF   03
3962:  MOVLB  9
3964:  MOVFF  98B,02
3968:  BCF    FD8.0
396A:  RLCF   02,F
396C:  RLCF   03,F
396E:  MOVF   02,W
3970:  ADDWF  x89,W
3972:  MOVWF  FE9
3974:  MOVF   x8A,W
3976:  ADDWFC 03,W
3978:  MOVWF  FEA
397A:  MOVFF  FEC,990
397E:  MOVF   FED,F
3980:  MOVFF  FEF,98D
3984:  MOVLB  0
3986:  CALL   20B4
398A:  MOVLB  9
398C:  INCF   x8B,F
398E:  BRA    392E
....................    }
.................... 
....................    modbus_serial_send_stop();
3990:  MOVLB  0
3992:  CALL   2106
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
3996:  MOVLB  9
3998:  MOVF   x84,F
399A:  BZ    39F0
399C:  MOVLB  0
399E:  CALL   213A
39A2:  MOVF   01,F
39A4:  BNZ   39D8
39A6:  MOVLW  FF
39A8:  MOVLB  5
39AA:  ADDWF  x8B,F
39AC:  BTFSS  FD8.0
39AE:  ADDWF  x8C,F
39B0:  BTFSS  FD8.0
39B2:  ADDWF  x8D,F
39B4:  BTFSS  FD8.0
39B6:  ADDWF  x8E,F
39B8:  MOVF   x8B,F
39BA:  BNZ   39CE
39BC:  MOVF   x8C,F
39BE:  BNZ   39CE
39C0:  MOVF   x8D,F
39C2:  BNZ   39CE
39C4:  MOVF   x8E,F
39C6:  BTFSS  FD8.2
39C8:  BRA    39CE
39CA:  MOVLB  0
39CC:  BRA    39D8
39CE:  CLRWDT
39D0:  NOP   
39D2:  MOVLB  9
39D4:  BRA    399C
39D6:  MOVLB  0
39D8:  MOVLB  5
39DA:  MOVF   x8B,F
39DC:  BNZ   39EE
39DE:  MOVF   x8C,F
39E0:  BNZ   39EE
39E2:  MOVF   x8D,F
39E4:  BNZ   39EE
39E6:  MOVF   x8E,F
39E8:  BNZ   39EE
39EA:  MOVLW  0C
39EC:  MOVWF  x96
39EE:  MOVLB  9
39F0:  MOVLB  5
39F2:  CLRF   x8E
39F4:  MOVLW  01
39F6:  MOVWF  x8D
39F8:  MOVLW  86
39FA:  MOVWF  x8C
39FC:  MOVLW  A0
39FE:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
3A00:  MOVFF  596,01
3A04:  MOVLB  0
3A06:  GOTO   3C2A (RETURN)
.................... }
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(int8 address, int8 byte_count, 
....................                             modbus_read_sub_request *request)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < (byte_count/7); i+=7)
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(int8 address, int8 byte_count, 
....................                             modbus_write_sub_request *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start,
....................                                     int16 read_quantity, int16 write_start,
....................                                     int16 write_quantity,
....................                                     int16 *write_registers_value)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(read_start,1));
....................    modbus_serial_putc(make8(read_start,0));
.................... 
....................    modbus_serial_putc(make8(read_quantity,1));
....................    modbus_serial_putc(make8(read_quantity,0));
.................... 
....................    modbus_serial_putc(make8(write_start, 1));
....................    modbus_serial_putc(make8(write_start, 0));
.................... 
....................    modbus_serial_putc(make8(write_quantity, 1));
....................    modbus_serial_putc(make8(write_quantity, 0));
.................... 
....................    modbus_serial_putc((int8)(2*write_quantity));
.................... 
....................    for(i=0; i < write_quantity ; i+=2)
....................    {
....................       modbus_serial_putc(make8(write_registers_value[i], 1));
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(FIFO_address, 1));
....................    modbus_serial_putc(make8(FIFO_address, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... #else
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*reg_data);
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... #endif
.................... 
.................... #include "iridium_sbd_rdTap.c"
.................... #define SBD_DEBUG 1
.................... 
.................... typedef struct {
.................... 	/* +SBDIX data from most recent */
.................... 	/* result from modem */
.................... 	int8  sbdix_response[42];
.................... 	/* parsed into */
.................... 	int8  sbdix_mo_status;
.................... 	int16 sbdix_mo_msn;
.................... 	int8  sbdix_mt_status;
.................... 	int16 sbdix_mt_msn;
.................... 	int16 sbdix_mt_length;
.................... 	int8  sbdix_mt_queued;
.................... 
.................... 
.................... 	/* "Mobile Originated" message from us to network */
.................... 	int8  mo_state;
.................... 	int8  mo_buff[272];
.................... 	int16 mo_length;
.................... 	int8  mo_try;
.................... 	int8  mo_sbdix_wait;
.................... 
.................... 	/* "Mobile Terminated" messages from network to us */
.................... 	int8  mt_ready;
.................... 	int8  mt_state;
.................... 	int8  mt_buff[256];
.................... 	int16 mt_length;
.................... 	int16 mt_checksum;
.................... 	
.................... 	/* ring alert */
.................... 	int8  ring_flag;
.................... 	int8  ring_state;
.................... 
.................... 	/* modem talking to us for status, AT commands, etc */
.................... 	int8 mr_ready;          /* 1=> message ready for consumption */
.................... 	int8 mr_buff[64];
.................... 	int8 mr_length;
.................... 	int8 mr_disable;
.................... //	int8 mr_receiver; /* 0 => iridum_mt_receive(), 1=> iridium_mo_send() */
.................... 
.................... } struct_iridium_sbd;
.................... 
.................... struct_iridium_sbd sbd={0};
.................... 
.................... int8 a_to_uint8(int8 *s) {
*
0F82:  MOVLB  9
0F84:  CLRF   x7E
....................    int8 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
0F86:  MOVFF  97D,FEA
0F8A:  MOVFF  97C,FE9
0F8E:  MOVF   FEF,W
0F90:  SUBLW  20
0F92:  BNZ   0F9C
....................       s++;
0F94:  INCF   x7C,F
0F96:  BTFSC  FD8.2
0F98:  INCF   x7D,F
0F9A:  BRA    0F86
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
0F9C:  MOVFF  97D,FEA
0FA0:  MOVFF  97C,FE9
0FA4:  MOVFF  FEF,97F
0FA8:  MOVF   x7F,W
0FAA:  SUBLW  2F
0FAC:  BC    0FD2
0FAE:  MOVF   x7F,W
0FB0:  SUBLW  39
0FB2:  BNC   0FD2
....................       value *= 10;
0FB4:  MOVF   x7E,W
0FB6:  MULLW  0A
0FB8:  MOVFF  FF3,97E
....................       value += (*s-'0');
0FBC:  MOVFF  97D,FEA
0FC0:  MOVFF  97C,FE9
0FC4:  MOVLW  30
0FC6:  SUBWF  FEF,W
0FC8:  ADDWF  x7E,F
....................       s++;
0FCA:  INCF   x7C,F
0FCC:  BTFSC  FD8.2
0FCE:  INCF   x7D,F
0FD0:  BRA    0F9C
....................    }
.................... 
....................    return value;
0FD2:  MOVFF  97E,01
0FD6:  MOVLB  0
0FD8:  RETURN 0
.................... }
.................... 
.................... int16 a_to_uint16(int8 *s) {
*
101A:  MOVLB  9
101C:  CLRF   x7F
101E:  CLRF   x7E
....................    int16 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
1020:  MOVFF  97D,FEA
1024:  MOVFF  97C,FE9
1028:  MOVF   FEF,W
102A:  SUBLW  20
102C:  BNZ   1036
....................       s++;
102E:  INCF   x7C,F
1030:  BTFSC  FD8.2
1032:  INCF   x7D,F
1034:  BRA    1020
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
1036:  MOVFF  97D,FEA
103A:  MOVFF  97C,FE9
103E:  MOVFF  FEF,980
1042:  MOVF   x80,W
1044:  SUBLW  2F
1046:  BC    1084
1048:  MOVF   x80,W
104A:  SUBLW  39
104C:  BNC   1084
....................       value *= 10;
104E:  MOVFF  97F,995
1052:  MOVFF  97E,994
1056:  CLRF   x97
1058:  MOVLW  0A
105A:  MOVWF  x96
105C:  MOVLB  0
105E:  RCALL  0CA2
1060:  MOVFF  02,97F
1064:  MOVFF  01,97E
....................       value += (*s-'0');
1068:  MOVFF  97D,FEA
106C:  MOVLB  9
106E:  MOVFF  97C,FE9
1072:  MOVLW  30
1074:  SUBWF  FEF,W
1076:  ADDWF  x7E,F
1078:  MOVLW  00
107A:  ADDWFC x7F,F
....................       s++;
107C:  INCF   x7C,F
107E:  BTFSC  FD8.2
1080:  INCF   x7D,F
1082:  BRA    1036
....................    }
.................... 
....................    return value;
1084:  MOVFF  97E,01
1088:  MOVFF  97F,02
108C:  MOVLB  0
108E:  RETURN 0
.................... }
.................... 
.................... void iridium_sbdix_parse(void) {
.................... 	int8 *p;
.................... 
.................... 	/*
.................... 	 * Quick check of potential validity of response:
.................... 	 * a) valid response would need to be at least 24 characters
.................... 	 * +SBDIX: 0, 25, 0, 0, 0, 0	
.................... 	 * 012345678901234567890123456789
.................... 	 *           1         2
.................... 	 * b) mo_status always starts at character 8
.................... 	 * */
.................... 	if ( strlen(sbd.sbdix_response) < 24 || ! isdigit(sbd.sbdix_response[8] ) ) {
*
122E:  MOVLW  06
1230:  MOVLB  9
1232:  MOVWF  x7D
1234:  MOVLW  96
1236:  MOVWF  x7C
1238:  MOVLB  0
123A:  BRA    0F48
123C:  MOVFF  02,97D
1240:  MOVFF  01,97C
1244:  MOVLB  9
1246:  MOVF   x7D,F
1248:  BNZ   1250
124A:  MOVF   x7C,W
124C:  SUBLW  17
124E:  BC    1266
1250:  MOVLB  6
1252:  MOVF   x9E,W
1254:  SUBLW  2F
1256:  BTFSS  FD8.0
1258:  BRA    125E
125A:  MOVLB  9
125C:  BRA    1266
125E:  MOVF   x9E,W
1260:  SUBLW  39
1262:  BC    126A
1264:  MOVLB  9
.................... 		/* if not a digit or too short, then we give up */
.................... 		return;
1266:  BRA    14E6
1268:  MOVLB  6
.................... 	}
.................... 	sbd.sbdix_mo_status=a_to_uint8(sbd.sbdix_response+8);
126A:  MOVLW  06
126C:  MOVLB  9
126E:  MOVWF  x7D
1270:  MOVLW  9E
1272:  MOVWF  x7C
1274:  MOVLB  0
1276:  RCALL  0F82
1278:  MOVFF  01,6C0
.................... 
.................... 	/* mo_msn (with preceeding space) starts after comma */
.................... 	p = strchr(sbd.sbdix_response+9,',');
127C:  MOVLW  06
127E:  MOVLB  9
1280:  MOVWF  x7F
1282:  MOVLW  9F
1284:  MOVWF  x7E
1286:  MOVLW  2C
1288:  MOVWF  x80
128A:  MOVLB  0
128C:  RCALL  0FDA
128E:  MOVFF  02,97B
1292:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
1296:  MOVLB  9
1298:  MOVF   x7A,F
129A:  BNZ   12A2
129C:  MOVF   x7B,F
129E:  BNZ   12A2
.................... 		/* not found */
.................... 		return;
12A0:  BRA    14E6
.................... 	}
.................... 	p++; /* swallow the ',' */
12A2:  INCF   x7A,F
12A4:  BTFSC  FD8.2
12A6:  INCF   x7B,F
.................... 	sbd.sbdix_mo_msn=a_to_uint16(p);
12A8:  MOVFF  97B,97D
12AC:  MOVFF  97A,97C
12B0:  MOVLB  0
12B2:  RCALL  101A
12B4:  MOVFF  02,6C2
12B8:  MOVFF  01,6C1
.................... 
.................... 	/* mt_status (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
12BC:  MOVLW  01
12BE:  MOVLB  9
12C0:  ADDWF  x7A,W
12C2:  MOVWF  x7C
12C4:  MOVLW  00
12C6:  ADDWFC x7B,W
12C8:  MOVWF  x7D
12CA:  MOVWF  x7F
12CC:  MOVFF  97C,97E
12D0:  MOVLW  2C
12D2:  MOVWF  x80
12D4:  MOVLB  0
12D6:  RCALL  0FDA
12D8:  MOVFF  02,97B
12DC:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
12E0:  MOVLB  9
12E2:  MOVF   x7A,F
12E4:  BNZ   12EC
12E6:  MOVF   x7B,F
12E8:  BNZ   12EC
.................... 		/* not found */
.................... 		return;
12EA:  BRA    14E6
.................... 	}
.................... 	p++; /* swallow the ',' */
12EC:  INCF   x7A,F
12EE:  BTFSC  FD8.2
12F0:  INCF   x7B,F
.................... 	sbd.sbdix_mt_status=a_to_uint8(p);
12F2:  MOVFF  97B,97D
12F6:  MOVFF  97A,97C
12FA:  MOVLB  0
12FC:  RCALL  0F82
12FE:  MOVFF  01,6C3
.................... 
.................... 	/* mt_msn (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
1302:  MOVLW  01
1304:  MOVLB  9
1306:  ADDWF  x7A,W
1308:  MOVWF  x7C
130A:  MOVLW  00
130C:  ADDWFC x7B,W
130E:  MOVWF  x7D
1310:  MOVWF  x7F
1312:  MOVFF  97C,97E
1316:  MOVLW  2C
1318:  MOVWF  x80
131A:  MOVLB  0
131C:  RCALL  0FDA
131E:  MOVFF  02,97B
1322:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
1326:  MOVLB  9
1328:  MOVF   x7A,F
132A:  BNZ   1332
132C:  MOVF   x7B,F
132E:  BNZ   1332
.................... 		/* not found */
.................... 		return;
1330:  BRA    14E6
.................... 	}
.................... 	p++; /* swallow the ',' */
1332:  INCF   x7A,F
1334:  BTFSC  FD8.2
1336:  INCF   x7B,F
.................... 	sbd.sbdix_mt_msn=a_to_uint16(p);
1338:  MOVFF  97B,97D
133C:  MOVFF  97A,97C
1340:  MOVLB  0
1342:  RCALL  101A
1344:  MOVFF  02,6C5
1348:  MOVFF  01,6C4
.................... 
.................... 	/* mt_length (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
134C:  MOVLW  01
134E:  MOVLB  9
1350:  ADDWF  x7A,W
1352:  MOVWF  x7C
1354:  MOVLW  00
1356:  ADDWFC x7B,W
1358:  MOVWF  x7D
135A:  MOVWF  x7F
135C:  MOVFF  97C,97E
1360:  MOVLW  2C
1362:  MOVWF  x80
1364:  MOVLB  0
1366:  RCALL  0FDA
1368:  MOVFF  02,97B
136C:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
1370:  MOVLB  9
1372:  MOVF   x7A,F
1374:  BNZ   137C
1376:  MOVF   x7B,F
1378:  BNZ   137C
.................... 		/* not found */
.................... 		return;
137A:  BRA    14E6
.................... 	}
.................... 	p++; /* swallow the ',' */
137C:  INCF   x7A,F
137E:  BTFSC  FD8.2
1380:  INCF   x7B,F
.................... 	sbd.sbdix_mt_length=a_to_uint16(p);
1382:  MOVFF  97B,97D
1386:  MOVFF  97A,97C
138A:  MOVLB  0
138C:  RCALL  101A
138E:  MOVFF  02,6C7
1392:  MOVFF  01,6C6
.................... 
.................... 	/* mt_queued (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
1396:  MOVLW  01
1398:  MOVLB  9
139A:  ADDWF  x7A,W
139C:  MOVWF  x7C
139E:  MOVLW  00
13A0:  ADDWFC x7B,W
13A2:  MOVWF  x7D
13A4:  MOVWF  x7F
13A6:  MOVFF  97C,97E
13AA:  MOVLW  2C
13AC:  MOVWF  x80
13AE:  MOVLB  0
13B0:  RCALL  0FDA
13B2:  MOVFF  02,97B
13B6:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
13BA:  MOVLB  9
13BC:  MOVF   x7A,F
13BE:  BNZ   13C6
13C0:  MOVF   x7B,F
13C2:  BNZ   13C6
.................... 		/* not found */
.................... 		return;
13C4:  BRA    14E6
.................... 	}
.................... 	p++; /* swallow the ',' */
13C6:  INCF   x7A,F
13C8:  BTFSC  FD8.2
13CA:  INCF   x7B,F
.................... 	sbd.sbdix_mt_queued=a_to_uint8(p);
13CC:  MOVFF  97B,97D
13D0:  MOVFF  97A,97C
13D4:  MOVLB  0
13D6:  RCALL  0F82
13D8:  MOVFF  01,6C8
.................... 
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_sbdix_parse():\r\n");
13DC:  MOVLW  E2
13DE:  MOVWF  FF6
13E0:  MOVLW  03
13E2:  MOVWF  FF7
13E4:  CALL   0B38
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_status   = %d\n",sbd.sbdix_mo_status);
13E8:  MOVLW  FE
13EA:  MOVWF  FF6
13EC:  MOVLW  03
13EE:  MOVWF  FF7
13F0:  MOVLW  18
13F2:  MOVLB  9
13F4:  MOVWF  x7C
13F6:  MOVLB  0
13F8:  CALL   0B5A
13FC:  MOVFF  6C0,97C
1400:  MOVLW  18
1402:  MOVLB  9
1404:  MOVWF  x7D
1406:  MOVLB  0
1408:  RCALL  10BC
140A:  MOVLW  0A
140C:  BTFSS  FA4.4
140E:  BRA    140C
1410:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_msn      = %lu\n",sbd.sbdix_mo_msn);
1412:  MOVLW  1A
1414:  MOVWF  FF6
1416:  MOVLW  04
1418:  MOVWF  FF7
141A:  MOVLW  18
141C:  MOVLB  9
141E:  MOVWF  x7C
1420:  MOVLB  0
1422:  CALL   0B5A
1426:  MOVLW  10
1428:  MOVWF  FE9
142A:  MOVFF  6C2,97D
142E:  MOVFF  6C1,97C
1432:  RCALL  117A
1434:  MOVLW  0A
1436:  BTFSS  FA4.4
1438:  BRA    1436
143A:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_status   = %d\n",sbd.sbdix_mt_status);
143C:  MOVLW  38
143E:  MOVWF  FF6
1440:  MOVLW  04
1442:  MOVWF  FF7
1444:  MOVLW  18
1446:  MOVLB  9
1448:  MOVWF  x7C
144A:  MOVLB  0
144C:  CALL   0B5A
1450:  MOVFF  6C3,97C
1454:  MOVLW  18
1456:  MOVLB  9
1458:  MOVWF  x7D
145A:  MOVLB  0
145C:  RCALL  10BC
145E:  MOVLW  0A
1460:  BTFSS  FA4.4
1462:  BRA    1460
1464:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_msn      = %lu\n",sbd.sbdix_mt_msn);
1466:  MOVLW  54
1468:  MOVWF  FF6
146A:  MOVLW  04
146C:  MOVWF  FF7
146E:  MOVLW  18
1470:  MOVLB  9
1472:  MOVWF  x7C
1474:  MOVLB  0
1476:  CALL   0B5A
147A:  MOVLW  10
147C:  MOVWF  FE9
147E:  MOVFF  6C5,97D
1482:  MOVFF  6C4,97C
1486:  RCALL  117A
1488:  MOVLW  0A
148A:  BTFSS  FA4.4
148C:  BRA    148A
148E:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_length   = %lu\n",sbd.sbdix_mt_length);
1490:  MOVLW  72
1492:  MOVWF  FF6
1494:  MOVLW  04
1496:  MOVWF  FF7
1498:  MOVLW  18
149A:  MOVLB  9
149C:  MOVWF  x7C
149E:  MOVLB  0
14A0:  CALL   0B5A
14A4:  MOVLW  10
14A6:  MOVWF  FE9
14A8:  MOVFF  6C7,97D
14AC:  MOVFF  6C6,97C
14B0:  RCALL  117A
14B2:  MOVLW  0A
14B4:  BTFSS  FA4.4
14B6:  BRA    14B4
14B8:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_queued   = %d\n",sbd.sbdix_mt_queued);
14BA:  MOVLW  90
14BC:  MOVWF  FF6
14BE:  MOVLW  04
14C0:  MOVWF  FF7
14C2:  MOVLW  18
14C4:  MOVLB  9
14C6:  MOVWF  x7C
14C8:  MOVLB  0
14CA:  CALL   0B5A
14CE:  MOVFF  6C8,97C
14D2:  MOVLW  18
14D4:  MOVLB  9
14D6:  MOVWF  x7D
14D8:  MOVLB  0
14DA:  RCALL  10BC
14DC:  MOVLW  0A
14DE:  BTFSS  FA4.4
14E0:  BRA    14DE
14E2:  MOVWF  F79
14E4:  MOVLB  9
.................... #endif
14E6:  MOVLB  0
14E8:  GOTO   421E (RETURN)
.................... 
.................... }
.................... 
.................... #if 0
.................... void _iridium_on(void) {
.................... 	/* turn power switch on */
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_high(CTRL_0); break;
.................... 		case 2: output_high(CTRL_1); break;
.................... 		case 3: output_high(CTRL_2); break;
.................... 		case 4: output_high(CTRL_3); break;
.................... 		case 5: output_high(CTRL_4); break;
.................... 	}
.................... 	
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000000);
.................... 
.................... }
.................... 
.................... void _iridium_off(void) {
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_low(CTRL_0); break;
.................... 		case 2: output_low(CTRL_1); break;
.................... 		case 3: output_low(CTRL_2); break;
.................... 		case 4: output_low(CTRL_3); break;
.................... 		case 5: output_low(CTRL_4); break;
.................... 	}
.................... 
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000010);
.................... }
.................... #endif
.................... 
.................... void iridium_mr_clear(void) {
.................... 	sbd.mr_ready=0;
*
0F14:  MOVLB  8
0F16:  CLRF   xE6
.................... 	sbd.mr_length=0;
0F18:  MOVLB  9
0F1A:  CLRF   x27
0F1C:  MOVLB  0
0F1E:  RETURN 0
.................... }
.................... 
.................... void iridium_mo_clear(void) {
.................... 	sbd.mo_length=0;
*
1CB2:  MOVLB  7
1CB4:  CLRF   xDB
1CB6:  CLRF   xDA
.................... 	sbd.mo_state=0;
1CB8:  MOVLB  6
1CBA:  CLRF   xC9
1CBC:  MOVLB  0
1CBE:  RETURN 0
.................... }
.................... 
.................... void iridium_mt_clear(void) {
.................... 	sbd.mt_length=0;
.................... 	sbd.mt_state=0;
.................... }
.................... 
.................... /* if we have characters to be received, this function reads them */
.................... void iridium_getc(void) {
.................... 	int8 c;
.................... 
.................... 
.................... 	/* read character from UART */
.................... 	c = uart_getc();
*
1656:  MOVFF  01,97A
.................... 
.................... 
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# uart_getc=%02x\r\n",c);
165A:  MOVLW  AC
165C:  MOVWF  FF6
165E:  MOVLW  04
1660:  MOVWF  FF7
1662:  MOVLW  0C
1664:  MOVLB  9
1666:  MOVWF  x7C
1668:  MOVLB  0
166A:  CALL   0B5A
166E:  MOVFF  97A,97B
1672:  MOVLW  57
1674:  MOVLB  9
1676:  MOVWF  x7C
1678:  MOVLB  0
167A:  BRA    1604
167C:  MOVLW  0D
167E:  BTFSS  FA4.4
1680:  BRA    167E
1682:  MOVWF  F79
1684:  MOVLW  0A
1686:  BTFSS  FA4.4
1688:  BRA    1686
168A:  MOVWF  F79
.................... #endif
.................... 
.................... 	if ( '\r' == c ) {
168C:  MOVLB  9
168E:  MOVF   x7A,W
1690:  SUBLW  0D
1692:  BNZ   1696
.................... 		/* except when receiving binary data, we don't care about '\r' */
.................... 		return;
1694:  BRA    172A
.................... 	}
.................... 
.................... 	/* modem always appears to send '\r' '\n' */
.................... 	
.................... 
.................... 	if ( 0 == sbd.mr_ready ) {
1696:  MOVLB  8
1698:  MOVF   xE6,F
169A:  BNZ   172C
.................... 		/* receiving data */
.................... 
.................... 		if ( '\n' == c && 0==sbd.mr_length ) {
169C:  MOVLB  9
169E:  MOVF   x7A,W
16A0:  SUBLW  0A
16A2:  BNZ   16AA
16A4:  MOVF   x27,F
16A6:  BNZ   16AA
.................... 			/* responses usually appear to be \r\nOK\r\n ... this skips the empty message */
.................... 			return;
16A8:  BRA    172A
.................... 		}
.................... 
.................... 		
.................... 		/* check for 'SBDRING' message and deal with it accordingly */
.................... 		if ( 'S'==sbd.mr_buff[0] && 'B'==sbd.mr_buff[1] && 'D'==sbd.mr_buff[2] 
.................... 			&& 'R'==sbd.mr_buff[3] && 'I'==sbd.mr_buff[4] && 'N'==sbd.mr_buff[5] && 'G'==c ) {
16AA:  MOVLB  8
16AC:  MOVF   xE7,W
16AE:  SUBLW  53
16B0:  BNZ   16EE
16B2:  MOVF   xE8,W
16B4:  SUBLW  42
16B6:  BNZ   16EE
16B8:  MOVF   xE9,W
16BA:  SUBLW  44
16BC:  BNZ   16EE
16BE:  MOVF   xEA,W
16C0:  SUBLW  52
16C2:  BNZ   16EE
16C4:  MOVF   xEB,W
16C6:  SUBLW  49
16C8:  BNZ   16EE
16CA:  MOVF   xEC,W
16CC:  SUBLW  4E
16CE:  BNZ   16EE
16D0:  MOVLB  9
16D2:  MOVF   x7A,W
16D4:  SUBLW  47
16D6:  BTFSC  FD8.2
16D8:  BRA    16DE
16DA:  MOVLB  8
16DC:  BRA    16EE
.................... 			sbd.ring_flag=1;
16DE:  MOVLW  01
16E0:  MOVLB  8
16E2:  MOVWF  xE4
.................... 			iridium_mr_clear();
16E4:  MOVLB  0
16E6:  RCALL  0F14
.................... 			return;
16E8:  MOVLB  9
16EA:  BRA    172A
16EC:  MOVLB  8
.................... 		 }
.................... 
.................... 		if ( '\n' == c ) {
16EE:  MOVLB  9
16F0:  MOVF   x7A,W
16F2:  SUBLW  0A
16F4:  BNZ   1710
.................... 			/* replace '\n' with '\0' */
.................... 			sbd.mr_buff[sbd.mr_length]='\0';
16F6:  MOVLW  E7
16F8:  ADDWF  x27,W
16FA:  MOVWF  FE9
16FC:  MOVLW  08
16FE:  MOVWF  FEA
1700:  BTFSC  FD8.0
1702:  INCF   FEA,F
1704:  CLRF   FEF
.................... 			
.................... 			/* mark that we have a message ready */
.................... 			sbd.mr_ready=1;
1706:  MOVLW  01
1708:  MOVLB  8
170A:  MOVWF  xE6
.................... 
.................... 			/* done */
.................... 			return;
170C:  MOVLB  9
170E:  BRA    172A
.................... 		}
.................... 
.................... 
.................... 		/* put in response buffer if not full */
.................... 		if ( sbd.mr_length < ( sizeof(sbd.mr_buff) - 1 ) ) {
1710:  MOVF   x27,W
1712:  SUBLW  3E
1714:  BNC   172A
.................... 			sbd.mr_buff[sbd.mr_length]=c;
1716:  MOVLW  E7
1718:  ADDWF  x27,W
171A:  MOVWF  FE9
171C:  MOVLW  08
171E:  MOVWF  FEA
1720:  BTFSC  FD8.0
1722:  INCF   FEA,F
1724:  MOVFF  97A,FEF
.................... 			sbd.mr_length++;
1728:  INCF   x27,F
.................... 		} else {
172A:  MOVLB  8
.................... 			/* buffer is full ... do nothing and wait for message to be terminated */
.................... 		}
.................... 	}
172C:  MOVLB  0
172E:  GOTO   428E (RETURN)
.................... }
.................... 
.................... void iridium_ringing(void) {
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_ringing() sbd.ring_state=%u\r\n",sbd.ring_state);
.................... #endif
.................... 
.................... 	if ( 0 == sbd.ring_state ) {
.................... 		/* nothing to do */
.................... 		return;
.................... 	}else if ( 1 == sbd.ring_state ) {
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"ATE0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.ring_state ) {
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT&K0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}	
.................... 	} else if ( 5 == sbd.ring_state ) {
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}
.................... 	} else if ( 7 == sbd.ring_state ) {
.................... 		/* send 'AT+CRIS' to determine why we rang */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+CRIS\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.ring_state ) {
.................... 		/* parse CRIS response. But in reality, with an SBD only device it can only be SBD message that causes us to ring */
.................... 	} 
.................... 
.................... }
.................... 
.................... void iridium_mo_send(void) {
.................... 	int16 l;
.................... 	int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... //	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u sbd.mo_sbdix_wait=%u\r\n",sbd.mo_state,sbd.mo_try,sbd.mo_sbdix_wait);
.................... #endif
.................... 
.................... 
.................... 	if ( 0 == sbd.mo_state ) {
*
1CC0:  MOVLB  6
1CC2:  MOVF   xC9,F
1CC4:  BNZ   1CCA
.................... 		/* nothing to do */
.................... 		return;
1CC6:  BRA    20A4
.................... 
.................... 	} else if ( 1 == sbd.mo_state ) {
1CC8:  BRA    209E
1CCA:  DECFSZ xC9,W
1CCC:  BRA    1CE4
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
1CCE:  MOVLB  0
1CD0:  CALL   0F14
.................... 		printf(uart_putc,"ATE0\r");
1CD4:  MOVLW  0E
1CD6:  MOVWF  FF6
1CD8:  MOVLW  05
1CDA:  MOVWF  FF7
1CDC:  RCALL  1742
.................... 		sbd.mo_state++;
1CDE:  MOVLB  6
1CE0:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mo_state ) {
1CE2:  BRA    209E
1CE4:  MOVF   xC9,W
1CE6:  SUBLW  02
1CE8:  BNZ   1D0E
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1CEA:  MOVLB  8
1CEC:  DECFSZ xE6,W
1CEE:  BRA    1D0A
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1CF0:  MOVF   xE7,W
1CF2:  SUBLW  4F
1CF4:  BNZ   1D02
1CF6:  MOVF   xE8,W
1CF8:  SUBLW  4B
1CFA:  BNZ   1D02
.................... 				sbd.mo_state++;
1CFC:  MOVLB  6
1CFE:  INCF   xC9,F
1D00:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
1D02:  MOVLB  0
1D04:  CALL   0F14
1D08:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mo_state ) {
1D0A:  BRA    20A0
1D0C:  MOVLB  6
1D0E:  MOVF   xC9,W
1D10:  SUBLW  03
1D12:  BNZ   1D2A
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
1D14:  MOVLB  0
1D16:  CALL   0F14
.................... 		printf(uart_putc,"AT&K0\r");
1D1A:  MOVLW  14
1D1C:  MOVWF  FF6
1D1E:  MOVLW  05
1D20:  MOVWF  FF7
1D22:  RCALL  1742
.................... 		sbd.mo_state++;
1D24:  MOVLB  6
1D26:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mo_state ) {
1D28:  BRA    209E
1D2A:  MOVF   xC9,W
1D2C:  SUBLW  04
1D2E:  BNZ   1D54
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1D30:  MOVLB  8
1D32:  DECFSZ xE6,W
1D34:  BRA    1D50
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1D36:  MOVF   xE7,W
1D38:  SUBLW  4F
1D3A:  BNZ   1D48
1D3C:  MOVF   xE8,W
1D3E:  SUBLW  4B
1D40:  BNZ   1D48
.................... 				sbd.mo_state++;
1D42:  MOVLB  6
1D44:  INCF   xC9,F
1D46:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1D48:  MOVLB  0
1D4A:  CALL   0F14
1D4E:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mo_state ) {
1D50:  BRA    20A0
1D52:  MOVLB  6
1D54:  MOVF   xC9,W
1D56:  SUBLW  05
1D58:  BNZ   1D70
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
1D5A:  MOVLB  0
1D5C:  CALL   0F14
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
1D60:  MOVLW  1C
1D62:  MOVWF  FF6
1D64:  MOVLW  05
1D66:  MOVWF  FF7
1D68:  RCALL  1742
.................... 		sbd.mo_state++;
1D6A:  MOVLB  6
1D6C:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mo_state ) {
1D6E:  BRA    209E
1D70:  MOVF   xC9,W
1D72:  SUBLW  06
1D74:  BNZ   1D9A
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
1D76:  MOVLB  8
1D78:  DECFSZ xE6,W
1D7A:  BRA    1D96
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1D7C:  MOVF   xE7,W
1D7E:  SUBLW  4F
1D80:  BNZ   1D8E
1D82:  MOVF   xE8,W
1D84:  SUBLW  4B
1D86:  BNZ   1D8E
.................... 				sbd.mo_state++;
1D88:  MOVLB  6
1D8A:  INCF   xC9,F
1D8C:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1D8E:  MOVLB  0
1D90:  CALL   0F14
1D94:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mo_state ) {
1D96:  BRA    20A0
1D98:  MOVLB  6
1D9A:  MOVF   xC9,W
1D9C:  SUBLW  07
1D9E:  BNZ   1DD6
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDWB=[<SBD Message Length>]' to tell modem how long our MO */
.................... 		iridium_mr_clear();
1DA0:  MOVLB  0
1DA2:  CALL   0F14
.................... 		printf(uart_putc,"AT+SBDWB=%lu\r",sbd.mo_length);
1DA6:  MOVLW  2A
1DA8:  MOVWF  FF6
1DAA:  MOVLW  05
1DAC:  MOVWF  FF7
1DAE:  MOVLW  09
1DB0:  MOVLB  9
1DB2:  MOVWF  x7E
1DB4:  MOVLB  0
1DB6:  BRA    1B12
1DB8:  MOVLW  10
1DBA:  MOVWF  FE9
1DBC:  MOVFF  7DB,97F
1DC0:  MOVFF  7DA,97E
1DC4:  BRA    1B3C
1DC6:  MOVLW  0D
1DC8:  MOVLB  9
1DCA:  MOVWF  x87
1DCC:  MOVLB  0
1DCE:  RCALL  1732
.................... 		sbd.mo_state++;
1DD0:  MOVLB  6
1DD2:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mo_state ) {
1DD4:  BRA    209E
1DD6:  MOVF   xC9,W
1DD8:  SUBLW  08
1DDA:  BNZ   1E12
.................... 		/* receive response 'READY' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1DDC:  MOVLB  8
1DDE:  DECFSZ xE6,W
1DE0:  BRA    1E0E
.................... 			if ( 'R'==sbd.mr_buff[0] 
....................                  && 'E'==sbd.mr_buff[1] 
....................                  && 'A'==sbd.mr_buff[2]
.................... 			     && 'D'==sbd.mr_buff[3]
.................... 			     && 'Y'==sbd.mr_buff[4]
1DE2:  MOVF   xE7,W
1DE4:  SUBLW  52
1DE6:  BNZ   1E06
1DE8:  MOVF   xE8,W
1DEA:  SUBLW  45
1DEC:  BNZ   1E06
1DEE:  MOVF   xE9,W
1DF0:  SUBLW  41
1DF2:  BNZ   1E06
1DF4:  MOVF   xEA,W
1DF6:  SUBLW  44
1DF8:  BNZ   1E06
1DFA:  MOVF   xEB,W
1DFC:  SUBLW  59
1DFE:  BNZ   1E06
.................... 			    ) {
.................... 				sbd.mo_state++;
1E00:  MOVLB  6
1E02:  INCF   xC9,F
1E04:  MOVLB  8
.................... 			}
.................... 		
.................... 			/* clear mr because either we got READY or we got a bad response */
.................... 			iridium_mr_clear();				
1E06:  MOVLB  0
1E08:  CALL   0F14
1E0C:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 9 == sbd.mo_state ) {
1E0E:  BRA    20A0
1E10:  MOVLB  6
1E12:  MOVF   xC9,W
1E14:  SUBLW  09
1E16:  BNZ   1EA0
.................... 		/* send binary message and 2 byte checksum */
.................... 		iridium_mr_clear();
1E18:  MOVLB  0
1E1A:  CALL   0F14
.................... 		checksum=0;
1E1E:  MOVLB  9
1E20:  CLRF   x7D
1E22:  CLRF   x7C
.................... 		/* send data bytes and update checksum */
.................... 		for ( l=0 ; l<sbd.mo_length ; l++ ) {
1E24:  CLRF   x7B
1E26:  CLRF   x7A
1E28:  MOVF   x7B,W
1E2A:  MOVLB  7
1E2C:  SUBWF  xDB,W
1E2E:  BNC   1E8C
1E30:  BNZ   1E42
1E32:  MOVF   xDA,W
1E34:  MOVLB  9
1E36:  SUBWF  x7A,W
1E38:  BTFSS  FD8.0
1E3A:  BRA    1E40
1E3C:  MOVLB  7
1E3E:  BRA    1E8C
1E40:  MOVLB  7
.................... 			uart_putc(sbd.mo_buff[l]);
1E42:  MOVLW  CA
1E44:  MOVLB  9
1E46:  ADDWF  x7A,W
1E48:  MOVWF  FE9
1E4A:  MOVLW  06
1E4C:  ADDWFC x7B,W
1E4E:  MOVWF  FEA
1E50:  MOVFF  FEF,987
1E54:  MOVLB  0
1E56:  RCALL  1732
.................... 			delay_us(500);
1E58:  CLRWDT
1E5A:  MOVLW  02
1E5C:  MOVLB  9
1E5E:  MOVWF  x7E
1E60:  MOVLW  F7
1E62:  MOVWF  x7F
1E64:  MOVLB  0
1E66:  BRA    1C04
1E68:  MOVLB  9
1E6A:  DECFSZ x7E,F
1E6C:  BRA    1E60
.................... 			checksum += sbd.mo_buff[l];
1E6E:  MOVLW  CA
1E70:  ADDWF  x7A,W
1E72:  MOVWF  FE9
1E74:  MOVLW  06
1E76:  ADDWFC x7B,W
1E78:  MOVWF  FEA
1E7A:  MOVF   FEF,W
1E7C:  ADDWF  x7C,F
1E7E:  MOVLW  00
1E80:  ADDWFC x7D,F
1E82:  INCF   x7A,F
1E84:  BTFSC  FD8.2
1E86:  INCF   x7B,F
1E88:  BRA    1E28
1E8A:  MOVLB  7
.................... 		}
.................... 
.................... 		/* send checksum bytes */
.................... 		uart_putc(make8(checksum,1));
1E8C:  MOVFF  97D,987
1E90:  MOVLB  0
1E92:  RCALL  1732
.................... 		uart_putc(make8(checksum,0));
1E94:  MOVFF  97C,987
1E98:  RCALL  1732
.................... 
.................... 		sbd.mo_state++;
1E9A:  MOVLB  6
1E9C:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		
.................... 	} else if ( 10 == sbd.mo_state ) {
1E9E:  BRA    209E
1EA0:  MOVF   xC9,W
1EA2:  SUBLW  0A
1EA4:  BNZ   1EC8
.................... 		/* 
.................... 		receive response <Status> which means 
.................... 		
.................... 		0 => SBD message successfully written to the ISU.
.................... 
.................... 		1 => SBD message write timeout. An insufficient number of bytes were transferred 
.................... 		to ISU during the transfer period of 60 seconds.
.................... 
.................... 		2 => SBD message checksum sent from DTE does not match the checksum calculated at 
.................... 		the ISU.
.................... 
.................... 		3 => SBD message size is not correct. The maximum mobile originated SBD message 
.................... 		length is 340 bytes. The minimum mobile originated SBD message length is 1 byte.
.................... 		*/
.................... 
.................... 		/* status must be 0 */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1EA6:  MOVLB  8
1EA8:  DECFSZ xE6,W
1EAA:  BRA    1EC4
.................... 			if ( '0'==sbd.mr_buff[0] ) {
1EAC:  MOVF   xE7,W
1EAE:  SUBLW  30
1EB0:  BNZ   1EBA
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
1EB2:  MOVLB  6
1EB4:  INCF   xC9,F
.................... 			} else {
1EB6:  BRA    1EC2
1EB8:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
1EBA:  MOVLB  0
1EBC:  CALL   0F14
1EC0:  MOVLB  6
1EC2:  MOVLB  8
.................... 			}
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mo_state ) {
1EC4:  BRA    20A0
1EC6:  MOVLB  6
1EC8:  MOVF   xC9,W
1ECA:  SUBLW  0B
1ECC:  BNZ   1EF2
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1ECE:  MOVLB  8
1ED0:  DECFSZ xE6,W
1ED2:  BRA    1EEE
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1ED4:  MOVF   xE7,W
1ED6:  SUBLW  4F
1ED8:  BNZ   1EE6
1EDA:  MOVF   xE8,W
1EDC:  SUBLW  4B
1EDE:  BNZ   1EE6
.................... 				sbd.mo_state++;
1EE0:  MOVLB  6
1EE2:  INCF   xC9,F
1EE4:  MOVLB  8
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
1EE6:  MOVLB  0
1EE8:  CALL   0F14
1EEC:  MOVLB  8
.................... 		}
.................... 
.................... 	} else if ( 12 == sbd.mo_state ) {
1EEE:  BRA    20A0
1EF0:  MOVLB  6
1EF2:  MOVF   xC9,W
1EF4:  SUBLW  0C
1EF6:  BNZ   1F1E
.................... 		/* send 'AT+SBDIX' to initiate Extended SBD Session */
.................... 
.................... 		if ( sbd.mo_try > 0 && 0 != sbd.mo_sbdix_wait ) {
1EF8:  MOVLB  7
1EFA:  MOVF   xDC,F
1EFC:  BZ    1F08
1EFE:  MOVF   xDD,F
1F00:  BZ    1F08
.................... 			/* external function decrements sbd.mo_sbdix_wait once per second */
.................... 			return;
1F02:  MOVLB  6
1F04:  BRA    20A4
1F06:  MOVLB  7
.................... 		}
.................... 
.................... 		iridium_mr_clear();
1F08:  MOVLB  0
1F0A:  CALL   0F14
.................... 		printf(uart_putc,"AT+SBDIX\r");
1F0E:  MOVLW  38
1F10:  MOVWF  FF6
1F12:  MOVLW  05
1F14:  MOVWF  FF7
1F16:  RCALL  1742
.................... 		sbd.mo_state++;
1F18:  MOVLB  6
1F1A:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 13 == sbd.mo_state ) {
1F1C:  BRA    209E
1F1E:  MOVF   xC9,W
1F20:  SUBLW  0D
1F22:  BNZ   1FB0
.................... 		/*
.................... 		receive response:
.................... 			 +SBDIX: <MO status>, <MOMSN>, <MT status>, <MTMSN>, <MT length>, <MT queued>
.................... 		which means
.................... 
.................... 		<MO status> - Any returned number with a value of 0 to 2 indicates your message 
.................... 		has been successfully transmitted. Any number above 2 indicates that the message 
.................... 		has not been successfully transmitted.
.................... 
.................... 		Per rock7 website (https://docs.rockblock.rock7.com/reference/sbdix):
.................... 		0	MO message, if any, transferred successfully.
.................... 		1	MO message, if any, transferred successfully, but the MT message in the queue was too big to be transferred.
.................... 		2	MO message, if any, transferred successfully, but the requested Location Update was not accepted.
.................... 		3 .. 4	Reserved, but indicate MO session success if used.
.................... 		5 .. 8	Reserved, but indicate MO session failure if used.
.................... 		10	GSS reported that the call did not complete in the allowed time.
.................... 		11	MO message queue at the GSS is full.
.................... 		12	MO message has too many segments.
.................... 		13	GSS reported that the session did not complete.
.................... 		14	Invalid segment size.
.................... 		15	Access is denied.
.................... 		16	ISU has been locked and may not make SBD calls (see +CULK command).
.................... 		17	Gateway not responding (local session timeout).
.................... 		18	Connection lost (RF drop).
.................... 		19	Link failure (A protocol error caused termination of the call).
.................... 		20 .. 31	Reserved, but indicate failure if used.
.................... 		32	No network service, unable to initiate call.
.................... 		33	Antenna fault, unable to initiate call.
.................... 		34	Radio is disabled, unable to initiate call (see *Rn command).
.................... 		35	ISU is busy, unable to initiate call.
.................... 		36	Try later, must wait 3 minutes since last registration.
.................... 		37	SBD service is temporarily disabled.
.................... 		38	Try later, traffic management period (see +SBDLOE command)
.................... 		39 .. 63	Reserved, but indicate failure if used.
.................... 		64	Band violation (attempt to transmit outside permitted frequency band).
.................... 		65	PLL lock failure; hardware error during attempted transmit.
.................... 
.................... 		<MOMSN> - This number denotes the MO message number and cycles between 0 and 65535.
.................... 
.................... 		<MT status>
.................... 			0 => No messages waiting to be received.
.................... 			1 => New message successfully received.
.................... 			2 => Error during mailbox check / message reception.
.................... 
.................... 		<MTMSN> - This number denotes the MT message number and cycles between 0 and 65535.
.................... 
.................... 		<MT length> - The size (in bytes) of the MT message.
.................... 
.................... 		<MT queued> - The number of MT messages in the queue waiting to be downloaded.
.................... 
.................... 		+SBDIX:32,22, 2, 0, 0, 0
....................         012345678901234567890123
....................         0         1         2
.................... 		*/
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1F24:  MOVLB  8
1F26:  DECFSZ xE6,W
1F28:  BRA    1FAC
.................... 			if ( '+'==sbd.mr_buff[0] && 'S'==sbd.mr_buff[1] &&
.................... 			     'B'==sbd.mr_buff[2] && 'D'==sbd.mr_buff[3] &&
.................... 			     'I'==sbd.mr_buff[4] && 'X'==sbd.mr_buff[5] 
1F2A:  MOVF   xE7,W
1F2C:  SUBLW  2B
1F2E:  BNZ   1FA4
1F30:  MOVF   xE8,W
1F32:  SUBLW  53
1F34:  BNZ   1FA4
1F36:  MOVF   xE9,W
1F38:  SUBLW  42
1F3A:  BNZ   1FA4
1F3C:  MOVF   xEA,W
1F3E:  SUBLW  44
1F40:  BNZ   1FA4
1F42:  MOVF   xEB,W
1F44:  SUBLW  49
1F46:  BNZ   1FA4
1F48:  MOVF   xEC,W
1F4A:  SUBLW  58
1F4C:  BNZ   1FA4
.................... 			) {
.................... 				/* copy +SBDIX result to seperate buffer so it can be further processed for message downloading */
.................... 				if ( '\0' == sbd.sbdix_response[0] ) {
1F4E:  MOVLB  6
1F50:  MOVF   x96,F
1F52:  BNZ   1F74
.................... 					strncpy(sbd.sbdix_response,sbd.mr_buff,sizeof(sbd.sbdix_response)-1);
1F54:  MOVLW  06
1F56:  MOVLB  9
1F58:  MOVWF  x7F
1F5A:  MOVLW  96
1F5C:  MOVWF  x7E
1F5E:  MOVLW  08
1F60:  MOVWF  x81
1F62:  MOVLW  E7
1F64:  MOVWF  x80
1F66:  CLRF   x83
1F68:  MOVLW  29
1F6A:  MOVWF  x82
1F6C:  MOVLB  0
1F6E:  BRA    1C2A
.................... 					sbd.sbdix_response[sizeof(sbd.sbdix_response)-1]='\0';
1F70:  MOVLB  6
1F72:  CLRF   xBF
.................... 				}
.................... 
.................... 
.................... 				/* so we got an +SBDIX response. If first byte ([8]) is '0', '1', '2' and second byte ([9]) is ',' 
.................... 				we are okay to proceed and clear buffer. If it is anything else, we need to wait and try again */
.................... 				/* TODO: white space location / pading may not be consistent. Use atoi style parsing to determine MO_STATUS reliably */
.................... 				if ( ' '==sbd.mr_buff[7] && ( sbd.mr_buff[8] >= '0' && sbd.mr_buff[8] <= '2'  && ',' == sbd.mr_buff[9]) ) {
1F74:  MOVLB  8
1F76:  MOVF   xEE,W
1F78:  SUBLW  20
1F7A:  BNZ   1F9A
1F7C:  MOVF   xEF,W
1F7E:  SUBLW  2F
1F80:  BC    1F9A
1F82:  MOVF   xEF,W
1F84:  SUBLW  32
1F86:  BNC   1F9A
1F88:  MOVF   xF0,W
1F8A:  SUBLW  2C
1F8C:  BNZ   1F9A
.................... 					sbd.mo_state++;
1F8E:  MOVLB  6
1F90:  INCF   xC9,F
.................... 					sbd.mo_try=0;
1F92:  MOVLB  7
1F94:  CLRF   xDC
.................... 				} else {
1F96:  BRA    1FA2
1F98:  MOVLB  8
.................... 					/* didn't get a 0 or 1 or 2 ... but still go on to next state for OK */
.................... 					sbd.mo_state++;
1F9A:  MOVLB  6
1F9C:  INCF   xC9,F
.................... 					sbd.mo_try++;
1F9E:  MOVLB  7
1FA0:  INCF   xDC,F
1FA2:  MOVLB  8
.................... 				}
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
1FA4:  MOVLB  0
1FA6:  CALL   0F14
1FAA:  MOVLB  8
.................... 		}
.................... 	} else if ( 14 == sbd.mo_state ) {
1FAC:  BRA    20A0
1FAE:  MOVLB  6
1FB0:  MOVF   xC9,W
1FB2:  SUBLW  0E
1FB4:  BNZ   2020
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1FB6:  MOVLB  8
1FB8:  DECFSZ xE6,W
1FBA:  BRA    1FD6
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1FBC:  MOVF   xE7,W
1FBE:  SUBLW  4F
1FC0:  BNZ   1FCE
1FC2:  MOVF   xE8,W
1FC4:  SUBLW  4B
1FC6:  BNZ   1FCE
.................... 				sbd.mo_state++;
1FC8:  MOVLB  6
1FCA:  INCF   xC9,F
1FCC:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
1FCE:  MOVLB  0
1FD0:  CALL   0F14
1FD4:  MOVLB  8
.................... 		}
.................... 
.................... 		if ( 0 != sbd.mo_try ) {
1FD6:  MOVLB  7
1FD8:  MOVF   xDC,F
1FDA:  BZ    201C
.................... 			/* need to try SBDIX again */
.................... 			sbd.mo_state=12;
1FDC:  MOVLW  0C
1FDE:  MOVLB  6
1FE0:  MOVWF  xC9
.................... 			/* back off */
.................... 			if ( 1 == sbd.mo_try || 2 == sbd.mo_try ) {
1FE2:  MOVLB  7
1FE4:  DECFSZ xDC,W
1FE6:  BRA    1FEA
1FE8:  BRA    1FF0
1FEA:  MOVF   xDC,W
1FEC:  SUBLW  02
1FEE:  BNZ   1FF6
.................... 				sbd.mo_sbdix_wait=3;
1FF0:  MOVLW  03
1FF2:  MOVWF  xDD
.................... 			} else if ( 3 == sbd.mo_try || 4 == sbd.mo_try ) {
1FF4:  BRA    201C
1FF6:  MOVF   xDC,W
1FF8:  SUBLW  03
1FFA:  BZ    2002
1FFC:  MOVF   xDC,W
1FFE:  SUBLW  04
2000:  BNZ   2008
.................... 				sbd.mo_sbdix_wait=21;
2002:  MOVLW  15
2004:  MOVWF  xDD
.................... 			} else if ( 5 == sbd.mo_try ) {
2006:  BRA    201C
2008:  MOVF   xDC,W
200A:  SUBLW  05
200C:  BNZ   2014
.................... 				sbd.mo_sbdix_wait=251;
200E:  MOVLW  FB
2010:  MOVWF  xDD
.................... 			} else {
2012:  BRA    201C
.................... 				/* give up and clear buffer */
.................... 				sbd.mo_state=15;
2014:  MOVLW  0F
2016:  MOVLB  6
2018:  MOVWF  xC9
201A:  MOVLB  7
.................... 			}
.................... 		}
.................... 	} else if ( 15 == sbd.mo_state ) {
201C:  BRA    20A2
201E:  MOVLB  6
2020:  MOVF   xC9,W
2022:  SUBLW  0F
2024:  BNZ   203E
.................... 
.................... 		/* send 'AT+SBDD=0' to clear MO buffer */
.................... 		iridium_mr_clear();
2026:  MOVLB  0
2028:  CALL   0F14
.................... 		printf(uart_putc,"AT+SBDD0\r");
202C:  MOVLW  42
202E:  MOVWF  FF6
2030:  MOVLW  05
2032:  MOVWF  FF7
2034:  CALL   1742
.................... 		sbd.mo_state++;
2038:  MOVLB  6
203A:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		/* TODO ... be careful about starting over without buffer being cleared */
.................... 	} else if ( 16 == sbd.mo_state ) {
203C:  BRA    209E
203E:  MOVF   xC9,W
2040:  SUBLW  10
2042:  BNZ   2066
.................... 		if ( 1 == sbd.mr_ready ) {
2044:  MOVLB  8
2046:  DECFSZ xE6,W
2048:  BRA    2062
.................... 			if ( '0'==sbd.mr_buff[0] ) {
204A:  MOVF   xE7,W
204C:  SUBLW  30
204E:  BNZ   2058
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
2050:  MOVLB  6
2052:  INCF   xC9,F
.................... 			} else {
2054:  BRA    2060
2056:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
2058:  MOVLB  0
205A:  CALL   0F14
205E:  MOVLB  6
2060:  MOVLB  8
.................... 			}
.................... 		}
.................... 	} else if ( 17 == sbd.mo_state ) {
2062:  BRA    20A0
2064:  MOVLB  6
2066:  MOVF   xC9,W
2068:  SUBLW  11
206A:  BNZ   2090
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
206C:  MOVLB  8
206E:  DECFSZ xE6,W
2070:  BRA    208C
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
2072:  MOVF   xE7,W
2074:  SUBLW  4F
2076:  BNZ   2084
2078:  MOVF   xE8,W
207A:  SUBLW  4B
207C:  BNZ   2084
.................... 				sbd.mo_state++;
207E:  MOVLB  6
2080:  INCF   xC9,F
2082:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
2084:  MOVLB  0
2086:  CALL   0F14
208A:  MOVLB  8
.................... 		}
.................... 
.................... 	} else if ( 18 == sbd.mo_state ) {
208C:  BRA    20A0
208E:  MOVLB  6
2090:  MOVF   xC9,W
2092:  SUBLW  12
2094:  BNZ   209E
.................... 		/* done sending */
.................... 		/* download MT if needed? */
.................... 		/* turn off modem */
.................... //		iridium_off();
.................... 
.................... 		/* go back to waiting */
.................... 		iridium_mr_clear();
2096:  MOVLB  0
2098:  CALL   0F14
.................... 		iridium_mo_clear();	
209C:  RCALL  1CB2
209E:  MOVLB  8
20A0:  MOVLB  7
20A2:  MOVLB  6
.................... 	}
20A4:  MOVLB  0
20A6:  GOTO   42C0 (RETURN)
.................... }
.................... 
.................... void iridium_mt_receive(void) {
.................... 	int8 c;
.................... 	static int16 l;
.................... 	static int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mt_receive() sbd.mt_state=%u\r\n",sbd.mt_state);
*
1762:  MOVLW  4C
1764:  MOVWF  FF6
1766:  MOVLW  05
1768:  MOVWF  FF7
176A:  MOVLW  24
176C:  MOVLB  9
176E:  MOVWF  x7C
1770:  MOVLB  0
1772:  CALL   0B5A
1776:  MOVFF  7DF,97B
177A:  MOVLW  1B
177C:  MOVLB  9
177E:  MOVWF  x7C
1780:  MOVLB  0
1782:  RCALL  14EC
1784:  MOVLW  0D
1786:  BTFSS  FA4.4
1788:  BRA    1786
178A:  MOVWF  F79
178C:  MOVLW  0A
178E:  BTFSS  FA4.4
1790:  BRA    178E
1792:  MOVWF  F79
.................... #endif
.................... 
.................... 
.................... 	if ( sbd.mt_state <= 1 ) {
1794:  MOVLB  7
1796:  MOVF   xDF,W
1798:  SUBLW  01
179A:  BNC   17B4
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
179C:  MOVLB  0
179E:  CALL   0F14
.................... 		printf(uart_putc,"ATE0\r");
17A2:  MOVLW  76
17A4:  MOVWF  FF6
17A6:  MOVLW  05
17A8:  MOVWF  FF7
17AA:  RCALL  1742
.................... 		sbd.mt_state = 2;
17AC:  MOVLW  02
17AE:  MOVLB  7
17B0:  MOVWF  xDF
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mt_state ) {
17B2:  BRA    1B0A
17B4:  MOVF   xDF,W
17B6:  SUBLW  02
17B8:  BNZ   17DE
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
17BA:  MOVLB  8
17BC:  DECFSZ xE6,W
17BE:  BRA    17DA
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
17C0:  MOVF   xE7,W
17C2:  SUBLW  4F
17C4:  BNZ   17D2
17C6:  MOVF   xE8,W
17C8:  SUBLW  4B
17CA:  BNZ   17D2
.................... 				sbd.mt_state++;
17CC:  MOVLB  7
17CE:  INCF   xDF,F
17D0:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
17D2:  MOVLB  0
17D4:  CALL   0F14
17D8:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mt_state ) {
17DA:  BRA    1B0A
17DC:  MOVLB  7
17DE:  MOVF   xDF,W
17E0:  SUBLW  03
17E2:  BNZ   17FA
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
17E4:  MOVLB  0
17E6:  CALL   0F14
.................... 		printf(uart_putc,"AT&K0\r");
17EA:  MOVLW  7C
17EC:  MOVWF  FF6
17EE:  MOVLW  05
17F0:  MOVWF  FF7
17F2:  RCALL  1742
.................... 		sbd.mt_state++;
17F4:  MOVLB  7
17F6:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mt_state ) {
17F8:  BRA    1B0A
17FA:  MOVF   xDF,W
17FC:  SUBLW  04
17FE:  BNZ   1824
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1800:  MOVLB  8
1802:  DECFSZ xE6,W
1804:  BRA    1820
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1806:  MOVF   xE7,W
1808:  SUBLW  4F
180A:  BNZ   1818
180C:  MOVF   xE8,W
180E:  SUBLW  4B
1810:  BNZ   1818
.................... 				sbd.mt_state++;
1812:  MOVLB  7
1814:  INCF   xDF,F
1816:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1818:  MOVLB  0
181A:  CALL   0F14
181E:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mt_state ) {
1820:  BRA    1B0A
1822:  MOVLB  7
1824:  MOVF   xDF,W
1826:  SUBLW  05
1828:  BNZ   1840
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
182A:  MOVLB  0
182C:  CALL   0F14
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
1830:  MOVLW  84
1832:  MOVWF  FF6
1834:  MOVLW  05
1836:  MOVWF  FF7
1838:  RCALL  1742
.................... 		sbd.mt_state++;
183A:  MOVLB  7
183C:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mt_state ) {
183E:  BRA    1B0A
1840:  MOVF   xDF,W
1842:  SUBLW  06
1844:  BNZ   186A
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
1846:  MOVLB  8
1848:  DECFSZ xE6,W
184A:  BRA    1866
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
184C:  MOVF   xE7,W
184E:  SUBLW  4F
1850:  BNZ   185E
1852:  MOVF   xE8,W
1854:  SUBLW  4B
1856:  BNZ   185E
.................... 				sbd.mt_state++;
1858:  MOVLB  7
185A:  INCF   xDF,F
185C:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
185E:  MOVLB  0
1860:  CALL   0F14
1864:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mt_state ) {
1866:  BRA    1B0A
1868:  MOVLB  7
186A:  MOVF   xDF,W
186C:  SUBLW  07
186E:  BNZ   188E
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDRB' to tell modem to send us our MT */
.................... 		iridium_mr_clear();
1870:  MOVLB  0
1872:  CALL   0F14
.................... 		sbd.mr_disable=1; /* switch iridum character receiver to binary */
1876:  MOVLW  01
1878:  MOVLB  9
187A:  MOVWF  x28
.................... 		printf(uart_putc,"AT+SBDRB\r");
187C:  MOVLW  92
187E:  MOVWF  FF6
1880:  MOVLW  05
1882:  MOVWF  FF7
1884:  MOVLB  0
1886:  RCALL  1742
.................... 		sbd.mt_state++;
1888:  MOVLB  7
188A:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mt_state ) {
188C:  BRA    1B0A
188E:  MOVF   xDF,W
1890:  SUBLW  08
1892:  BNZ   18B6
.................... 		/* receive first byte of length */
.................... 		if ( ! uart_kbhit() ) {
1894:  MOVLB  0
1896:  RCALL  15F2
1898:  MOVF   01,F
189A:  BNZ   189E
.................... 			/* no character available */
.................... 			return;
189C:  BRA    1B0C
.................... 		}
.................... 	
.................... 		sbd.mt_length=make16(uart_getc(),0);
*
18A8:  MOVFF  01,8E1
18AC:  MOVLB  8
18AE:  CLRF   xE0
.................... 		sbd.mt_state++;
18B0:  MOVLB  7
18B2:  INCF   xDF,F
.................... 	} else if ( 9 == sbd.mt_state ) {
18B4:  BRA    1B0A
18B6:  MOVF   xDF,W
18B8:  SUBLW  09
18BA:  BNZ   18EC
.................... 		/* receive second byte of length */
.................... 		if ( ! uart_kbhit() ) {
18BC:  MOVLB  0
18BE:  RCALL  15F2
18C0:  MOVF   01,F
18C2:  BNZ   18C6
.................... 			/* no character available */
.................... 			return;
18C4:  BRA    1B0C
.................... 		}
.................... 	
.................... 		sbd.mt_length += uart_getc();
*
18D0:  MOVF   01,W
18D2:  MOVLB  8
18D4:  ADDWF  xE0,F
18D6:  MOVLW  00
18D8:  ADDWFC xE1,F
.................... 		sbd.mt_state++;
18DA:  MOVLB  7
18DC:  INCF   xDF,F
.................... 
.................... 		checksum=0;
18DE:  MOVLB  9
18E0:  CLRF   x2E
18E2:  CLRF   x2D
.................... 		l=0;
18E4:  CLRF   x2C
18E6:  CLRF   x2B
.................... 	} else if ( 10 == sbd.mt_state ) {
18E8:  BRA    1B0C
18EA:  MOVLB  7
18EC:  MOVF   xDF,W
18EE:  SUBLW  0A
18F0:  BNZ   195C
.................... 		/* receive MT length of characters and calculate checksum */
.................... 		if ( ! uart_kbhit() ) {
18F2:  MOVLB  0
18F4:  RCALL  15F2
18F6:  MOVF   01,F
18F8:  BNZ   18FC
.................... 			/* no character available */
.................... 			return;
18FA:  BRA    1B0C
.................... 		}
.................... 
.................... 		if ( 0 == sbd.mt_length ) {
18FC:  MOVLB  8
18FE:  MOVF   xE0,F
1900:  BNZ   1910
1902:  MOVF   xE1,F
1904:  BNZ   1910
.................... 			/* zero byte message skips this state */
.................... 			sbd.mt_state++;
1906:  MOVLB  7
1908:  INCF   xDF,F
.................... 			return;
190A:  MOVLB  0
190C:  BRA    1B0C
190E:  MOVLB  8
.................... 		}
.................... 
.................... 		c = uart_getc();
*
191A:  MOVFF  01,97A
.................... 		sbd.mt_buff[l]=c;
191E:  MOVLW  E0
1920:  MOVLB  9
1922:  ADDWF  x2B,W
1924:  MOVWF  FE9
1926:  MOVLW  07
1928:  ADDWFC x2C,W
192A:  MOVWF  FEA
192C:  MOVFF  97A,FEF
.................... 		checksum += c;
1930:  MOVF   x7A,W
1932:  ADDWF  x2D,F
1934:  MOVLW  00
1936:  ADDWFC x2E,F
.................... 		l++;
1938:  INCF   x2B,F
193A:  BTFSC  FD8.2
193C:  INCF   x2C,F
.................... 
.................... 		if ( l == sbd.mt_length ) {
193E:  MOVLB  8
1940:  MOVF   xE0,W
1942:  MOVLB  9
1944:  SUBWF  x2B,W
1946:  BNZ   1958
1948:  MOVLB  8
194A:  MOVF   xE1,W
194C:  MOVLB  9
194E:  SUBWF  x2C,W
1950:  BNZ   1958
.................... 			/* received right number of characters */
.................... 			sbd.mt_state++;
1952:  MOVLB  7
1954:  INCF   xDF,F
1956:  MOVLB  9
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mt_state ) {
1958:  BRA    1B0C
195A:  MOVLB  7
195C:  MOVF   xDF,W
195E:  SUBLW  0B
1960:  BNZ   1984
.................... 		if ( ! uart_kbhit() ) {
1962:  MOVLB  0
1964:  RCALL  15F2
1966:  MOVF   01,F
1968:  BNZ   196C
.................... 			/* no character available */
.................... 			return;
196A:  BRA    1B0C
.................... 		}
.................... 
.................... 		/* high byte of checksum */
.................... 		l=make16(uart_getc(),0);
*
1976:  MOVFF  01,92C
197A:  MOVLB  9
197C:  CLRF   x2B
.................... 		sbd.mt_state++;
197E:  MOVLB  7
1980:  INCF   xDF,F
.................... 	} else if ( 12 == sbd.mt_state ) {
1982:  BRA    1B0A
1984:  MOVF   xDF,W
1986:  SUBLW  0C
1988:  BNZ   19B4
.................... 		if ( ! uart_kbhit() ) {
198A:  MOVLB  0
198C:  RCALL  15F2
198E:  MOVF   01,F
1990:  BNZ   1994
.................... 			/* no character available */
.................... 			return;
1992:  BRA    1B0C
.................... 		}
.................... 
.................... 		/* low byte of checksum */
.................... 		l += uart_getc();
*
199E:  MOVF   01,W
19A0:  MOVLB  9
19A2:  ADDWF  x2B,F
19A4:  MOVLW  00
19A6:  ADDWFC x2C,F
.................... 		sbd.mt_state++;
19A8:  MOVLB  7
19AA:  INCF   xDF,F
.................... 
.................... 		sbd.mr_disable=0;
19AC:  MOVLB  9
19AE:  CLRF   x28
.................... 	} else if ( 13 == sbd.mt_state ) {
19B0:  BRA    1B0C
19B2:  MOVLB  7
19B4:  MOVF   xDF,W
19B6:  SUBLW  0D
19B8:  BTFSS  FD8.2
19BA:  BRA    1AC4
.................... 		/* compare local and remote checksum */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mt_receive() checksum l=%lu r=%lu\r\n",checksum,l);
19BC:  MOVLW  9C
19BE:  MOVWF  FF6
19C0:  MOVLW  05
19C2:  MOVWF  FF7
19C4:  MOVLW  22
19C6:  MOVLB  9
19C8:  MOVWF  x7C
19CA:  MOVLB  0
19CC:  CALL   0B5A
19D0:  MOVLW  10
19D2:  MOVWF  FE9
19D4:  MOVFF  92E,97D
19D8:  MOVFF  92D,97C
19DC:  CALL   117A
19E0:  MOVLW  C1
19E2:  MOVWF  FF6
19E4:  MOVLW  05
19E6:  MOVWF  FF7
19E8:  MOVLW  03
19EA:  MOVLB  9
19EC:  MOVWF  x7C
19EE:  MOVLB  0
19F0:  CALL   0B5A
19F4:  MOVLW  10
19F6:  MOVWF  FE9
19F8:  MOVFF  92C,97D
19FC:  MOVFF  92B,97C
1A00:  CALL   117A
1A04:  MOVLW  0D
1A06:  BTFSS  FA4.4
1A08:  BRA    1A06
1A0A:  MOVWF  F79
1A0C:  MOVLW  0A
1A0E:  BTFSS  FA4.4
1A10:  BRA    1A0E
1A12:  MOVWF  F79
.................... #endif
.................... 
.................... 		if ( checksum == l ) {
1A14:  MOVLB  9
1A16:  MOVF   x2B,W
1A18:  SUBWF  x2D,W
1A1A:  BNZ   1ABC
1A1C:  MOVF   x2C,W
1A1E:  SUBWF  x2E,W
1A20:  BNZ   1ABC
.................... 			/* checksums matched, we have a good message! */
.................... 			sbd.mt_ready=1;
1A22:  MOVLW  01
1A24:  MOVLB  7
1A26:  MOVWF  xDE
.................... 
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# iridium_mt_receive() mt_ready=1, here is our message:\r\n");
1A28:  MOVLW  CA
1A2A:  MOVWF  FF6
1A2C:  MOVLW  05
1A2E:  MOVWF  FF7
1A30:  MOVLB  0
1A32:  CALL   0B38
.................... 			for ( l=0 ; l<sbd.mt_length ; l++ ) {
1A36:  MOVLB  9
1A38:  CLRF   x2C
1A3A:  CLRF   x2B
1A3C:  MOVF   x2C,W
1A3E:  MOVLB  8
1A40:  SUBWF  xE1,W
1A42:  BNC   1ABE
1A44:  BNZ   1A56
1A46:  MOVF   xE0,W
1A48:  MOVLB  9
1A4A:  SUBWF  x2B,W
1A4C:  BTFSS  FD8.0
1A4E:  BRA    1A54
1A50:  MOVLB  8
1A52:  BRA    1ABE
1A54:  MOVLB  8
.................... 				fprintf(STREAM_WORLD,"# mt_buff[%lu]=%c\r\n",l,sbd.mt_buff[l]);
1A56:  MOVLW  E0
1A58:  MOVLB  9
1A5A:  ADDWF  x2B,W
1A5C:  MOVWF  FE9
1A5E:  MOVLW  07
1A60:  ADDWFC x2C,W
1A62:  MOVWF  FEA
1A64:  MOVFF  FEF,97B
1A68:  MOVLW  04
1A6A:  MOVWF  FF6
1A6C:  MOVLW  06
1A6E:  MOVWF  FF7
1A70:  MOVLW  0A
1A72:  MOVWF  x7C
1A74:  MOVLB  0
1A76:  CALL   0B5A
1A7A:  MOVLW  10
1A7C:  MOVWF  FE9
1A7E:  MOVFF  92C,97D
1A82:  MOVFF  92B,97C
1A86:  CALL   117A
1A8A:  MOVLW  5D
1A8C:  BTFSS  FA4.4
1A8E:  BRA    1A8C
1A90:  MOVWF  F79
1A92:  MOVLW  3D
1A94:  BTFSS  FA4.4
1A96:  BRA    1A94
1A98:  MOVWF  F79
1A9A:  MOVLB  9
1A9C:  MOVF   x7B,W
1A9E:  BTFSS  FA4.4
1AA0:  BRA    1A9E
1AA2:  MOVWF  F79
1AA4:  MOVLW  0D
1AA6:  BTFSS  FA4.4
1AA8:  BRA    1AA6
1AAA:  MOVWF  F79
1AAC:  MOVLW  0A
1AAE:  BTFSS  FA4.4
1AB0:  BRA    1AAE
1AB2:  MOVWF  F79
1AB4:  INCF   x2B,F
1AB6:  BTFSC  FD8.2
1AB8:  INCF   x2C,F
1ABA:  BRA    1A3C
1ABC:  MOVLB  8
.................... 			}
.................... #endif
.................... 		}
.................... 
.................... 		/* even if we have a bad checksum, we advance to next state and watch for OK */
.................... 		sbd.mt_state++;
1ABE:  MOVLB  7
1AC0:  INCF   xDF,F
.................... 
.................... 	} else if ( 14 == sbd.mt_state ) {
1AC2:  BRA    1B0A
1AC4:  MOVF   xDF,W
1AC6:  SUBLW  0E
1AC8:  BNZ   1AFC
.................... 		/* 
.................... 		Iridium reference manual says:
.................... 		"There are no response codes generated by the ISU for this command".
.................... 		But it does, in fact, give an "OK" (0x0D 0x0A 0x4F 0x4B 0x0D 0x0A) 
.................... 		about 2.7ms after finishing send the SBD data 
.................... 		*/
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1ACA:  MOVLB  8
1ACC:  DECFSZ xE6,W
1ACE:  BRA    1AF8
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1AD0:  MOVF   xE7,W
1AD2:  SUBLW  4F
1AD4:  BNZ   1AF0
1AD6:  MOVF   xE8,W
1AD8:  SUBLW  4B
1ADA:  BNZ   1AF0
.................... 				sbd.mt_state++;
1ADC:  MOVLB  7
1ADE:  INCF   xDF,F
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# iridium_mt_receive() got final OK\r\n");
1AE0:  MOVLW  18
1AE2:  MOVWF  FF6
1AE4:  MOVLW  06
1AE6:  MOVWF  FF7
1AE8:  MOVLB  0
1AEA:  CALL   0B38
1AEE:  MOVLB  8
.................... #endif
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1AF0:  MOVLB  0
1AF2:  CALL   0F14
1AF6:  MOVLB  8
.................... 		}	
.................... 	} else if ( 15 == sbd.mt_state ) {
1AF8:  BRA    1B0A
1AFA:  MOVLB  7
1AFC:  MOVF   xDF,W
1AFE:  SUBLW  0F
1B00:  BNZ   1B0A
.................... 		/* message has processed */
.................... 		sbd.sbdix_mt_status=0;
1B02:  MOVLB  6
1B04:  CLRF   xC3
.................... 		sbd.mt_state=0;
1B06:  MOVLB  7
1B08:  CLRF   xDF
1B0A:  MOVLB  9
1B0C:  MOVLB  0
.................... 	}
1B0E:  GOTO   42A8 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #if 0
.................... 			/* if not using RING ALERT through the UART, we can do this */
.................... 			/* check if RING ALERT is active via the !CTS pin connected to RING ALERT line on the SBD modem */
.................... 			if ( bit_test(uart_read(UART_MSR),4) ) {
.................... 				sbd.ring_flag=1;
.................... 			}
.................... #endif
.................... 
.................... #include "interrupt_rdTap.c"
.................... /* int_timer2 in modbus_int_uart.c */
.................... 
.................... #int_timer4
.................... void isr_10ms(void) {
.................... 	static int8 sc=0;
.................... 	static int16 li=0;
.................... 
.................... 	/* once per second */
.................... 	sc++;
*
063E:  MOVLB  9
0640:  INCF   x2F,F
.................... 	if ( 100==sc ) {
0642:  MOVF   x2F,W
0644:  SUBLW  64
0646:  BNZ   067C
.................... 		sc=0;
0648:  CLRF   x2F
.................... 
.................... 		li++;
064A:  INCF   x30,F
064C:  BTFSC  FD8.2
064E:  INCF   x31,F
.................... 		if ( li >= config.live_interval ) {
0650:  MOVLB  5
0652:  MOVF   x87,W
0654:  MOVLB  9
0656:  SUBWF  x31,W
0658:  BNC   0672
065A:  BNZ   0666
065C:  MOVLB  5
065E:  MOVF   x86,W
0660:  MOVLB  9
0662:  SUBWF  x30,W
0664:  BNC   0672
.................... 			li=0;
0666:  CLRF   x31
0668:  CLRF   x30
.................... 			timers.now_poll=1;
066A:  MOVLW  01
066C:  MOVLB  3
066E:  MOVWF  x61
0670:  MOVLB  9
.................... 		}
.................... 
.................... 
.................... 		if ( sbd.mo_sbdix_wait > 0 ) {
0672:  MOVLB  7
0674:  MOVF   xDD,F
0676:  BZ    067A
.................... 			sbd.mo_sbdix_wait--;
0678:  DECF   xDD,F
067A:  MOVLB  9
.................... 		}
.................... 	}
.................... 
.................... 	if ( timers.world_timeout < 255 ) {
067C:  MOVLB  3
067E:  INCFSZ x62,W
0680:  BRA    0684
0682:  BRA    0686
.................... 		timers.world_timeout++;
0684:  INCF   x62,F
.................... 	}
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
0686:  MOVF   x64,F
0688:  BNZ   0690
.................... 		output_low(LED_GREEN);
068A:  BCF    F93.5
068C:  BCF    F8A.5
.................... 	} else {
068E:  BRA    0696
.................... 		output_high(LED_GREEN);
0690:  BCF    F93.5
0692:  BSF    F8A.5
.................... 		timers.led_on_green--;
0694:  DECF   x64,F
.................... 	}
.................... 
.................... }
.................... 
.................... 
.................... /* int_rda in modbus_int_uart.c */
.................... 
0696:  BCF    FB7.7
0698:  MOVLB  0
069A:  GOTO   0084
.................... #int_rda2
.................... void isr_world(void) {
.................... 	static int8 pre[5];
.................... 
.................... 
.................... 
.................... 	if ( query.buff_ready ) {
*
06B4:  MOVLB  5
06B6:  MOVF   x6D,F
06B8:  BZ    06C0
.................... 		/* throw out data received while processing previous query */
.................... 		fgetc(STREAM_WORLD);
06BA:  MOVLB  0
06BC:  RCALL  069E
06BE:  MOVLB  5
.................... 	}
.................... 
.................... 	/* timeout after 100 milliseconds */
.................... 	if ( timers.world_timeout > 10 ) {
06C0:  MOVLB  3
06C2:  MOVF   x62,W
06C4:  SUBLW  0A
06C6:  BC    06CE
.................... 		query.buff_pos=0;
06C8:  MOVLB  5
06CA:  CLRF   x6C
06CC:  MOVLB  3
.................... //		output_toggle(LED_RED);
.................... 	}
.................... 	timers.world_timeout=0;
06CE:  CLRF   x62
.................... 
.................... 	if ( 0 == query.buff_pos ) {
06D0:  MOVLB  5
06D2:  MOVF   x6C,F
06D4:  BNZ   0746
.................... 		pre[0]=pre[1];
06D6:  MOVFF  933,932
.................... 		pre[1]=pre[2];
06DA:  MOVFF  934,933
.................... 		pre[2]=pre[3];
06DE:  MOVFF  935,934
.................... 		pre[3]=pre[4];
06E2:  MOVFF  936,935
.................... 		pre[4]=fgetc(STREAM_WORLD);
06E6:  MOVLB  0
06E8:  RCALL  069E
06EA:  MOVFF  01,936
.................... 
.................... 		/* packet addressed to us */
.................... 		if ( '#'==pre[0] && config.serial_prefix==pre[1] && config.serial_number==make16(pre[2],pre[3]) ) {
06EE:  MOVLB  9
06F0:  MOVF   x32,W
06F2:  SUBLW  23
06F4:  BNZ   0742
06F6:  MOVF   x33,W
06F8:  MOVLB  5
06FA:  SUBWF  x83,W
06FC:  BTFSC  FD8.2
06FE:  BRA    0704
0700:  MOVLB  9
0702:  BRA    0742
0704:  MOVFF  934,03
0708:  MOVLB  9
070A:  MOVF   x35,W
070C:  MOVLB  5
070E:  SUBWF  x84,W
0710:  BTFSC  FD8.2
0712:  BRA    0718
0714:  MOVLB  9
0716:  BRA    0742
0718:  MOVF   03,W
071A:  SUBWF  x85,W
071C:  BTFSC  FD8.2
071E:  BRA    0724
0720:  MOVLB  9
0722:  BRA    0742
.................... 			output_high(CTRL_1);
0724:  BCF    F92.1
0726:  BSF    F89.1
.................... 			query.buff[0]=pre[0];
0728:  MOVFF  932,46C
.................... 			query.buff[1]=pre[1];
072C:  MOVFF  933,46D
.................... 			query.buff[2]=pre[2];
0730:  MOVFF  934,46E
.................... 			query.buff[3]=pre[3];
0734:  MOVFF  935,46F
.................... 			query.buff[4]=pre[4];
0738:  MOVFF  936,470
.................... 			query.buff_pos=5;
073C:  MOVLW  05
073E:  MOVWF  x6C
0740:  MOVLB  9
.................... 		}
.................... 	} else {
0742:  BRA    0782
0744:  MOVLB  5
.................... 		query.buff[query.buff_pos++]=fgetc(STREAM_WORLD);
0746:  MOVF   x6C,W
0748:  INCF   x6C,F
074A:  ADDLW  6C
074C:  MOVWF  FE9
074E:  MOVLW  04
0750:  MOVWF  FEA
0752:  BTFSC  FD8.0
0754:  INCF   FEA,F
0756:  MOVFF  FEA,99E
075A:  MOVFF  FE9,99D
075E:  MOVLB  0
0760:  RCALL  069E
0762:  MOVFF  99E,FEA
0766:  MOVFF  99D,FE9
076A:  MOVFF  01,FEF
.................... 
.................... 		if ( query.buff_pos == query.buff[4] ) {
076E:  MOVLB  4
0770:  MOVF   x70,W
0772:  MOVLB  5
0774:  SUBWF  x6C,W
0776:  BNZ   0780
.................... 			output_toggle(CTRL_1);
0778:  BCF    F92.1
077A:  BTG    F89.1
.................... 			query.buff_ready=1;
077C:  MOVLW  01
077E:  MOVWF  x6D
0780:  MOVLB  9
.................... 		}
.................... 	}
.................... }
.................... 
0782:  BCF    FA4.5
0784:  MOVLB  0
0786:  GOTO   0084
.................... #include "live_rdTap.c"
.................... /* pass reg_crc value of 0xFFFF to reset */
.................... int16 crc_chk_pass(int16 reg_crc, int8 *data, int8 length) {
.................... 	int8 j;
.................... 	
.................... 	while ( length-- ) {
*
228E:  MOVLB  9
2290:  MOVF   x97,W
2292:  DECF   x97,F
2294:  XORLW  00
2296:  BZ    22E0
.................... 		reg_crc ^= *data++;
2298:  MOVFF  996,FEA
229C:  MOVF   x95,W
229E:  INCF   x95,F
22A0:  BTFSC  FD8.2
22A2:  INCF   x96,F
22A4:  MOVWF  FE9
22A6:  MOVF   FEF,W
22A8:  XORWF  x93,F
.................... 
.................... 		for ( j=0 ; j<8 ; j++ ) {
22AA:  CLRF   x98
22AC:  MOVF   x98,W
22AE:  SUBLW  07
22B0:  BNC   22DE
.................... 			if ( reg_crc & 0x01 ) {
22B2:  MOVF   x93,W
22B4:  ANDLW  01
22B6:  MOVWF  00
22B8:  CLRF   03
22BA:  MOVF   00,W
22BC:  IORWF  03,W
22BE:  BZ    22D4
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001;
22C0:  BCF    FD8.0
22C2:  RRCF   x94,W
22C4:  MOVWF  x9A
22C6:  RRCF   x93,W
22C8:  XORLW  01
22CA:  MOVWF  x93
22CC:  MOVF   x9A,W
22CE:  XORLW  A0
22D0:  MOVWF  x94
.................... 			} else {
22D2:  BRA    22DA
.................... 				reg_crc=reg_crc>>1;
22D4:  BCF    FD8.0
22D6:  RRCF   x94,F
22D8:  RRCF   x93,F
.................... 			}
22DA:  INCF   x98,F
22DC:  BRA    22AC
.................... 		}	
22DE:  BRA    2290
.................... 	}
.................... 	
.................... 	return reg_crc;
22E0:  MOVFF  993,01
22E4:  MOVFF  994,02
22E8:  MOVLB  0
22EA:  RETURN 0
.................... }
.................... 
.................... void live_send(void) {
.................... 	int16 lCRC;
.................... 	int8 i;
.................... 	int8 buff[17];
.................... 	int16 completeLength;
.................... 
.................... 	completeLength=sizeof(buff) + qbuff.rResultLength + 2;
*
22F4:  MOVLW  11
22F6:  MOVLB  4
22F8:  ADDWF  x68,W
22FA:  ADDLW  02
22FC:  MOVLB  9
22FE:  MOVWF  x91
2300:  CLRF   x92
2302:  BTFSC  FD8.0
2304:  INCF   x92,F
.................... 
.................... 	buff[0]='#';
2306:  MOVLW  23
2308:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
230A:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
230E:  MOVFF  585,982
2312:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0); 
2314:  MOVFF  584,983
2318:  MOVLB  9
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */
231A:  SETF   x84
.................... 	buff[5]=18; /* packet type */
231C:  MOVLW  12
231E:  MOVWF  x85
.................... 	buff[6]=make8(completeLength,1);
2320:  MOVFF  992,986
.................... 	buff[7]=make8(completeLength,0);
2324:  MOVFF  991,987
.................... 
.................... 	buff[8]=make8(qbuff.measurementNumber,1);
2328:  MOVFF  46B,988
232C:  MOVLB  9
.................... 	buff[9]=make8(qbuff.measurementNumber,0);
232E:  MOVFF  46A,989
2332:  MOVLB  9
.................... 
.................... 	/* device info */
.................... 	/* WorldData device type identifier (16-bit) */
.................... 	i=qbuff.deviceNumber;
2334:  MOVFF  469,97F
.................... 	buff[10]=make8(device[i].typeWorld,1);
2338:  CLRF   x95
233A:  MOVFF  97F,994
233E:  CLRF   x97
2340:  MOVLW  0D
2342:  MOVWF  x96
2344:  MOVLB  0
2346:  CALL   0CA2
234A:  MOVFF  01,993
234E:  MOVLW  01
2350:  MOVLB  9
2352:  ADDWF  01,W
2354:  MOVWF  01
2356:  MOVLW  00
2358:  ADDWFC 02,W
235A:  MOVWF  03
235C:  MOVF   01,W
235E:  ADDLW  21
2360:  MOVWF  FE9
2362:  MOVLW  00
2364:  ADDWFC 03,W
2366:  MOVWF  FEA
2368:  MOVFF  FEC,98A
236C:  MOVF   FED,F
236E:  MOVFF  FEF,993
.................... 	buff[11]=make8(device[i].typeWorld,0);
2372:  CLRF   x95
2374:  MOVFF  97F,994
2378:  CLRF   x97
237A:  MOVLW  0D
237C:  MOVWF  x96
237E:  MOVLB  0
2380:  CALL   0CA2
2384:  MOVFF  01,993
2388:  MOVLW  01
238A:  MOVLB  9
238C:  ADDWF  01,W
238E:  MOVWF  01
2390:  MOVLW  00
2392:  ADDWFC 02,W
2394:  MOVWF  03
2396:  MOVF   01,W
2398:  ADDLW  21
239A:  MOVWF  FE9
239C:  MOVLW  00
239E:  ADDWFC 03,W
23A0:  MOVWF  FEA
23A2:  MOVFF  FEC,994
23A6:  MOVF   FED,F
23A8:  MOVFF  FEF,98B
.................... 	/* manufacturers serial number */
.................... 	buff[12]=make8(device[i].serialNumber,3);
23AC:  CLRF   x95
23AE:  MOVFF  97F,994
23B2:  CLRF   x97
23B4:  MOVLW  0D
23B6:  MOVWF  x96
23B8:  MOVLB  0
23BA:  CALL   0CA2
23BE:  MOVFF  01,993
23C2:  MOVLW  05
23C4:  MOVLB  9
23C6:  ADDWF  01,W
23C8:  MOVWF  01
23CA:  MOVLW  00
23CC:  ADDWFC 02,W
23CE:  MOVWF  03
23D0:  MOVF   01,W
23D2:  ADDLW  21
23D4:  MOVWF  FE9
23D6:  MOVLW  00
23D8:  ADDWFC 03,W
23DA:  MOVWF  FEA
23DC:  MOVFF  FEF,993
23E0:  MOVFF  FEC,994
23E4:  MOVFF  FEC,995
23E8:  MOVFF  FEC,98C
.................... 	buff[13]=make8(device[i].serialNumber,2);
23EC:  CLRF   x95
23EE:  MOVFF  97F,994
23F2:  CLRF   x97
23F4:  MOVLW  0D
23F6:  MOVWF  x96
23F8:  MOVLB  0
23FA:  CALL   0CA2
23FE:  MOVFF  01,993
2402:  MOVLW  05
2404:  MOVLB  9
2406:  ADDWF  01,W
2408:  MOVWF  01
240A:  MOVLW  00
240C:  ADDWFC 02,W
240E:  MOVWF  03
2410:  MOVF   01,W
2412:  ADDLW  21
2414:  MOVWF  FE9
2416:  MOVLW  00
2418:  ADDWFC 03,W
241A:  MOVWF  FEA
241C:  MOVFF  FEF,993
2420:  MOVFF  FEC,994
2424:  MOVFF  FEC,98D
2428:  MOVFF  FEC,996
.................... 	buff[14]=make8(device[i].serialNumber,1);
242C:  CLRF   x95
242E:  MOVFF  97F,994
2432:  CLRF   x97
2434:  MOVLW  0D
2436:  MOVWF  x96
2438:  MOVLB  0
243A:  CALL   0CA2
243E:  MOVFF  01,993
2442:  MOVLW  05
2444:  MOVLB  9
2446:  ADDWF  01,W
2448:  MOVWF  01
244A:  MOVLW  00
244C:  ADDWFC 02,W
244E:  MOVWF  03
2450:  MOVF   01,W
2452:  ADDLW  21
2454:  MOVWF  FE9
2456:  MOVLW  00
2458:  ADDWFC 03,W
245A:  MOVWF  FEA
245C:  MOVFF  FEF,993
2460:  MOVFF  FEC,98E
2464:  MOVFF  FEC,995
2468:  MOVFF  FEC,996
.................... 	buff[15]=make8(device[i].serialNumber,0);
246C:  CLRF   x95
246E:  MOVFF  97F,994
2472:  CLRF   x97
2474:  MOVLW  0D
2476:  MOVWF  x96
2478:  MOVLB  0
247A:  CALL   0CA2
247E:  MOVFF  01,993
2482:  MOVLW  05
2484:  MOVLB  9
2486:  ADDWF  01,W
2488:  MOVWF  01
248A:  MOVLW  00
248C:  ADDWFC 02,W
248E:  MOVWF  03
2490:  MOVF   01,W
2492:  ADDLW  21
2494:  MOVWF  FE9
2496:  MOVLW  00
2498:  ADDWFC 03,W
249A:  MOVWF  FEA
249C:  MOVFF  FEF,98F
24A0:  MOVFF  FEC,994
24A4:  MOVFF  FEC,995
24A8:  MOVFF  FEC,996
.................... 	/* status of the data read */
.................... 	buff[16]=qbuff.rException;
24AC:  MOVFF  367,990
.................... 
.................... 	/* compute CRC on header and result data */
.................... 	lCRC=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
24B0:  SETF   x94
24B2:  SETF   x93
24B4:  MOVLW  09
24B6:  MOVWF  x96
24B8:  MOVLW  81
24BA:  MOVWF  x95
24BC:  MOVLW  10
24BE:  MOVWF  x97
24C0:  MOVLB  0
24C2:  RCALL  228E
24C4:  MOVFF  02,97E
24C8:  MOVFF  01,97D
.................... 	lCRC=crc_chk_pass(lCRC,qbuff.rResult,qbuff.rResultLength);
24CC:  MOVFF  97E,994
24D0:  MOVFF  97D,993
24D4:  MOVLW  03
24D6:  MOVLB  9
24D8:  MOVWF  x96
24DA:  MOVLW  68
24DC:  MOVWF  x95
24DE:  MOVFF  468,997
24E2:  MOVLB  0
24E4:  RCALL  228E
24E6:  MOVFF  02,97E
24EA:  MOVFF  01,97D
.................... 
.................... 	/* send buff, qbuff.rResult, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
24EE:  MOVLB  9
24F0:  CLRF   x7F
24F2:  MOVF   x7F,W
24F4:  SUBLW  10
24F6:  BNC   2516
.................... 		fputc(buff[i],STREAM_WORLD);
24F8:  CLRF   03
24FA:  MOVF   x7F,W
24FC:  ADDLW  80
24FE:  MOVWF  FE9
2500:  MOVLW  09
2502:  ADDWFC 03,W
2504:  MOVWF  FEA
2506:  MOVFF  FEF,993
250A:  MOVF   x93,W
250C:  MOVLB  0
250E:  RCALL  22EC
2510:  MOVLB  9
2512:  INCF   x7F,F
2514:  BRA    24F2
.................... 	}	
.................... 	for ( i=0 ; i<qbuff.rResultLength ; i++ ) {
2516:  CLRF   x7F
2518:  MOVLB  4
251A:  MOVF   x68,W
251C:  MOVLB  9
251E:  SUBWF  x7F,W
2520:  BC    2540
.................... 		fputc(qbuff.rResult[i],STREAM_WORLD);
2522:  MOVLW  68
2524:  ADDWF  x7F,W
2526:  MOVWF  FE9
2528:  MOVLW  03
252A:  MOVWF  FEA
252C:  BTFSC  FD8.0
252E:  INCF   FEA,F
2530:  MOVFF  FEF,993
2534:  MOVF   x93,W
2536:  MOVLB  0
2538:  RCALL  22EC
253A:  MOVLB  9
253C:  INCF   x7F,F
253E:  BRA    2518
.................... 	}
.................... 	fputc(make8(lCRC,1),STREAM_WORLD);
2540:  MOVFF  97E,993
2544:  MOVF   x93,W
2546:  MOVLB  0
2548:  RCALL  22EC
.................... 	fputc(make8(lCRC,0),STREAM_WORLD);
254A:  MOVFF  97D,993
254E:  MOVLB  9
2550:  MOVF   x93,W
2552:  MOVLB  0
2554:  RCALL  22EC
2556:  RETURN 0
.................... }
.................... 
.................... 
.................... #include "queryHandler_rdTap.c"
.................... /* this will do an arbitrary query to some other device on the network */
.................... void query_other(void) {
.................... 	int8 parseType;
.................... 	int8 i;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_other()\r\n");
.................... 	fprintf(STREAM_WORLD,"# query function=%lu\r\n",query.function);
.................... #endif
.................... 
.................... 	if ( query.function <= DEV_TYPE_MODBUS_MAX ) {
*
3A46:  MOVLB  5
3A48:  MOVF   x7A,F
3A4A:  BTFSS  FD8.2
3A4C:  BRA    3C9E
3A4E:  MOVF   x79,W
3A50:  SUBLW  07
3A52:  BTFSS  FD8.0
3A54:  BRA    3C9E
.................... 		/* modbus device type */
.................... 		switch ( query.function ) {
3A56:  MOVF   x79,W
3A58:  MOVWF  00
3A5A:  MOVF   x7A,W
3A5C:  MOVWF  03
3A5E:  MOVF   03,W
3A60:  BNZ   3A6A
3A62:  MOVF   00,F
3A64:  MOVLB  0
3A66:  BZ    3AD2
3A68:  MOVLB  5
3A6A:  MOVF   03,W
3A6C:  BNZ   3A78
3A6E:  MOVLW  01
3A70:  SUBWF  00,W
3A72:  MOVLB  0
3A74:  BZ    3AD4
3A76:  MOVLB  5
3A78:  MOVF   03,W
3A7A:  BNZ   3A86
3A7C:  MOVLW  02
3A7E:  SUBWF  00,W
3A80:  MOVLB  0
3A82:  BZ    3AFC
3A84:  MOVLB  5
3A86:  MOVF   03,W
3A88:  BNZ   3A94
3A8A:  MOVLW  03
3A8C:  SUBWF  00,W
3A8E:  MOVLB  0
3A90:  BZ    3B22
3A92:  MOVLB  5
3A94:  MOVF   03,W
3A96:  BNZ   3AA2
3A98:  MOVLW  04
3A9A:  SUBWF  00,W
3A9C:  MOVLB  0
3A9E:  BZ    3B4A
3AA0:  MOVLB  5
3AA2:  MOVF   03,W
3AA4:  BNZ   3AB0
3AA6:  MOVLW  05
3AA8:  SUBWF  00,W
3AAA:  MOVLB  0
3AAC:  BZ    3B72
3AAE:  MOVLB  5
3AB0:  MOVF   03,W
3AB2:  BNZ   3AC0
3AB4:  MOVLW  06
3AB6:  SUBWF  00,W
3AB8:  MOVLB  0
3ABA:  BTFSC  FD8.2
3ABC:  BRA    3BA4
3ABE:  MOVLB  5
3AC0:  MOVF   03,W
3AC2:  BNZ   3AD0
3AC4:  MOVLW  07
3AC6:  SUBWF  00,W
3AC8:  MOVLB  0
3ACA:  BTFSC  FD8.2
3ACC:  BRA    3BFA
3ACE:  MOVLB  5
3AD0:  BRA    3C3A
.................... 			case DEV_TYPE_DISABLED:
.................... 				return;
3AD2:  BRA    3D64
.................... 			case DEV_TYPE_MODBUS_1: /* not very well tested */
.................... 				query.resultException=modbus_read_coils(query.network_address, query.start_address, query.n_words);
3AD4:  MOVFF  577,982
3AD8:  MOVFF  57C,984
3ADC:  MOVFF  57B,983
3AE0:  MOVLB  9
3AE2:  CLRF   x86
3AE4:  MOVFF  57D,985
3AE8:  MOVLB  0
3AEA:  CALL   2558
3AEE:  MOVFF  01,581
.................... 				parseType=1;
3AF2:  MOVLW  01
3AF4:  MOVLB  9
3AF6:  MOVWF  x80
.................... 				break;
3AF8:  MOVLB  5
3AFA:  BRA    3C3A
.................... 			case DEV_TYPE_MODBUS_2: /* not very well tested */
.................... 				query.resultException=modbus_read_discrete_input(query.network_address, query.start_address, query.n_words);
3AFC:  MOVFF  577,982
3B00:  MOVFF  57C,984
3B04:  MOVFF  57B,983
3B08:  MOVLB  9
3B0A:  CLRF   x86
3B0C:  MOVFF  57D,985
3B10:  MOVLB  0
3B12:  BRA    36DA
3B14:  MOVFF  01,581
.................... 				parseType=1;
3B18:  MOVLW  01
3B1A:  MOVLB  9
3B1C:  MOVWF  x80
.................... 				break;
3B1E:  MOVLB  5
3B20:  BRA    3C3A
.................... 			case DEV_TYPE_MODBUS_3: /* tested */
.................... 				query.resultException=modbus_read_holding_registers(query.network_address, query.start_address, query.n_words);
3B22:  MOVFF  577,982
3B26:  MOVFF  57C,984
3B2A:  MOVFF  57B,983
3B2E:  MOVLB  9
3B30:  CLRF   x86
3B32:  MOVFF  57D,985
3B36:  MOVLB  0
3B38:  CALL   21F6
3B3C:  MOVFF  01,581
.................... 				parseType=1;
3B40:  MOVLW  01
3B42:  MOVLB  9
3B44:  MOVWF  x80
.................... 				break;
3B46:  MOVLB  5
3B48:  BRA    3C3A
.................... 			case DEV_TYPE_MODBUS_4: /* tested */
.................... 				query.resultException=modbus_read_input_registers(query.network_address, query.start_address, query.n_words);
3B4A:  MOVFF  577,982
3B4E:  MOVFF  57C,984
3B52:  MOVFF  57B,983
3B56:  MOVLB  9
3B58:  CLRF   x86
3B5A:  MOVFF  57D,985
3B5E:  MOVLB  0
3B60:  CALL   215E
3B64:  MOVFF  01,581
.................... 				parseType=1;
3B68:  MOVLW  01
3B6A:  MOVLB  9
3B6C:  MOVWF  x80
.................... 				break;
3B6E:  MOVLB  5
3B70:  BRA    3C3A
.................... 			case DEV_TYPE_MODBUS_5: /* tested */
.................... 				query.resultException=modbus_write_single_coil(query.network_address, query.start_address, query.buff[query.data_start_offset]);
3B72:  MOVLW  6C
3B74:  MOVLB  5
3B76:  ADDWF  x7E,W
3B78:  MOVWF  FE9
3B7A:  MOVLW  04
3B7C:  MOVWF  FEA
3B7E:  BTFSC  FD8.0
3B80:  INCF   FEA,F
3B82:  MOVFF  FEF,986
3B86:  MOVFF  577,983
3B8A:  MOVFF  57C,985
3B8E:  MOVFF  57B,984
3B92:  MOVLB  0
3B94:  BRA    3782
3B96:  MOVFF  01,581
.................... 				parseType=2;
3B9A:  MOVLW  02
3B9C:  MOVLB  9
3B9E:  MOVWF  x80
.................... 				break;
3BA0:  MOVLB  5
3BA2:  BRA    3C3A
.................... 			case DEV_TYPE_MODBUS_6: /* tested */
.................... 				query.resultException=modbus_write_single_register(query.network_address, query.start_address, 
.................... 					make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
3BA4:  MOVLW  6C
3BA6:  MOVLB  5
3BA8:  ADDWF  x7E,W
3BAA:  MOVWF  FE9
3BAC:  MOVLW  04
3BAE:  MOVWF  FEA
3BB0:  BTFSC  FD8.0
3BB2:  INCF   FEA,F
3BB4:  MOVFF  FEF,982
3BB8:  MOVLW  01
3BBA:  ADDWF  x7E,W
3BBC:  ADDLW  6C
3BBE:  MOVWF  FE9
3BC0:  MOVLW  04
3BC2:  MOVWF  FEA
3BC4:  BTFSC  FD8.0
3BC6:  INCF   FEA,F
3BC8:  MOVFF  FEF,983
3BCC:  MOVFF  982,985
3BD0:  MOVFF  983,984
3BD4:  MOVFF  577,986
3BD8:  MOVFF  57C,988
3BDC:  MOVFF  57B,987
3BE0:  MOVFF  982,98A
3BE4:  MOVFF  983,989
3BE8:  MOVLB  0
3BEA:  BRA    383E
3BEC:  MOVFF  01,581
.................... 				parseType=2;
3BF0:  MOVLW  02
3BF2:  MOVLB  9
3BF4:  MOVWF  x80
.................... 				return;
3BF6:  MOVLB  0
3BF8:  BRA    3D64
.................... 			case DEV_TYPE_MODBUS_16: /* tested ... endian issues lead to having to send data in a (backwards?) order */
.................... 				query.resultException=modbus_write_multiple_registers_flip(query.network_address, query.start_address, 
.................... 					query.n_words,&query.buff+query.data_start_offset
.................... 				);
3BFA:  MOVLW  6C
3BFC:  MOVLB  5
3BFE:  ADDWF  x7E,W
3C00:  MOVLB  9
3C02:  MOVWF  x82
3C04:  MOVLW  04
3C06:  MOVWF  x83
3C08:  BTFSC  FD8.0
3C0A:  INCF   x83,F
3C0C:  MOVFF  577,984
3C10:  MOVFF  57C,986
3C14:  MOVFF  57B,985
3C18:  CLRF   x88
3C1A:  MOVFF  57D,987
3C1E:  MOVFF  983,98A
3C22:  MOVFF  982,989
3C26:  MOVLB  0
3C28:  BRA    38E6
3C2A:  MOVFF  01,581
.................... 				parseType=2;
3C2E:  MOVLW  02
3C30:  MOVLB  9
3C32:  MOVWF  x80
.................... 				return;
3C34:  MOVLB  0
3C36:  BRA    3D64
3C38:  MOVLB  5
.................... 		}	
.................... 
.................... 		/* Modbus query performed above. */
.................... 		/* no error, copy data to buffer to send response */
.................... 		if ( 1==parseType && 0==query.resultException ) {
3C3A:  MOVLB  9
3C3C:  DECFSZ x80,W
3C3E:  BRA    3C7A
3C40:  MOVLB  5
3C42:  MOVF   x81,F
3C44:  BTFSC  FD8.2
3C46:  BRA    3C4C
3C48:  MOVLB  9
3C4A:  BRA    3C7A
.................... 			query.resultLength=modbus_rx.len-1;
3C4C:  MOVLW  01
3C4E:  SUBWF  x94,W
3C50:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[1],modbus_rx.len-1); 
3C52:  MOVLW  01
3C54:  SUBWF  x94,W
3C56:  MOVLB  9
3C58:  MOVWF  x82
3C5A:  MOVLW  04
3C5C:  MOVWF  FEA
3C5E:  MOVLW  6C
3C60:  MOVWF  FE9
3C62:  MOVLW  05
3C64:  MOVWF  FE2
3C66:  MOVLW  98
3C68:  MOVWF  FE1
3C6A:  MOVF   x82,W
3C6C:  MOVWF  01
3C6E:  BZ    3C78
3C70:  MOVFF  FE6,FEE
3C74:  DECFSZ 01,F
3C76:  BRA    3C70
.................... 		} else if ( 2==parseType && 0==query.resultException ) {
3C78:  BRA    3C9A
3C7A:  MOVF   x80,W
3C7C:  SUBLW  02
3C7E:  BNZ   3C9A
3C80:  MOVLB  5
3C82:  MOVF   x81,F
3C84:  BTFSC  FD8.2
3C86:  BRA    3C8C
3C88:  MOVLB  9
3C8A:  BRA    3C9A
.................... 			/* return the value of the coil we wrote */
.................... 			query.resultLength=2;
3C8C:  MOVLW  02
3C8E:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[3],2); 
3C90:  MOVFF  59A,46C
3C94:  MOVFF  59B,46D
3C98:  MOVLB  9
.................... 		}
.................... 	} else if ( query.function <= DEV_TYPE_I2C_MAX ) {
3C9A:  BRA    3D62
3C9C:  MOVLB  5
3C9E:  MOVF   x7A,F
3CA0:  BNZ   3D64
3CA2:  MOVF   x79,W
3CA4:  SUBLW  17
3CA6:  BNC   3D64
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# query_other for I2C network_adress=%lu, start_address=%lu n_words=%u\r\n",
.................... 			query.network_address,
.................... 			query.start_address,
.................... 			query.n_words
.................... 		);
.................... #endif
.................... 
.................... 		if ( DEV_TYPE_I2C_READ_8 == query.function ) {
3CA8:  MOVF   x79,W
3CAA:  SUBLW  10
3CAC:  BNZ   3CD8
3CAE:  MOVF   x7A,F
3CB0:  BNZ   3CD8
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_READ_8\r\n");
.................... #endif
.................... 
.................... 			/* start a read at start address then just read a byte at a time. n_words is actually bytes */
.................... 			i2c_buff_read(query.network_address, query.start_address, query.buff, query.n_words);
3CB2:  MOVFF  577,982
3CB6:  MOVFF  57B,983
3CBA:  MOVLW  04
3CBC:  MOVLB  9
3CBE:  MOVWF  x85
3CC0:  MOVLW  6C
3CC2:  MOVWF  x84
3CC4:  MOVFF  57D,986
3CC8:  MOVLB  0
3CCA:  CALL   25F0
.................... 			query.resultLength = query.n_words; /* in bytes */
3CCE:  MOVFF  57D,582
.................... 			query.resultException=0;
3CD2:  MOVLB  5
3CD4:  CLRF   x81
.................... 		} else if ( DEV_TYPE_I2C_WRITE_16 == query.function ) {
3CD6:  BRA    3D64
3CD8:  MOVF   x79,W
3CDA:  SUBLW  15
3CDC:  BNZ   3D64
3CDE:  MOVF   x7A,F
3CE0:  BNZ   3D64
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_WRITE_16\r\n");
.................... #endif
.................... 
.................... 			for ( i=0 ; i<query.n_words ; i++ ) {
3CE2:  MOVLB  9
3CE4:  CLRF   x81
3CE6:  MOVLB  5
3CE8:  MOVF   x7D,W
3CEA:  MOVLB  9
3CEC:  SUBWF  x81,W
3CEE:  BC    3D62
.................... #if DEBUG_ASCII
.................... 				fprintf(STREAM_WORLD,"# writing 0x%04lx to I2C device 0x%02x at address %lu\r\n",
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1]),
.................... 					query.network_address,
.................... 					(query.start_address+i*2)
.................... 				);
.................... #endif
.................... 
.................... 				i2c_register_write16(
.................... 					query.network_address,
.................... 					(query.start_address+i*2),
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1])
.................... 				);
3CF0:  BCF    FD8.0
3CF2:  RLCF   x81,W
3CF4:  MOVLB  5
3CF6:  ADDWF  x7B,W
3CF8:  MOVLB  9
3CFA:  MOVWF  x82
3CFC:  MOVLW  00
3CFE:  MOVLB  5
3D00:  ADDWFC x7C,W
3D02:  MOVLB  9
3D04:  MOVWF  x83
3D06:  BCF    FD8.0
3D08:  RLCF   x81,W
3D0A:  MOVLB  5
3D0C:  ADDWF  x7E,W
3D0E:  ADDLW  6C
3D10:  MOVWF  FE9
3D12:  MOVLW  04
3D14:  MOVWF  FEA
3D16:  BTFSC  FD8.0
3D18:  INCF   FEA,F
3D1A:  MOVFF  FEF,984
3D1E:  BCF    FD8.0
3D20:  MOVLB  9
3D22:  RLCF   x81,W
3D24:  MOVLB  5
3D26:  ADDWF  x7E,W
3D28:  ADDLW  01
3D2A:  ADDLW  6C
3D2C:  MOVWF  FE9
3D2E:  MOVLW  04
3D30:  MOVWF  FEA
3D32:  BTFSC  FD8.0
3D34:  INCF   FEA,F
3D36:  MOVFF  FEF,985
3D3A:  MOVFF  984,987
3D3E:  MOVFF  985,986
3D42:  MOVFF  577,988
3D46:  MOVFF  982,989
3D4A:  MOVFF  984,98B
3D4E:  MOVFF  985,98A
3D52:  MOVLB  0
3D54:  BRA    3A0A
.................... 
.................... 				query.resultLength = 0; /* in bytes */
3D56:  MOVLB  5
3D58:  CLRF   x82
.................... 				query.resultException=0;
3D5A:  CLRF   x81
3D5C:  MOVLB  9
3D5E:  INCF   x81,F
3D60:  BRA    3CE6
.................... 
.................... 			}
.................... 
.................... 		} else {
3D62:  MOVLB  5
3D64:  MOVLB  0
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# un-implemented I2C query function\r\n");
.................... #endif
.................... 		}
.................... 
.................... 	}
3D66:  GOTO   3F88 (RETURN)
.................... }
.................... 
.................... 
.................... /* 
.................... try to write the specified register
.................... if successful, return 0, otherwise return a modbus exception
.................... */
.................... exception query_self_write_register(int16 address, int16 value) {
.................... 	int8 dev, offset;
.................... 	int16 last;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_write_register address=%lu value=%lu\r\n",address,value);
.................... #endif
.................... 
.................... 	/* if we have been unlocked, then we can modify serial number */
.................... 	if ( timers.factory_unlocked ) {
*
32CC:  MOVLB  3
32CE:  MOVF   x63,F
32D0:  BZ    3308
.................... 		if ( 1000 == address ) {
32D2:  MOVLB  9
32D4:  MOVF   x84,W
32D6:  SUBLW  E8
32D8:  BNZ   32EC
32DA:  MOVF   x85,W
32DC:  SUBLW  03
32DE:  BNZ   32EC
.................... 			config.serial_prefix=value;
32E0:  MOVFF  986,583
.................... 			return 0;
32E4:  MOVLW  00
32E6:  MOVWF  01
32E8:  BRA    35F6
.................... 		} else if ( 1001 == address ) {
32EA:  BRA    3306
32EC:  MOVF   x84,W
32EE:  SUBLW  E9
32F0:  BNZ   3306
32F2:  MOVF   x85,W
32F4:  SUBLW  03
32F6:  BNZ   3306
.................... 			config.serial_number=value;
32F8:  MOVFF  987,585
32FC:  MOVFF  986,584
.................... 			return 0;
3300:  MOVLW  00
3302:  MOVWF  01
3304:  BRA    35F6
3306:  MOVLB  3
.................... 		}
.................... 	}
.................... 
.................... 	if ( address < 1000 ) {
3308:  MOVLB  9
330A:  MOVF   x85,W
330C:  SUBLW  03
330E:  BTFSS  FD8.0
3310:  BRA    351A
3312:  BNZ   331C
3314:  MOVF   x84,W
3316:  SUBLW  E7
3318:  BTFSS  FD8.0
331A:  BRA    351A
.................... 		dev=address>>3;
331C:  RRCF   x85,W
331E:  MOVWF  03
3320:  RRCF   x84,W
3322:  MOVWF  02
3324:  RRCF   03,F
3326:  RRCF   02,F
3328:  RRCF   03,F
332A:  RRCF   02,F
332C:  MOVFF  02,988
.................... 		offset=address&0b111;
3330:  MOVF   x84,W
3332:  ANDLW  07
3334:  MOVWF  x89
.................... 
.................... 		if ( dev > DEV_MAX_N )
3336:  MOVF   x88,W
3338:  SUBLW  40
333A:  BC    3342
.................... 			return ILLEGAL_DATA_ADDRESS;
333C:  MOVLW  02
333E:  MOVWF  01
3340:  BRA    35F6
.................... 
.................... 		switch ( offset ) {
3342:  MOVF   x89,W
3344:  ADDLW  F8
3346:  BTFSC  FD8.0
3348:  BRA    3518
334A:  ADDLW  08
334C:  MOVLB  0
334E:  GOTO   35FC
.................... 			case 0: device[dev].type=make8(value,0); break;
3352:  MOVLB  9
3354:  CLRF   x95
3356:  MOVFF  988,994
335A:  CLRF   x97
335C:  MOVLW  0D
335E:  MOVWF  x96
3360:  MOVLB  0
3362:  CALL   0CA2
3366:  MOVFF  02,98D
336A:  MOVFF  01,98C
336E:  MOVLW  21
3370:  MOVLB  9
3372:  ADDWF  01,W
3374:  MOVWF  FE9
3376:  MOVLW  00
3378:  ADDWFC 02,W
337A:  MOVWF  FEA
337C:  MOVFF  986,FEF
3380:  BRA    3518
.................... 			case 1: device[dev].typeWorld=value; break;
3382:  MOVLB  9
3384:  CLRF   x95
3386:  MOVFF  988,994
338A:  CLRF   x97
338C:  MOVLW  0D
338E:  MOVWF  x96
3390:  MOVLB  0
3392:  CALL   0CA2
3396:  MOVFF  02,98D
339A:  MOVFF  01,98C
339E:  MOVLW  01
33A0:  MOVLB  9
33A2:  ADDWF  01,W
33A4:  MOVWF  01
33A6:  MOVLW  00
33A8:  ADDWFC 02,W
33AA:  MOVWF  03
33AC:  MOVF   01,W
33AE:  ADDLW  21
33B0:  MOVWF  FE9
33B2:  MOVLW  00
33B4:  ADDWFC 03,W
33B6:  MOVWF  FEA
33B8:  MOVFF  987,FEC
33BC:  MOVF   FED,F
33BE:  MOVFF  986,FEF
33C2:  BRA    3518
.................... 			case 2: device[dev].transmitEvery=make8(value,0); break;
33C4:  MOVLB  9
33C6:  CLRF   x95
33C8:  MOVFF  988,994
33CC:  CLRF   x97
33CE:  MOVLW  0D
33D0:  MOVWF  x96
33D2:  MOVLB  0
33D4:  CALL   0CA2
33D8:  MOVFF  02,98D
33DC:  MOVFF  01,98C
33E0:  MOVLW  03
33E2:  MOVLB  9
33E4:  ADDWF  01,W
33E6:  MOVWF  01
33E8:  MOVLW  00
33EA:  ADDWFC 02,W
33EC:  MOVWF  03
33EE:  MOVF   01,W
33F0:  ADDLW  21
33F2:  MOVWF  FE9
33F4:  MOVLW  00
33F6:  ADDWFC 03,W
33F8:  MOVWF  FEA
33FA:  MOVFF  986,FEF
33FE:  BRA    3518
.................... 			case 3: device[dev].networkAddress=make8(value,0); break;
3400:  MOVLB  9
3402:  CLRF   x95
3404:  MOVFF  988,994
3408:  CLRF   x97
340A:  MOVLW  0D
340C:  MOVWF  x96
340E:  MOVLB  0
3410:  CALL   0CA2
3414:  MOVFF  02,98D
3418:  MOVFF  01,98C
341C:  MOVLW  04
341E:  MOVLB  9
3420:  ADDWF  01,W
3422:  MOVWF  01
3424:  MOVLW  00
3426:  ADDWFC 02,W
3428:  MOVWF  03
342A:  MOVF   01,W
342C:  ADDLW  21
342E:  MOVWF  FE9
3430:  MOVLW  00
3432:  ADDWFC 03,W
3434:  MOVWF  FEA
3436:  MOVFF  986,FEF
343A:  BRA    3518
.................... 			/* first pass get the high word of serial number */
.................... 			case 4: last=value; break;
343C:  MOVFF  987,98B
3440:  MOVFF  986,98A
3444:  MOVLB  9
3446:  BRA    3518
.................... 			/* second pass, combine last value and current value */
.................... 			case 5: device[dev].serialNumber=make32(last,value); break; /* was missing a break prior to 2024-04-03 */
3448:  MOVLB  9
344A:  CLRF   x95
344C:  MOVFF  988,994
3450:  CLRF   x97
3452:  MOVLW  0D
3454:  MOVWF  x96
3456:  MOVLB  0
3458:  CALL   0CA2
345C:  MOVFF  02,98D
3460:  MOVFF  01,98C
3464:  MOVLW  05
3466:  MOVLB  9
3468:  ADDWF  01,W
346A:  MOVWF  01
346C:  MOVLW  00
346E:  ADDWFC 02,W
3470:  MOVWF  03
3472:  MOVF   01,W
3474:  ADDLW  21
3476:  MOVWF  FE9
3478:  MOVLW  00
347A:  ADDWFC 03,W
347C:  MOVWF  FEA
347E:  MOVF   FEE,F
3480:  MOVFF  98A,FEC
3484:  MOVFF  98B,FEC
3488:  MOVF   FED,F
348A:  MOVF   FED,F
348C:  MOVF   FED,F
348E:  MOVFF  986,FEF
3492:  MOVFF  987,FEC
3496:  BRA    3518
.................... 			case 6: device[dev].startRegister=value; break;
3498:  MOVLB  9
349A:  CLRF   x95
349C:  MOVFF  988,994
34A0:  CLRF   x97
34A2:  MOVLW  0D
34A4:  MOVWF  x96
34A6:  MOVLB  0
34A8:  CALL   0CA2
34AC:  MOVFF  02,98D
34B0:  MOVFF  01,98C
34B4:  MOVLW  09
34B6:  MOVLB  9
34B8:  ADDWF  01,W
34BA:  MOVWF  01
34BC:  MOVLW  00
34BE:  ADDWFC 02,W
34C0:  MOVWF  03
34C2:  MOVF   01,W
34C4:  ADDLW  21
34C6:  MOVWF  FE9
34C8:  MOVLW  00
34CA:  ADDWFC 03,W
34CC:  MOVWF  FEA
34CE:  MOVFF  987,FEC
34D2:  MOVF   FED,F
34D4:  MOVFF  986,FEF
34D8:  BRA    3518
.................... 			case 7: device[dev].nRegisters=make8(value,0); break;
34DA:  MOVLB  9
34DC:  CLRF   x95
34DE:  MOVFF  988,994
34E2:  CLRF   x97
34E4:  MOVLW  0D
34E6:  MOVWF  x96
34E8:  MOVLB  0
34EA:  CALL   0CA2
34EE:  MOVFF  02,98D
34F2:  MOVFF  01,98C
34F6:  MOVLW  0B
34F8:  MOVLB  9
34FA:  ADDWF  01,W
34FC:  MOVWF  01
34FE:  MOVLW  00
3500:  ADDWFC 02,W
3502:  MOVWF  03
3504:  MOVF   01,W
3506:  ADDLW  21
3508:  MOVWF  FE9
350A:  MOVLW  00
350C:  ADDWFC 03,W
350E:  MOVWF  FEA
3510:  MOVFF  986,FEF
3514:  BRA    3518
3516:  MOVLB  9
.................... 		}
.................... 	} else {
3518:  BRA    35EE
.................... 		/* publicly writeable addresses */
.................... 
.................... 		switch ( address ) {
351A:  MOVF   x84,W
351C:  MOVWF  00
351E:  MOVF   x85,W
3520:  MOVWF  03
3522:  MOVLW  04
3524:  SUBWF  03,W
3526:  BNZ   3532
3528:  MOVLW  4C
352A:  SUBWF  00,W
352C:  MOVLB  0
352E:  BZ    3574
3530:  MOVLB  9
3532:  MOVLW  07
3534:  SUBWF  03,W
3536:  BNZ   3542
3538:  MOVLW  CD
353A:  SUBWF  00,W
353C:  MOVLB  0
353E:  BZ    357E
3540:  MOVLB  9
3542:  MOVLW  07
3544:  SUBWF  03,W
3546:  BNZ   3552
3548:  MOVLW  CE
354A:  SUBWF  00,W
354C:  MOVLB  0
354E:  BZ    3582
3550:  MOVLB  9
3552:  MOVLW  07
3554:  SUBWF  03,W
3556:  BNZ   3562
3558:  MOVLW  CF
355A:  SUBWF  00,W
355C:  MOVLB  0
355E:  BZ    35A2
3560:  MOVLB  9
3562:  MOVLW  4E
3564:  SUBWF  03,W
3566:  BNZ   3572
3568:  MOVLW  1F
356A:  SUBWF  00,W
356C:  MOVLB  0
356E:  BZ    35BE
3570:  MOVLB  9
3572:  BRA    35E8
.................... 			case 1100: config.live_interval=value; break;
3574:  MOVFF  987,587
3578:  MOVFF  986,586
357C:  BRA    35F0
.................... 
.................... 			case 1997:
.................... 				reset_cpu(); break; /* break doesn't do anything, but makes the compiler complain less */
357E:  RESET
3580:  BRA    35F0
.................... 			case 1998:
.................... 				if ( 1998 != value ) return ILLEGAL_DATA_VALUE;
3582:  MOVLB  9
3584:  MOVF   x86,W
3586:  SUBLW  CE
3588:  BNZ   3590
358A:  MOVF   x87,W
358C:  SUBLW  07
358E:  BZ    3596
3590:  MOVLW  03
3592:  MOVWF  01
3594:  BRA    35F6
.................... 				write_default_param_file();
3596:  MOVLB  0
3598:  CALL   0C78
.................... 				write_default_device_file();
359C:  CALL   0D16
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# writing default files\r\n");
.................... #endif
.................... 				break;
35A0:  BRA    35F0
.................... 			case 1999:
.................... 				/* write config to EEPROM */
.................... 				if ( 1 != value ) return ILLEGAL_DATA_VALUE;
35A2:  MOVLB  9
35A4:  DECFSZ x86,W
35A6:  BRA    35AC
35A8:  MOVF   x87,F
35AA:  BZ    35B2
35AC:  MOVLW  03
35AE:  MOVWF  01
35B0:  BRA    35F6
.................... 				write_param_file();
35B2:  MOVLB  0
35B4:  CALL   0C24
.................... 				write_device_file();
35B8:  CALL   0CC4
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# config.live_interval=%lu\r\n",config.live_interval);
.................... #endif
.................... 
.................... 				break;
35BC:  BRA    35F0
.................... 
.................... 			case 19999:
.................... 				/* unlock factory programming registers when we get 1802 in passcode register */
.................... 				if ( 1802 != value ) {
35BE:  MOVLB  9
35C0:  MOVF   x86,W
35C2:  SUBLW  0A
35C4:  BNZ   35CC
35C6:  MOVF   x87,W
35C8:  SUBLW  07
35CA:  BZ    35D8
.................... 					timers.factory_unlocked=0;
35CC:  MOVLB  3
35CE:  CLRF   x63
.................... 					return ILLEGAL_DATA_VALUE;
35D0:  MOVLW  03
35D2:  MOVWF  01
35D4:  MOVLB  9
35D6:  BRA    35F6
.................... 				}
.................... 				timers.factory_unlocked=1;
35D8:  MOVLW  01
35DA:  MOVLB  3
35DC:  MOVWF  x63
.................... 				/* green LED for 2 seconds */
.................... 				timers.led_on_green=200;
35DE:  MOVLW  C8
35E0:  MOVWF  x64
.................... 				break;
35E2:  MOVLB  0
35E4:  BRA    35F0
35E6:  MOVLB  9
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# factory unlocked\r\n");
.................... #endif
.................... 
.................... 			default:
.................... 				return ILLEGAL_DATA_ADDRESS;
35E8:  MOVLW  02
35EA:  MOVWF  01
35EC:  BRA    35F6
35EE:  MOVLB  0
.................... 		}
.................... 	}
.................... 
.................... 	/* must not have triggered an exception */
.................... 	return 0;
35F0:  MOVLW  00
35F2:  MOVWF  01
35F4:  MOVLB  9
35F6:  MOVLB  0
35F8:  GOTO   36C4 (RETURN)
.................... }
.................... 
.................... 
.................... /* address to read, put 16-bit results in query.buff[n] and query.buff[n+1] */
.................... exception query_self_read_register(int16 address, int8 n) {
.................... 	int16 result;
.................... 	int8 dev;
.................... 	int8 offset;
.................... 
.................... 
.................... 	if ( address < 1000 ) {
*
2E7A:  MOVLB  9
2E7C:  MOVF   x89,W
2E7E:  SUBLW  03
2E80:  BTFSS  FD8.0
2E82:  BRA    3160
2E84:  BNZ   2E8E
2E86:  MOVF   x88,W
2E88:  SUBLW  E7
2E8A:  BTFSS  FD8.0
2E8C:  BRA    3160
.................... 		dev=address>>3;
2E8E:  RRCF   x89,W
2E90:  MOVWF  03
2E92:  RRCF   x88,W
2E94:  MOVWF  02
2E96:  RRCF   03,F
2E98:  RRCF   02,F
2E9A:  RRCF   03,F
2E9C:  RRCF   02,F
2E9E:  MOVFF  02,98D
.................... 		offset=address&0b111;
2EA2:  MOVF   x88,W
2EA4:  ANDLW  07
2EA6:  MOVWF  x8E
.................... 
.................... 		if ( dev > DEV_MAX_N )
2EA8:  MOVF   x8D,W
2EAA:  SUBLW  40
2EAC:  BC    2EB4
.................... 			return ILLEGAL_DATA_ADDRESS;
2EAE:  MOVLW  02
2EB0:  MOVWF  01
2EB2:  BRA    3258
.................... 
.................... 		switch ( offset ) {
2EB4:  MOVF   x8E,W
2EB6:  ADDLW  F8
2EB8:  BTFSC  FD8.0
2EBA:  BRA    315E
2EBC:  ADDLW  08
2EBE:  MOVLB  0
2EC0:  GOTO   325E
.................... 			case 0: result=device[dev].type; break;
2EC4:  MOVLB  9
2EC6:  CLRF   x95
2EC8:  MOVFF  98D,994
2ECC:  CLRF   x97
2ECE:  MOVLW  0D
2ED0:  MOVWF  x96
2ED2:  MOVLB  0
2ED4:  CALL   0CA2
2ED8:  MOVFF  02,990
2EDC:  MOVFF  01,98F
2EE0:  MOVLW  21
2EE2:  MOVLB  9
2EE4:  ADDWF  01,W
2EE6:  MOVWF  FE9
2EE8:  MOVLW  00
2EEA:  ADDWFC 02,W
2EEC:  MOVWF  FEA
2EEE:  CLRF   x8C
2EF0:  MOVFF  FEF,98B
2EF4:  BRA    315E
.................... 			case 1: result=device[dev].typeWorld; break;
2EF6:  MOVLB  9
2EF8:  CLRF   x95
2EFA:  MOVFF  98D,994
2EFE:  CLRF   x97
2F00:  MOVLW  0D
2F02:  MOVWF  x96
2F04:  MOVLB  0
2F06:  CALL   0CA2
2F0A:  MOVFF  02,990
2F0E:  MOVFF  01,98F
2F12:  MOVLW  01
2F14:  MOVLB  9
2F16:  ADDWF  01,W
2F18:  MOVWF  01
2F1A:  MOVLW  00
2F1C:  ADDWFC 02,W
2F1E:  MOVWF  03
2F20:  MOVF   01,W
2F22:  ADDLW  21
2F24:  MOVWF  FE9
2F26:  MOVLW  00
2F28:  ADDWFC 03,W
2F2A:  MOVWF  FEA
2F2C:  MOVFF  FEC,98C
2F30:  MOVF   FED,F
2F32:  MOVFF  FEF,98B
2F36:  BRA    315E
.................... 			case 2: result=device[dev].transmitEvery; break;
2F38:  MOVLB  9
2F3A:  CLRF   x95
2F3C:  MOVFF  98D,994
2F40:  CLRF   x97
2F42:  MOVLW  0D
2F44:  MOVWF  x96
2F46:  MOVLB  0
2F48:  CALL   0CA2
2F4C:  MOVFF  02,990
2F50:  MOVFF  01,98F
2F54:  MOVLW  03
2F56:  MOVLB  9
2F58:  ADDWF  01,W
2F5A:  MOVWF  01
2F5C:  MOVLW  00
2F5E:  ADDWFC 02,W
2F60:  MOVWF  03
2F62:  MOVF   01,W
2F64:  ADDLW  21
2F66:  MOVWF  FE9
2F68:  MOVLW  00
2F6A:  ADDWFC 03,W
2F6C:  MOVWF  FEA
2F6E:  CLRF   x8C
2F70:  MOVFF  FEF,98B
2F74:  BRA    315E
.................... 			case 3: result=device[dev].networkAddress; break;
2F76:  MOVLB  9
2F78:  CLRF   x95
2F7A:  MOVFF  98D,994
2F7E:  CLRF   x97
2F80:  MOVLW  0D
2F82:  MOVWF  x96
2F84:  MOVLB  0
2F86:  CALL   0CA2
2F8A:  MOVFF  02,990
2F8E:  MOVFF  01,98F
2F92:  MOVLW  04
2F94:  MOVLB  9
2F96:  ADDWF  01,W
2F98:  MOVWF  01
2F9A:  MOVLW  00
2F9C:  ADDWFC 02,W
2F9E:  MOVWF  03
2FA0:  MOVF   01,W
2FA2:  ADDLW  21
2FA4:  MOVWF  FE9
2FA6:  MOVLW  00
2FA8:  ADDWFC 03,W
2FAA:  MOVWF  FEA
2FAC:  CLRF   x8C
2FAE:  MOVFF  FEF,98B
2FB2:  BRA    315E
.................... 			case 4: result=make16(make8(device[dev].serialNumber,3),make8(device[dev].serialNumber,2)); break;
2FB4:  MOVLB  9
2FB6:  CLRF   x95
2FB8:  MOVFF  98D,994
2FBC:  CLRF   x97
2FBE:  MOVLW  0D
2FC0:  MOVWF  x96
2FC2:  MOVLB  0
2FC4:  CALL   0CA2
2FC8:  MOVFF  01,98F
2FCC:  MOVLW  05
2FCE:  MOVLB  9
2FD0:  ADDWF  01,W
2FD2:  MOVWF  01
2FD4:  MOVLW  00
2FD6:  ADDWFC 02,W
2FD8:  MOVWF  03
2FDA:  MOVF   01,W
2FDC:  ADDLW  21
2FDE:  MOVWF  FE9
2FE0:  MOVLW  00
2FE2:  ADDWFC 03,W
2FE4:  MOVWF  FEA
2FE6:  MOVFF  FEF,98F
2FEA:  MOVFF  FEC,990
2FEE:  MOVFF  FEC,991
2FF2:  MOVFF  FEC,992
2FF6:  MOVFF  992,993
2FFA:  CLRF   x95
2FFC:  MOVFF  98D,994
3000:  CLRF   x97
3002:  MOVLW  0D
3004:  MOVWF  x96
3006:  MOVLB  0
3008:  CALL   0CA2
300C:  MOVFF  01,994
3010:  MOVLW  05
3012:  MOVLB  9
3014:  ADDWF  01,W
3016:  MOVWF  01
3018:  MOVLW  00
301A:  ADDWFC 02,W
301C:  MOVWF  03
301E:  MOVF   01,W
3020:  ADDLW  21
3022:  MOVWF  FE9
3024:  MOVLW  00
3026:  ADDWFC 03,W
3028:  MOVWF  FEA
302A:  MOVFF  FEF,994
302E:  MOVFF  FEC,995
3032:  MOVFF  FEC,996
3036:  MOVFF  FEC,997
303A:  MOVFF  996,998
303E:  MOVFF  992,98C
3042:  MOVFF  996,98B
3046:  BRA    315E
.................... 			case 5: result=make16(make8(device[dev].serialNumber,1),make8(device[dev].serialNumber,0)); break;
3048:  MOVLB  9
304A:  CLRF   x95
304C:  MOVFF  98D,994
3050:  CLRF   x97
3052:  MOVLW  0D
3054:  MOVWF  x96
3056:  MOVLB  0
3058:  CALL   0CA2
305C:  MOVFF  01,98F
3060:  MOVLW  05
3062:  MOVLB  9
3064:  ADDWF  01,W
3066:  MOVWF  01
3068:  MOVLW  00
306A:  ADDWFC 02,W
306C:  MOVWF  03
306E:  MOVF   01,W
3070:  ADDLW  21
3072:  MOVWF  FE9
3074:  MOVLW  00
3076:  ADDWFC 03,W
3078:  MOVWF  FEA
307A:  MOVFF  FEF,98F
307E:  MOVFF  FEC,990
3082:  MOVFF  FEC,991
3086:  MOVFF  FEC,992
308A:  MOVFF  990,993
308E:  CLRF   x95
3090:  MOVFF  98D,994
3094:  CLRF   x97
3096:  MOVLW  0D
3098:  MOVWF  x96
309A:  MOVLB  0
309C:  CALL   0CA2
30A0:  MOVFF  01,994
30A4:  MOVLW  05
30A6:  MOVLB  9
30A8:  ADDWF  01,W
30AA:  MOVWF  01
30AC:  MOVLW  00
30AE:  ADDWFC 02,W
30B0:  MOVWF  03
30B2:  MOVF   01,W
30B4:  ADDLW  21
30B6:  MOVWF  FE9
30B8:  MOVLW  00
30BA:  ADDWFC 03,W
30BC:  MOVWF  FEA
30BE:  MOVFF  FEF,994
30C2:  MOVFF  FEC,995
30C6:  MOVFF  FEC,996
30CA:  MOVFF  FEC,997
30CE:  MOVFF  994,998
30D2:  MOVFF  990,98C
30D6:  MOVFF  994,98B
30DA:  BRA    315E
.................... 			case 6: result=device[dev].startRegister; break;
30DC:  MOVLB  9
30DE:  CLRF   x95
30E0:  MOVFF  98D,994
30E4:  CLRF   x97
30E6:  MOVLW  0D
30E8:  MOVWF  x96
30EA:  MOVLB  0
30EC:  CALL   0CA2
30F0:  MOVFF  02,990
30F4:  MOVFF  01,98F
30F8:  MOVLW  09
30FA:  MOVLB  9
30FC:  ADDWF  01,W
30FE:  MOVWF  01
3100:  MOVLW  00
3102:  ADDWFC 02,W
3104:  MOVWF  03
3106:  MOVF   01,W
3108:  ADDLW  21
310A:  MOVWF  FE9
310C:  MOVLW  00
310E:  ADDWFC 03,W
3110:  MOVWF  FEA
3112:  MOVFF  FEC,98C
3116:  MOVF   FED,F
3118:  MOVFF  FEF,98B
311C:  BRA    315E
.................... 			case 7: result=device[dev].nRegisters; break;
311E:  MOVLB  9
3120:  CLRF   x95
3122:  MOVFF  98D,994
3126:  CLRF   x97
3128:  MOVLW  0D
312A:  MOVWF  x96
312C:  MOVLB  0
312E:  CALL   0CA2
3132:  MOVFF  02,990
3136:  MOVFF  01,98F
313A:  MOVLW  0B
313C:  MOVLB  9
313E:  ADDWF  01,W
3140:  MOVWF  01
3142:  MOVLW  00
3144:  ADDWFC 02,W
3146:  MOVWF  03
3148:  MOVF   01,W
314A:  ADDLW  21
314C:  MOVWF  FE9
314E:  MOVLW  00
3150:  ADDWFC 03,W
3152:  MOVWF  FEA
3154:  CLRF   x8C
3156:  MOVFF  FEF,98B
315A:  BRA    315E
315C:  MOVLB  9
.................... 		}
.................... 	} else {
315E:  BRA    3226
.................... 		switch ( address ) {
3160:  MOVF   x88,W
3162:  MOVWF  00
3164:  MOVF   x89,W
3166:  MOVWF  03
3168:  MOVLW  03
316A:  SUBWF  03,W
316C:  BNZ   3178
316E:  MOVLW  E8
3170:  SUBWF  00,W
3172:  MOVLB  0
3174:  BZ    31DA
3176:  MOVLB  9
3178:  MOVLW  03
317A:  SUBWF  03,W
317C:  BNZ   3188
317E:  MOVLW  E9
3180:  SUBWF  00,W
3182:  MOVLB  0
3184:  BZ    31E4
3186:  MOVLB  9
3188:  MOVLW  03
318A:  SUBWF  03,W
318C:  BNZ   3198
318E:  MOVLW  EA
3190:  SUBWF  00,W
3192:  MOVLB  0
3194:  BZ    31F0
3196:  MOVLB  9
3198:  MOVLW  03
319A:  SUBWF  03,W
319C:  BNZ   31A8
319E:  MOVLW  EB
31A0:  SUBWF  00,W
31A2:  MOVLB  0
31A4:  BZ    31FA
31A6:  MOVLB  9
31A8:  MOVLW  03
31AA:  SUBWF  03,W
31AC:  BNZ   31B8
31AE:  MOVLW  EC
31B0:  SUBWF  00,W
31B2:  MOVLB  0
31B4:  BZ    3202
31B6:  MOVLB  9
31B8:  MOVLW  03
31BA:  SUBWF  03,W
31BC:  BNZ   31C8
31BE:  MOVLW  ED
31C0:  SUBWF  00,W
31C2:  MOVLB  0
31C4:  BZ    320C
31C6:  MOVLB  9
31C8:  MOVLW  04
31CA:  SUBWF  03,W
31CC:  BNZ   31D8
31CE:  MOVLW  4C
31D0:  SUBWF  00,W
31D2:  MOVLB  0
31D4:  BZ    3214
31D6:  MOVLB  9
31D8:  BRA    3220
.................... 			case 1000: result=config.serial_prefix; break;
31DA:  MOVLB  9
31DC:  CLRF   x8C
31DE:  MOVFF  583,98B
31E2:  BRA    3226
.................... 			case 1001: result=config.serial_number; break;
31E4:  MOVFF  585,98C
31E8:  MOVFF  584,98B
31EC:  MOVLB  9
31EE:  BRA    3226
.................... 			case 1002: result='R'; break;
31F0:  MOVLB  9
31F2:  CLRF   x8C
31F4:  MOVLW  52
31F6:  MOVWF  x8B
31F8:  BRA    3226
.................... 			case 1003: result=0; break;
31FA:  MOVLB  9
31FC:  CLRF   x8C
31FE:  CLRF   x8B
3200:  BRA    3226
.................... 			case 1004: result='4'; break;
3202:  MOVLB  9
3204:  CLRF   x8C
3206:  MOVLW  34
3208:  MOVWF  x8B
320A:  BRA    3226
.................... 			case 1005: result=0; break;
320C:  MOVLB  9
320E:  CLRF   x8C
3210:  CLRF   x8B
3212:  BRA    3226
.................... 	
.................... 			case 1100: result=config.live_interval; break;
3214:  MOVFF  587,98C
3218:  MOVFF  586,98B
321C:  MOVLB  9
321E:  BRA    3226
.................... 	
.................... 			default: return ILLEGAL_DATA_ADDRESS;
3220:  MOVLW  02
3222:  MOVWF  01
3224:  BRA    3258
.................... 		}
.................... 	}
.................... 
.................... //	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u) result=%lu\r\n",address,n,result);
.................... 
.................... 	query.buff[n]  =make8(result,1);
3226:  MOVLW  6C
3228:  ADDWF  x8A,W
322A:  MOVWF  FE9
322C:  MOVLW  04
322E:  MOVWF  FEA
3230:  BTFSC  FD8.0
3232:  INCF   FEA,F
3234:  MOVFF  98C,FEF
.................... 	query.buff[n+1]=make8(result,0);
3238:  MOVLW  01
323A:  ADDWF  x8A,W
323C:  ADDLW  6C
323E:  MOVWF  FE9
3240:  MOVLW  04
3242:  MOVWF  FEA
3244:  BTFSC  FD8.0
3246:  INCF   FEA,F
3248:  MOVFF  98B,FEF
.................... 	query.resultLength += 2;
324C:  MOVLW  02
324E:  MOVLB  5
3250:  ADDWF  x82,F
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u, result=%lu, query.resultLength=%u)\r\n",
.................... 		address,
.................... 		n,
.................... 		result,
.................... 		query.resultLength
.................... 	);
.................... #endif
.................... 
.................... 
.................... 	return 0;
3252:  MOVLW  00
3254:  MOVWF  01
3256:  MOVLB  9
3258:  MOVLB  0
325A:  GOTO   32B8 (RETURN)
.................... }
.................... 
.................... exception query_self_read_registers(int16 address, int8 nRegisters) {
*
3288:  MOVLB  9
328A:  CLRF   x84
.................... 	int8 i;
.................... 	exception e=0;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers (address=%lu, nRegisters=%u)\r\n",address,nRegisters);
.................... #endif
.................... 
.................... 	for ( i=0 ; i<nRegisters && 0==e ; i++ ) {
328C:  CLRF   x83
328E:  MOVF   x82,W
3290:  SUBWF  x83,W
3292:  BC    32C2
3294:  MOVF   x84,F
3296:  BNZ   32C2
.................... 		e=query_self_read_register(address+i,i*2);
3298:  MOVF   x83,W
329A:  ADDWF  x80,W
329C:  MOVWF  x85
329E:  MOVLW  00
32A0:  ADDWFC x81,W
32A2:  MOVWF  x86
32A4:  BCF    FD8.0
32A6:  RLCF   x83,W
32A8:  MOVWF  x87
32AA:  MOVFF  986,989
32AE:  MOVFF  985,988
32B2:  MOVWF  x8A
32B4:  MOVLB  0
32B6:  BRA    2E7A
32B8:  MOVFF  01,984
.................... 	}
.................... 
.................... 
.................... #if DEBUG_ASCII
32BC:  MOVLB  9
32BE:  INCF   x83,F
32C0:  BRA    328E
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers returning e=%u\r\n",e);
.................... #endif
.................... 
.................... 
.................... 	return e;
32C2:  MOVFF  984,01
32C6:  MOVLB  0
32C8:  GOTO   367A (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void query_self(void) {
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self( query.function=%lu, query.start_address=%lu, query.n_words=%u)\r\n",
.................... 		query.function,
.................... 		query.start_address,
.................... 		query.n_words
.................... 	);
.................... #endif
.................... 
.................... 	query.resultLength=0;
*
3626:  MOVLB  5
3628:  CLRF   x82
.................... 
.................... 	switch ( query.function ) {
362A:  MOVF   x79,W
362C:  MOVWF  00
362E:  MOVF   x7A,W
3630:  MOVWF  03
3632:  MOVF   03,W
3634:  BNZ   3640
3636:  MOVLW  03
3638:  SUBWF  00,W
363A:  MOVLB  0
363C:  BZ    366C
363E:  MOVLB  5
3640:  MOVF   03,W
3642:  BNZ   364E
3644:  MOVLW  04
3646:  SUBWF  00,W
3648:  MOVLB  0
364A:  BZ    366C
364C:  MOVLB  5
364E:  MOVF   03,W
3650:  BNZ   365C
3652:  MOVLW  06
3654:  SUBWF  00,W
3656:  MOVLB  0
3658:  BZ    3680
365A:  MOVLB  5
365C:  MOVF   03,W
365E:  BNZ   366A
3660:  MOVLW  07
3662:  SUBWF  00,W
3664:  MOVLB  0
3666:  BZ    36CA
3668:  MOVLB  5
366A:  BRA    36CE
.................... 		case DEV_TYPE_MODBUS_3:
.................... 		case DEV_TYPE_MODBUS_4:
.................... 			/* read registers */
.................... 			query.resultException=query_self_read_registers(query.start_address, query.n_words);
366C:  MOVFF  57C,981
3670:  MOVFF  57B,980
3674:  MOVFF  57D,982
3678:  BRA    3288
367A:  MOVFF  01,581
.................... 			break;
367E:  BRA    36D4
.................... 		case DEV_TYPE_MODBUS_6:
.................... 			/* write single register */
.................... 			query.resultException=query_self_write_register(query.start_address, 
.................... 				make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
3680:  MOVLW  6C
3682:  MOVLB  5
3684:  ADDWF  x7E,W
3686:  MOVWF  FE9
3688:  MOVLW  04
368A:  MOVWF  FEA
368C:  BTFSC  FD8.0
368E:  INCF   FEA,F
3690:  MOVFF  FEF,980
3694:  MOVLW  01
3696:  ADDWF  x7E,W
3698:  ADDLW  6C
369A:  MOVWF  FE9
369C:  MOVLW  04
369E:  MOVWF  FEA
36A0:  BTFSC  FD8.0
36A2:  INCF   FEA,F
36A4:  MOVFF  FEF,981
36A8:  MOVFF  980,983
36AC:  MOVFF  981,982
36B0:  MOVFF  57C,985
36B4:  MOVFF  57B,984
36B8:  MOVFF  980,987
36BC:  MOVFF  981,986
36C0:  MOVLB  0
36C2:  BRA    32CC
36C4:  MOVFF  01,581
.................... 			break;
36C8:  BRA    36D4
.................... 		case DEV_TYPE_MODBUS_16:
.................... 			/* write multiple registers */
.................... 			break;
36CA:  BRA    36D4
36CC:  MOVLB  5
.................... 		default:
.................... 			query.resultException=ILLEGAL_FUNCTION;
36CE:  MOVLW  01
36D0:  MOVWF  x81
.................... 			query.resultLength=0;
36D2:  CLRF   x82
36D4:  MOVLB  0
.................... 	}
36D6:  GOTO   3F80 (RETURN)
.................... }
.................... 
.................... /*
.................... Remote query (from WorldData to us) syntax
.................... '#'                 0  STX
.................... RECV'R ID PREFIX    1  First character (A-Z) for gateway serial number
.................... RECV'R ID MSB       2  gateway serial number
.................... RECV'R ID LSB       3  
.................... PACKET LENGTH       4  
.................... PACKET TYPE         5  type of packet we are receiving (19)
.................... QUERY ID MSB        6  32 bit query id that we must answer with
.................... QUERY ID            7
.................... QUERY ID            8
.................... QUERY ID LSB        9
.................... QUERY DEV SN MSB    10 32 bit serial number of device to query
.................... QUERY DEV SN        11
.................... QUERY DEV SN        12
.................... QUERY DEV SN LSB    13
.................... Q NETWORK ADDR MSB  14 Network address of device to query, if SN not specified
.................... Q NETWORK ADDR LSB  15
.................... QUERY FUNCTION MSB  16 type of query to perform
.................... QUERY FUNCTION LSB  17
.................... QUERY ADDRESS MSB   18 start address for query
.................... QUERY ADDRESS LSB   19
.................... QUERY N WORDS       20 number of 16-bit words in query data
.................... QUERY DATA[0] MSB   [] first word of query data
.................... QUERY DATA[0] LSB   [+1]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... 
.................... Parse first four bytes for match to our serial number. If matched, receive rest 
.................... of packet and do checksum.
.................... 
.................... Send query to network one of two ways:
.................... if ( 0 != query_dev_sn ) then scan device table to determine network id
.................... else use network id
.................... 
.................... if ( 0==network id || our_serial_number==query_dev_sn ) then use local registers
.................... else perform network query
.................... */
.................... 
.................... void query_reset(void) {
.................... 	query.buff_pos=0;
*
09C2:  MOVLB  5
09C4:  CLRF   x6C
.................... 	
.................... 	/* !buff_ready causes serial receive interrupt to throw out data ... so clear last */
.................... 	query.buff_ready=0;
09C6:  CLRF   x6D
09C8:  MOVLB  0
09CA:  RETURN 0
.................... }
.................... 
.................... /* 
.................... response to remote query (from us to WorldData)
.................... '#'                 0  STX
.................... SERIAL PREFIX       1  First character (A-Z) for serial number
.................... SERIAL MSB          2  high byte of sending station ID
.................... SERIAL LSB          3  low byte of sending station ID
.................... PACKET LENGTH       4  always 0xff
.................... PACKET TYPE         5  type of packet we are sending (20)
.................... PACKET LENGTH MSB   6  number of byte for packet including STX through CRC
.................... PACKET LENGTH LSB   7
.................... QUERY ID MSB        8  32 bit query id that we are answering
.................... QUERY ID            9
.................... QUERY ID            10
.................... QUERY ID LSB        11
.................... QUERY EXCEPTION     12 exception encountered in performing query
.................... QUERY DATA[0] MSB [13] first word of query data
.................... QUERY DATA[0] LSB [14]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... */
.................... void query_response(void) {
.................... 	int8 buff[13];
.................... 	int16 l;
.................... 	int8 i;
.................... 
.................... 	buff[0]='#';
*
3D6A:  MOVLW  23
3D6C:  MOVLB  9
3D6E:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
3D70:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
3D74:  MOVFF  585,982
3D78:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0);
3D7A:  MOVFF  584,983
3D7E:  MOVLB  9
.................... 	buff[4]=0xff;
3D80:  SETF   x84
.................... 	buff[5]=20;
3D82:  MOVLW  14
3D84:  MOVWF  x85
.................... 	/* packet length */
.................... 	l=sizeof(buff)+query.resultLength+2;
3D86:  MOVLW  0D
3D88:  MOVLB  5
3D8A:  ADDWF  x82,W
3D8C:  ADDLW  02
3D8E:  MOVLB  9
3D90:  MOVWF  x8D
3D92:  CLRF   x8E
3D94:  BTFSC  FD8.0
3D96:  INCF   x8E,F
.................... 	buff[6]=make8(l,1);
3D98:  MOVFF  98E,986
.................... 	buff[7]=make8(l,0);
3D9C:  MOVFF  98D,987
.................... 
.................... 	buff[8]=make8(query.query_id,3);
3DA0:  MOVFF  572,988
3DA4:  MOVLB  9
.................... 	buff[9]=make8(query.query_id,2);
3DA6:  MOVFF  571,989
3DAA:  MOVLB  9
.................... 	buff[10]=make8(query.query_id,1);
3DAC:  MOVFF  570,98A
3DB0:  MOVLB  9
.................... 	buff[11]=make8(query.query_id,0);
3DB2:  MOVFF  56F,98B
3DB6:  MOVLB  9
.................... 	buff[12]=query.resultException;
3DB8:  MOVFF  581,98C
.................... 
.................... 	/* compute CRC on header (skip STX) and result data */
.................... 	l=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
3DBC:  SETF   x94
3DBE:  SETF   x93
3DC0:  MOVLW  09
3DC2:  MOVWF  x96
3DC4:  MOVLW  81
3DC6:  MOVWF  x95
3DC8:  MOVLW  0C
3DCA:  MOVWF  x97
3DCC:  MOVLB  0
3DCE:  CALL   228E
3DD2:  MOVFF  02,98E
3DD6:  MOVFF  01,98D
.................... 	l=crc_chk_pass(l,query.buff,query.resultLength);
3DDA:  MOVFF  98E,994
3DDE:  MOVFF  98D,993
3DE2:  MOVLW  04
3DE4:  MOVLB  9
3DE6:  MOVWF  x96
3DE8:  MOVLW  6C
3DEA:  MOVWF  x95
3DEC:  MOVFF  582,997
3DF0:  MOVLB  0
3DF2:  CALL   228E
3DF6:  MOVFF  02,98E
3DFA:  MOVFF  01,98D
.................... 
.................... 	output_high(CTRL_0);
3DFE:  BCF    F92.0
3E00:  BSF    F89.0
.................... 	/* send buff, result, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
3E02:  MOVLB  9
3E04:  CLRF   x8F
3E06:  MOVF   x8F,W
3E08:  SUBLW  0C
3E0A:  BNC   3E2C
.................... 		fputc(buff[i],STREAM_WORLD);
3E0C:  CLRF   03
3E0E:  MOVF   x8F,W
3E10:  ADDLW  80
3E12:  MOVWF  FE9
3E14:  MOVLW  09
3E16:  ADDWFC 03,W
3E18:  MOVWF  FEA
3E1A:  MOVFF  FEF,990
3E1E:  MOVF   x90,W
3E20:  MOVLB  0
3E22:  CALL   22EC
3E26:  MOVLB  9
3E28:  INCF   x8F,F
3E2A:  BRA    3E06
.................... 	}	
.................... 	for ( i=0 ; i<query.resultLength ; i++ ) {
3E2C:  CLRF   x8F
3E2E:  MOVLB  5
3E30:  MOVF   x82,W
3E32:  MOVLB  9
3E34:  SUBWF  x8F,W
3E36:  BC    3E58
.................... 		fputc(query.buff[i],STREAM_WORLD);
3E38:  MOVLW  6C
3E3A:  ADDWF  x8F,W
3E3C:  MOVWF  FE9
3E3E:  MOVLW  04
3E40:  MOVWF  FEA
3E42:  BTFSC  FD8.0
3E44:  INCF   FEA,F
3E46:  MOVFF  FEF,990
3E4A:  MOVF   x90,W
3E4C:  MOVLB  0
3E4E:  CALL   22EC
3E52:  MOVLB  9
3E54:  INCF   x8F,F
3E56:  BRA    3E2E
.................... 	}
.................... 	fputc(make8(l,1),STREAM_WORLD);
3E58:  MOVFF  98E,990
3E5C:  MOVF   x90,W
3E5E:  MOVLB  0
3E60:  CALL   22EC
.................... 	fputc(make8(l,0),STREAM_WORLD);
3E64:  MOVFF  98D,990
3E68:  MOVLB  9
3E6A:  MOVF   x90,W
3E6C:  MOVLB  0
3E6E:  CALL   22EC
.................... 
.................... 
.................... 	delay_ms(10);
3E72:  MOVLW  0A
3E74:  MOVLB  9
3E76:  MOVWF  x90
3E78:  MOVLB  0
3E7A:  CALL   0A94
.................... 	output_low(CTRL_0);
3E7E:  BCF    F92.0
3E80:  BCF    F89.0
.................... 
.................... #if 0
3E82:  GOTO   3F8A (RETURN)
.................... 	fprintf(STREAM_WORLD,"# query result (query.resultLength=%u query.resultException=%u):\r\n",query.resultLength,query.resultException);
.................... 	/* query.resultLength is in bytes  .... result is in 16-bit words */
.................... 	for ( i=0 ; i<query.resultLength ; i+=2 ) {
.................... 		fprintf(STREAM_WORLD,"# query.buff[%u]=%lu (0x%04lX)\r\n",
.................... 			i/2,
.................... 			make16(query.buff[i],query.buff[i+1]),
.................... 			make16(query.buff[i],query.buff[i+1])
.................... 		);
.................... 		query.buff[i]=0xff;
.................... 		query.buff[i+1]=0xff;
.................... 	}
.................... #endif
.................... }
.................... 
.................... /* we received a query addressed to us */
.................... void query_process(void) {
.................... 	int32 our_serial;
.................... //	int8 i;
.................... 	int16 lCRC;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# in query_process()\r\n");
.................... #endif
.................... 
.................... 	query.packet_length=query.buff[4];
3E86:  MOVFF  470,56E
.................... 	query.crc=make16(query.buff[query.packet_length-2],query.buff[query.packet_length-1]);	
3E8A:  MOVLW  02
3E8C:  MOVLB  5
3E8E:  SUBWF  x6E,W
3E90:  ADDLW  6C
3E92:  MOVWF  FE9
3E94:  MOVLW  04
3E96:  MOVWF  FEA
3E98:  BTFSC  FD8.0
3E9A:  INCF   FEA,F
3E9C:  MOVFF  FEF,580
3EA0:  MOVLW  01
3EA2:  SUBWF  x6E,W
3EA4:  ADDLW  6C
3EA6:  MOVWF  FE9
3EA8:  MOVLW  04
3EAA:  MOVWF  FEA
3EAC:  BTFSC  FD8.0
3EAE:  INCF   FEA,F
3EB0:  MOVFF  FEF,57F
.................... 	lCRC = crc_chk_pass(0xFFFF,query.buff+1,query.packet_length-3);
3EB4:  MOVLW  03
3EB6:  SUBWF  x6E,W
3EB8:  MOVLB  9
3EBA:  MOVWF  x80
3EBC:  SETF   x94
3EBE:  SETF   x93
3EC0:  MOVLW  04
3EC2:  MOVWF  x96
3EC4:  MOVLW  6D
3EC6:  MOVWF  x95
3EC8:  MOVFF  980,997
3ECC:  MOVLB  0
3ECE:  CALL   228E
3ED2:  MOVFF  02,97F
3ED6:  MOVFF  01,97E
.................... 
.................... 	if ( lCRC != query.crc ) {
3EDA:  MOVLB  5
3EDC:  MOVF   x7F,W
3EDE:  MOVLB  9
3EE0:  SUBWF  x7E,W
3EE2:  BNZ   3EEE
3EE4:  MOVLB  5
3EE6:  MOVF   x80,W
3EE8:  MOVLB  9
3EEA:  SUBWF  x7F,W
3EEC:  BZ    3EF0
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# CRC 0x%04lX != 0x%04lX (LOCAL)\r\n",query.crc,lCRC);
.................... #endif
.................... 		return;
3EEE:  BRA    3F8C
.................... 	}
.................... 
.................... 
.................... 	if ( 19 != query.buff[5] ) {
3EF0:  MOVLB  4
3EF2:  MOVF   x71,W
3EF4:  SUBLW  13
3EF6:  BZ    3EFE
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# not query type 19 ... don't know how to handle!\r\n");
.................... #endif
.................... 		return;
3EF8:  MOVLB  9
3EFA:  BRA    3F8C
3EFC:  MOVLB  4
.................... 	}
.................... 
.................... 	
.................... 	query.query_id=make32(query.buff[6],query.buff[7],query.buff[8],query.buff[9]);
3EFE:  MOVFF  472,572
3F02:  MOVFF  473,571
3F06:  MOVFF  474,570
3F0A:  MOVFF  475,56F
.................... 	query.device_serial=make32(query.buff[10],query.buff[11],query.buff[12],query.buff[13]);
3F0E:  MOVFF  476,576
3F12:  MOVFF  477,575
3F16:  MOVFF  478,574
3F1A:  MOVFF  479,573
.................... 	query.network_address=make16(query.buff[14],query.buff[15]);
3F1E:  MOVFF  47A,578
3F22:  MOVFF  47B,577
.................... 	query.function=make16(query.buff[16],query.buff[17]);
3F26:  MOVFF  47C,57A
3F2A:  MOVFF  47D,579
.................... 	query.start_address=make16(query.buff[18],query.buff[19]);
3F2E:  MOVFF  47E,57C
3F32:  MOVFF  47F,57B
.................... 	query.n_words=query.buff[20];
3F36:  MOVFF  480,57D
.................... 	query.data_start_offset=21;
3F3A:  MOVLW  15
3F3C:  MOVLB  5
3F3E:  MOVWF  x7E
.................... 	
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# length=%u (query.buff_pos=%u)\r\n",query.packet_length,query.buff_pos);
.................... 	fprintf(STREAM_WORLD,"# query_id=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.query_id,3),
.................... 		make8(query.query_id,2),
.................... 		make8(query.query_id,1),
.................... 		make8(query.query_id,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# device serial=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.device_serial,3),
.................... 		make8(query.device_serial,2),
.................... 		make8(query.device_serial,1),
.................... 		make8(query.device_serial,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# network address=%lu\r\n",query.network_address);
.................... 	fprintf(STREAM_WORLD,"# function=%lu\r\n",query.function);
.................... 	fprintf(STREAM_WORLD,"# start address=%lu\r\n",query.start_address);
.................... 	fprintf(STREAM_WORLD,"# n_words=%u\r\n",query.n_words);
.................... 
.................... 	/* n words can be the number of query words, in which case we won't have any data besides the CRC */
.................... 	for ( i=0 ; i<query.n_words && i<query.packet_length-2 ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# word[%u]=%lu\r\n",i,make16(query.buff[21+i*2],query.buff[22+i*2]));
.................... 	}
.................... 
.................... 	fprintf(STREAM_WORLD,"# rCRC=%lu\r\n",query.crc);
.................... #endif
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# dump whole packet:\r\n");
.................... 	for ( i=0 ; i<query.packet_length ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# buff[%u]=0x%02X",i,query.buff[i]);
.................... 		if ( i==query.data_start_offset )
.................... 			fprintf(STREAM_WORLD," (start)");
.................... 		fprintf(STREAM_WORLD,"\r\n");
.................... 	}
.................... #endif
.................... 
.................... 	query.resultLength=0;
3F40:  CLRF   x82
.................... 	/* check to see who handles this query */
.................... 	our_serial=make32(0,config.serial_prefix,config.serial_number);
3F42:  MOVLB  9
3F44:  CLRF   x7D
3F46:  MOVFF  583,97C
3F4A:  MOVFF  584,97A
3F4E:  MOVFF  585,97B
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"#   our serial=%c%lu\r\n",config.serial_prefix,config.serial_number);
.................... 	fprintf(STREAM_WORLD,"# query serial=%c%lu\r\n",make8(query.device_serial,2),(int16) query.device_serial);
.................... #endif
.................... 
.................... 	if ( our_serial == query.device_serial ) {
3F52:  MOVLB  5
3F54:  MOVF   x73,W
3F56:  MOVLB  9
3F58:  SUBWF  x7A,W
3F5A:  BNZ   3F84
3F5C:  MOVLB  5
3F5E:  MOVF   x74,W
3F60:  MOVLB  9
3F62:  SUBWF  x7B,W
3F64:  BNZ   3F84
3F66:  MOVLB  5
3F68:  MOVF   x75,W
3F6A:  MOVLB  9
3F6C:  SUBWF  x7C,W
3F6E:  BNZ   3F84
3F70:  MOVLB  5
3F72:  MOVF   x76,W
3F74:  MOVLB  9
3F76:  SUBWF  x7D,W
3F78:  BNZ   3F84
.................... 		query_self();
3F7A:  MOVLB  0
3F7C:  GOTO   3626
.................... 	} else {
3F80:  BRA    3F88
3F82:  MOVLB  9
.................... 		query_other();
3F84:  MOVLB  0
3F86:  BRA    3A46
.................... 		
.................... 	}	
.................... 
.................... 	query_response();
3F88:  BRA    3D6A
3F8A:  MOVLB  9
3F8C:  MOVLB  0
3F8E:  GOTO   430C (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void deviceQuery(void) {
.................... 	static int16 measurementNumber=0;
.................... 	static int8  nCycles[DEV_MAX_N];
.................... 	int8 n;
.................... 	int16 l;
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... #endif
.................... 
.................... 	/* check if next cycle will be an SBD transmission. */
.................... 	if ( 1 == timers.sbd_cycle ) {
*
267A:  MOVLB  3
267C:  DECFSZ x65,W
267E:  BRA    2698
2680:  MOVF   x66,F
2682:  BNZ   2698
.................... 		/* next cycle will be an Iridium transmit cycle, so turn on modem and clear outgoing buffer */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() next cycle will be SBD transmit cycle.\r\n");
2684:  MOVLW  8A
2686:  MOVWF  FF6
2688:  MOVLW  07
268A:  MOVWF  FF7
268C:  MOVLB  0
268E:  CALL   0B38
.................... #endif
.................... //		iridium_on();
.................... 		iridium_mo_clear();
2692:  CALL   1CB2
2696:  MOVLB  3
.................... 	}
.................... 
.................... 	/* check if we are going to be doing a SBD transmision */
.................... 	if ( 0 == timers.sbd_cycle ) {
2698:  MOVF   x65,F
269A:  BNZ   26F8
269C:  MOVF   x66,F
269E:  BNZ   26F8
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() this cycle is an SBD transmit cycle.\r\n");
26A0:  MOVLW  C4
26A2:  MOVWF  FF6
26A4:  MOVLW  07
26A6:  MOVWF  FF7
26A8:  MOVLB  0
26AA:  CALL   0B38
.................... #endif
.................... 		/* turn on modem in case it isn't already on */
.................... //		iridium_on();
.................... 		/* clear MO buffer */
.................... 		iridium_mo_clear();
26AE:  CALL   1CB2
.................... 
.................... 		/* build header */
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,1);
26B2:  MOVLB  7
26B4:  MOVFF  7DB,03
26B8:  MOVF   xDA,W
26BA:  INCF   xDA,F
26BC:  BTFSC  FD8.2
26BE:  INCF   xDB,F
26C0:  MOVLB  9
26C2:  MOVWF  x7D
26C4:  MOVLW  CA
26C6:  ADDWF  x7D,W
26C8:  MOVWF  FE9
26CA:  MOVLW  06
26CC:  ADDWFC 03,W
26CE:  MOVWF  FEA
26D0:  MOVFF  938,FEF
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,0);
26D4:  MOVLB  7
26D6:  MOVFF  7DB,03
26DA:  MOVF   xDA,W
26DC:  INCF   xDA,F
26DE:  BTFSC  FD8.2
26E0:  INCF   xDB,F
26E2:  MOVLB  9
26E4:  MOVWF  x7D
26E6:  MOVLW  CA
26E8:  ADDWF  x7D,W
26EA:  MOVWF  FE9
26EC:  MOVLW  06
26EE:  ADDWFC 03,W
26F0:  MOVWF  FEA
26F2:  MOVFF  937,FEF
26F6:  MOVLB  3
.................... 	}
.................... 
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() querying all enabled devices:\r\n");
.................... #endif
.................... 
.................... 	for ( n=0 ; n<DEV_MAX_N ; n++ ) {
26F8:  MOVLB  9
26FA:  CLRF   x7A
26FC:  MOVF   x7A,W
26FE:  SUBLW  3F
2700:  BTFSS  FD8.0
2702:  BRA    2E14
.................... 		restart_wdt();
2704:  CLRWDT
.................... 		timers.led_on_green=100;
2706:  MOVLW  64
2708:  MOVLB  3
270A:  MOVWF  x64
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[n].type ) 
270C:  MOVLB  9
270E:  CLRF   x95
2710:  MOVFF  97A,994
2714:  CLRF   x97
2716:  MOVLW  0D
2718:  MOVWF  x96
271A:  MOVLB  0
271C:  CALL   0CA2
2720:  MOVFF  02,97E
2724:  MOVFF  01,97D
2728:  MOVLW  21
272A:  MOVLB  9
272C:  ADDWF  01,W
272E:  MOVWF  FE9
2730:  MOVLW  00
2732:  ADDWFC 02,W
2734:  MOVWF  FEA
2736:  MOVF   FEF,W
2738:  BNZ   273C
.................... 			continue;
273A:  BRA    2E0C
.................... 
.................... 		nCycles[n]++;
273C:  CLRF   03
273E:  MOVF   x7A,W
2740:  ADDLW  39
2742:  MOVWF  FE9
2744:  MOVLW  09
2746:  ADDWFC 03,W
2748:  MOVWF  FEA
274A:  INCF   FEF,F
.................... 		if ( nCycles[n] < device[n].transmitEvery ) {
274C:  CLRF   03
274E:  MOVF   x7A,W
2750:  ADDLW  39
2752:  MOVWF  FE9
2754:  MOVLW  09
2756:  ADDWFC 03,W
2758:  MOVWF  FEA
275A:  MOVFF  FEF,97D
275E:  CLRF   x95
2760:  MOVFF  97A,994
2764:  CLRF   x97
2766:  MOVLW  0D
2768:  MOVWF  x96
276A:  MOVLB  0
276C:  CALL   0CA2
2770:  MOVFF  02,97F
2774:  MOVFF  01,97E
2778:  MOVLW  03
277A:  MOVLB  9
277C:  ADDWF  01,W
277E:  MOVWF  01
2780:  MOVLW  00
2782:  ADDWFC 02,W
2784:  MOVWF  03
2786:  MOVF   01,W
2788:  ADDLW  21
278A:  MOVWF  FE9
278C:  MOVLW  00
278E:  ADDWFC 03,W
2790:  MOVWF  FEA
2792:  MOVF   FEF,W
2794:  SUBWF  x7D,W
2796:  BC    279C
.................... 			continue;
2798:  BRA    2E0C
.................... 		} else {
279A:  BRA    27AC
.................... 			nCycles[n]=0;
279C:  CLRF   03
279E:  MOVF   x7A,W
27A0:  ADDLW  39
27A2:  MOVWF  FE9
27A4:  MOVLW  09
27A6:  ADDWFC 03,W
27A8:  MOVWF  FEA
27AA:  CLRF   FEF
.................... 		}
.................... 
.................... 
.................... 
.................... 		qbuff.deviceNumber=n;
27AC:  MOVFF  97A,469
.................... 		qbuff.measurementNumber=measurementNumber;
27B0:  MOVFF  938,46B
27B4:  MOVFF  937,46A
.................... 
.................... 
.................... 		if ( device[n].type <= DEV_TYPE_MODBUS_MAX ) {
27B8:  CLRF   x95
27BA:  MOVFF  97A,994
27BE:  CLRF   x97
27C0:  MOVLW  0D
27C2:  MOVWF  x96
27C4:  MOVLB  0
27C6:  CALL   0CA2
27CA:  MOVFF  02,97E
27CE:  MOVFF  01,97D
27D2:  MOVLW  21
27D4:  MOVLB  9
27D6:  ADDWF  01,W
27D8:  MOVWF  FE9
27DA:  MOVLW  00
27DC:  ADDWFC 02,W
27DE:  MOVWF  FEA
27E0:  MOVF   FEF,W
27E2:  SUBLW  07
27E4:  BTFSS  FD8.0
27E6:  BRA    2BF8
.................... 			/* modbus device type */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() MODBUS device\r\n");
.................... #endif
.................... 			/* set serial port speed */
.................... 			if ( DEV_SERIAL_19200 == device[n].serialSpeed ) {
27E8:  CLRF   x95
27EA:  MOVFF  97A,994
27EE:  CLRF   x97
27F0:  MOVLW  0D
27F2:  MOVWF  x96
27F4:  MOVLB  0
27F6:  CALL   0CA2
27FA:  MOVFF  02,97E
27FE:  MOVFF  01,97D
2802:  MOVLW  0C
2804:  MOVLB  9
2806:  ADDWF  01,W
2808:  MOVWF  01
280A:  MOVLW  00
280C:  ADDWFC 02,W
280E:  MOVWF  03
2810:  MOVF   01,W
2812:  ADDLW  21
2814:  MOVWF  FE9
2816:  MOVLW  00
2818:  ADDWFC 03,W
281A:  MOVWF  FEA
281C:  MOVF   FEF,W
281E:  SUBLW  01
2820:  BNZ   2832
.................... 				set_uart_speed(19200,MODBUS_SERIAL);
2822:  BCF    FA7.3
2824:  MOVLW  19
2826:  MOVWF  FAF
2828:  MOVLW  A6
282A:  MOVWF  FAC
282C:  MOVLW  90
282E:  MOVWF  FAB
.................... 			} else {
2830:  BRA    2840
.................... 				set_uart_speed(9600,MODBUS_SERIAL);
2832:  BCF    FA7.3
2834:  MOVLW  0C
2836:  MOVWF  FAF
2838:  MOVLW  A2
283A:  MOVWF  FAC
283C:  MOVLW  90
283E:  MOVWF  FAB
.................... 			}
.................... 
.................... 			if ( DEV_TYPE_MODBUS_3 == device[n].type || DEV_TYPE_MODBUS_4 == device[n].type ) {
2840:  CLRF   x95
2842:  MOVFF  97A,994
2846:  CLRF   x97
2848:  MOVLW  0D
284A:  MOVWF  x96
284C:  MOVLB  0
284E:  CALL   0CA2
2852:  MOVFF  02,97E
2856:  MOVFF  01,97D
285A:  MOVLW  21
285C:  MOVLB  9
285E:  ADDWF  01,W
2860:  MOVWF  FE9
2862:  MOVLW  00
2864:  ADDWFC 02,W
2866:  MOVWF  FEA
2868:  MOVF   FEF,W
286A:  SUBLW  03
286C:  BZ    289E
286E:  CLRF   x95
2870:  MOVFF  97A,994
2874:  CLRF   x97
2876:  MOVLW  0D
2878:  MOVWF  x96
287A:  MOVLB  0
287C:  CALL   0CA2
2880:  MOVFF  02,980
2884:  MOVFF  01,97F
2888:  MOVLW  21
288A:  MOVLB  9
288C:  ADDWF  01,W
288E:  MOVWF  FE9
2890:  MOVLW  00
2892:  ADDWFC 02,W
2894:  MOVWF  FEA
2896:  MOVF   FEF,W
2898:  SUBLW  04
289A:  BTFSS  FD8.2
289C:  BRA    2A96
.................... 				/* Modbus read input or holding registers */
.................... 				if ( DEV_TYPE_MODBUS_4 == device[n].type ) {
289E:  CLRF   x95
28A0:  MOVFF  97A,994
28A4:  CLRF   x97
28A6:  MOVLW  0D
28A8:  MOVWF  x96
28AA:  MOVLB  0
28AC:  CALL   0CA2
28B0:  MOVFF  02,97E
28B4:  MOVFF  01,97D
28B8:  MOVLW  21
28BA:  MOVLB  9
28BC:  ADDWF  01,W
28BE:  MOVWF  FE9
28C0:  MOVLW  00
28C2:  ADDWFC 02,W
28C4:  MOVWF  FEA
28C6:  MOVF   FEF,W
28C8:  SUBLW  04
28CA:  BNZ   2992
.................... 					qbuff.rException=modbus_read_input_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
28CC:  CLRF   x95
28CE:  MOVFF  97A,994
28D2:  CLRF   x97
28D4:  MOVLW  0D
28D6:  MOVWF  x96
28D8:  MOVLB  0
28DA:  CALL   0CA2
28DE:  MOVFF  02,97E
28E2:  MOVFF  01,97D
28E6:  MOVLW  04
28E8:  MOVLB  9
28EA:  ADDWF  01,W
28EC:  MOVWF  01
28EE:  MOVLW  00
28F0:  ADDWFC 02,W
28F2:  MOVWF  03
28F4:  MOVF   01,W
28F6:  ADDLW  21
28F8:  MOVWF  FE9
28FA:  MOVLW  00
28FC:  ADDWFC 03,W
28FE:  MOVWF  FEA
2900:  MOVFF  FEF,97D
2904:  CLRF   x95
2906:  MOVFF  97A,994
290A:  CLRF   x97
290C:  MOVLW  0D
290E:  MOVWF  x96
2910:  MOVLB  0
2912:  CALL   0CA2
2916:  MOVFF  01,97E
291A:  MOVLW  09
291C:  MOVLB  9
291E:  ADDWF  01,W
2920:  MOVWF  01
2922:  MOVLW  00
2924:  ADDWFC 02,W
2926:  MOVWF  03
2928:  MOVF   01,W
292A:  ADDLW  21
292C:  MOVWF  FE9
292E:  MOVLW  00
2930:  ADDWFC 03,W
2932:  MOVWF  FEA
2934:  MOVFF  FEC,97F
2938:  MOVF   FED,F
293A:  MOVFF  FEF,97E
293E:  CLRF   x95
2940:  MOVFF  97A,994
2944:  CLRF   x97
2946:  MOVLW  0D
2948:  MOVWF  x96
294A:  MOVLB  0
294C:  CALL   0CA2
2950:  MOVFF  02,981
2954:  MOVFF  01,980
2958:  MOVLW  0B
295A:  MOVLB  9
295C:  ADDWF  01,W
295E:  MOVWF  01
2960:  MOVLW  00
2962:  ADDWFC 02,W
2964:  MOVWF  03
2966:  MOVF   01,W
2968:  ADDLW  21
296A:  MOVWF  FE9
296C:  MOVLW  00
296E:  ADDWFC 03,W
2970:  MOVWF  FEA
2972:  MOVFF  FEF,985
2976:  MOVFF  97D,982
297A:  MOVFF  97F,984
297E:  MOVFF  97E,983
2982:  CLRF   x86
2984:  MOVLB  0
2986:  CALL   215E
298A:  MOVFF  01,367
.................... 				} else {
298E:  BRA    2A54
2990:  MOVLB  9
.................... 					qbuff.rException=modbus_read_holding_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
2992:  CLRF   x95
2994:  MOVFF  97A,994
2998:  CLRF   x97
299A:  MOVLW  0D
299C:  MOVWF  x96
299E:  MOVLB  0
29A0:  CALL   0CA2
29A4:  MOVFF  02,97E
29A8:  MOVFF  01,97D
29AC:  MOVLW  04
29AE:  MOVLB  9
29B0:  ADDWF  01,W
29B2:  MOVWF  01
29B4:  MOVLW  00
29B6:  ADDWFC 02,W
29B8:  MOVWF  03
29BA:  MOVF   01,W
29BC:  ADDLW  21
29BE:  MOVWF  FE9
29C0:  MOVLW  00
29C2:  ADDWFC 03,W
29C4:  MOVWF  FEA
29C6:  MOVFF  FEF,97D
29CA:  CLRF   x95
29CC:  MOVFF  97A,994
29D0:  CLRF   x97
29D2:  MOVLW  0D
29D4:  MOVWF  x96
29D6:  MOVLB  0
29D8:  CALL   0CA2
29DC:  MOVFF  01,97E
29E0:  MOVLW  09
29E2:  MOVLB  9
29E4:  ADDWF  01,W
29E6:  MOVWF  01
29E8:  MOVLW  00
29EA:  ADDWFC 02,W
29EC:  MOVWF  03
29EE:  MOVF   01,W
29F0:  ADDLW  21
29F2:  MOVWF  FE9
29F4:  MOVLW  00
29F6:  ADDWFC 03,W
29F8:  MOVWF  FEA
29FA:  MOVFF  FEC,97F
29FE:  MOVF   FED,F
2A00:  MOVFF  FEF,97E
2A04:  CLRF   x95
2A06:  MOVFF  97A,994
2A0A:  CLRF   x97
2A0C:  MOVLW  0D
2A0E:  MOVWF  x96
2A10:  MOVLB  0
2A12:  CALL   0CA2
2A16:  MOVFF  02,981
2A1A:  MOVFF  01,980
2A1E:  MOVLW  0B
2A20:  MOVLB  9
2A22:  ADDWF  01,W
2A24:  MOVWF  01
2A26:  MOVLW  00
2A28:  ADDWFC 02,W
2A2A:  MOVWF  03
2A2C:  MOVF   01,W
2A2E:  ADDLW  21
2A30:  MOVWF  FE9
2A32:  MOVLW  00
2A34:  ADDWFC 03,W
2A36:  MOVWF  FEA
2A38:  MOVFF  FEF,985
2A3C:  MOVFF  97D,982
2A40:  MOVFF  97F,984
2A44:  MOVFF  97E,983
2A48:  CLRF   x86
2A4A:  MOVLB  0
2A4C:  CALL   21F6
2A50:  MOVFF  01,367
.................... 				}
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
2A54:  MOVLB  3
2A56:  MOVF   x67,F
2A58:  BNZ   2A92
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
2A5A:  MOVLW  01
2A5C:  MOVLB  5
2A5E:  SUBWF  x94,W
2A60:  MOVLB  4
2A62:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
2A64:  MOVLW  01
2A66:  MOVLB  5
2A68:  SUBWF  x94,W
2A6A:  MOVLB  9
2A6C:  MOVWF  x7D
2A6E:  MOVLW  03
2A70:  MOVWF  FEA
2A72:  MOVLW  68
2A74:  MOVWF  FE9
2A76:  MOVLW  05
2A78:  MOVWF  FE2
2A7A:  MOVLW  98
2A7C:  MOVWF  FE1
2A7E:  MOVF   x7D,W
2A80:  MOVWF  01
2A82:  BZ    2A8C
2A84:  MOVFF  FE6,FEE
2A88:  DECFSZ 01,F
2A8A:  BRA    2A84
.................... 
.................... 					live_send();
2A8C:  MOVLB  0
2A8E:  RCALL  22F4
2A90:  MOVLB  3
.................... 				}
.................... 			} else if ( DEV_TYPE_MODBUS_1==device[n].type || DEV_TYPE_MODBUS_2==device[n].type ) {
2A92:  BRA    2BF4
2A94:  MOVLB  9
2A96:  CLRF   x95
2A98:  MOVFF  97A,994
2A9C:  CLRF   x97
2A9E:  MOVLW  0D
2AA0:  MOVWF  x96
2AA2:  MOVLB  0
2AA4:  CALL   0CA2
2AA8:  MOVFF  02,97E
2AAC:  MOVFF  01,97D
2AB0:  MOVLW  21
2AB2:  MOVLB  9
2AB4:  ADDWF  01,W
2AB6:  MOVWF  FE9
2AB8:  MOVLW  00
2ABA:  ADDWFC 02,W
2ABC:  MOVWF  FEA
2ABE:  MOVF   FEF,W
2AC0:  SUBLW  01
2AC2:  BZ    2AF4
2AC4:  CLRF   x95
2AC6:  MOVFF  97A,994
2ACA:  CLRF   x97
2ACC:  MOVLW  0D
2ACE:  MOVWF  x96
2AD0:  MOVLB  0
2AD2:  CALL   0CA2
2AD6:  MOVFF  02,980
2ADA:  MOVFF  01,97F
2ADE:  MOVLW  21
2AE0:  MOVLB  9
2AE2:  ADDWF  01,W
2AE4:  MOVWF  FE9
2AE6:  MOVLW  00
2AE8:  ADDWFC 02,W
2AEA:  MOVWF  FEA
2AEC:  MOVF   FEF,W
2AEE:  SUBLW  02
2AF0:  BTFSS  FD8.2
2AF2:  BRA    2BF6
.................... 				/* Modbus read coil or discrete input */
.................... 				qbuff.rException=modbus_read_coils(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
2AF4:  CLRF   x95
2AF6:  MOVFF  97A,994
2AFA:  CLRF   x97
2AFC:  MOVLW  0D
2AFE:  MOVWF  x96
2B00:  MOVLB  0
2B02:  CALL   0CA2
2B06:  MOVFF  02,97E
2B0A:  MOVFF  01,97D
2B0E:  MOVLW  04
2B10:  MOVLB  9
2B12:  ADDWF  01,W
2B14:  MOVWF  01
2B16:  MOVLW  00
2B18:  ADDWFC 02,W
2B1A:  MOVWF  03
2B1C:  MOVF   01,W
2B1E:  ADDLW  21
2B20:  MOVWF  FE9
2B22:  MOVLW  00
2B24:  ADDWFC 03,W
2B26:  MOVWF  FEA
2B28:  MOVFF  FEF,97D
2B2C:  CLRF   x95
2B2E:  MOVFF  97A,994
2B32:  CLRF   x97
2B34:  MOVLW  0D
2B36:  MOVWF  x96
2B38:  MOVLB  0
2B3A:  CALL   0CA2
2B3E:  MOVFF  01,97E
2B42:  MOVLW  09
2B44:  MOVLB  9
2B46:  ADDWF  01,W
2B48:  MOVWF  01
2B4A:  MOVLW  00
2B4C:  ADDWFC 02,W
2B4E:  MOVWF  03
2B50:  MOVF   01,W
2B52:  ADDLW  21
2B54:  MOVWF  FE9
2B56:  MOVLW  00
2B58:  ADDWFC 03,W
2B5A:  MOVWF  FEA
2B5C:  MOVFF  FEC,97F
2B60:  MOVF   FED,F
2B62:  MOVFF  FEF,97E
2B66:  CLRF   x95
2B68:  MOVFF  97A,994
2B6C:  CLRF   x97
2B6E:  MOVLW  0D
2B70:  MOVWF  x96
2B72:  MOVLB  0
2B74:  CALL   0CA2
2B78:  MOVFF  02,981
2B7C:  MOVFF  01,980
2B80:  MOVLW  0B
2B82:  MOVLB  9
2B84:  ADDWF  01,W
2B86:  MOVWF  01
2B88:  MOVLW  00
2B8A:  ADDWFC 02,W
2B8C:  MOVWF  03
2B8E:  MOVF   01,W
2B90:  ADDLW  21
2B92:  MOVWF  FE9
2B94:  MOVLW  00
2B96:  ADDWFC 03,W
2B98:  MOVWF  FEA
2B9A:  MOVFF  FEF,985
2B9E:  MOVFF  97D,982
2BA2:  MOVFF  97F,984
2BA6:  MOVFF  97E,983
2BAA:  CLRF   x86
2BAC:  MOVLB  0
2BAE:  RCALL  2558
2BB0:  MOVFF  01,367
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
2BB4:  MOVLB  3
2BB6:  MOVF   x67,F
2BB8:  BNZ   2BF4
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
2BBA:  MOVLW  01
2BBC:  MOVLB  5
2BBE:  SUBWF  x94,W
2BC0:  MOVLB  4
2BC2:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
2BC4:  MOVLW  01
2BC6:  MOVLB  5
2BC8:  SUBWF  x94,W
2BCA:  MOVLB  9
2BCC:  MOVWF  x7D
2BCE:  MOVLW  03
2BD0:  MOVWF  FEA
2BD2:  MOVLW  68
2BD4:  MOVWF  FE9
2BD6:  MOVLW  05
2BD8:  MOVWF  FE2
2BDA:  MOVLW  98
2BDC:  MOVWF  FE1
2BDE:  MOVF   x7D,W
2BE0:  MOVWF  01
2BE2:  BZ    2BEC
2BE4:  MOVFF  FE6,FEE
2BE8:  DECFSZ 01,F
2BEA:  BRA    2BE4
.................... 
.................... 					live_send();
2BEC:  MOVLB  0
2BEE:  CALL   22F4
2BF2:  MOVLB  3
2BF4:  MOVLB  9
.................... 				}
.................... 			}
.................... 		} else if ( device[n].type <= DEV_TYPE_I2C_MAX ) {
2BF6:  BRA    2D58
2BF8:  CLRF   x95
2BFA:  MOVFF  97A,994
2BFE:  CLRF   x97
2C00:  MOVLW  0D
2C02:  MOVWF  x96
2C04:  MOVLB  0
2C06:  CALL   0CA2
2C0A:  MOVFF  02,97E
2C0E:  MOVFF  01,97D
2C12:  MOVLW  21
2C14:  MOVLB  9
2C16:  ADDWF  01,W
2C18:  MOVWF  FE9
2C1A:  MOVLW  00
2C1C:  ADDWFC 02,W
2C1E:  MOVWF  FEA
2C20:  MOVF   FEF,W
2C22:  SUBLW  17
2C24:  BTFSS  FD8.0
2C26:  BRA    2D58
.................... 			/* I2C device */
.................... 
.................... #if DEBUG_ASCII
.................... 			restart_wdt();
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() I2C device\r\n");
.................... 			fprintf(STREAM_WORLD,"device[%u]\r\n",n);
.................... 			fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[n].type);
.................... 			fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[n].transmitEvery);
.................... 			fprintf(STREAM_WORLD,"\tnetworkAddress=0x%02x\r\n",device[n].networkAddress);
.................... 			fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 				make8(device[n].serialNumber,3),
.................... 				make8(device[n].serialNumber,2),
.................... 				make8(device[n].serialNumber,1),
.................... 				make8(device[n].serialNumber,0)
.................... 			);
.................... 			fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[n].startRegister);
.................... 			fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[n].nRegisters);
.................... #endif
.................... 
.................... 			if ( DEV_TYPE_I2C_READ_8 == device[n].type ) {
2C28:  CLRF   x95
2C2A:  MOVFF  97A,994
2C2E:  CLRF   x97
2C30:  MOVLW  0D
2C32:  MOVWF  x96
2C34:  MOVLB  0
2C36:  CALL   0CA2
2C3A:  MOVFF  02,97E
2C3E:  MOVFF  01,97D
2C42:  MOVLW  21
2C44:  MOVLB  9
2C46:  ADDWF  01,W
2C48:  MOVWF  FE9
2C4A:  MOVLW  00
2C4C:  ADDWFC 02,W
2C4E:  MOVWF  FEA
2C50:  MOVF   FEF,W
2C52:  SUBLW  10
2C54:  BTFSS  FD8.2
2C56:  BRA    2D58
.................... 				/* start a read at start address then just read a byte at a time. nRegisters is bytes */
.................... //fprintf(STREAM_WORLD,"z");
.................... 				i2c_buff_read(device[n].networkAddress, device[n].startRegister, qbuff.rResult, device[n].nRegisters);
2C58:  CLRF   x95
2C5A:  MOVFF  97A,994
2C5E:  CLRF   x97
2C60:  MOVLW  0D
2C62:  MOVWF  x96
2C64:  MOVLB  0
2C66:  CALL   0CA2
2C6A:  MOVFF  02,97E
2C6E:  MOVFF  01,97D
2C72:  MOVLW  04
2C74:  MOVLB  9
2C76:  ADDWF  01,W
2C78:  MOVWF  01
2C7A:  MOVLW  00
2C7C:  ADDWFC 02,W
2C7E:  MOVWF  03
2C80:  MOVF   01,W
2C82:  ADDLW  21
2C84:  MOVWF  FE9
2C86:  MOVLW  00
2C88:  ADDWFC 03,W
2C8A:  MOVWF  FEA
2C8C:  MOVFF  FEF,97D
2C90:  CLRF   x95
2C92:  MOVFF  97A,994
2C96:  CLRF   x97
2C98:  MOVLW  0D
2C9A:  MOVWF  x96
2C9C:  MOVLB  0
2C9E:  CALL   0CA2
2CA2:  MOVFF  01,97E
2CA6:  MOVLW  09
2CA8:  MOVLB  9
2CAA:  ADDWF  01,W
2CAC:  MOVWF  01
2CAE:  MOVLW  00
2CB0:  ADDWFC 02,W
2CB2:  MOVWF  03
2CB4:  MOVF   01,W
2CB6:  ADDLW  21
2CB8:  MOVWF  FE9
2CBA:  MOVLW  00
2CBC:  ADDWFC 03,W
2CBE:  MOVWF  FEA
2CC0:  MOVFF  FEC,97F
2CC4:  MOVF   FED,F
2CC6:  MOVFF  FEF,97E
2CCA:  CLRF   x95
2CCC:  MOVFF  97A,994
2CD0:  CLRF   x97
2CD2:  MOVLW  0D
2CD4:  MOVWF  x96
2CD6:  MOVLB  0
2CD8:  CALL   0CA2
2CDC:  MOVFF  02,981
2CE0:  MOVFF  01,980
2CE4:  MOVLW  0B
2CE6:  MOVLB  9
2CE8:  ADDWF  01,W
2CEA:  MOVWF  01
2CEC:  MOVLW  00
2CEE:  ADDWFC 02,W
2CF0:  MOVWF  03
2CF2:  MOVF   01,W
2CF4:  ADDLW  21
2CF6:  MOVWF  FE9
2CF8:  MOVLW  00
2CFA:  ADDWFC 03,W
2CFC:  MOVWF  FEA
2CFE:  MOVFF  FEF,986
2D02:  MOVFF  97D,982
2D06:  MOVFF  97E,983
2D0A:  MOVLW  03
2D0C:  MOVWF  x85
2D0E:  MOVLW  68
2D10:  MOVWF  x84
2D12:  MOVLB  0
2D14:  RCALL  25F0
.................... 
.................... 				qbuff.rException=0;
2D16:  MOVLB  3
2D18:  CLRF   x67
.................... 				qbuff.rResultLength=device[n].nRegisters;
2D1A:  MOVLB  9
2D1C:  CLRF   x95
2D1E:  MOVFF  97A,994
2D22:  CLRF   x97
2D24:  MOVLW  0D
2D26:  MOVWF  x96
2D28:  MOVLB  0
2D2A:  CALL   0CA2
2D2E:  MOVFF  01,97D
2D32:  MOVLW  0B
2D34:  MOVLB  9
2D36:  ADDWF  01,W
2D38:  MOVWF  01
2D3A:  MOVLW  00
2D3C:  ADDWFC 02,W
2D3E:  MOVWF  03
2D40:  MOVF   01,W
2D42:  ADDLW  21
2D44:  MOVWF  FE9
2D46:  MOVLW  00
2D48:  ADDWFC 03,W
2D4A:  MOVWF  FEA
2D4C:  MOVFF  FEF,468
.................... //fprintf(STREAM_WORLD,"Z");
.................... #if DEBUG_ASCII
.................... 				/* debug dump */
.................... 				restart_wdt();
.................... 				for ( i=0 ; i<device[n].nRegisters ; i++ ) {
.................... 					fprintf(STREAM_WORLD,"# reg addr[0x%02x]=0x%02x (%u)\r\n",i+device[n].startRegister,qbuff.rResult[i],qbuff.rResult[i]);
.................... 				}
.................... #endif
.................... 
.................... 				live_send();
2D50:  MOVLB  0
2D52:  CALL   22F4
2D56:  MOVLB  9
.................... 
.................... 			}
.................... 
.................... 		} else {
.................... 			/* local */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() local (not implemented) device\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* Add data to SBD if this is an SBD cycle and we have valid data */
.................... 		if ( 0 == timers.sbd_cycle && 0 == qbuff.rException ) {
2D58:  MOVLB  3
2D5A:  MOVF   x65,F
2D5C:  BNZ   2E0E
2D5E:  MOVF   x66,F
2D60:  BNZ   2E0E
2D62:  MOVF   x67,F
2D64:  BNZ   2E0E
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() adding to sbd.mo_buff since qbuff.rException=0\r\n");
2D66:  MOVLW  FC
2D68:  MOVWF  FF6
2D6A:  MOVLW  07
2D6C:  MOVWF  FF7
2D6E:  MOVLB  0
2D70:  CALL   0B38
.................... #endif
.................... 			/* sub-header, 2 bytes, device number, and data length */
.................... 			sbd.mo_buff[sbd.mo_length++]=n;
2D74:  MOVLB  7
2D76:  MOVFF  7DB,03
2D7A:  MOVF   xDA,W
2D7C:  INCF   xDA,F
2D7E:  BTFSC  FD8.2
2D80:  INCF   xDB,F
2D82:  MOVLB  9
2D84:  MOVWF  x7D
2D86:  MOVLW  CA
2D88:  ADDWF  x7D,W
2D8A:  MOVWF  FE9
2D8C:  MOVLW  06
2D8E:  ADDWFC 03,W
2D90:  MOVWF  FEA
2D92:  MOVFF  97A,FEF
.................... 			sbd.mo_buff[sbd.mo_length++]=qbuff.rResultLength;
2D96:  MOVLB  7
2D98:  MOVFF  7DB,03
2D9C:  MOVF   xDA,W
2D9E:  INCF   xDA,F
2DA0:  BTFSC  FD8.2
2DA2:  INCF   xDB,F
2DA4:  MOVLB  9
2DA6:  MOVWF  x7D
2DA8:  MOVLW  CA
2DAA:  ADDWF  x7D,W
2DAC:  MOVWF  FE9
2DAE:  MOVLW  06
2DB0:  ADDWFC 03,W
2DB2:  MOVWF  FEA
2DB4:  MOVFF  468,FEF
.................... 		
.................... 			/* sub-message */
.................... 			for ( l=0 ; l<qbuff.rResultLength ; l++ ) {
2DB8:  CLRF   x7C
2DBA:  CLRF   x7B
2DBC:  MOVF   x7C,F
2DBE:  BNZ   2E0C
2DC0:  MOVLB  4
2DC2:  MOVF   x68,W
2DC4:  MOVLB  9
2DC6:  SUBWF  x7B,W
2DC8:  BC    2E0C
.................... 				sbd.mo_buff[sbd.mo_length++]=qBuff.rResult[l];
2DCA:  MOVLB  7
2DCC:  MOVFF  7DB,97E
2DD0:  MOVF   xDA,W
2DD2:  INCF   xDA,F
2DD4:  BTFSC  FD8.2
2DD6:  INCF   xDB,F
2DD8:  MOVLB  9
2DDA:  MOVWF  x7D
2DDC:  MOVLW  CA
2DDE:  ADDWF  x7D,W
2DE0:  MOVWF  01
2DE2:  MOVLW  06
2DE4:  ADDWFC x7E,W
2DE6:  MOVWF  03
2DE8:  MOVLW  68
2DEA:  ADDWF  x7B,W
2DEC:  MOVWF  FE9
2DEE:  MOVLW  03
2DF0:  ADDWFC x7C,W
2DF2:  MOVWF  FEA
2DF4:  MOVFF  FEF,981
2DF8:  MOVFF  03,FEA
2DFC:  MOVFF  01,FE9
2E00:  MOVFF  981,FEF
2E04:  INCF   x7B,F
2E06:  BTFSC  FD8.2
2E08:  INCF   x7C,F
2E0A:  BRA    2DBC
2E0C:  MOVLB  3
.................... 			}
.................... 		}
2E0E:  MOVLB  9
2E10:  INCF   x7A,F
2E12:  BRA    26FC
.................... 
.................... 	}
.................... 
.................... 	/* if we have data to send, then we sent it */
.................... 	if ( 0 == timers.sbd_cycle && sbd.mo_length > 0 ) {
2E14:  MOVLB  3
2E16:  MOVF   x65,F
2E18:  BNZ   2E44
2E1A:  MOVF   x66,F
2E1C:  BNZ   2E44
2E1E:  MOVLB  7
2E20:  MOVF   xDA,F
2E22:  BNZ   2E2E
2E24:  MOVF   xDB,F
2E26:  BTFSS  FD8.2
2E28:  BRA    2E2E
2E2A:  MOVLB  3
2E2C:  BRA    2E44
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() setting sbd.mo_state=1\r\n");
2E2E:  MOVLW  3E
2E30:  MOVWF  FF6
2E32:  MOVLW  08
2E34:  MOVWF  FF7
2E36:  MOVLB  0
2E38:  CALL   0B38
.................... #endif
.................... 		sbd.mo_state=1;
2E3C:  MOVLW  01
2E3E:  MOVLB  6
2E40:  MOVWF  xC9
2E42:  MOVLB  3
.................... 	}
.................... 
.................... 	measurementNumber++;
2E44:  MOVLB  9
2E46:  INCF   x37,F
2E48:  BTFSC  FD8.2
2E4A:  INCF   x38,F
.................... 
.................... 	if ( 0 == timers.sbd_cycle ) {
2E4C:  MOVLB  3
2E4E:  MOVF   x65,F
2E50:  BNZ   2E6C
2E52:  MOVF   x66,F
2E54:  BNZ   2E6C
.................... 		timers.sbd_cycle=(config.sbd_every-1);
2E56:  MOVLW  01
2E58:  MOVLB  5
2E5A:  SUBWF  x89,W
2E5C:  MOVLB  3
2E5E:  MOVWF  x65
2E60:  MOVLW  00
2E62:  MOVLB  5
2E64:  SUBWFB x8A,W
2E66:  MOVLB  3
2E68:  MOVWF  x66
.................... 	} else {
2E6A:  BRA    2E74
.................... 		timers.sbd_cycle--;
2E6C:  MOVF   x65,W
2E6E:  BTFSC  FD8.2
2E70:  DECF   x66,F
2E72:  DECF   x65,F
.................... 	}
2E74:  MOVLB  0
2E76:  GOTO   4300 (RETURN)
.................... }
.................... 
.................... void init() {
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
0AC4:  MOVLW  62
0AC6:  MOVWF  FD3
0AC8:  CLRF   F9B
0ACA:  CLRF   F64
.................... 	setup_adc_ports(NO_ANALOGS);
0ACC:  MOVLB  F
0ACE:  MOVF   x5C,W
0AD0:  ANDLW  80
0AD2:  MOVWF  x5C
0AD4:  MOVLW  00
0AD6:  MOVWF  x5D
0AD8:  BCF    FC1.3
0ADA:  BCF    FC1.4
0ADC:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
0ADE:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
0AE0:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
0AE2:  MOVLW  1F
0AE4:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
0AE6:  MOVLW  F0
0AE8:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
0AEA:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
0AEC:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
0AEE:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
0AF0:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
0AF2:  BCF    F94.5
0AF4:  BCF    F8B.5
.................... 
.................... 	setup_timer_4(T4_DIV_BY_16,77,16); 
0AF6:  MOVLW  78
0AF8:  IORLW  06
0AFA:  MOVWF  F88
0AFC:  MOVLW  4D
0AFE:  MOVWF  FA9
.................... 	enable_interrupts(INT_TIMER4);	
0B00:  BSF    FB6.7
.................... 
.................... 	/* global structures initialized to 0, set something else below if needed */
.................... 	timers.now_poll=1;
0B02:  MOVLW  01
0B04:  MOVLB  3
0B06:  MOVWF  x61
.................... 	timers.sbd_cycle=1; /* next packet will be an SBD packet */
0B08:  CLRF   x66
0B0A:  MOVWF  x65
.................... 	timers.world_timeout=255;
0B0C:  SETF   x62
.................... 	timers.factory_unlocked=0;
0B0E:  CLRF   x63
.................... 	timers.led_on_green=0;
0B10:  CLRF   x64
.................... 
.................... 	query_reset();
0B12:  MOVLB  0
0B14:  RCALL  09C2
.................... 
.................... 	/* receive data from serial ports */
.................... 	enable_interrupts(INT_RDA2);
0B16:  BSF    FA3.5
.................... 
.................... #if MCP3208_ENABLED
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
.................... #endif
.................... 
.................... 
.................... 	if ( config.sbd_config ) {
0B18:  MOVLB  5
0B1A:  MOVF   x88,F
0B1C:  BZ    0B2A
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# init() initializing I2C Uart for SBD @ 19200\r\n");
.................... #endif
.................... 		/* initialize I2C UART for Iridium @ 19200 */
.................... 		uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
0B1E:  MOVLW  06
0B20:  MOVLB  9
0B22:  MOVWF  x7A
0B24:  MOVLB  0
0B26:  BRA    0A28
0B28:  MOVLB  5
.................... 	}
.................... 
.................... 	delay_ms(14);
0B2A:  MOVLW  0E
0B2C:  MOVLB  9
0B2E:  MOVWF  x90
0B30:  MOVLB  0
0B32:  RCALL  0A94
0B34:  GOTO   405C (RETURN)
.................... }
.................... 
.................... void main(void) {
*
3F92:  CLRF   FF8
3F94:  BCF    FD0.7
3F96:  BSF    07.7
3F98:  MOVLW  62
3F9A:  MOVWF  FD3
3F9C:  CLRF   F9B
3F9E:  CLRF   F64
3FA0:  CLRF   20
3FA2:  BSF    FB9.3
3FA4:  MOVLW  22
3FA6:  MOVWF  F7B
3FA8:  MOVLW  00
3FAA:  MOVWF  F7C
3FAC:  MOVLW  A6
3FAE:  MOVWF  FBA
3FB0:  MOVLW  90
3FB2:  MOVWF  FA6
3FB4:  BSF    F94.3
3FB6:  BSF    F94.4
3FB8:  MOVLW  04
3FBA:  MOVWF  FC8
3FBC:  MOVLW  28
3FBE:  MOVWF  FC6
3FC0:  BCF    FC7.7
3FC2:  BCF    FC7.6
3FC4:  BCF    FA7.3
3FC6:  MOVLW  0C
3FC8:  MOVWF  FAF
3FCA:  MOVLW  A2
3FCC:  MOVWF  FAC
3FCE:  MOVLW  90
3FD0:  MOVWF  FAB
3FD2:  MOVLB  5
3FD4:  CLRF   x8E
3FD6:  MOVLW  01
3FD8:  MOVWF  x8D
3FDA:  MOVLW  86
3FDC:  MOVWF  x8C
3FDE:  MOVLW  A0
3FE0:  MOVWF  x8B
3FE2:  BCF    x8F.0
3FE4:  CLRF   x90
3FE6:  MOVLB  9
3FE8:  CLRF   x2A
3FEA:  CLRF   x29
3FEC:  MOVLB  F
3FEE:  MOVF   x5C,W
3FF0:  ANDLW  80
3FF2:  MOVWF  x5C
3FF4:  MOVLW  00
3FF6:  MOVWF  x5D
3FF8:  BCF    FC1.3
3FFA:  BCF    FC1.4
3FFC:  BCF    FC1.5
3FFE:  CLRF   x5E
4000:  CLRF   x5F
4002:  BRA    4018
4004:  DATA 02,00
4006:  DATA 1A,00
4008:  DATA 00,FF
400A:  DATA 46,96
400C:  DATA 00,FF
400E:  DATA C0,00
4010:  DATA 95,C0
4012:  DATA 00,4E
4014:  DATA 49,2B
4016:  DATA 00,00
4018:  MOVLW  00
401A:  MOVWF  FF8
401C:  MOVLW  40
401E:  MOVWF  FF7
4020:  MOVLW  04
4022:  MOVWF  FF6
4024:  TBLRD*+
4026:  MOVF   FF5,W
4028:  MOVWF  00
402A:  XORLW  00
402C:  BZ    4054
402E:  TBLRD*+
4030:  MOVF   FF5,W
4032:  MOVWF  01
4034:  BTFSC  FE8.7
4036:  BRA    4042
4038:  ANDLW  3F
403A:  MOVWF  FEA
403C:  TBLRD*+
403E:  MOVFF  FF5,FE9
4042:  BTFSC  01.6
4044:  TBLRD*+
4046:  BTFSS  01.6
4048:  TBLRD*+
404A:  MOVFF  FF5,FEE
404E:  DCFSNZ 00,F
4050:  BRA    4024
4052:  BRA    4046
4054:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	/* normal device startup */
.................... 	init();
4056:  MOVLB  0
4058:  GOTO   0AC4
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking wait\r\n");
.................... #endif
.................... 	for ( i=0 ; i<STARTUP_BLINKS ; i++ ) {
405C:  MOVLB  9
405E:  CLRF   x79
4060:  MOVF   x79,W
4062:  SUBLW  31
4064:  BNC   408C
.................... 		restart_wdt();
4066:  CLRWDT
.................... 
.................... 		output_high(LED_GREEN);
4068:  BCF    F93.5
406A:  BSF    F8A.5
.................... 		delay_ms(100);
406C:  MOVLW  64
406E:  MOVWF  x90
4070:  MOVLB  0
4072:  CALL   0A94
.................... 		output_low(LED_GREEN);
4076:  BCF    F93.5
4078:  BCF    F8A.5
.................... 		delay_ms(100);
407A:  MOVLW  64
407C:  MOVLB  9
407E:  MOVWF  x90
4080:  MOVLB  0
4082:  CALL   0A94
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# main() blink=%u\r\n",i);
.................... #endif
.................... 	}
.................... 
.................... #if 1
4086:  MOVLB  9
4088:  INCF   x79,F
408A:  BRA    4060
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking done\r\n");
408C:  MOVLW  68
408E:  MOVWF  FF6
4090:  MOVLW  08
4092:  MOVWF  FF7
4094:  MOVLB  0
4096:  CALL   0B38
.................... 
.................... 	fprintf(STREAM_WORLD,"# rdTap %s %sr\n",__DATE__,__TIME__);
409A:  MOVLW  8A
409C:  MOVWF  FF6
409E:  MOVLW  08
40A0:  MOVWF  FF7
40A2:  MOVLW  08
40A4:  MOVLB  9
40A6:  MOVWF  x7C
40A8:  MOVLB  0
40AA:  CALL   0B5A
40AE:  MOVLW  9A
40B0:  MOVWF  FF6
40B2:  MOVLW  08
40B4:  MOVWF  FF7
40B6:  CALL   0B38
40BA:  MOVLW  20
40BC:  BTFSS  FA4.4
40BE:  BRA    40BC
40C0:  MOVWF  F79
40C2:  MOVLW  A4
40C4:  MOVWF  FF6
40C6:  MOVLW  08
40C8:  MOVWF  FF7
40CA:  CALL   0B38
40CE:  MOVLW  72
40D0:  BTFSS  FA4.4
40D2:  BRA    40D0
40D4:  MOVWF  F79
40D6:  MOVLW  0A
40D8:  BTFSS  FA4.4
40DA:  BRA    40D8
40DC:  MOVWF  F79
.................... 
.................... 	fprintf(STREAM_WORLD,"# restart cause: ");
40DE:  MOVLW  AE
40E0:  MOVWF  FF6
40E2:  MOVLW  08
40E4:  MOVWF  FF7
40E6:  CALL   0B38
.................... 	switch ( restart_cause ) {
40EA:  MOVLW  07
40EC:  SUBWF  00,W
40EE:  BZ    4114
40F0:  MOVLW  0B
40F2:  SUBWF  00,W
40F4:  BZ    4122
40F6:  MOVLW  0F
40F8:  SUBWF  00,W
40FA:  BZ    4130
40FC:  MOVLW  0C
40FE:  SUBWF  00,W
4100:  BZ    413E
4102:  MOVLW  0E
4104:  SUBWF  00,W
4106:  BZ    414C
4108:  MOVLW  03
410A:  SUBWF  00,W
410C:  BZ    415A
410E:  MOVF   00,F
4110:  BZ    4168
4112:  BRA    4176
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_WORLD,"WDT TIMEOUT"); break;
4114:  MOVLW  C0
4116:  MOVWF  FF6
4118:  MOVLW  08
411A:  MOVWF  FF7
411C:  CALL   0B38
4120:  BRA    4182
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_WORLD,"MCLR FROM SLEEP"); break;
4122:  MOVLW  CC
4124:  MOVWF  FF6
4126:  MOVLW  08
4128:  MOVWF  FF7
412A:  CALL   0B38
412E:  BRA    4182
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_WORLD,"MCLR FROM RUN"); break;
4130:  MOVLW  DC
4132:  MOVWF  FF6
4134:  MOVLW  08
4136:  MOVWF  FF7
4138:  CALL   0B38
413C:  BRA    4182
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_WORLD,"NORMAL POWER UP"); break;
413E:  MOVLW  EA
4140:  MOVWF  FF6
4142:  MOVLW  08
4144:  MOVWF  FF7
4146:  CALL   0B38
414A:  BRA    4182
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_WORLD,"BROWNOUT RESTART"); break;
414C:  MOVLW  FA
414E:  MOVWF  FF6
4150:  MOVLW  08
4152:  MOVWF  FF7
4154:  CALL   0B38
4158:  BRA    4182
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_WORLD,"WDT FROM SLEEP"); break;
415A:  MOVLW  0C
415C:  MOVWF  FF6
415E:  MOVLW  09
4160:  MOVWF  FF7
4162:  CALL   0B38
4166:  BRA    4182
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_WORLD,"RESET INSTRUCTION"); break;
4168:  MOVLW  1C
416A:  MOVWF  FF6
416C:  MOVLW  09
416E:  MOVWF  FF7
4170:  CALL   0B38
4174:  BRA    4182
.................... 		default:                fprintf(STREAM_WORLD,"UNKNOWN!");
4176:  MOVLW  2E
4178:  MOVWF  FF6
417A:  MOVLW  09
417C:  MOVWF  FF7
417E:  CALL   0B38
.................... 	}
.................... 	fprintf(STREAM_WORLD,"\r\n");
4182:  MOVLW  0D
4184:  BTFSS  FA4.4
4186:  BRA    4184
4188:  MOVWF  F79
418A:  MOVLW  0A
418C:  BTFSS  FA4.4
418E:  BRA    418C
4190:  MOVWF  F79
.................... #endif
.................... 
.................... 	restart_wdt();
4192:  CLRWDT
.................... 	enable_interrupts(GLOBAL);
4194:  MOVLW  C0
4196:  IORWF  FF2,F
.................... 
.................... 	write_default_param_file();
4198:  CALL   0C78
.................... 	write_default_device_file();
419C:  CALL   0D16
.................... 
.................... 	read_param_file();
41A0:  GOTO   0E4E
.................... 	read_device_file();
41A4:  GOTO   0E9C
.................... 
.................... 	restart_wdt();
41A8:  CLRWDT
.................... 	modbus_init();
41AA:  GOTO   0EFC
.................... 
.................... #if DEBUG_ASCII
.................... 	devicesDump();
.................... #endif
.................... 
.................... 	iridium_mr_clear();
41AE:  CALL   0F14
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() starting for ( ; ; ) loop\r\n");
.................... #endif
.................... 
.................... 
.................... 	/* main loop */
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
41B2:  CLRWDT
.................... 
.................... 		if ( config.sbd_config ) {
41B4:  MOVLB  5
41B6:  MOVF   x88,F
41B8:  BTFSC  FD8.2
41BA:  BRA    42EE
.................... 			/* iridium enabled */
.................... 
.................... 			/* act on flag set by SBDRING in UART character processor or RING ALERT line */
.................... 			if ( sbd.ring_flag ) {
41BC:  MOVLB  8
41BE:  MOVF   xE4,F
41C0:  BZ    41DC
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# main() sbd.ring_flag=1\r\n");
41C2:  MOVLW  38
41C4:  MOVWF  FF6
41C6:  MOVLW  09
41C8:  MOVWF  FF7
41CA:  MOVLB  0
41CC:  CALL   0B38
.................... #endif
.................... 				/* our easiest way to get the ringing message is to send another message. This also
.................... 				would help capture the results from a query */
.................... 				timers.sbd_cycle=1; /* next packet will be an SBD packet */
41D0:  MOVLB  3
41D2:  CLRF   x66
41D4:  MOVLW  01
41D6:  MOVWF  x65
.................... 
.................... 				sbd.ring_flag=0;
41D8:  MOVLB  8
41DA:  CLRF   xE4
.................... 			}
.................... 
.................... 			if ( '\0' != sbd.sbdix_response[0] && 0 == sbd.mo_state ) {
41DC:  MOVLB  6
41DE:  MOVF   x96,F
41E0:  BZ    4268
41E2:  MOVF   xC9,F
41E4:  BNZ   4268
.................... 				/* 
.................... 				if there is something in our +SBDIX response we should check if we have a message or need to 
.................... 				get a message. But wait until MO sending is done (state machine idle).
.................... 				*/
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_response='%s'\r\n",sbd.sbdix_response);
41E6:  MOVLW  54
41E8:  MOVWF  FF6
41EA:  MOVLW  09
41EC:  MOVWF  FF7
41EE:  MOVLW  16
41F0:  MOVLB  9
41F2:  MOVWF  x7C
41F4:  MOVLB  0
41F6:  CALL   0B5A
41FA:  MOVLW  06
41FC:  MOVWF  FEA
41FE:  MOVLW  96
4200:  MOVWF  FE9
4202:  GOTO   0F20
4206:  MOVLW  6C
4208:  MOVWF  FF6
420A:  MOVLW  09
420C:  MOVWF  FF7
420E:  MOVLW  03
4210:  MOVLB  9
4212:  MOVWF  x7C
4214:  MOVLB  0
4216:  CALL   0B5A
.................... #endif
.................... 
....................  				iridium_sbdix_parse();
421A:  GOTO   122E
.................... 
.................... 				/* clear the unparsed buffer so we don't get back here */
.................... 				sbd.sbdix_response[0]='\0';
421E:  MOVLB  6
4220:  CLRF   x96
.................... 
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
4222:  MOVF   xC8,F
4224:  BZ    4268
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
4226:  MOVLB  3
4228:  CLRF   x66
422A:  MOVLW  01
422C:  MOVWF  x65
.................... 					
.................... #if DEBUG_SBD
.................... 					fprintf(STREAM_WORLD,"# sbd.sbdix_mt_queued > 0 (is %u)\r\n",sbd.sbdix_mt_queued);
422E:  MOVLW  70
4230:  MOVWF  FF6
4232:  MOVLW  09
4234:  MOVWF  FF7
4236:  MOVLW  1E
4238:  MOVLB  9
423A:  MOVWF  x7C
423C:  MOVLB  0
423E:  CALL   0B5A
4242:  MOVFF  6C8,97B
4246:  MOVLW  1B
4248:  MOVLB  9
424A:  MOVWF  x7C
424C:  MOVLB  0
424E:  CALL   14EC
4252:  MOVLW  90
4254:  MOVWF  FF6
4256:  MOVLW  09
4258:  MOVWF  FF7
425A:  MOVLW  03
425C:  MOVLB  9
425E:  MOVWF  x7C
4260:  MOVLB  0
4262:  CALL   0B5A
4266:  MOVLB  6
.................... #endif
.................... 				}
.................... 			}
.................... 
.................... 			/* read character into MR if we don't have an unprocessed message and there is a character available */
.................... 			if ( 0==sbd.mr_ready && ! sbd.mr_disable && uart_kbhit() ) {
4268:  MOVLB  8
426A:  MOVF   xE6,F
426C:  BNZ   4290
426E:  MOVLB  9
4270:  MOVF   x28,F
4272:  BTFSC  FD8.2
4274:  BRA    427A
4276:  MOVLB  8
4278:  BRA    4290
427A:  MOVLB  0
427C:  CALL   15F2
4280:  MOVF   01,F
4282:  BTFSS  FD8.2
4284:  BRA    428A
4286:  MOVLB  8
4288:  BRA    4290
.................... 				iridium_getc();
428A:  GOTO   164C
428E:  MOVLB  8
.................... 			}
.................... 
.................... 			/* download message from SBD modem */
.................... 			if ( 1 == sbd.sbdix_mt_status ) {
4290:  MOVLB  6
4292:  DECFSZ xC3,W
4294:  BRA    42AA
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_mt_status=1\r\n");
4296:  MOVLW  94
4298:  MOVWF  FF6
429A:  MOVLW  09
429C:  MOVWF  FF7
429E:  MOVLB  0
42A0:  CALL   0B38
.................... #endif
.................... 				iridium_mt_receive();
42A4:  GOTO   1762
42A8:  MOVLB  6
.................... 			}
.................... 
.................... 			/* send messages to SBD modem */
.................... 			if ( 0 != sbd.mo_state && 0 == sbd.mt_state ) {
42AA:  MOVF   xC9,F
42AC:  BZ    42C2
42AE:  MOVLB  7
42B0:  MOVF   xDF,F
42B2:  BTFSC  FD8.2
42B4:  BRA    42BA
42B6:  MOVLB  6
42B8:  BRA    42C2
.................... 				iridium_mo_send();
42BA:  MOVLB  0
42BC:  GOTO   1CC0
42C0:  MOVLB  6
.................... 			}
.................... 
.................... 			if ( 1 == sbd.mt_ready ) {
42C2:  MOVLB  7
42C4:  DECFSZ xDE,W
42C6:  BRA    42EC
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.mt_ready=1\r\n");
42C8:  MOVLW  AE
42CA:  MOVWF  FF6
42CC:  MOVLW  09
42CE:  MOVWF  FF7
42D0:  MOVLB  0
42D2:  CALL   0B38
.................... #endif
.................... 				/* TODO: send to message parser */
.................... 				sbd.mt_ready=0;
42D6:  MOVLB  7
42D8:  CLRF   xDE
.................... 
.................... 				/* do another SBDIX if we have sbd.mt_queued > 0 */
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
42DA:  MOVLB  6
42DC:  MOVF   xC8,F
42DE:  BZ    42EA
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
42E0:  MOVLB  3
42E2:  CLRF   x66
42E4:  MOVLW  01
42E6:  MOVWF  x65
42E8:  MOVLB  6
42EA:  MOVLB  7
42EC:  MOVLB  5
.................... 				}
.................... 			} 
.................... 		}
.................... 
.................... 
.................... 		if ( timers.now_poll ) {
42EE:  MOVLB  3
42F0:  MOVF   x61,F
42F2:  BZ    4302
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll\r\n");
.................... #endif
.................... 			timers.now_poll=0;
42F4:  CLRF   x61
.................... 			timers.led_on_green=200;
42F6:  MOVLW  C8
42F8:  MOVWF  x64
.................... 			deviceQuery();
42FA:  MOVLB  0
42FC:  GOTO   267A
4300:  MOVLB  3
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll done\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* queries are messages send to us that we respond to */
.................... 		if ( query.buff_ready ) {
4302:  MOVLB  5
4304:  MOVF   x6D,F
4306:  BZ    4312
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_process()\r\n");
.................... #endif
.................... 
.................... 			query_process();
4308:  MOVLB  0
430A:  BRA    3E86
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_reset()\r\n");
.................... #endif
.................... 	
.................... 			query_reset();
430C:  CALL   09C2
4310:  MOVLB  5
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() done with query.buff_ready()\r\n");
.................... #endif
.................... 		}
4312:  MOVLB  0
4314:  BRA    41B2
.................... 	}
.................... }
.................... 
4316:  SLEEP 

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 2B67   NOPUT BROWNOUT BORV30 ZPBORM WDT WDT1024
   Word  3: 0900   CANB MSSPMSK7 NOMCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
