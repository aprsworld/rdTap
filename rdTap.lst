CCS PCH C Compiler, Version 5.117, 2295               09-Apr-24 19:50

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\rdTap\rdTap.lst

               ROM used:   17830 bytes (54%)
                           Largest free fragment is 14934
               RAM used:   2426 (67%) at main() level
                           2463 (68%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   4224
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   0304
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0378
006C:  BTFSS  FA3.5
006E:  GOTO   0078
0072:  BTFSC  FA4.5
0074:  GOTO   07F2
0078:  BTFSS  FB6.7
007A:  GOTO   0084
007E:  BTFSC  FB7.7
0080:  GOTO   077C
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #define DEBUG_ASCII     0
.................... #define DEBUG_SBD       1
.................... #define MCP3208_ENABLED 0
.................... #define STARTUP_BLINKS  50
.................... 
.................... 
.................... #include "rdTap.h"
.................... #include <18F25K80.h>
.................... //////////// Standard Header file for the PIC18F25K80 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F25K80
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 01,C0
00F4:  DATA 80,41
00F6:  DATA 00,C1
00F8:  DATA 81,40
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 00,C1
010C:  DATA 81,40
010E:  DATA 01,C0
0110:  DATA 80,41
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 01,C0
011C:  DATA 80,41
011E:  DATA 00,C1
0120:  DATA 81,40
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 00,C1
0134:  DATA 81,40
0136:  DATA 01,C0
0138:  DATA 80,41
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 01,C0
0154:  DATA 80,41
0156:  DATA 00,C1
0158:  DATA 81,40
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 00,C1
0174:  DATA 81,40
0176:  DATA 01,C0
0178:  DATA 80,41
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 01,C0
018C:  DATA 80,41
018E:  DATA 00,C1
0190:  DATA 81,40
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 00,C1
019C:  DATA 81,40
019E:  DATA 01,C0
01A0:  DATA 80,41
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 01,C0
01B4:  DATA 80,41
01B6:  DATA 00,C1
01B8:  DATA 81,40
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  DATA 00,C1
01CC:  DATA 81,40
01CE:  DATA 01,C0
01D0:  DATA 80,41
01D2:  DATA 00,C1
01D4:  DATA 81,40
01D6:  DATA 01,C0
01D8:  DATA 80,41
01DA:  DATA 01,C0
01DC:  DATA 80,41
01DE:  DATA 00,C1
01E0:  DATA 81,40
01E2:  CLRF   FF7
01E4:  ADDLW  F2
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  RETURN 0
01F2:  DATA 00,C0
01F4:  DATA C1,01
01F6:  DATA C3,03
01F8:  DATA 02,C2
01FA:  DATA C6,06
01FC:  DATA 07,C7
01FE:  DATA 05,C5
0200:  DATA C4,04
0202:  DATA CC,0C
0204:  DATA 0D,CD
0206:  DATA 0F,CF
0208:  DATA CE,0E
020A:  DATA 0A,CA
020C:  DATA CB,0B
020E:  DATA C9,09
0210:  DATA 08,C8
0212:  DATA D8,18
0214:  DATA 19,D9
0216:  DATA 1B,DB
0218:  DATA DA,1A
021A:  DATA 1E,DE
021C:  DATA DF,1F
021E:  DATA DD,1D
0220:  DATA 1C,DC
0222:  DATA 14,D4
0224:  DATA D5,15
0226:  DATA D7,17
0228:  DATA 16,D6
022A:  DATA D2,12
022C:  DATA 13,D3
022E:  DATA 11,D1
0230:  DATA D0,10
0232:  DATA F0,30
0234:  DATA 31,F1
0236:  DATA 33,F3
0238:  DATA F2,32
023A:  DATA 36,F6
023C:  DATA F7,37
023E:  DATA F5,35
0240:  DATA 34,F4
0242:  DATA 3C,FC
0244:  DATA FD,3D
0246:  DATA FF,3F
0248:  DATA 3E,FE
024A:  DATA FA,3A
024C:  DATA 3B,FB
024E:  DATA 39,F9
0250:  DATA F8,38
0252:  DATA 28,E8
0254:  DATA E9,29
0256:  DATA EB,2B
0258:  DATA 2A,EA
025A:  DATA EE,2E
025C:  DATA 2F,EF
025E:  DATA 2D,ED
0260:  DATA EC,2C
0262:  DATA E4,24
0264:  DATA 25,E5
0266:  DATA 27,E7
0268:  DATA E6,26
026A:  DATA 22,E2
026C:  DATA E3,23
026E:  DATA E1,21
0270:  DATA 20,E0
0272:  DATA A0,60
0274:  DATA 61,A1
0276:  DATA 63,A3
0278:  DATA A2,62
027A:  DATA 66,A6
027C:  DATA A7,67
027E:  DATA A5,65
0280:  DATA 64,A4
0282:  DATA 6C,AC
0284:  DATA AD,6D
0286:  DATA AF,6F
0288:  DATA 6E,AE
028A:  DATA AA,6A
028C:  DATA 6B,AB
028E:  DATA 69,A9
0290:  DATA A8,68
0292:  DATA 78,B8
0294:  DATA B9,79
0296:  DATA BB,7B
0298:  DATA 7A,BA
029A:  DATA BE,7E
029C:  DATA 7F,BF
029E:  DATA 7D,BD
02A0:  DATA BC,7C
02A2:  DATA B4,74
02A4:  DATA 75,B5
02A6:  DATA 77,B7
02A8:  DATA B6,76
02AA:  DATA 72,B2
02AC:  DATA B3,73
02AE:  DATA B1,71
02B0:  DATA 70,B0
02B2:  DATA 50,90
02B4:  DATA 91,51
02B6:  DATA 93,53
02B8:  DATA 52,92
02BA:  DATA 96,56
02BC:  DATA 57,97
02BE:  DATA 55,95
02C0:  DATA 94,54
02C2:  DATA 9C,5C
02C4:  DATA 5D,9D
02C6:  DATA 5F,9F
02C8:  DATA 9E,5E
02CA:  DATA 5A,9A
02CC:  DATA 9B,5B
02CE:  DATA 99,59
02D0:  DATA 58,98
02D2:  DATA 88,48
02D4:  DATA 49,89
02D6:  DATA 4B,8B
02D8:  DATA 8A,4A
02DA:  DATA 4E,8E
02DC:  DATA 8F,4F
02DE:  DATA 8D,4D
02E0:  DATA 4C,8C
02E2:  DATA 44,84
02E4:  DATA 85,45
02E6:  DATA 87,47
02E8:  DATA 46,86
02EA:  DATA 82,42
02EC:  DATA 43,83
02EE:  DATA 41,81
02F0:  DATA 80,40
*
03E2:  DATA 23,20
03E4:  DATA 69,72
03E6:  DATA 69,64
03E8:  DATA 69,75
03EA:  DATA 6D,5F
03EC:  DATA 73,62
03EE:  DATA 64,69
03F0:  DATA 78,5F
03F2:  DATA 70,61
03F4:  DATA 72,73
03F6:  DATA 65,28
03F8:  DATA 29,3A
03FA:  DATA 0D,0A
03FC:  DATA 00,00
03FE:  DATA 23,20
0400:  DATA 20,20
0402:  DATA 73,62
0404:  DATA 64,69
0406:  DATA 78,5F
0408:  DATA 6D,6F
040A:  DATA 5F,73
040C:  DATA 74,61
040E:  DATA 74,75
0410:  DATA 73,20
0412:  DATA 20,20
0414:  DATA 3D,20
0416:  DATA 25,64
0418:  DATA 0A,00
041A:  DATA 23,20
041C:  DATA 20,20
041E:  DATA 73,62
0420:  DATA 64,69
0422:  DATA 78,5F
0424:  DATA 6D,6F
0426:  DATA 5F,6D
0428:  DATA 73,6E
042A:  DATA 20,20
042C:  DATA 20,20
042E:  DATA 20,20
0430:  DATA 3D,20
0432:  DATA 25,6C
0434:  DATA 75,0A
0436:  DATA 00,00
0438:  DATA 23,20
043A:  DATA 20,20
043C:  DATA 73,62
043E:  DATA 64,69
0440:  DATA 78,5F
0442:  DATA 6D,74
0444:  DATA 5F,73
0446:  DATA 74,61
0448:  DATA 74,75
044A:  DATA 73,20
044C:  DATA 20,20
044E:  DATA 3D,20
0450:  DATA 25,64
0452:  DATA 0A,00
0454:  DATA 23,20
0456:  DATA 20,20
0458:  DATA 73,62
045A:  DATA 64,69
045C:  DATA 78,5F
045E:  DATA 6D,74
0460:  DATA 5F,6D
0462:  DATA 73,6E
0464:  DATA 20,20
0466:  DATA 20,20
0468:  DATA 20,20
046A:  DATA 3D,20
046C:  DATA 25,6C
046E:  DATA 75,0A
0470:  DATA 00,00
0472:  DATA 23,20
0474:  DATA 20,20
0476:  DATA 73,62
0478:  DATA 64,69
047A:  DATA 78,5F
047C:  DATA 6D,74
047E:  DATA 5F,6C
0480:  DATA 65,6E
0482:  DATA 67,74
0484:  DATA 68,20
0486:  DATA 20,20
0488:  DATA 3D,20
048A:  DATA 25,6C
048C:  DATA 75,0A
048E:  DATA 00,00
0490:  DATA 23,20
0492:  DATA 20,20
0494:  DATA 73,62
0496:  DATA 64,69
0498:  DATA 78,5F
049A:  DATA 6D,74
049C:  DATA 5F,71
049E:  DATA 75,65
04A0:  DATA 75,65
04A2:  DATA 64,20
04A4:  DATA 20,20
04A6:  DATA 3D,20
04A8:  DATA 25,64
04AA:  DATA 0A,00
04AC:  DATA 23,20
04AE:  DATA 69,72
04B0:  DATA 69,64
04B2:  DATA 69,75
04B4:  DATA 6D,5F
04B6:  DATA 72,69
04B8:  DATA 6E,67
04BA:  DATA 69,6E
04BC:  DATA 67,28
04BE:  DATA 29,20
04C0:  DATA 73,62
04C2:  DATA 64,2E
04C4:  DATA 72,69
04C6:  DATA 6E,67
04C8:  DATA 5F,73
04CA:  DATA 74,61
04CC:  DATA 74,65
04CE:  DATA 3D,25
04D0:  DATA 75,0D
04D2:  DATA 0A,00
04D4:  DATA 41,54
04D6:  DATA 45,30
04D8:  DATA 0D,00
04DA:  DATA 41,54
04DC:  DATA 26,4B
04DE:  DATA 30,0D
04E0:  DATA 00,00
04E2:  DATA 41,54
04E4:  DATA 2B,53
04E6:  DATA 42,44
04E8:  DATA 4D,54
04EA:  DATA 41,3D
04EC:  DATA 31,0D
04EE:  DATA 00,00
04F0:  DATA 41,54
04F2:  DATA 2B,43
04F4:  DATA 52,49
04F6:  DATA 53,0D
04F8:  DATA 00,00
04FA:  DATA 41,54
04FC:  DATA 45,30
04FE:  DATA 0D,00
0500:  DATA 41,54
0502:  DATA 26,4B
0504:  DATA 30,0D
0506:  DATA 00,00
0508:  DATA 41,54
050A:  DATA 2B,53
050C:  DATA 42,44
050E:  DATA 4D,54
0510:  DATA 41,3D
0512:  DATA 31,0D
0514:  DATA 00,00
0516:  DATA 41,54
0518:  DATA 2B,53
051A:  DATA 42,44
051C:  DATA 57,42
051E:  DATA 3D,25
0520:  DATA 6C,75
0522:  DATA 0D,00
0524:  DATA 23,20
0526:  DATA 69,72
0528:  DATA 69,64
052A:  DATA 69,75
052C:  DATA 6D,5F
052E:  DATA 6D,6F
0530:  DATA 5F,73
0532:  DATA 65,6E
0534:  DATA 64,28
0536:  DATA 29,20
0538:  DATA 73,62
053A:  DATA 64,2E
053C:  DATA 6D,6F
053E:  DATA 5F,73
0540:  DATA 74,61
0542:  DATA 74,65
0544:  DATA 3D,25
0546:  DATA 75,20
0548:  DATA 73,74
054A:  DATA 61,72
054C:  DATA 74,0D
054E:  DATA 0A,00
0550:  DATA 41,54
0552:  DATA 2B,53
0554:  DATA 42,44
0556:  DATA 49,58
0558:  DATA 0D,00
055A:  DATA 23,20
055C:  DATA 69,72
055E:  DATA 69,64
0560:  DATA 69,75
0562:  DATA 6D,5F
0564:  DATA 6D,6F
0566:  DATA 5F,73
0568:  DATA 65,6E
056A:  DATA 64,28
056C:  DATA 29,20
056E:  DATA 73,62
0570:  DATA 64,2E
0572:  DATA 6D,6F
0574:  DATA 5F,73
0576:  DATA 74,61
0578:  DATA 74,65
057A:  DATA 3D,25
057C:  DATA 75,20
057E:  DATA 73,74
0580:  DATA 61,72
0582:  DATA 74,0D
0584:  DATA 0A,00
0586:  DATA 23,20
0588:  DATA 69,72
058A:  DATA 69,64
058C:  DATA 69,75
058E:  DATA 6D,5F
0590:  DATA 6D,6F
0592:  DATA 5F,73
0594:  DATA 65,6E
0596:  DATA 64,28
0598:  DATA 29,20
059A:  DATA 73,62
059C:  DATA 64,2E
059E:  DATA 6D,6F
05A0:  DATA 5F,73
05A2:  DATA 74,61
05A4:  DATA 74,65
05A6:  DATA 3D,25
05A8:  DATA 75,20
05AA:  DATA 73,62
05AC:  DATA 64,2E
05AE:  DATA 6D,6F
05B0:  DATA 5F,74
05B2:  DATA 72,79
05B4:  DATA 3D,25
05B6:  DATA 75,20
05B8:  DATA 73,74
05BA:  DATA 61,72
05BC:  DATA 74,0D
05BE:  DATA 0A,00
05C0:  DATA 23,20
05C2:  DATA 69,72
05C4:  DATA 69,64
05C6:  DATA 69,75
05C8:  DATA 6D,5F
05CA:  DATA 6D,6F
05CC:  DATA 5F,73
05CE:  DATA 65,6E
05D0:  DATA 64,28
05D2:  DATA 29,20
05D4:  DATA 73,62
05D6:  DATA 64,2E
05D8:  DATA 6D,6F
05DA:  DATA 5F,73
05DC:  DATA 74,61
05DE:  DATA 74,65
05E0:  DATA 3D,25
05E2:  DATA 75,20
05E4:  DATA 73,62
05E6:  DATA 64,2E
05E8:  DATA 6D,6F
05EA:  DATA 5F,74
05EC:  DATA 72,79
05EE:  DATA 3D,25
05F0:  DATA 75,20
05F2:  DATA 66,69
05F4:  DATA 6E,69
05F6:  DATA 73,68
05F8:  DATA 0D,0A
05FA:  DATA 00,00
05FC:  DATA 41,54
05FE:  DATA 2B,53
0600:  DATA 42,44
0602:  DATA 44,30
0604:  DATA 0D,00
0606:  DATA 23,20
0608:  DATA 69,72
060A:  DATA 69,64
060C:  DATA 69,75
060E:  DATA 6D,5F
0610:  DATA 6D,6F
0612:  DATA 5F,73
0614:  DATA 65,6E
0616:  DATA 64,28
0618:  DATA 29,20
061A:  DATA 73,62
061C:  DATA 64,2E
061E:  DATA 6D,6F
0620:  DATA 5F,73
0622:  DATA 74,61
0624:  DATA 74,65
0626:  DATA 3D,25
0628:  DATA 75,20
062A:  DATA 73,74
062C:  DATA 61,72
062E:  DATA 74,0D
0630:  DATA 0A,00
0632:  DATA 23,20
0634:  DATA 69,72
0636:  DATA 69,64
0638:  DATA 69,75
063A:  DATA 6D,5F
063C:  DATA 6D,6F
063E:  DATA 5F,73
0640:  DATA 65,6E
0642:  DATA 64,28
0644:  DATA 29,20
0646:  DATA 73,62
0648:  DATA 64,2E
064A:  DATA 6D,6F
064C:  DATA 5F,73
064E:  DATA 74,61
0650:  DATA 74,65
0652:  DATA 3D,25
0654:  DATA 75,20
0656:  DATA 73,74
0658:  DATA 61,72
065A:  DATA 74,0D
065C:  DATA 0A,00
065E:  DATA 23,20
0660:  DATA 69,72
0662:  DATA 69,64
0664:  DATA 69,75
0666:  DATA 6D,5F
0668:  DATA 6D,6F
066A:  DATA 5F,73
066C:  DATA 65,6E
066E:  DATA 64,28
0670:  DATA 29,20
0672:  DATA 73,62
0674:  DATA 64,2E
0676:  DATA 6D,6F
0678:  DATA 5F,73
067A:  DATA 74,61
067C:  DATA 74,65
067E:  DATA 3D,25
0680:  DATA 75,20
0682:  DATA 73,74
0684:  DATA 61,72
0686:  DATA 74,0D
0688:  DATA 0A,00
068A:  DATA 23,20
068C:  DATA 69,72
068E:  DATA 69,64
0690:  DATA 69,75
0692:  DATA 6D,5F
0694:  DATA 6D,74
0696:  DATA 5F,72
0698:  DATA 65,63
069A:  DATA 65,69
069C:  DATA 76,65
069E:  DATA 28,29
06A0:  DATA 20,73
06A2:  DATA 62,64
06A4:  DATA 2E,6D
06A6:  DATA 74,5F
06A8:  DATA 73,74
06AA:  DATA 61,74
06AC:  DATA 65,3D
06AE:  DATA 25,75
06B0:  DATA 0D,0A
06B2:  DATA 00,00
06B4:  DATA 41,54
06B6:  DATA 45,30
06B8:  DATA 0D,00
06BA:  DATA 41,54
06BC:  DATA 26,4B
06BE:  DATA 30,0D
06C0:  DATA 00,00
06C2:  DATA 41,54
06C4:  DATA 2B,53
06C6:  DATA 42,44
06C8:  DATA 4D,54
06CA:  DATA 41,3D
06CC:  DATA 31,0D
06CE:  DATA 00,00
06D0:  DATA 41,54
06D2:  DATA 2B,53
06D4:  DATA 42,44
06D6:  DATA 52,42
06D8:  DATA 0D,00
06DA:  DATA 23,20
06DC:  DATA 69,72
06DE:  DATA 69,64
06E0:  DATA 69,75
06E2:  DATA 6D,5F
06E4:  DATA 6D,74
06E6:  DATA 5F,72
06E8:  DATA 65,63
06EA:  DATA 65,69
06EC:  DATA 76,65
06EE:  DATA 28,29
06F0:  DATA 20,63
06F2:  DATA 68,65
06F4:  DATA 63,6B
06F6:  DATA 73,75
06F8:  DATA 6D,20
06FA:  DATA 6C,3D
06FC:  DATA 25,6C
06FE:  DATA 75,20
0700:  DATA 72,3D
0702:  DATA 25,6C
0704:  DATA 75,0D
0706:  DATA 0A,00
0708:  DATA 23,20
070A:  DATA 69,72
070C:  DATA 69,64
070E:  DATA 69,75
0710:  DATA 6D,5F
0712:  DATA 6D,74
0714:  DATA 5F,72
0716:  DATA 65,63
0718:  DATA 65,69
071A:  DATA 76,65
071C:  DATA 28,29
071E:  DATA 20,6D
0720:  DATA 74,5F
0722:  DATA 72,65
0724:  DATA 61,64
0726:  DATA 79,3D
0728:  DATA 31,2C
072A:  DATA 20,68
072C:  DATA 65,72
072E:  DATA 65,20
0730:  DATA 69,73
0732:  DATA 20,6F
0734:  DATA 75,72
0736:  DATA 20,6D
0738:  DATA 65,73
073A:  DATA 73,61
073C:  DATA 67,65
073E:  DATA 3A,0D
0740:  DATA 0A,00
0742:  DATA 23,20
0744:  DATA 6D,74
0746:  DATA 5F,62
0748:  DATA 75,66
074A:  DATA 66,5B
074C:  DATA 25,6C
074E:  DATA 75,5D
0750:  DATA 3D,25
0752:  DATA 63,0D
0754:  DATA 0A,00
0756:  DATA 23,20
0758:  DATA 69,72
075A:  DATA 69,64
075C:  DATA 69,75
075E:  DATA 6D,5F
0760:  DATA 6D,74
0762:  DATA 5F,72
0764:  DATA 65,63
0766:  DATA 65,69
0768:  DATA 76,65
076A:  DATA 28,29
076C:  DATA 20,67
076E:  DATA 6F,74
0770:  DATA 20,66
0772:  DATA 69,6E
0774:  DATA 61,6C
0776:  DATA 20,4F
0778:  DATA 4B,0D
077A:  DATA 0A,00
*
08C8:  DATA 23,20
08CA:  DATA 64,65
08CC:  DATA 76,69
08CE:  DATA 63,65
08D0:  DATA 51,75
08D2:  DATA 65,72
08D4:  DATA 79,28
08D6:  DATA 29,20
08D8:  DATA 6E,65
08DA:  DATA 78,74
08DC:  DATA 20,63
08DE:  DATA 79,63
08E0:  DATA 6C,65
08E2:  DATA 20,77
08E4:  DATA 69,6C
08E6:  DATA 6C,20
08E8:  DATA 62,65
08EA:  DATA 20,53
08EC:  DATA 42,44
08EE:  DATA 20,74
08F0:  DATA 72,61
08F2:  DATA 6E,73
08F4:  DATA 6D,69
08F6:  DATA 74,20
08F8:  DATA 63,79
08FA:  DATA 63,6C
08FC:  DATA 65,2E
08FE:  DATA 0D,0A
0900:  DATA 00,00
0902:  DATA 23,20
0904:  DATA 64,65
0906:  DATA 76,69
0908:  DATA 63,65
090A:  DATA 51,75
090C:  DATA 65,72
090E:  DATA 79,28
0910:  DATA 29,20
0912:  DATA 74,68
0914:  DATA 69,73
0916:  DATA 20,63
0918:  DATA 79,63
091A:  DATA 6C,65
091C:  DATA 20,69
091E:  DATA 73,20
0920:  DATA 61,6E
0922:  DATA 20,53
0924:  DATA 42,44
0926:  DATA 20,74
0928:  DATA 72,61
092A:  DATA 6E,73
092C:  DATA 6D,69
092E:  DATA 74,20
0930:  DATA 63,79
0932:  DATA 63,6C
0934:  DATA 65,2E
0936:  DATA 0D,0A
0938:  DATA 00,00
093A:  DATA 23,20
093C:  DATA 64,65
093E:  DATA 76,69
0940:  DATA 63,65
0942:  DATA 51,75
0944:  DATA 65,72
0946:  DATA 79,28
0948:  DATA 29,20
094A:  DATA 61,64
094C:  DATA 64,69
094E:  DATA 6E,67
0950:  DATA 20,74
0952:  DATA 6F,20
0954:  DATA 73,62
0956:  DATA 64,2E
0958:  DATA 6D,6F
095A:  DATA 5F,62
095C:  DATA 75,66
095E:  DATA 66,20
0960:  DATA 73,69
0962:  DATA 6E,63
0964:  DATA 65,20
0966:  DATA 71,62
0968:  DATA 75,66
096A:  DATA 66,2E
096C:  DATA 72,45
096E:  DATA 78,63
0970:  DATA 65,70
0972:  DATA 74,69
0974:  DATA 6F,6E
0976:  DATA 3D,30
0978:  DATA 0D,0A
097A:  DATA 00,00
097C:  DATA 23,20
097E:  DATA 64,65
0980:  DATA 76,69
0982:  DATA 63,65
0984:  DATA 51,75
0986:  DATA 65,72
0988:  DATA 79,28
098A:  DATA 29,20
098C:  DATA 73,65
098E:  DATA 74,74
0990:  DATA 69,6E
0992:  DATA 67,20
0994:  DATA 73,62
0996:  DATA 64,2E
0998:  DATA 6D,6F
099A:  DATA 5F,73
099C:  DATA 74,61
099E:  DATA 74,65
09A0:  DATA 3D,31
09A2:  DATA 0D,0A
09A4:  DATA 00,00
09A6:  DATA 23,20
09A8:  DATA 6D,61
09AA:  DATA 69,6E
09AC:  DATA 28,29
09AE:  DATA 20,73
09B0:  DATA 74,61
09B2:  DATA 72,74
09B4:  DATA 75,70
09B6:  DATA 20,62
09B8:  DATA 6C,69
09BA:  DATA 6E,6B
09BC:  DATA 69,6E
09BE:  DATA 67,20
09C0:  DATA 64,6F
09C2:  DATA 6E,65
09C4:  DATA 0D,0A
09C6:  DATA 00,00
09C8:  DATA 23,20
09CA:  DATA 72,64
09CC:  DATA 54,61
09CE:  DATA 70,20
09D0:  DATA 25,73
09D2:  DATA 20,25
09D4:  DATA 73,72
09D6:  DATA 0A,00
09D8:  DATA 30,39
09DA:  DATA 2D,41
09DC:  DATA 70,72
09DE:  DATA 2D,32
09E0:  DATA 34,00
09E2:  DATA 31,39
09E4:  DATA 3A,35
09E6:  DATA 30,3A
09E8:  DATA 32,39
09EA:  DATA 00,00
09EC:  DATA 23,20
09EE:  DATA 72,65
09F0:  DATA 73,74
09F2:  DATA 61,72
09F4:  DATA 74,20
09F6:  DATA 63,61
09F8:  DATA 75,73
09FA:  DATA 65,3A
09FC:  DATA 20,00
09FE:  DATA 57,44
0A00:  DATA 54,20
0A02:  DATA 54,49
0A04:  DATA 4D,45
0A06:  DATA 4F,55
0A08:  DATA 54,00
0A0A:  DATA 4D,43
0A0C:  DATA 4C,52
0A0E:  DATA 20,46
0A10:  DATA 52,4F
0A12:  DATA 4D,20
0A14:  DATA 53,4C
0A16:  DATA 45,45
0A18:  DATA 50,00
0A1A:  DATA 4D,43
0A1C:  DATA 4C,52
0A1E:  DATA 20,46
0A20:  DATA 52,4F
0A22:  DATA 4D,20
0A24:  DATA 52,55
0A26:  DATA 4E,00
0A28:  DATA 4E,4F
0A2A:  DATA 52,4D
0A2C:  DATA 41,4C
0A2E:  DATA 20,50
0A30:  DATA 4F,57
0A32:  DATA 45,52
0A34:  DATA 20,55
0A36:  DATA 50,00
0A38:  DATA 42,52
0A3A:  DATA 4F,57
0A3C:  DATA 4E,4F
0A3E:  DATA 55,54
0A40:  DATA 20,52
0A42:  DATA 45,53
0A44:  DATA 54,41
0A46:  DATA 52,54
0A48:  DATA 00,00
0A4A:  DATA 57,44
0A4C:  DATA 54,20
0A4E:  DATA 46,52
0A50:  DATA 4F,4D
0A52:  DATA 20,53
0A54:  DATA 4C,45
0A56:  DATA 45,50
0A58:  DATA 00,00
0A5A:  DATA 52,45
0A5C:  DATA 53,45
0A5E:  DATA 54,20
0A60:  DATA 49,4E
0A62:  DATA 53,54
0A64:  DATA 52,55
0A66:  DATA 43,54
0A68:  DATA 49,4F
0A6A:  DATA 4E,00
0A6C:  DATA 55,4E
0A6E:  DATA 4B,4E
0A70:  DATA 4F,57
0A72:  DATA 4E,21
0A74:  DATA 00,00
0A76:  DATA 23,20
0A78:  DATA 6D,61
0A7A:  DATA 69,6E
0A7C:  DATA 28,29
0A7E:  DATA 20,73
0A80:  DATA 62,64
0A82:  DATA 2E,72
0A84:  DATA 69,6E
0A86:  DATA 67,5F
0A88:  DATA 66,6C
0A8A:  DATA 61,67
0A8C:  DATA 3D,31
0A8E:  DATA 0D,0A
0A90:  DATA 00,00
0A92:  DATA 23,20
0A94:  DATA 73,62
0A96:  DATA 64,2E
0A98:  DATA 73,62
0A9A:  DATA 64,69
0A9C:  DATA 78,5F
0A9E:  DATA 72,65
0AA0:  DATA 73,70
0AA2:  DATA 6F,6E
0AA4:  DATA 73,65
0AA6:  DATA 3D,27
0AA8:  DATA 25,73
0AAA:  DATA 27,0D
0AAC:  DATA 0A,00
0AAE:  DATA 23,20
0AB0:  DATA 73,62
0AB2:  DATA 64,2E
0AB4:  DATA 73,62
0AB6:  DATA 64,69
0AB8:  DATA 78,5F
0ABA:  DATA 6D,74
0ABC:  DATA 5F,71
0ABE:  DATA 75,65
0AC0:  DATA 75,65
0AC2:  DATA 64,20
0AC4:  DATA 3E,20
0AC6:  DATA 30,20
0AC8:  DATA 28,69
0ACA:  DATA 73,20
0ACC:  DATA 25,75
0ACE:  DATA 29,0D
0AD0:  DATA 0A,00
0AD2:  DATA 23,20
0AD4:  DATA 73,62
0AD6:  DATA 64,2E
0AD8:  DATA 73,62
0ADA:  DATA 64,69
0ADC:  DATA 78,5F
0ADE:  DATA 6D,74
0AE0:  DATA 5F,73
0AE2:  DATA 74,61
0AE4:  DATA 74,75
0AE6:  DATA 73,3D
0AE8:  DATA 31,0D
0AEA:  DATA 0A,00
0AEC:  DATA 23,20
0AEE:  DATA 73,62
0AF0:  DATA 64,2E
0AF2:  DATA 6D,74
0AF4:  DATA 5F,72
0AF6:  DATA 65,61
0AF8:  DATA 64,79
0AFA:  DATA 3D,31
0AFC:  DATA 0D,0A
0AFE:  DATA 00,00
*
0C76:  TBLRD*+
0C78:  MOVF   FF5,F
0C7A:  BZ    0C96
0C7C:  MOVFF  FF6,97D
0C80:  MOVFF  FF7,97E
0C84:  MOVF   FF5,W
0C86:  BTFSS  FA4.4
0C88:  BRA    0C86
0C8A:  MOVWF  F79
0C8C:  MOVFF  97D,FF6
0C90:  MOVFF  97E,FF7
0C94:  BRA    0C76
0C96:  RETURN 0
0C98:  TBLRD*+
0C9A:  MOVFF  FF6,97F
0C9E:  MOVFF  FF7,980
0CA2:  MOVF   FF5,W
0CA4:  BTFSS  FA4.4
0CA6:  BRA    0CA4
0CA8:  MOVWF  F79
0CAA:  MOVFF  97F,FF6
0CAE:  MOVFF  980,FF7
0CB2:  MOVLB  9
0CB4:  DECFSZ x7E,F
0CB6:  BRA    0CBA
0CB8:  BRA    0CBE
0CBA:  MOVLB  0
0CBC:  BRA    0C98
0CBE:  MOVLB  0
0CC0:  RETURN 0
*
0DE0:  MOVLB  9
0DE2:  MOVF   x94,W
0DE4:  MULWF  x96
0DE6:  MOVFF  FF3,01
0DEA:  MOVFF  FF4,00
0DEE:  MULWF  x97
0DF0:  MOVF   FF3,W
0DF2:  ADDWF  00,F
0DF4:  MOVF   x95,W
0DF6:  MULWF  x96
0DF8:  MOVF   FF3,W
0DFA:  ADDWFC 00,W
0DFC:  MOVWF  02
0DFE:  MOVLB  0
0E00:  RETURN 0
*
105E:  MOVF   FEF,F
1060:  BZ    1082
1062:  MOVFF  FEA,97B
1066:  MOVFF  FE9,97A
106A:  MOVF   FEF,W
106C:  BTFSS  FA4.4
106E:  BRA    106C
1070:  MOVWF  F79
1072:  MOVFF  97B,FEA
1076:  MOVFF  97A,FE9
107A:  INCF   FE9,F
107C:  BTFSC  FD8.2
107E:  INCF   FEA,F
1080:  BRA    105E
1082:  GOTO   4498 (RETURN)
*
11CE:  MOVLB  9
11D0:  MOVF   x83,W
11D2:  CLRF   01
11D4:  SUBWF  x82,W
11D6:  BC    11DE
11D8:  MOVFF  982,00
11DC:  BRA    11F6
11DE:  CLRF   00
11E0:  MOVLW  08
11E2:  MOVWF  x84
11E4:  RLCF   x82,F
11E6:  RLCF   00,F
11E8:  MOVF   x83,W
11EA:  SUBWF  00,W
11EC:  BTFSC  FD8.0
11EE:  MOVWF  00
11F0:  RLCF   01,F
11F2:  DECFSZ x84,F
11F4:  BRA    11E4
11F6:  MOVLB  0
11F8:  RETURN 0
11FA:  MOVLW  20
11FC:  MOVLB  9
11FE:  BTFSS  x7D.4
1200:  MOVLW  30
1202:  MOVWF  x7E
1204:  MOVFF  97C,00
1208:  BTFSS  00.7
120A:  BRA    121C
120C:  COMF   00,F
120E:  INCF   00,F
1210:  MOVFF  00,97C
1214:  MOVLW  2D
1216:  MOVWF  x7E
1218:  BSF    x7D.7
121A:  BSF    x7D.0
121C:  MOVF   01,W
121E:  MOVFF  97C,982
1222:  MOVLW  64
1224:  MOVWF  x83
1226:  MOVLB  0
1228:  RCALL  11CE
122A:  MOVFF  00,97C
122E:  MOVLW  30
1230:  ADDWF  01,W
1232:  MOVLB  9
1234:  MOVWF  x7F
1236:  MOVFF  97C,982
123A:  MOVLW  0A
123C:  MOVWF  x83
123E:  MOVLB  0
1240:  RCALL  11CE
1242:  MOVLW  30
1244:  ADDWF  00,W
1246:  MOVLB  9
1248:  MOVWF  x81
124A:  MOVLW  30
124C:  ADDWF  01,W
124E:  MOVWF  x80
1250:  MOVFF  97E,00
1254:  MOVLW  30
1256:  SUBWF  x7F,W
1258:  BZ    1262
125A:  BSF    x7D.1
125C:  BTFSC  x7D.7
125E:  BSF    x7D.2
1260:  BRA    1286
1262:  MOVFF  97E,97F
1266:  MOVLW  20
1268:  MOVWF  x7E
126A:  MOVLW  30
126C:  SUBWF  x80,W
126E:  BZ    1278
1270:  BSF    x7D.0
1272:  BTFSC  x7D.7
1274:  BSF    x7D.1
1276:  BRA    1286
1278:  BTFSS  FD8.2
127A:  BSF    x7D.0
127C:  BNZ   1286
127E:  MOVFF  97F,980
1282:  MOVLW  20
1284:  MOVWF  x7F
1286:  BTFSC  x7D.2
1288:  BRA    1294
128A:  BTFSC  x7D.1
128C:  BRA    129C
128E:  BTFSC  x7D.0
1290:  BRA    12A4
1292:  BRA    12AC
1294:  MOVF   x7E,W
1296:  BTFSS  FA4.4
1298:  BRA    1296
129A:  MOVWF  F79
129C:  MOVF   x7F,W
129E:  BTFSS  FA4.4
12A0:  BRA    129E
12A2:  MOVWF  F79
12A4:  MOVF   x80,W
12A6:  BTFSS  FA4.4
12A8:  BRA    12A6
12AA:  MOVWF  F79
12AC:  MOVF   x81,W
12AE:  BTFSS  FA4.4
12B0:  BRA    12AE
12B2:  MOVWF  F79
12B4:  MOVLB  0
12B6:  RETURN 0
12B8:  MOVFF  FEA,984
12BC:  MOVFF  FE9,983
12C0:  MOVLB  9
12C2:  SWAPF  x7D,W
12C4:  IORLW  F0
12C6:  MOVWF  x7F
12C8:  ADDWF  x7F,F
12CA:  ADDLW  E2
12CC:  MOVWF  x80
12CE:  ADDLW  32
12D0:  MOVWF  x82
12D2:  MOVF   x7D,W
12D4:  ANDLW  0F
12D6:  ADDWF  x80,F
12D8:  ADDWF  x80,F
12DA:  ADDWF  x82,F
12DC:  ADDLW  E9
12DE:  MOVWF  x81
12E0:  ADDWF  x81,F
12E2:  ADDWF  x81,F
12E4:  SWAPF  x7C,W
12E6:  ANDLW  0F
12E8:  ADDWF  x81,F
12EA:  ADDWF  x82,F
12EC:  RLCF   x81,F
12EE:  RLCF   x82,F
12F0:  COMF   x82,F
12F2:  RLCF   x82,F
12F4:  MOVF   x7C,W
12F6:  ANDLW  0F
12F8:  ADDWF  x82,F
12FA:  RLCF   x7F,F
12FC:  MOVLW  07
12FE:  MOVWF  x7E
1300:  MOVLW  0A
1302:  DECF   x81,F
1304:  ADDWF  x82,F
1306:  BNC   1302
1308:  DECF   x80,F
130A:  ADDWF  x81,F
130C:  BNC   1308
130E:  DECF   x7F,F
1310:  ADDWF  x80,F
1312:  BNC   130E
1314:  DECF   x7E,F
1316:  ADDWF  x7F,F
1318:  BNC   1314
131A:  MOVLW  09
131C:  MOVWF  FEA
131E:  MOVLW  7E
1320:  MOVWF  FE9
1322:  MOVLW  07
1324:  ANDWF  x83,W
1326:  BCF    x83.6
1328:  ADDWF  FE9,F
132A:  MOVLW  00
132C:  ADDWFC FEA,F
132E:  MOVF   FE9,W
1330:  SUBLW  82
1332:  BNZ   133C
1334:  MOVF   FEA,W
1336:  SUBLW  09
1338:  BNZ   133C
133A:  BSF    x83.6
133C:  MOVF   FEF,W
133E:  MOVWF  00
1340:  BNZ   1352
1342:  BTFSC  x83.6
1344:  BRA    1352
1346:  BTFSC  x83.4
1348:  BRA    1362
134A:  BTFSC  x83.3
134C:  BRA    1352
134E:  MOVLW  20
1350:  BRA    1358
1352:  BSF    x83.3
1354:  BCF    x83.4
1356:  MOVLW  30
1358:  ADDWF  00,F
135A:  MOVF   00,W
135C:  BTFSS  FA4.4
135E:  BRA    135C
1360:  MOVWF  F79
1362:  MOVF   FEE,W
1364:  BTFSS  x83.6
1366:  BRA    132E
1368:  MOVLB  0
136A:  RETURN 0
*
162A:  MOVF   01,W
162C:  MOVFF  97E,982
1630:  MOVLW  64
1632:  MOVLB  9
1634:  MOVWF  x83
1636:  MOVLB  0
1638:  RCALL  11CE
163A:  MOVFF  00,97E
163E:  MOVF   01,W
1640:  MOVLW  30
1642:  BNZ   1654
1644:  MOVLB  9
1646:  BTFSS  x7F.1
1648:  BRA    1666
164A:  BTFSC  x7F.3
164C:  BRA    1666
164E:  BTFSC  x7F.4
1650:  MOVLW  20
1652:  BRA    165C
1654:  MOVLB  9
1656:  BCF    x7F.3
1658:  BCF    x7F.4
165A:  BSF    x7F.0
165C:  ADDWF  01,F
165E:  MOVF   01,W
1660:  BTFSS  FA4.4
1662:  BRA    1660
1664:  MOVWF  F79
1666:  MOVFF  97E,982
166A:  MOVLW  0A
166C:  MOVWF  x83
166E:  MOVLB  0
1670:  RCALL  11CE
1672:  MOVFF  00,97E
1676:  MOVF   01,W
1678:  MOVLW  30
167A:  BNZ   168C
167C:  MOVLB  9
167E:  BTFSC  x7F.3
1680:  BRA    1698
1682:  BTFSS  x7F.0
1684:  BRA    1698
1686:  BTFSC  x7F.4
1688:  MOVLW  20
168A:  MOVLB  0
168C:  ADDWF  01,F
168E:  MOVF   01,W
1690:  BTFSS  FA4.4
1692:  BRA    1690
1694:  MOVWF  F79
1696:  MOVLB  9
1698:  MOVLW  30
169A:  ADDWF  x7E,F
169C:  MOVF   x7E,W
169E:  BTFSS  FA4.4
16A0:  BRA    169E
16A2:  MOVWF  F79
16A4:  MOVLB  0
16A6:  RETURN 0
*
1806:  TBLRD*+
1808:  MOVF   FF5,F
180A:  BZ    1824
180C:  MOVFF  FF6,97E
1810:  MOVFF  FF7,97F
1814:  MOVFF  FF5,987
1818:  RCALL  17F6
181A:  MOVFF  97E,FF6
181E:  MOVFF  97F,FF7
1822:  BRA    1806
1824:  RETURN 0
*
1BD4:  TBLRD*+
1BD6:  MOVFF  FF6,97F
1BDA:  MOVFF  FF7,980
1BDE:  MOVFF  FF5,987
1BE2:  RCALL  17F6
1BE4:  MOVFF  97F,FF6
1BE8:  MOVFF  980,FF7
1BEC:  MOVLB  9
1BEE:  DECFSZ x7E,F
1BF0:  BRA    1BF4
1BF2:  BRA    1BF8
1BF4:  MOVLB  0
1BF6:  BRA    1BD4
1BF8:  MOVLB  0
1BFA:  GOTO   1E7A (RETURN)
1BFE:  MOVFF  FEA,986
1C02:  MOVFF  FE9,985
1C06:  MOVLB  9
1C08:  SWAPF  x7F,W
1C0A:  IORLW  F0
1C0C:  MOVWF  x81
1C0E:  ADDWF  x81,F
1C10:  ADDLW  E2
1C12:  MOVWF  x82
1C14:  ADDLW  32
1C16:  MOVWF  x84
1C18:  MOVF   x7F,W
1C1A:  ANDLW  0F
1C1C:  ADDWF  x82,F
1C1E:  ADDWF  x82,F
1C20:  ADDWF  x84,F
1C22:  ADDLW  E9
1C24:  MOVWF  x83
1C26:  ADDWF  x83,F
1C28:  ADDWF  x83,F
1C2A:  SWAPF  x7E,W
1C2C:  ANDLW  0F
1C2E:  ADDWF  x83,F
1C30:  ADDWF  x84,F
1C32:  RLCF   x83,F
1C34:  RLCF   x84,F
1C36:  COMF   x84,F
1C38:  RLCF   x84,F
1C3A:  MOVF   x7E,W
1C3C:  ANDLW  0F
1C3E:  ADDWF  x84,F
1C40:  RLCF   x81,F
1C42:  MOVLW  07
1C44:  MOVWF  x80
1C46:  MOVLW  0A
1C48:  DECF   x83,F
1C4A:  ADDWF  x84,F
1C4C:  BNC   1C48
1C4E:  DECF   x82,F
1C50:  ADDWF  x83,F
1C52:  BNC   1C4E
1C54:  DECF   x81,F
1C56:  ADDWF  x82,F
1C58:  BNC   1C54
1C5A:  DECF   x80,F
1C5C:  ADDWF  x81,F
1C5E:  BNC   1C5A
1C60:  MOVLW  09
1C62:  MOVWF  FEA
1C64:  MOVLW  80
1C66:  MOVWF  FE9
1C68:  MOVLW  07
1C6A:  ANDWF  x85,W
1C6C:  BCF    x85.6
1C6E:  ADDWF  FE9,F
1C70:  MOVLW  00
1C72:  ADDWFC FEA,F
1C74:  MOVF   FE9,W
1C76:  SUBLW  84
1C78:  BNZ   1C82
1C7A:  MOVF   FEA,W
1C7C:  SUBLW  09
1C7E:  BNZ   1C82
1C80:  BSF    x85.6
1C82:  MOVF   FEF,W
1C84:  MOVWF  00
1C86:  BNZ   1C98
1C88:  BTFSC  x85.6
1C8A:  BRA    1C98
1C8C:  BTFSC  x85.4
1C8E:  BRA    1CBA
1C90:  BTFSC  x85.3
1C92:  BRA    1C98
1C94:  MOVLW  20
1C96:  BRA    1C9E
1C98:  BSF    x85.3
1C9A:  BCF    x85.4
1C9C:  MOVLW  30
1C9E:  ADDWF  00,F
1CA0:  MOVFF  FEA,97F
1CA4:  MOVFF  FE9,97E
1CA8:  MOVFF  00,987
1CAC:  MOVLB  0
1CAE:  RCALL  17F6
1CB0:  MOVFF  97F,FEA
1CB4:  MOVFF  97E,FE9
1CB8:  MOVLB  9
1CBA:  MOVF   FEE,W
1CBC:  BTFSS  x85.6
1CBE:  BRA    1C74
1CC0:  MOVLB  0
1CC2:  GOTO   1E88 (RETURN)
*
34F0:  ADDWF  FE8,W
34F2:  CLRF   FF7
34F4:  RLCF   FF7,F
34F6:  ADDLW  0B
34F8:  MOVWF  FF6
34FA:  MOVLW  35
34FC:  ADDWFC FF7,F
34FE:  TBLRD*-
3500:  MOVF   FF5,W
3502:  MOVWF  FFA
3504:  TBLRD*
3506:  MOVF   FF5,W
3508:  MOVWF  FF9
350A:  DATA 56,31
350C:  DATA 88,31
350E:  DATA CA,31
3510:  DATA 08,32
3512:  DATA 46,32
3514:  DATA DA,32
3516:  DATA 6E,33
3518:  DATA B0,33
*
388E:  ADDWF  FE8,W
3890:  CLRF   FF7
3892:  RLCF   FF7,F
3894:  ADDLW  A9
3896:  MOVWF  FF6
3898:  MOVLW  38
389A:  ADDWFC FF7,F
389C:  TBLRD*-
389E:  MOVF   FF5,W
38A0:  MOVWF  FFA
38A2:  TBLRD*
38A4:  MOVF   FF5,W
38A6:  MOVWF  FF9
38A8:  DATA E4,35
38AA:  DATA 14,36
38AC:  DATA 56,36
38AE:  DATA 92,36
38B0:  DATA CE,36
38B2:  DATA DA,36
38B4:  DATA 2A,37
38B6:  DATA 6C,37
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #device *=16
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses NOPUT
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... //#fuses WDT512
.................... #fuses WDT1024
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses SOSC_DIG
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... 
.................... 
.................... #byte ANCON0=GETENV("SFR:ancon0")
.................... #byte ANCON1=GETENV("SFR:ancon1")
.................... 
.................... 
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
*
1CEC:  MOVFF  97F,985
1CF0:  MOVFF  97E,984
1CF4:  MOVLB  9
1CF6:  MOVF   x82,F
1CF8:  BNZ   1CFE
1CFA:  MOVF   x83,F
1CFC:  BZ    1D44
1CFE:  MOVFF  981,FEA
1D02:  MOVFF  980,FE9
1D06:  MOVF   FEF,F
1D08:  BZ    1D44
....................      *s++ = *s2++;
1D0A:  MOVFF  985,03
1D0E:  MOVF   x84,W
1D10:  INCF   x84,F
1D12:  BTFSC  FD8.2
1D14:  INCF   x85,F
1D16:  MOVWF  x86
1D18:  MOVFF  03,987
1D1C:  MOVFF  981,FEA
1D20:  MOVF   x80,W
1D22:  INCF   x80,F
1D24:  BTFSC  FD8.2
1D26:  INCF   x81,F
1D28:  MOVWF  FE9
1D2A:  MOVFF  FEF,988
1D2E:  MOVFF  03,FEA
1D32:  MOVFF  986,FE9
1D36:  MOVFF  988,FEF
1D3A:  MOVF   x82,W
1D3C:  BTFSC  FD8.2
1D3E:  DECF   x83,F
1D40:  DECF   x82,F
1D42:  BRA    1CF6
....................   for (; n > 0; n--)
1D44:  MOVF   x82,F
1D46:  BNZ   1D4C
1D48:  MOVF   x83,F
1D4A:  BZ    1D66
....................      *s++ = '\0';
1D4C:  MOVFF  985,FEA
1D50:  MOVF   x84,W
1D52:  INCF   x84,F
1D54:  BTFSC  FD8.2
1D56:  INCF   x85,F
1D58:  MOVWF  FE9
1D5A:  CLRF   FEF
1D5C:  MOVF   x82,W
1D5E:  BTFSC  FD8.2
1D60:  DECF   x83,F
1D62:  DECF   x82,F
1D64:  BRA    1D44
.................... 
....................   return(s1);
1D66:  MOVFF  97E,01
1D6A:  MOVFF  97F,02
1D6E:  MOVLB  0
1D70:  GOTO   20A4 (RETURN)
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
*
1118:  MOVFF  97F,FEA
111C:  MOVLB  9
111E:  MOVFF  97E,FE9
1122:  MOVF   x80,W
1124:  SUBWF  FEF,W
1126:  BZ    114C
....................       if (*s == '\0')
1128:  MOVFF  97F,03
112C:  MOVFF  97E,FE9
1130:  MOVFF  03,FEA
1134:  MOVF   FEF,F
1136:  BNZ   1140
....................          return(0);
1138:  MOVLW  00
113A:  MOVWF  01
113C:  MOVWF  02
113E:  BRA    1154
1140:  INCF   x7E,F
1142:  BTFSC  FD8.2
1144:  INCF   x7F,F
1146:  MOVLB  0
1148:  BRA    1118
114A:  MOVLB  9
....................    return(s);
114C:  MOVFF  97E,01
1150:  MOVFF  97F,02
1154:  MOVLB  0
1156:  RETURN 0
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
1086:  MOVFF  97D,97F
108A:  MOVFF  97C,97E
108E:  MOVFF  97F,FEA
1092:  MOVLB  9
1094:  MOVFF  97E,FE9
1098:  MOVF   FEF,F
109A:  BZ    10A8
109C:  INCF   x7E,F
109E:  BTFSC  FD8.2
10A0:  INCF   x7F,F
10A2:  MOVLB  0
10A4:  BRA    108E
10A6:  MOVLB  9
....................    return(sc - s);
10A8:  MOVF   x7C,W
10AA:  SUBWF  x7E,W
10AC:  MOVWF  00
10AE:  MOVF   x7D,W
10B0:  SUBWFB x7F,W
10B2:  MOVWF  03
10B4:  MOVFF  00,01
10B8:  MOVWF  02
10BA:  MOVLB  0
10BC:  GOTO   137A (RETURN)
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #use delay(clock=8000000, restart_wdt)
*
0BD2:  MOVLW  09
0BD4:  MOVWF  FEA
0BD6:  MOVLW  90
0BD8:  MOVWF  FE9
0BDA:  MOVF   FEF,W
0BDC:  BZ    0C00
0BDE:  MOVLW  02
0BE0:  MOVWF  01
0BE2:  MOVLW  BF
0BE4:  MOVWF  00
0BE6:  CLRWDT
0BE8:  DECFSZ 00,F
0BEA:  BRA    0BE6
0BEC:  DECFSZ 01,F
0BEE:  BRA    0BE2
0BF0:  MOVLW  96
0BF2:  MOVWF  00
0BF4:  DECFSZ 00,F
0BF6:  BRA    0BF4
0BF8:  BRA    0BFA
0BFA:  CLRWDT
0BFC:  DECFSZ FEF,F
0BFE:  BRA    0BDE
0C00:  RETURN 0
*
1CC6:  MOVLW  09
1CC8:  MOVLB  9
1CCA:  SUBWF  x7F,F
1CCC:  BNC   1CE6
1CCE:  MOVLW  09
1CD0:  MOVWF  FEA
1CD2:  MOVLW  7F
1CD4:  MOVWF  FE9
1CD6:  BCF    FD8.0
1CD8:  RRCF   FEF,F
1CDA:  MOVF   FEF,W
1CDC:  BZ    1CE6
1CDE:  BRA    1CE2
1CE0:  CLRWDT
1CE2:  DECFSZ FEF,F
1CE4:  BRA    1CE0
1CE6:  MOVLB  0
1CE8:  GOTO   1F2A (RETURN)
.................... 
.................... /* 
.................... Parameters and devices are stored in 1024 byte EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x0000
.................... #define DEVICE_CRC_ADDRESS 0x0002
.................... 
.................... #define PARAM_ADDRESS      0x0004 /* parameters go from 4 to 127 ... 123 bytes max */ 
.................... #define DEVICE_ADDRESS     0x0080 /* devices go from 128 to 1024 ... 896 bytes max */
.................... 
.................... 
.................... /* uart1 is for modbus and set in modbus_int_uart */
.................... #use rs232(UART2,stream=STREAM_WORLD, baud=57600, errors)	
*
07DC:  BTFSS  FA4.5
07DE:  BRA    07DC
07E0:  MOVFF  FA6,20
07E4:  MOVFF  F7A,01
07E8:  BTFSS  20.1
07EA:  BRA    07F0
07EC:  BCF    FA6.4
07EE:  BSF    FA6.4
07F0:  RETURN 0
*
257E:  BTFSS  FA4.4
2580:  BRA    257E
2582:  MOVWF  F79
2584:  RETURN 0
.................... 
.................... 
.................... #use standard_io(A)
.................... #use standard_io(B)
.................... #use standard_io(C)
.................... 
.................... /* I2C on hardware */
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, FAST)
*
0B0A:  BCF    FC6.7
0B0C:  BCF    F9E.3
0B0E:  MOVFF  98D,FC9
0B12:  MOVLW  02
0B14:  BTFSC  FC6.7
0B16:  BRA    0B22
0B18:  BTFSC  FC7.2
0B1A:  BRA    0B18
0B1C:  MOVLW  00
0B1E:  BTFSC  FC5.6
0B20:  MOVLW  01
0B22:  MOVWF  01
0B24:  RETURN 0
*
16A8:  BCF    FC6.6
16AA:  BSF    FC5.3
16AC:  BTFSC  FC5.3
16AE:  BRA    16AC
16B0:  BTFSC  00.0
16B2:  BCF    FC5.5
16B4:  BTFSS  00.0
16B6:  BSF    FC5.5
16B8:  BSF    FC5.4
16BA:  BTFSC  FC5.4
16BC:  BRA    16BA
16BE:  MOVFF  FC9,01
16C2:  RETURN 0
.................... 
.................... 
.................... 
.................... #define LED_GREEN       PIN_B5
.................... 
.................... #define SER_TO_NET      PIN_B6
.................... #define SER_FROM_NET    PIN_B7
.................... #define RS485_DE        PIN_C5
.................... 
.................... 
.................... #define CTRL_0          PIN_A0
.................... #define CTRL_1          PIN_A1
.................... #define CTRL_2          PIN_A2
.................... #define CTRL_3          PIN_A3
.................... #define CTRL_4          PIN_A5
.................... 
.................... #define STAT_0          PIN_A7
.................... #define STAT_1          PIN_A6
.................... #define STAT_2          PIN_C0
.................... #define STAT_3          PIN_C1
.................... #define STAT_4          PIN_C2
.................... 
.................... #define I2C_SCL         PIN_C3
.................... #define I2C_SDA         PIN_C4
.................... 
.................... #define CS_ADC0         PIN_B0
.................... #define SPI_DIN         PIN_B1
.................... #define SPI_DOUT        PIN_B2
.................... #define SPI_CLK         PIN_B3
.................... #define CS_ADC1         PIN_B4
.................... 
.................... /* U4 - first ADC */
.................... #define ADC_CH_VDIV_0   0
.................... #define ADC_CH_IMON_0   1
.................... #define ADC_CH_VDIV_1   2
.................... #define ADC_CH_IMON_1   3
.................... #define ADC_CH_VDIV_2   4
.................... #define ADC_CH_IMON_2   5
.................... #define ADC_CH_VDIV_3   6
.................... #define ADC_CH_IMON_3   7
.................... 
.................... /* U6 - second ADC */
.................... #define ADC_CH_VDIV_4   8
.................... #define ADC_CH_IMON_4   9
.................... #define ADC_CH_VDIV_5   10
.................... #define ADC_CH_TP_1     11
.................... #define ADC_CH_VDIV_6   12
.................... #define ADC_CH_TP_2     13
.................... #define ADC_CH_VDIV_7   14
.................... #define ADC_CH_TP_3     15
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /* device types for struct_device */
.................... #define DEV_TYPE_DISABLED       0
.................... 
.................... /* modbus slave on RS-485 bus */
.................... #define DEV_TYPE_MODBUS_1       1
.................... #define DEV_TYPE_MODBUS_2       2
.................... #define DEV_TYPE_MODBUS_3       3
.................... #define DEV_TYPE_MODBUS_4       4
.................... #define DEV_TYPE_MODBUS_5       5
.................... #define DEV_TYPE_MODBUS_6       6
.................... #define DEV_TYPE_MODBUS_16      7
.................... #define DEV_TYPE_MODBUS_MAX     7
.................... 
.................... /* I2C slave on I2C bus */
.................... #define DEV_TYPE_I2C_READ_8     16
.................... #define DEV_TYPE_I2C_READ_16    17
.................... #define DEV_TYPE_I2C_READ_24    18
.................... #define DEV_TYPE_I2C_READ_32    19
.................... #define DEV_TYPE_I2C_WRITE_8    20
.................... #define DEV_TYPE_I2C_WRITE_16   21
.................... #define DEV_TYPE_I2C_WRITE_24   22
.................... #define DEV_TYPE_I2C_WRITE_32   23
.................... #define DEV_TYPE_I2C_MAX        23
.................... 
.................... /* local registers on this device */
.................... #define DEV_TYPE_LOCAL_READ_16  32
.................... #define DEV_TYPE_LOCAL_WRITE_16 33
.................... #define DEV_TYPE_LOCAL_MAX      33
.................... 
.................... 
.................... 
.................... /* serial port speeds */
.................... #define DEV_SERIAL_9600  0
.................... #define DEV_SERIAL_19200 1
.................... 
.................... 
.................... #define DEV_MAX_N 64
.................... 
.................... #include "worldDeviceTypes.h"
.................... /* Continental Control Systems, Watt Node Modbus */
.................... #define DEVICE_TYPE_WORLD_WNC_BASIC           1  /* 1000, 34 */
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED        2
.................... #define DEVICE_TYPE_WORLD_WNC_CONFIGURATION   3
.................... #define DEVICE_TYPE_WORLD_WNC_DIAGNOSTIC      4
.................... #define DEVICE_TYPE_WORLD_WNC_ADVANCED_ENERGY 5  /* 1100, 38 */
.................... 
.................... /* APRS World, XRW2G */
.................... #define DEVICE_TYPE_WORLD_XRW2G_BASIC         100 /* 0, 46 */
.................... #define DEVICE_TYPE_WORLD_XRW2G_DIAGNOSTIC    101
.................... #define DEVICE_TYPE_WORLD_XRW2G_CONFIGURATION 102
.................... 
.................... /* Morningstar, Relay Driver */
.................... #define DEVICE_TYPE_WORLD_RD1_RAM             200 /* 0, 18 */
.................... #define DEVICE_TYPE_WORLD_RD1_COILS           201 /* 0, 4 */
.................... 
.................... /* Morningstar, Tri-Star */
.................... #define DEVICE_TYPE_WORLD_TS_RAM              300 /* 8, 21 */
.................... #define DEVICE_TYPE_WORLD_TS_COILS            301
.................... #define DEVICE_TYPE_WORLD_TS_EEPROM           302
.................... #define DEVICE_TYPE_WORLD_TS_KWH              303 /* 57388, 3 */
.................... 
.................... /* Morningstar, Tri-Star MPPT */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_SCALING                  320 /* 0, 4 */
.................... #define DEVICE_TYPE_WORLD_TSMPPT_FILTERED_ADC             321 /* 24, 38 */
.................... 
.................... /* Advancetech, Adam 4xxx MODBUS */
.................... #define ADAM_4XXX_ANALOG_CURRENT                          400 /* 0, 8 */
.................... 
.................... /* smaller block definitions for SatCon PVS50 ... not implemented or seen in the wild. Do not use */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_SOFTWARE           500 /* 30009, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_ACTIVE_FAULTS      501 /* 30017, 3 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_DC                 502 /* 30020, 4 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_CURRENT    503 /* 30035, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_LINE_VOLTAGE    504 /* 30040, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_AC_POWER           505 /* 30043, 5 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_GROUND_IMPEDANCE   506 /* 30049, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT     507 /* 30050, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_CURRENT_AVG 508 /* 30089, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH         509 /* 30090, 32 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STRING_KWH_AVG     510 /* 30129, 1 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_KWH                511 /* 30131, 8 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_TIMERS             512 /* 30275, 2 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_STATE              513 /* 30279, 2 */
.................... 
.................... /* SatCon PVS50 inverter. Manual has +30001 offset. */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_0      520 /* 9, 40 registers ... error, should be 41 */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_1      521 /* 50, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_2      522 /* 90, 40 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_3      523 /* 131, 8 registers */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_4      524 /* 175, 2 registers ... not programmed at west point! */
.................... #define DEVICE_TYPE_WORLD_SATCON_PVS50_5      525 /* 275, 6 registers ... */
.................... 
.................... 
.................... /* PC&S Multitek MP850MPDV19PE CUSTOM 1 */
.................... /* Registers re-arranged to be consecutive, starting with reg 0 */
.................... /* Values are 32-bit Floating Point */
.................... /* Register list: */
.................... /* 0 - V 1 ... Voltage */
.................... /* 2 - I 1 ... Current */
.................... /* 4 - kW Sum */
.................... /* 6 - kWHr (Import) */
.................... /* 8 - kWd  (Import) ... Demand over last 3 minutes */
.................... /* 10 - Ad ... Demand current over last 3 minutes*/
.................... /* 12 - kWHr (Export) */
.................... /* 14 - A.h */
.................... /* 16 - Max kWd (Import) */
.................... /* 18 - Max Ad */
.................... 
.................... #define DEVICE_TYPE_WORLD_M850MPD_CUSTOM_1	 600 /* 0, 20 registers */
.................... 
.................... 
.................... #define DEVICE_TYPE_WORLD_SHUNTMONITOR_BASIC  700 /* 0, 32 registers */
.................... 
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_BASIC      800 /* 0, 39 registers */
.................... #define DEVICE_TYPE_WORLD_WRENDAQ4_CONFIG     801 /* 1000, 15 registers */
.................... 
.................... /* Midnite Solar Classic - based on 2011-05-21 specification */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_BASIC       900 /* 4113, 31 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_WIND_CURVE  901 /* 4300, 16 registers */
.................... #define DEVICE_TYPE_WORLD_CLASSIC_RESTING     902 /* 4274, 3  registers */
.................... 
.................... /* APRS World POE Monitor */
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_BASIC    1000 
.................... #define DEVICE_TYPE_WORLD_POEMONITOR_CONFIG   1001
.................... 
.................... /* APRS World watchdog Arlo */
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_BASIC  1100
.................... #define DEVICE_TYPE_WORLD_WATCHDOGARLO_CONFIG 1101
.................... 
.................... /* China HUM temperature and relative humidity sensor */
.................... #define DEVICE_TYPE_WORLD_HUM_TEMPERATURE      1200
.................... #define DEVICE_TYPE_WORLD_HUM_RELATIVEHUMIDITY 1201
.................... 
.................... /* "Center" brand soundmeter */
.................... #define TYPE_TYPE_WORLD_SOUNDMETER_CENTER      1300
.................... 
.................... /* PS2Tap */
.................... #define DEVICE_TYPE_WORLD_PS2TAP_BASIC         1400 /* 0, 19 registers */
.................... 
.................... /* Veris E50 Series Power Meter */
.................... #define DEVICE_TYPE_WORLD_VERISE50_BASIC       1500 /* 256, 54 registers */
.................... 
.................... 
.................... /* Note: List not complete.  Reference master list in WorldDataCollector. */
.................... 
.................... 
.................... /* generic rsdata */
.................... #define DEVICE_TYPE_WORLD_RSDATA               32000 /* Integer */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT         32001 /* IEEE-754 single precision floating point (32-bit) data */
.................... #define DEVICE_TYPE_WORLD_RSDATA_FLOAT_LITTLE  32002 
.................... 
.................... 
.................... typedef struct {
.................... 	int8  type;           /* device query type */
.................... 	int16 typeWorld;      /* see worldDeviceTypes.h for defines */
.................... 	int8  transmitEvery;
.................... 	int8  networkAddress; /* modbus or I2C address */
.................... 	int32 serialNumber;   /* APRS World or other serial number */
.................... 	int16 startRegister;
.................... 	int8  nRegisters;
.................... 	int8  serialSpeed;    /* see rsTap.h for defines */
.................... } struct_device;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  now_poll;
.................... 	int8  world_timeout;
.................... 	int8  factory_unlocked;
.................... 	int8  led_on_green;
.................... 	int16 sbd_cycle;
.................... } struct_timer;
.................... 
.................... 
.................... typedef struct {
.................... 	int8  rException;
.................... 	int8  rResult[256];
.................... 	int8  rResultLength;
.................... 	int8  deviceNumber;
.................... 	int16 measurementNumber;
.................... } struct_qbuff;
.................... 
.................... typedef struct {
.................... 	int8 buff[256];
.................... 	int8 buff_pos;
.................... 	int8 buff_ready;
.................... 
.................... 	int8  packet_length;
.................... 	int32 query_id;
.................... 	int32 device_serial;
.................... 	int16 network_address;
.................... 	int16 function;
.................... 	int16 start_address;
.................... 	int8  n_words;
.................... 	int8  data_start_offset;
.................... 	int16 crc;
.................... 
.................... 	int8  resultException;
.................... 	int8  resultLength;
.................... } struct_query;
.................... 
.................... typedef struct {
.................... 	int8  serial_prefix;
.................... 	int16 serial_number;
.................... 	
.................... 	int16 live_interval;
.................... 
.................... 	/* Iridium SBD or other limited bandwidth transmission */
.................... 	/* 0 is no SBD, 1...5 is SBD modem with power switch on CONTROL pin 1...5 */
.................... 	int8  sbd_config;
.................... 
.................... 	/*	
.................... 	every n'th live transmission we transmit the SBD data
.................... 	Interval should be at least 10 minutes to allow for full retry cycle	
.................... 	on cycle before transmit, we clear previous buffer and turn on modem 
.................... 	*/
.................... 	int16 sbd_every;
.................... 
.................... } struct_config;
.................... 
.................... /* global structures */
.................... struct_device device[DEV_MAX_N];
.................... struct_timer  timers;
.................... struct_qbuff  qbuff;
.................... struct_query  query;
.................... struct_config config;
.................... 
.................... #include "i2c_access_rdTap.c"
.................... int16 i2c_register_read16(int8 i2c_address, int8 regaddr) {
.................... 	int8 msb, lsb;
.................... 
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address);
.................... 	i2c_write(regaddr);
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
.................... 	delay_us(15);
.................... 	i2c_write(i2c_address | 1);  // read cycle
.................... 	msb=i2c_read(1);
.................... 	lsb=i2c_read(0);                                
.................... 	i2c_stop();
.................... 
.................... 	return make16(msb,lsb);
.................... }
.................... 
.................... void i2c_buff_read(int8 i2c_address, int8 regaddr, int8 *data, int8 count) {
.................... 	/* start I2C transaction and write the register we want to read to the slave */
.................... 	i2c_start();
*
2882:  BSF    FC5.0
2884:  BTFSC  FC5.0
2886:  BRA    2884
.................... 	delay_us(15);
2888:  CLRWDT
288A:  MOVLW  09
288C:  MOVWF  00
288E:  DECFSZ 00,F
2890:  BRA    288E
2892:  NOP   
.................... 	i2c_write(i2c_address);
2894:  MOVFF  982,98D
2898:  CALL   0B0A
.................... 	i2c_write(regaddr);
289C:  MOVFF  983,98D
28A0:  CALL   0B0A
.................... 
.................... 	/* restart I2C and read two bytes from the slave */
.................... 	i2c_start();
28A4:  BSF    FC5.1
28A6:  BTFSC  FC5.1
28A8:  BRA    28A6
.................... 	delay_us(15);
28AA:  CLRWDT
28AC:  MOVLW  09
28AE:  MOVWF  00
28B0:  DECFSZ 00,F
28B2:  BRA    28B0
28B4:  NOP   
.................... 	i2c_write(i2c_address | 1);  // read cycle
28B6:  MOVLB  9
28B8:  MOVF   x82,W
28BA:  IORLW  01
28BC:  MOVWF  x87
28BE:  MOVWF  x8D
28C0:  MOVLB  0
28C2:  CALL   0B0A
.................... 
.................... 	/* stop reading before last byte */	
.................... 	while ( count-- != 1 ) {
28C6:  MOVLB  9
28C8:  MOVF   x86,W
28CA:  DECF   x86,F
28CC:  SUBLW  01
28CE:  BZ    28F0
.................... 		*data=i2c_read(1);
28D0:  MOVFF  985,FEA
28D4:  MOVFF  984,FE9
28D8:  MOVLW  01
28DA:  MOVWF  00
28DC:  MOVLB  0
28DE:  CALL   16A8
28E2:  MOVFF  01,FEF
.................... 		data++;
28E6:  MOVLB  9
28E8:  INCF   x84,F
28EA:  BTFSC  FD8.2
28EC:  INCF   x85,F
28EE:  BRA    28C8
.................... 	}
.................... 
.................... 	/* send last byte with a NAK */
.................... 	*data=i2c_read(0);                                
28F0:  MOVFF  985,FEA
28F4:  MOVFF  984,FE9
28F8:  CLRF   00
28FA:  MOVLB  0
28FC:  CALL   16A8
2900:  MOVFF  01,FEF
.................... 	i2c_stop();
2904:  BSF    FC5.2
2906:  BTFSC  FC5.2
2908:  BRA    2906
290A:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void i2c_register_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start();
*
3C9C:  BSF    FC5.0
3C9E:  BTFSC  FC5.0
3CA0:  BRA    3C9E
.................... 	delay_us(15);                                                 
3CA2:  CLRWDT
3CA4:  MOVLW  09
3CA6:  MOVWF  00
3CA8:  DECFSZ 00,F
3CAA:  BRA    3CA8
3CAC:  NOP   
.................... 	i2c_write(i2c_address); // write cycle                       
3CAE:  MOVFF  988,98D
3CB2:  CALL   0B0A
.................... 	i2c_write(regaddr);  // write cycle         
3CB6:  MOVFF  989,98D
3CBA:  CALL   0B0A
.................... 	i2c_write(make8(value,1));
3CBE:  MOVFF  98B,98D
3CC2:  CALL   0B0A
.................... 	i2c_write(make8(value,0));
3CC6:  MOVFF  98A,98D
3CCA:  CALL   0B0A
.................... 	i2c_stop();
3CCE:  BSF    FC5.2
3CD0:  BTFSC  FC5.2
3CD2:  BRA    3CD0
3CD4:  GOTO   3FE8 (RETURN)
.................... }
.................... 
.................... void i2c_register_write32(int8 i2c_address, int8 regaddr, int32 value) {
.................... 	i2c_start();
.................... 	delay_us(15);                                                 
.................... 	i2c_write(i2c_address); // write cycle                       
.................... 	i2c_write(regaddr);  // write cycle     
.................... 	i2c_write(make8(value,3));
.................... 	i2c_write(make8(value,2));    
.................... 	i2c_write(make8(value,1));
.................... 	i2c_write(make8(value,0));
.................... 	i2c_stop();
.................... }
.................... 
.................... #include "mcp3208_rdTap.c"
.................... #define MCP3208_CLK  SPI_CLK
.................... #define MCP3208_DOUT SPI_DOUT
.................... #define MCP3208_DIN  SPI_DIN
.................... 
.................... 
.................... void mcp3208_init(void) {
.................... 	output_high(CS_ADC1);
.................... 	output_high(CS_ADC0);
.................... }
.................... 
.................... int16 mcp3208_read(int8 ch) {
.................... 	int16 value;
.................... 	int8 i;
.................... 	int8 c;
.................... 
.................... //	return (int16) ch; 
.................... 
.................... 
.................... 
.................... 	output_low(MCP3208_CLK);
.................... 	output_high(MCP3208_DIN);
.................... 
.................... 
.................... 	if ( ch<8 ) {
.................... 		output_low(CS_ADC0);
.................... 	} else {
.................... 		output_low(CS_ADC1);
.................... 		ch-=8;
.................... 	}
.................... 
.................... 	/* d0, d1, d2, single / !differential, start */	
.................... 	if ( 0 == ch ) 
.................... 		c=0b00011;
.................... 	else if ( 1 == ch ) 
.................... 		c=0b10011;
.................... 	else if ( 2 == ch ) 
.................... 		c=0b01011;
.................... 	else if ( 3 == ch ) 
.................... 		c=0b11011;
.................... 	else if ( 4 == ch )
.................... 		c=0b00111;
.................... 	else if ( 5 == ch ) 
.................... 		c=0b10111;
.................... 	else if ( 6 == ch )
.................... 		c=0b01111;
.................... 	else
.................... 		c=0b11111;
.................... 
.................... 	/* select out channel and start the conversion */
.................... 	for ( i=0 ; i<5 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		output_bit(MCP3208_DIN,c&1);
.................... 		c=c>>1;
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 
.................... 	value=0;
.................... 	for ( i=0 ; i<14 ; i++ ) {
.................... 		output_low(MCP3208_CLK);
.................... 		shift_left(&value,2,input(MCP3208_DOUT));
.................... 		output_high(MCP3208_CLK);
.................... 	}
.................... 
.................... 	bit_clear(value,13);
.................... 	bit_clear(value,12);
.................... 
.................... 	/* de-select both ADCs */
.................... 	mcp3208_init();
.................... 
.................... 	return value;
.................... }
.................... 
.................... #include "uart_sc16is740_rdTap.c"
.................... /* register map for SC16IS740 */
.................... #define UART_RHR          0x00 //  Recv Holding Register is 0x00 in READ Mode
.................... #define UART_THR          0x00 //  Xmit Holding Register is 0x00 in WRITE Mode
.................... #define UART_IER          0x01  // Interrupt Enable Register
.................... #define UART_FCR          0x02  // FIFO Control Register in WRITE Mode
.................... #define UART_LCR          0x03  // Line Control Register
.................... #define UART_MCR          0x04  // Modem Control Register
.................... #define UART_LSR          0x05  // Line status Register
.................... #define UART_MSR          0x06  // Modem Status Register
.................... #define UART_SPR          0x07  // ScratchPad Register
.................... #define UART_TCR          0x06  // Transmission Control Register
.................... #define UART_TLR          0x07  // Trigger Level Register
.................... #define UART_TXLVL        0x08  // Xmit FIFO Level Register
.................... #define UART_RXLVL        0x09  // Recv FIFO Level Register
.................... #define UART_EFCR         0x0F  // Extra Features Control Register
.................... 
.................... #define UART_DLL          0x00  // Divisor Latch LSB  0x00
.................... #define UART_DLH          0x01  // Divisor Latch MSB  0x01
.................... 
.................... #define UART_EFR          0x02  // Enhanced Function Register
.................... 
.................... #define UART_I2C_WRITE    0x00
.................... #define UART_I2C_READ     0x01                                               
.................... 
.................... /* A0 and A1 at VSS */
.................... #define UART_ADDR         0x9A
.................... 
.................... int8 uart_read(int8 regaddr) {
.................... 	int8 data;
.................... 
.................... 	i2c_start();
*
16C4:  BSF    FC5.0
16C6:  BTFSC  FC5.0
16C8:  BRA    16C6
.................... 	delay_us(15);
16CA:  CLRWDT
16CC:  MOVLW  09
16CE:  MOVWF  00
16D0:  DECFSZ 00,F
16D2:  BRA    16D0
16D4:  NOP   
.................... 	i2c_write(UART_ADDR);
16D6:  MOVLW  9A
16D8:  MOVLB  9
16DA:  MOVWF  x8D
16DC:  MOVLB  0
16DE:  CALL   0B0A
.................... 	i2c_write(regaddr<<3);
16E2:  MOVLB  9
16E4:  RLCF   x7B,W
16E6:  MOVWF  x7D
16E8:  RLCF   x7D,F
16EA:  RLCF   x7D,F
16EC:  MOVLW  F8
16EE:  ANDWF  x7D,F
16F0:  MOVFF  97D,98D
16F4:  MOVLB  0
16F6:  CALL   0B0A
.................... 	i2c_start();
16FA:  BSF    FC5.1
16FC:  BTFSC  FC5.1
16FE:  BRA    16FC
.................... 	delay_us(15);
1700:  CLRWDT
1702:  MOVLW  09
1704:  MOVWF  00
1706:  DECFSZ 00,F
1708:  BRA    1706
170A:  NOP   
.................... 	i2c_write(UART_ADDR | UART_I2C_READ);  // read cycle                                 
170C:  MOVLW  9B
170E:  MOVLB  9
1710:  MOVWF  x8D
1712:  MOVLB  0
1714:  CALL   0B0A
.................... 	data=i2c_read(0);
1718:  CLRF   00
171A:  RCALL  16A8
171C:  MOVFF  01,97C
.................... 	i2c_stop();
1720:  BSF    FC5.2
1722:  BTFSC  FC5.2
1724:  BRA    1722
.................... 
.................... 	return data;
1726:  MOVLB  9
1728:  MOVFF  97C,01
172C:  MOVLB  0
172E:  RETURN 0
.................... }
.................... 
.................... void uart_write(int8 regaddr, int8 data ) {                                                                  
.................... 	i2c_start();
*
0B26:  BSF    FC5.0
0B28:  BTFSC  FC5.0
0B2A:  BRA    0B28
.................... 	delay_us(15);                                                 
0B2C:  CLRWDT
0B2E:  MOVLW  09
0B30:  MOVWF  00
0B32:  DECFSZ 00,F
0B34:  BRA    0B32
0B36:  NOP   
.................... 	i2c_write(UART_ADDR); // write cycle                       
0B38:  MOVLW  9A
0B3A:  MOVLB  9
0B3C:  MOVWF  x8D
0B3E:  MOVLB  0
0B40:  RCALL  0B0A
.................... 	i2c_write(regaddr<< 3);  // write cycle         
0B42:  MOVLB  9
0B44:  RLCF   x88,W
0B46:  MOVWF  x8A
0B48:  RLCF   x8A,F
0B4A:  RLCF   x8A,F
0B4C:  MOVLW  F8
0B4E:  ANDWF  x8A,F
0B50:  MOVFF  98A,98D
0B54:  MOVLB  0
0B56:  RCALL  0B0A
.................... 	i2c_write(data);
0B58:  MOVFF  989,98D
0B5C:  RCALL  0B0A
.................... 	i2c_stop();
0B5E:  BSF    FC5.2
0B60:  BTFSC  FC5.2
0B62:  BRA    0B60
0B64:  RETURN 0
.................... } 
.................... 
.................... void uart_putc(int8 data ) {
.................... 	uart_write(UART_THR, data);  // send data to UART Transmit Holding Register
*
17F6:  MOVLB  9
17F8:  CLRF   x88
17FA:  MOVFF  987,989
17FE:  MOVLB  0
1800:  CALL   0B26
1804:  RETURN 0
.................... }
.................... 
.................... int1 uart_kbhit(void) {
.................... 	return (uart_read(UART_LSR) & 0x01);
*
1730:  MOVLW  05
1732:  MOVLB  9
1734:  MOVWF  x7B
1736:  MOVLB  0
1738:  RCALL  16C4
173A:  MOVF   01,W
173C:  ANDLW  01
173E:  MOVWF  01
1740:  RETURN 0
.................... }
.................... 
.................... 
.................... #inline
.................... int8 uart_getc() {
.................... 	return uart_read(UART_RHR);
1742:  MOVLB  9
1744:  CLRF   x7B
1746:  MOVLB  0
1748:  RCALL  16C4
174A:  MOVF   01,W
*
1962:  MOVLB  9
1964:  CLRF   x7B
1966:  MOVLB  0
1968:  RCALL  16C4
196A:  MOVF   01,W
*
198A:  MOVLB  9
198C:  CLRF   x7B
198E:  MOVLB  0
1990:  RCALL  16C4
1992:  MOVF   01,W
*
19D4:  MOVLB  9
19D6:  CLRF   x7B
19D8:  MOVLB  0
19DA:  RCALL  16C4
19DC:  MOVF   01,W
*
1A30:  MOVLB  9
1A32:  CLRF   x7B
1A34:  MOVLB  0
1A36:  RCALL  16C4
1A38:  MOVF   01,W
*
1A58:  MOVLB  9
1A5A:  CLRF   x7B
1A5C:  MOVLB  0
1A5E:  RCALL  16C4
1A60:  MOVF   01,W
.................... }
.................... 
.................... #inline
.................... /* returns true when transmit register is empty */
.................... int1 uart_tx_empty() {
.................... 	return bit_test(uart_read(UART_LSR),5);
.................... }
.................... 
.................... void uart_init(int8 divisor) {
.................... 	/* UART divisor calculator spreadsheet uart_divisor_calc.xls */
.................... 	uart_write(UART_LCR, 0x80); // 0x80 to program baud rate divisor
*
0B66:  MOVLW  03
0B68:  MOVLB  9
0B6A:  MOVWF  x88
0B6C:  MOVLW  80
0B6E:  MOVWF  x89
0B70:  MOVLB  0
0B72:  RCALL  0B26
.................... 	uart_write(UART_DLL, divisor);    // divide clock by 2 for 57600 baud when using 1.8432 crystal
0B74:  MOVLB  9
0B76:  CLRF   x88
0B78:  MOVFF  97A,989
0B7C:  MOVLB  0
0B7E:  RCALL  0B26
.................... 								      // divide clock by 12 for 9600 baud when using 1.8432 crystal
.................... 	uart_write(UART_DLH, 0);
0B80:  MOVLW  01
0B82:  MOVLB  9
0B84:  MOVWF  x88
0B86:  CLRF   x89
0B88:  MOVLB  0
0B8A:  RCALL  0B26
.................... 
.................... 	uart_write(UART_LCR, 0xBF); // access EFR register
0B8C:  MOVLW  03
0B8E:  MOVLB  9
0B90:  MOVWF  x88
0B92:  MOVLW  BF
0B94:  MOVWF  x89
0B96:  MOVLB  0
0B98:  RCALL  0B26
.................... 	uart_write(UART_EFR, 0X10); // enable enhanced registers
0B9A:  MOVLW  02
0B9C:  MOVLB  9
0B9E:  MOVWF  x88
0BA0:  MOVLW  10
0BA2:  MOVWF  x89
0BA4:  MOVLB  0
0BA6:  RCALL  0B26
....................  	uart_write(UART_LCR, 0x03); // 8 data bits, 1 stop bit, no parity
0BA8:  MOVLW  03
0BAA:  MOVLB  9
0BAC:  MOVWF  x88
0BAE:  MOVWF  x89
0BB0:  MOVLB  0
0BB2:  RCALL  0B26
.................... //	uart_write(UART_IER, 0x01); // enable interrupt on receive data becomming available
.................... 	uart_write(UART_IER, 0x00); // disable all interrupts
0BB4:  MOVLW  01
0BB6:  MOVLB  9
0BB8:  MOVWF  x88
0BBA:  CLRF   x89
0BBC:  MOVLB  0
0BBE:  RCALL  0B26
.................... 	uart_write(UART_FCR, 0x07); // reset TXFIFO, reset RXFIFO, enable FIFO mode
0BC0:  MOVLW  02
0BC2:  MOVLB  9
0BC4:  MOVWF  x88
0BC6:  MOVLW  07
0BC8:  MOVWF  x89
0BCA:  MOVLB  0
0BCC:  RCALL  0B26
0BCE:  GOTO   0C66 (RETURN)
.................... }
.................... 
.................... 
.................... #include "param_rdTap.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0CF6:  MOVF   x98,W
0CF8:  XORWF  x99,W
0CFA:  MOVWF  01
*
0F72:  MOVF   x98,W
0F74:  XORWF  x99,W
0F76:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
0F06:  MOVLB  9
0F08:  CLRF   x83
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0F0A:  MOVFF  982,985
0F0E:  MOVF   x81,W
0F10:  BTFSC  FD8.2
0F12:  DECF   x82,F
0F14:  DECF   x81,F
0F16:  MOVWF  x84
0F18:  MOVF   x84,F
0F1A:  BNZ   0F20
0F1C:  MOVF   x85,F
0F1E:  BZ    0F84
.................... 		*data = read_eeprom( address++ );
0F20:  MOVFF  980,03
0F24:  MOVF   x7F,W
0F26:  MOVWF  FE9
0F28:  MOVFF  03,FEA
0F2C:  MOVF   x7E,W
0F2E:  MOVWF  03
0F30:  MOVF   x7D,W
0F32:  INCF   x7D,F
0F34:  BTFSC  FD8.2
0F36:  INCF   x7E,F
0F38:  MOVWF  x86
0F3A:  MOVFF  03,987
0F3E:  MOVFF  FF2,988
0F42:  BCF    FF2.7
0F44:  MOVFF  987,F75
0F48:  MOVFF  986,F74
0F4C:  BCF    F7F.6
0F4E:  BCF    F7F.7
0F50:  BSF    F7F.0
0F52:  MOVF   F73,W
0F54:  BTFSC  x88.7
0F56:  BSF    FF2.7
0F58:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
0F5A:  MOVFF  980,03
0F5E:  MOVF   x7F,W
0F60:  MOVWF  FE9
0F62:  MOVFF  03,FEA
0F66:  MOVFF  FEF,984
0F6A:  MOVFF  983,998
0F6E:  MOVFF  984,999
*
0F78:  MOVFF  01,983
.................... 		data++;
0F7C:  INCF   x7F,F
0F7E:  BTFSC  FD8.2
0F80:  INCF   x80,F
0F82:  BRA    0F0A
.................... 	}
.................... 	return crc;
0F84:  MOVFF  983,01
0F88:  MOVLB  0
0F8A:  RETURN 0
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
*
0CC2:  MOVLB  9
0CC4:  CLRF   x96
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0CC6:  MOVFF  995,998
0CCA:  MOVF   x94,W
0CCC:  BTFSC  FD8.2
0CCE:  DECF   x95,F
0CD0:  DECF   x94,F
0CD2:  MOVWF  x97
0CD4:  MOVF   x97,F
0CD6:  BNZ   0CDC
0CD8:  MOVF   x98,F
0CDA:  BZ    0D5A
.................... 		restart_wdt();
0CDC:  CLRWDT
.................... 		crc = xor_crc(crc,*data);
0CDE:  MOVFF  993,03
0CE2:  MOVF   x92,W
0CE4:  MOVWF  FE9
0CE6:  MOVFF  03,FEA
0CEA:  MOVFF  FEF,997
0CEE:  MOVFF  996,998
0CF2:  MOVFF  997,999
*
0CFC:  MOVFF  01,996
.................... 		write_eeprom( address++, *data++ );
0D00:  MOVF   x91,W
0D02:  MOVWF  03
0D04:  MOVF   x90,W
0D06:  INCF   x90,F
0D08:  BTFSC  FD8.2
0D0A:  INCF   x91,F
0D0C:  MOVWF  x97
0D0E:  MOVFF  03,998
0D12:  MOVF   x93,W
0D14:  MOVWF  03
0D16:  MOVF   x92,W
0D18:  INCF   x92,F
0D1A:  BTFSC  FD8.2
0D1C:  INCF   x93,F
0D1E:  MOVWF  FE9
0D20:  MOVFF  03,FEA
0D24:  MOVFF  FEF,999
0D28:  MOVF   FF2,W
0D2A:  MOVWF  00
0D2C:  BCF    FF2.7
0D2E:  MOVFF  998,F75
0D32:  MOVFF  997,F74
0D36:  MOVFF  999,F73
0D3A:  BCF    F7F.6
0D3C:  BCF    F7F.7
0D3E:  BSF    F7F.2
0D40:  MOVLB  F
0D42:  MOVLW  55
0D44:  MOVWF  F7E
0D46:  MOVLW  AA
0D48:  MOVWF  F7E
0D4A:  BSF    F7F.1
0D4C:  BTFSC  F7F.1
0D4E:  BRA    0D4C
0D50:  BCF    F7F.2
0D52:  MOVF   00,W
0D54:  IORWF  FF2,F
0D56:  MOVLB  9
0D58:  BRA    0CC6
.................... 	}
.................... 
.................... 	return crc;
0D5A:  MOVFF  996,01
0D5E:  MOVLB  0
0D60:  RETURN 0
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
0D62:  MOVLW  05
0D64:  MOVLB  9
0D66:  MOVWF  x8E
0D68:  MOVLW  83
0D6A:  MOVWF  x8D
0D6C:  CLRF   x91
0D6E:  MOVLW  04
0D70:  MOVWF  x90
0D72:  MOVFF  98E,993
0D76:  MOVFF  98D,992
0D7A:  CLRF   x95
0D7C:  MOVLW  08
0D7E:  MOVWF  x94
0D80:  MOVLB  0
0D82:  RCALL  0CC2
0D84:  MOVFF  01,98C
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
0D88:  MOVF   FF2,W
0D8A:  MOVWF  00
0D8C:  BCF    FF2.7
0D8E:  CLRF   F75
0D90:  CLRF   F74
0D92:  MOVFF  98C,F73
0D96:  BCF    F7F.6
0D98:  BCF    F7F.7
0D9A:  BSF    F7F.2
0D9C:  MOVLB  F
0D9E:  MOVLW  55
0DA0:  MOVWF  F7E
0DA2:  MOVLW  AA
0DA4:  MOVWF  F7E
0DA6:  BSF    F7F.1
0DA8:  BTFSC  F7F.1
0DAA:  BRA    0DA8
0DAC:  BCF    F7F.2
0DAE:  MOVF   00,W
0DB0:  IORWF  FF2,F
0DB2:  MOVLB  0
0DB4:  RETURN 0
.................... 
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0DB6:  MOVLW  96
0DB8:  MOVLB  3
0DBA:  MOVWF  x64
.................... //	fprintf(world,"# writing default parameters\r\n");
.................... 
.................... 	config.serial_prefix='A';
0DBC:  MOVLW  41
0DBE:  MOVLB  5
0DC0:  MOVWF  x83
.................... 	config.serial_number=4820;
0DC2:  MOVLW  12
0DC4:  MOVWF  x85
0DC6:  MOVLW  D4
0DC8:  MOVWF  x84
.................... 		/* 
.................... 			A4797 Fairway UAF (SBD in slot 5 closest to power connector)
.................... 			A4800 Fairway UVic (SBD in slot 1)
.................... 			A4810 Uvic Spare Fairway panel (SBD in slot 1)
.................... 			A4820 JJJ Bench (SBD in slot 1)
.................... 		*/
.................... 
.................... 	/* data to internet on STREAM_WORLD port */
.................... 	config.live_interval=10; 
0DCA:  CLRF   x87
0DCC:  MOVLW  0A
0DCE:  MOVWF  x86
.................... 
.................... 	/* Iridium SBD requires dcswc_module_rockblock which provides an I2C UART */
.................... 	config.sbd_config=1;   /* physical slot for module. Used for power control */
0DD0:  MOVLW  01
0DD2:  MOVWF  x88
.................... 	config.sbd_every=90; /* send SBD message every this number of live_interval */
0DD4:  CLRF   x8A
0DD6:  MOVLW  5A
0DD8:  MOVWF  x89
....................                            /* with 10 second live interval, 4320 => SBD every 12 hours */
....................                            /* with 10 second live interval, 1080 => SBD every 3 hours */			
....................                            /* with 10 second live interval, 90 => SBD every 15 minutes */
.................... 				
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0DDA:  MOVLB  0
0DDC:  RCALL  0D62
0DDE:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS,(void *)&config, sizeof(config)); 
*
0F8C:  MOVLW  05
0F8E:  MOVLB  9
0F90:  MOVWF  x7C
0F92:  MOVLW  83
0F94:  MOVWF  x7B
0F96:  CLRF   x7E
0F98:  MOVLW  04
0F9A:  MOVWF  x7D
0F9C:  MOVFF  97C,980
0FA0:  MOVFF  97B,97F
0FA4:  CLRF   x82
0FA6:  MOVLW  08
0FA8:  MOVWF  x81
0FAA:  MOVLB  0
0FAC:  RCALL  0F06
0FAE:  MOVFF  01,97A
.................... 
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
0FB2:  MOVFF  FF2,97B
0FB6:  BCF    FF2.7
0FB8:  CLRF   F75
0FBA:  CLRF   F74
0FBC:  BCF    F7F.6
0FBE:  BCF    F7F.7
0FC0:  BSF    F7F.0
0FC2:  MOVF   F73,W
0FC4:  MOVLB  9
0FC6:  BTFSC  x7B.7
0FC8:  BSF    FF2.7
0FCA:  SUBWF  x7A,W
0FCC:  BZ    0FD4
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_param_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_param_file();
0FCE:  MOVLB  0
0FD0:  RCALL  0DB6
0FD2:  MOVLB  9
.................... 	}
0FD4:  MOVLB  0
0FD6:  GOTO   4436 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "paramDevice_rdTap.c"
.................... void write_device_file() {
.................... 	int8 crc;
.................... 
.................... 
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(DEVICE_ADDRESS,(void *)&device,sizeof(device));
*
0E02:  MOVLB  9
0E04:  MOVLW  21
0E06:  MOVWF  x8E
0E08:  CLRF   x91
0E0A:  MOVLW  80
0E0C:  MOVWF  x90
0E0E:  CLRF   x93
0E10:  MOVFF  98E,992
0E14:  MOVLW  03
0E16:  MOVWF  x95
0E18:  MOVLW  40
0E1A:  MOVWF  x94
0E1C:  MOVLB  0
0E1E:  RCALL  0CC2
0E20:  MOVFF  01,98D
.................... 	/* write the CRC that was calculated on the structure */
.................... 	write_eeprom(DEVICE_CRC_ADDRESS,crc);
0E24:  MOVF   FF2,W
0E26:  MOVWF  00
0E28:  BCF    FF2.7
0E2A:  CLRF   F75
0E2C:  MOVLW  02
0E2E:  MOVWF  F74
0E30:  MOVFF  98D,F73
0E34:  BCF    F7F.6
0E36:  BCF    F7F.7
0E38:  BSF    F7F.2
0E3A:  MOVLB  F
0E3C:  MOVLW  55
0E3E:  MOVWF  F7E
0E40:  MOVLW  AA
0E42:  MOVWF  F7E
0E44:  BSF    F7F.1
0E46:  BTFSC  F7F.1
0E48:  BRA    0E46
0E4A:  BCF    F7F.2
0E4C:  MOVF   00,W
0E4E:  IORWF  FF2,F
0E50:  MOVLB  0
0E52:  RETURN 0
.................... 
.................... //	fprintf(STREAM_WORLD,"# write_device_file crc=%u\r\n",crc);
.................... }
.................... 
.................... /* load device configuration from program memory */
.................... void write_default_device_file(void) {
.................... 	int8 i;
.................... 
.................... 	/* green LED for 1.5 seconds */
.................... 	timers.led_on_green=150;
0E54:  MOVLW  96
0E56:  MOVLB  3
0E58:  MOVWF  x64
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# disabling all devices\r\n");
.................... #endif
.................... 
.................... 	/* disable all devices */
.................... 	for ( i=0 ; i<DEV_MAX_N ; i++ ) {
0E5A:  MOVLB  9
0E5C:  CLRF   x8C
0E5E:  MOVF   x8C,W
0E60:  SUBLW  3F
0E62:  BNC   0E88
.................... 		device[i].type=DEV_TYPE_DISABLED;	
0E64:  CLRF   x95
0E66:  MOVFF  98C,994
0E6A:  CLRF   x97
0E6C:  MOVLW  0D
0E6E:  MOVWF  x96
0E70:  MOVLB  0
0E72:  RCALL  0DE0
0E74:  MOVLW  21
0E76:  MOVLB  9
0E78:  ADDWF  01,W
0E7A:  MOVWF  FE9
0E7C:  MOVLW  00
0E7E:  ADDWFC 02,W
0E80:  MOVWF  FEA
0E82:  CLRF   FEF
.................... 	}
.................... 
.................... #if 0
.................... 	/* UAF Fairway */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4790; 
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4791; 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4792; 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Fairway on A4800 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4806; /*  4264646 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4808; /* 4264648 */
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38;
.................... 	device[2].serialNumber=('A'<<16) + 4807; /* 4264647 */ 
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 0
.................... 	/* UVIC Spare Panel on A4810 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[0].transmitEvery=1;
.................... 	device[0].networkAddress=0x3e;
.................... 	device[0].serialNumber=('A'<<16) + 4801; /* 4264641 */
.................... 	device[0].startRegister=0;
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[1].transmitEvery=1;
.................... 	device[1].networkAddress=0x36;
.................... 	device[1].serialNumber=('A'<<16) + 4802; /* 4264642 */ 
.................... 	device[1].startRegister=0;
.................... 	device[1].nRegisters=32;
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
.................... 	device[2].transmitEvery=1;
.................... 	device[2].networkAddress=0x38; 
.................... 	device[2].serialNumber=('A'<<16) + 4803; /* 4264643 */
.................... 	device[2].startRegister=0;
.................... 	device[2].nRegisters=32;
.................... #endif
.................... 
.................... #if 1
0E84:  INCF   x8C,F
0E86:  BRA    0E5E
.................... 	/* JJJ Test board on A4820 */
.................... 	/* dcswc_module_latching_contactor */
.................... 	device[0].type=DEV_TYPE_I2C_READ_8;
0E88:  MOVLW  10
0E8A:  MOVWF  21
.................... 	device[0].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0E8C:  MOVLW  7D
0E8E:  MOVWF  23
0E90:  CLRF   22
.................... 	device[0].transmitEvery=1;
0E92:  MOVLW  01
0E94:  MOVWF  24
.................... 	device[0].networkAddress=0x3e;
0E96:  MOVLW  3E
0E98:  MOVWF  25
.................... 	device[0].serialNumber=('A'<<16) + 4821; 
0E9A:  CLRF   29
0E9C:  MOVLW  41
0E9E:  MOVWF  28
0EA0:  MOVLW  12
0EA2:  MOVWF  27
0EA4:  MOVLW  D5
0EA6:  MOVWF  26
.................... 	device[0].startRegister=0;
0EA8:  CLRF   2B
0EAA:  CLRF   2A
.................... 	device[0].nRegisters=3*2; /* three two byte registers */
0EAC:  MOVLW  06
0EAE:  MOVWF  2C
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[1].type=DEV_TYPE_I2C_READ_8;
0EB0:  MOVLW  10
0EB2:  MOVWF  2E
.................... 	device[1].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0EB4:  MOVLW  7D
0EB6:  MOVWF  30
0EB8:  CLRF   2F
.................... 	device[1].transmitEvery=1;
0EBA:  MOVLW  01
0EBC:  MOVWF  31
.................... 	device[1].networkAddress=0x36;
0EBE:  MOVLW  36
0EC0:  MOVWF  32
.................... 	device[1].serialNumber=('A'<<16) + 4822; 
0EC2:  CLRF   36
0EC4:  MOVLW  41
0EC6:  MOVWF  35
0EC8:  MOVLW  12
0ECA:  MOVWF  34
0ECC:  MOVLW  D6
0ECE:  MOVWF  33
.................... 	device[1].startRegister=0;
0ED0:  CLRF   38
0ED2:  CLRF   37
.................... 	device[1].nRegisters=32;
0ED4:  MOVLW  20
0ED6:  MOVWF  39
.................... 
.................... 	/* dcswc_module_voltage_current_counter */
.................... 	device[2].type=DEV_TYPE_I2C_READ_8;
0ED8:  MOVLW  10
0EDA:  MOVWF  3B
.................... 	device[2].typeWorld=DEVICE_TYPE_WORLD_RSDATA;
0EDC:  MOVLW  7D
0EDE:  MOVWF  3D
0EE0:  CLRF   3C
.................... 	device[2].transmitEvery=1;
0EE2:  MOVLW  01
0EE4:  MOVWF  3E
.................... 	device[2].networkAddress=0x38;
0EE6:  MOVLW  38
0EE8:  MOVWF  3F
.................... 	device[2].serialNumber=('A'<<16) + 4823; 
0EEA:  CLRF   43
0EEC:  MOVLW  41
0EEE:  MOVWF  42
0EF0:  MOVLW  12
0EF2:  MOVWF  41
0EF4:  MOVLW  D7
0EF6:  MOVWF  40
.................... 	device[2].startRegister=0;
0EF8:  CLRF   45
0EFA:  CLRF   44
.................... 	device[2].nRegisters=32;
0EFC:  MOVLW  20
0EFE:  MOVWF  46
.................... #endif
.................... 
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# write_device_file()\r\n");
.................... #endif
.................... 
.................... 	write_device_file();
0F00:  MOVLB  0
0F02:  RCALL  0E02
0F04:  RETURN 0
.................... }
.................... 
.................... void read_device_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(DEVICE_ADDRESS,(void *)&device, sizeof(device)); 
*
0FDA:  MOVLB  9
0FDC:  MOVLW  21
0FDE:  MOVWF  x7B
0FE0:  CLRF   x7E
0FE2:  MOVLW  80
0FE4:  MOVWF  x7D
0FE6:  CLRF   x80
0FE8:  MOVFF  97B,97F
0FEC:  MOVLW  03
0FEE:  MOVWF  x82
0FF0:  MOVLW  40
0FF2:  MOVWF  x81
0FF4:  MOVLB  0
0FF6:  RCALL  0F06
0FF8:  MOVFF  01,97A
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# read_device_file crc=%u\r\n",crc);
.................... #endif
.................... 
.................... 	if ( crc != read_eeprom(DEVICE_CRC_ADDRESS) ) {
0FFC:  MOVFF  FF2,97B
1000:  BCF    FF2.7
1002:  CLRF   F75
1004:  MOVLW  02
1006:  MOVWF  F74
1008:  BCF    F7F.6
100A:  BCF    F7F.7
100C:  BSF    F7F.0
100E:  MOVF   F73,W
1010:  MOVLB  9
1012:  BTFSC  x7B.7
1014:  BSF    FF2.7
1016:  SUBWF  x7A,W
1018:  BZ    1020
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# read_device_file CRC mis-match. Writing new default!\r\n");
.................... #endif
.................... 		write_default_device_file();
101A:  MOVLB  0
101C:  RCALL  0E54
101E:  MOVLB  9
.................... 	}
1020:  MOVLB  0
1022:  GOTO   443A (RETURN)
.................... }
.................... 
.................... void devicesDump(void) {
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... 
.................... 	fprintf(STREAM_WORLD,"# dumping all enabled devices:\r\n");
.................... 	for ( i=0 ; i<16 ; i++ ) {
.................... 		restart_wdt();
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[i].type ) 
.................... 			continue;
.................... 
.................... 		fprintf(STREAM_WORLD,"device[%u]\r\n",i);
.................... 		fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[i].type);
.................... 		fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[i].transmitEvery);
.................... 		fprintf(STREAM_WORLD,"\tnetworkAddress=%u\r\n",device[i].networkAddress);
.................... 		fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 			make8(device[i].serialNumber,3),
.................... 			make8(device[i].serialNumber,2),
.................... 			make8(device[i].serialNumber,1),
.................... 			make8(device[i].serialNumber,0)
.................... 		);
.................... 		fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[i].startRegister);
.................... 		fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[i].nRegisters);
.................... 	}
.................... 	fprintf(STREAM_WORLD,"# done\r\n");
.................... #endif
.................... }
.................... 
.................... #include "modbus_int_uart_rdTap.c"
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2)   ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //// MASTER API:                                                                      ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /*Some defines so we can use identifiers to set things up*/
.................... #define MODBUS_TYPE_MASTER 99999
.................... #define MODBUS_TYPE_SLAVE 88888
.................... #define MODBUS_INT_RDA 77777
.................... #define MODBUS_INT_RDA2 66666
.................... #define MODBUS_INT_EXT 55555
.................... 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER
.................... 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA  // Select between external interrupt
.................... #define MODBUS_SERIAL_BAUD 9600
.................... #define MODBUS_SERIAL_RX_PIN       NET_RX   // Data receive pin
.................... #define MODBUS_SERIAL_TX_PIN       NET_TX   // Data transmit pin
.................... #define MODBUS_SERIAL_ENABLE_PIN   RS485_DE   // Controls DE pin.  RX low, TX high.
.................... #define MODBUS_SERIAL_RX_ENABLE    RS485_NOT_RE   // Controls RE pin.  Should keep low.
.................... #define MODBUS_SERIAL_TIMEOUT      100000     //in us
.................... 
.................... 
.................... #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, parity=N, stream=MODBUS_SERIAL, errors)
*
0336:  BTFSS  F9E.5
0338:  BRA    0336
033A:  MOVFF  FAB,20
033E:  MOVFF  FAE,01
0342:  BTFSS  20.1
0344:  BRA    034A
0346:  BCF    FAB.4
0348:  BSF    FAB.4
034A:  RETURN 0
*
233C:  BTFSS  F9E.4
233E:  BRA    233C
2340:  MOVWF  FAD
2342:  GOTO   234E (RETURN)
.................... #define RCV_OFF() {disable_interrupts(INT_RDA);}
.................... 
.................... 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  255      //size of send/rcv buffer
.................... 
.................... 
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
.................... 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................     if(address)\
....................     {\
....................         while(!modbus_kbhit() && --modbus_serial_wait)\
....................             delay_us(1);\
....................         if(!modbus_serial_wait)\
....................             modbus_rx.error=TIMEOUT;\
....................     }\
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... //#byte TXSTA=getenv("sfr:TXSTA")
.................... #byte TXSTA=0xfad
.................... #bit TRMT=TXSTA.1
.................... 
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }   
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    int8 b[2];
....................    int16 d;
.................... } modbus_serial_crc;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void rcv_on(void) {
.................... 	// Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
.................... 	while(kbhit(MODBUS_SERIAL)) {
*
1026:  BTFSS  F9E.5
1028:  BRA    1030
.................... 		fgetc(MODBUS_SERIAL);
102A:  CALL   0336
102E:  BRA    1026
.................... 	}  
.................... 	
.................... 	clear_interrupt(INT_RDA);
1030:  MOVF   FAE,W
.................... //	output_low(MODBUS_SERIAL_RX_ENABLE);
.................... 	output_low(RS485_DE);
1032:  BCF    F94.5
1034:  BCF    F8B.5
.................... 	enable_interrupts(INT_RDA);
1036:  BSF    F9D.5
1038:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init()
.................... {
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
103A:  BCF    F94.5
103C:  BCF    F8B.5
.................... 
....................    RCV_ON();
103E:  RCALL  1026
.................... 
.................... //   setup_timer_2(T2_DIV_BY_16,249,5);   //10ms interrupts
....................    setup_timer_2(T2_DIV_BY_16,249,10);   //20ms interrupts
1040:  MOVLW  48
1042:  IORLW  06
1044:  MOVWF  FCA
1046:  MOVLW  F9
1048:  MOVWF  FCB
.................... 
....................    enable_interrupts(GLOBAL);
104A:  MOVLW  C0
104C:  IORWF  FF2,F
104E:  GOTO   4440 (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... void modbus_enable_timeout(int1 enable)
.................... {
....................    disable_interrupts(INT_TIMER2);
*
02F2:  BCF    F9D.1
....................    if (enable) {
02F4:  MOVLB  9
02F6:  MOVF   x9C,F
02F8:  BZ    0300
....................       set_timer2(0);
02FA:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2);
02FC:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2);
02FE:  BSF    F9D.1
....................    }
0300:  MOVLB  0
0302:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... #int_timer2
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
0304:  MOVLB  5
0306:  MOVF   x90,W
0308:  SUBLW  02
030A:  BNZ   0320
030C:  MOVF   x91,F
030E:  BNZ   0320
0310:  MOVF   x92,F
0312:  BNZ   0320
0314:  BTFSC  x8F.0
0316:  BRA    0320
....................    {
....................       modbus_rx.len-=2;
0318:  MOVLW  02
031A:  SUBWF  x94,F
....................       modbus_serial_new=TRUE;
031C:  BSF    x8F.0
....................    }
031E:  BRA    0322
....................    else
....................       modbus_serial_new=FALSE;
0320:  BCF    x8F.0
.................... 
....................    modbus_serial_crc.d=0xFFFF;
0322:  SETF   x92
0324:  SETF   x91
....................    modbus_serial_state=MODBUS_GETADDY;
0326:  CLRF   x90
....................    modbus_enable_timeout(FALSE);
0328:  MOVLB  9
032A:  CLRF   x9C
032C:  MOVLB  0
032E:  RCALL  02F2
0330:  BCF    F9E.1
0332:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................   int8 uIndex ; // will index into CRC lookup table
.................... 
....................   uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
034C:  MOVLB  5
034E:  MOVF   x92,W
0350:  MOVLB  9
0352:  XORWF  x9C,W
0354:  MOVWF  x9D
....................   modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
0356:  CLRF   03
0358:  MOVF   x9D,W
035A:  MOVLB  0
035C:  RCALL  00D2
035E:  MOVWF  01
0360:  MOVLB  5
0362:  MOVF   x91,W
0364:  XORWF  01,W
0366:  MOVWF  x92
....................   modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0368:  CLRF   03
036A:  MOVLB  9
036C:  MOVF   x9D,W
036E:  MOVLB  0
0370:  RCALL  01E2
0372:  MOVFF  FE8,591
0376:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c)
.................... {
....................    fputc(c, MODBUS_SERIAL);
*
2346:  MOVLB  9
2348:  MOVF   x90,W
234A:  MOVLB  0
234C:  BRA    233C
234E:  CLRF   19
2350:  BTFSC  FF2.7
2352:  BSF    19.7
2354:  BCF    FF2.7
....................    modbus_calc_crc(c);
2356:  MOVFF  990,99C
235A:  CALL   034C
235E:  BTFSC  19.7
2360:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
2362:  CLRWDT
2364:  MOVLW  44
2366:  MOVWF  00
2368:  DECFSZ 00,F
236A:  BRA    2368
236C:  BRA    236E
236E:  RETURN 0
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
.................... #int_rda
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
.................... #int_rda2
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT)
.................... #int_ext
.................... #else
.................... #error Please define a correct interrupt source
.................... #endif
.................... void incomming_modbus_serial() {
....................    char c;
.................... 
....................    c=fgetc(MODBUS_SERIAL);
*
0378:  RCALL  0336
037A:  MOVFF  01,99B
.................... 
....................    if (!modbus_serial_new)
037E:  MOVLB  5
0380:  BTFSC  x8F.0
0382:  BRA    03DA
....................    {
....................       if(modbus_serial_state == MODBUS_GETADDY)
0384:  MOVF   x90,F
0386:  BNZ   0398
....................       {
....................          modbus_serial_crc.d = 0xFFFF;
0388:  SETF   x92
038A:  SETF   x91
....................          modbus_rx.address = c;
038C:  MOVFF  99B,593
....................          modbus_serial_state++;
0390:  INCF   x90,F
....................          modbus_rx.len = 0;
0392:  CLRF   x94
....................          modbus_rx.error=0;
0394:  CLRF   x96
....................       }
0396:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETFUNC)
0398:  DECFSZ x90,W
039A:  BRA    03A4
....................       {
....................          modbus_rx.func = c;
039C:  MOVFF  99B,595
....................          modbus_serial_state++;
03A0:  INCF   x90,F
....................       }
03A2:  BRA    03C6
....................       else if(modbus_serial_state == MODBUS_GETDATA)
03A4:  MOVF   x90,W
03A6:  SUBLW  02
03A8:  BNZ   03C6
....................       {
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;}
03AA:  INCFSZ x94,W
03AC:  BRA    03B2
03AE:  MOVLW  FE
03B0:  MOVWF  x94
....................          modbus_rx.data[modbus_rx.len]=c;
03B2:  MOVLW  97
03B4:  ADDWF  x94,W
03B6:  MOVWF  FE9
03B8:  MOVLW  05
03BA:  MOVWF  FEA
03BC:  BTFSC  FD8.0
03BE:  INCF   FEA,F
03C0:  MOVFF  99B,FEF
....................          modbus_rx.len++;
03C4:  INCF   x94,F
....................       }
.................... 
....................       modbus_calc_crc(c);
03C6:  MOVFF  99B,99C
03CA:  MOVLB  0
03CC:  RCALL  034C
....................       modbus_enable_timeout(TRUE);
03CE:  MOVLW  01
03D0:  MOVLB  9
03D2:  MOVWF  x9C
03D4:  MOVLB  0
03D6:  RCALL  02F2
03D8:  MOVLB  5
....................    }
03DA:  BCF    F9E.5
03DC:  MOVLB  0
03DE:  GOTO   0084
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func)
.................... {
....................    modbus_serial_crc.d=0xFFFF;
*
2370:  MOVLB  5
2372:  SETF   x92
2374:  SETF   x91
....................    modbus_serial_new=FALSE;
2376:  BCF    x8F.0
.................... 
....................    RCV_OFF();
2378:  BCF    F9D.5
....................    
....................    output_high(MODBUS_SERIAL_ENABLE_PIN);
237A:  BCF    F94.5
237C:  BSF    F8B.5
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
237E:  CLRWDT
2380:  MOVLW  F2
2382:  MOVWF  00
2384:  DECFSZ 00,F
2386:  BRA    2384
.................... 
....................    modbus_serial_putc(to);
2388:  MOVFF  98D,990
238C:  MOVLB  0
238E:  RCALL  2346
....................    modbus_serial_putc(func);
2390:  MOVFF  98E,990
2394:  RCALL  2346
2396:  RETURN 0
.................... }
.................... 
.................... void modbus_serial_send_stop()
.................... {
....................    int8 crc_low, crc_high;
.................... 
.................... 
....................    crc_high=modbus_serial_crc.b[1];
2398:  MOVFF  592,98E
....................    crc_low=modbus_serial_crc.b[0];
239C:  MOVFF  591,98D
.................... 
....................    modbus_serial_putc(crc_high);
23A0:  MOVFF  98E,990
23A4:  RCALL  2346
....................    modbus_serial_putc(crc_low);
23A6:  MOVFF  98D,990
23AA:  RCALL  2346
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................    WAIT_FOR_HW_BUFFER();
23AC:  BTFSS  FAD.1
23AE:  BRA    23AC
.................... #endif
....................     
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
23B0:  CLRWDT
23B2:  MOVLW  F2
23B4:  MOVWF  00
23B6:  DECFSZ 00,F
23B8:  BRA    23B6
.................... 
.................... 
....................    RCV_ON();
23BA:  CALL   1026
.................... 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
23BE:  BCF    F94.5
23C0:  BCF    F8B.5
.................... 
....................    modbus_serial_crc.d=0xFFFF;
23C2:  MOVLB  5
23C4:  SETF   x92
23C6:  SETF   x91
23C8:  MOVLB  0
23CA:  RETURN 0
.................... 
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
23CC:  MOVLB  5
23CE:  BTFSC  x8F.0
23D0:  BRA    23DA
....................       return FALSE;
23D2:  MOVLW  00
23D4:  MOVWF  01
23D6:  BRA    23EC
23D8:  BRA    23E6
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
23DA:  BTFSS  x95.7
23DC:  BRA    23E6
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
23DE:  MOVFF  597,596
....................       modbus_rx.len = 1;
23E2:  MOVLW  01
23E4:  MOVWF  x94
....................    }
....................    modbus_serial_new=FALSE;
23E6:  BCF    x8F.0
....................    return TRUE;
23E8:  MOVLW  01
23EA:  MOVWF  01
23EC:  MOVLB  0
23EE:  RETURN 0
.................... }
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... /*MODBUS Master Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
*
27EA:  MOVFF  982,98D
27EE:  MOVLW  01
27F0:  MOVLB  9
27F2:  MOVWF  x8E
27F4:  MOVLB  0
27F6:  RCALL  2370
.................... 
....................    modbus_serial_putc(make8(start_address,1));
27F8:  MOVFF  984,990
27FC:  RCALL  2346
....................    modbus_serial_putc(make8(start_address,0));
27FE:  MOVFF  983,990
2802:  RCALL  2346
.................... 
....................    modbus_serial_putc(make8(quantity,1));
2804:  MOVFF  986,990
2808:  RCALL  2346
....................    modbus_serial_putc(make8(quantity,0));
280A:  MOVFF  985,990
280E:  RCALL  2346
.................... 
....................    modbus_serial_send_stop();
2810:  RCALL  2398
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2812:  MOVLB  9
2814:  MOVF   x82,F
2816:  BZ    286A
2818:  MOVLB  0
281A:  RCALL  23CC
281C:  MOVF   01,F
281E:  BNZ   2852
2820:  MOVLW  FF
2822:  MOVLB  5
2824:  ADDWF  x8B,F
2826:  BTFSS  FD8.0
2828:  ADDWF  x8C,F
282A:  BTFSS  FD8.0
282C:  ADDWF  x8D,F
282E:  BTFSS  FD8.0
2830:  ADDWF  x8E,F
2832:  MOVF   x8B,F
2834:  BNZ   2848
2836:  MOVF   x8C,F
2838:  BNZ   2848
283A:  MOVF   x8D,F
283C:  BNZ   2848
283E:  MOVF   x8E,F
2840:  BTFSS  FD8.2
2842:  BRA    2848
2844:  MOVLB  0
2846:  BRA    2852
2848:  CLRWDT
284A:  NOP   
284C:  MOVLB  9
284E:  BRA    2818
2850:  MOVLB  0
2852:  MOVLB  5
2854:  MOVF   x8B,F
2856:  BNZ   2868
2858:  MOVF   x8C,F
285A:  BNZ   2868
285C:  MOVF   x8D,F
285E:  BNZ   2868
2860:  MOVF   x8E,F
2862:  BNZ   2868
2864:  MOVLW  0C
2866:  MOVWF  x96
2868:  MOVLB  9
286A:  MOVLB  5
286C:  CLRF   x8E
286E:  MOVLW  01
2870:  MOVWF  x8D
2872:  MOVLW  86
2874:  MOVWF  x8C
2876:  MOVLW  A0
2878:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
287A:  MOVFF  596,01
287E:  MOVLB  0
2880:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
*
396C:  MOVFF  982,98D
3970:  MOVLW  02
3972:  MOVLB  9
3974:  MOVWF  x8E
3976:  MOVLB  0
3978:  CALL   2370
.................... 
....................    modbus_serial_putc(make8(start_address,1));
397C:  MOVFF  984,990
3980:  CALL   2346
....................    modbus_serial_putc(make8(start_address,0));
3984:  MOVFF  983,990
3988:  CALL   2346
.................... 
....................    modbus_serial_putc(make8(quantity,1));
398C:  MOVFF  986,990
3990:  CALL   2346
....................    modbus_serial_putc(make8(quantity,0));
3994:  MOVFF  985,990
3998:  CALL   2346
.................... 
....................    modbus_serial_send_stop();
399C:  CALL   2398
....................       
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
39A0:  MOVLB  9
39A2:  MOVF   x82,F
39A4:  BZ    39FA
39A6:  MOVLB  0
39A8:  CALL   23CC
39AC:  MOVF   01,F
39AE:  BNZ   39E2
39B0:  MOVLW  FF
39B2:  MOVLB  5
39B4:  ADDWF  x8B,F
39B6:  BTFSS  FD8.0
39B8:  ADDWF  x8C,F
39BA:  BTFSS  FD8.0
39BC:  ADDWF  x8D,F
39BE:  BTFSS  FD8.0
39C0:  ADDWF  x8E,F
39C2:  MOVF   x8B,F
39C4:  BNZ   39D8
39C6:  MOVF   x8C,F
39C8:  BNZ   39D8
39CA:  MOVF   x8D,F
39CC:  BNZ   39D8
39CE:  MOVF   x8E,F
39D0:  BTFSS  FD8.2
39D2:  BRA    39D8
39D4:  MOVLB  0
39D6:  BRA    39E2
39D8:  CLRWDT
39DA:  NOP   
39DC:  MOVLB  9
39DE:  BRA    39A6
39E0:  MOVLB  0
39E2:  MOVLB  5
39E4:  MOVF   x8B,F
39E6:  BNZ   39F8
39E8:  MOVF   x8C,F
39EA:  BNZ   39F8
39EC:  MOVF   x8D,F
39EE:  BNZ   39F8
39F0:  MOVF   x8E,F
39F2:  BNZ   39F8
39F4:  MOVLW  0C
39F6:  MOVWF  x96
39F8:  MOVLB  9
39FA:  MOVLB  5
39FC:  CLRF   x8E
39FE:  MOVLW  01
3A00:  MOVWF  x8D
3A02:  MOVLW  86
3A04:  MOVWF  x8C
3A06:  MOVLW  A0
3A08:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
3A0A:  MOVFF  596,01
3A0E:  MOVLB  0
3A10:  GOTO   3DA6 (RETURN)
.................... }
.................... 
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
*
2488:  MOVFF  982,98D
248C:  MOVLW  03
248E:  MOVLB  9
2490:  MOVWF  x8E
2492:  MOVLB  0
2494:  RCALL  2370
.................... 
....................    modbus_serial_putc(make8(start_address,1));
2496:  MOVFF  984,990
249A:  RCALL  2346
....................    modbus_serial_putc(make8(start_address,0));
249C:  MOVFF  983,990
24A0:  RCALL  2346
.................... 
....................    modbus_serial_putc(make8(quantity,1));
24A2:  MOVFF  986,990
24A6:  RCALL  2346
....................    modbus_serial_putc(make8(quantity,0));
24A8:  MOVFF  985,990
24AC:  RCALL  2346
.................... 
....................    modbus_serial_send_stop();
24AE:  RCALL  2398
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
24B0:  MOVLB  9
24B2:  MOVF   x82,F
24B4:  BZ    2508
24B6:  MOVLB  0
24B8:  RCALL  23CC
24BA:  MOVF   01,F
24BC:  BNZ   24F0
24BE:  MOVLW  FF
24C0:  MOVLB  5
24C2:  ADDWF  x8B,F
24C4:  BTFSS  FD8.0
24C6:  ADDWF  x8C,F
24C8:  BTFSS  FD8.0
24CA:  ADDWF  x8D,F
24CC:  BTFSS  FD8.0
24CE:  ADDWF  x8E,F
24D0:  MOVF   x8B,F
24D2:  BNZ   24E6
24D4:  MOVF   x8C,F
24D6:  BNZ   24E6
24D8:  MOVF   x8D,F
24DA:  BNZ   24E6
24DC:  MOVF   x8E,F
24DE:  BTFSS  FD8.2
24E0:  BRA    24E6
24E2:  MOVLB  0
24E4:  BRA    24F0
24E6:  CLRWDT
24E8:  NOP   
24EA:  MOVLB  9
24EC:  BRA    24B6
24EE:  MOVLB  0
24F0:  MOVLB  5
24F2:  MOVF   x8B,F
24F4:  BNZ   2506
24F6:  MOVF   x8C,F
24F8:  BNZ   2506
24FA:  MOVF   x8D,F
24FC:  BNZ   2506
24FE:  MOVF   x8E,F
2500:  BNZ   2506
2502:  MOVLW  0C
2504:  MOVWF  x96
2506:  MOVLB  9
2508:  MOVLB  5
250A:  CLRF   x8E
250C:  MOVLW  01
250E:  MOVWF  x8D
2510:  MOVLW  86
2512:  MOVWF  x8C
2514:  MOVLW  A0
2516:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
2518:  MOVFF  596,01
251C:  MOVLB  0
251E:  RETURN 0
.................... }
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
*
23F0:  MOVFF  982,98D
23F4:  MOVLW  04
23F6:  MOVLB  9
23F8:  MOVWF  x8E
23FA:  MOVLB  0
23FC:  RCALL  2370
.................... 
....................    modbus_serial_putc(make8(start_address,1));
23FE:  MOVFF  984,990
2402:  RCALL  2346
....................    modbus_serial_putc(make8(start_address,0));
2404:  MOVFF  983,990
2408:  RCALL  2346
.................... 
.................... 
....................    modbus_serial_putc(make8(quantity,1));
240A:  MOVFF  986,990
240E:  RCALL  2346
....................    modbus_serial_putc(make8(quantity,0));
2410:  MOVFF  985,990
2414:  RCALL  2346
.................... 
....................    modbus_serial_send_stop();
2416:  RCALL  2398
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
2418:  MOVLB  9
241A:  MOVF   x82,F
241C:  BZ    2470
241E:  MOVLB  0
2420:  RCALL  23CC
2422:  MOVF   01,F
2424:  BNZ   2458
2426:  MOVLW  FF
2428:  MOVLB  5
242A:  ADDWF  x8B,F
242C:  BTFSS  FD8.0
242E:  ADDWF  x8C,F
2430:  BTFSS  FD8.0
2432:  ADDWF  x8D,F
2434:  BTFSS  FD8.0
2436:  ADDWF  x8E,F
2438:  MOVF   x8B,F
243A:  BNZ   244E
243C:  MOVF   x8C,F
243E:  BNZ   244E
2440:  MOVF   x8D,F
2442:  BNZ   244E
2444:  MOVF   x8E,F
2446:  BTFSS  FD8.2
2448:  BRA    244E
244A:  MOVLB  0
244C:  BRA    2458
244E:  CLRWDT
2450:  NOP   
2452:  MOVLB  9
2454:  BRA    241E
2456:  MOVLB  0
2458:  MOVLB  5
245A:  MOVF   x8B,F
245C:  BNZ   246E
245E:  MOVF   x8C,F
2460:  BNZ   246E
2462:  MOVF   x8D,F
2464:  BNZ   246E
2466:  MOVF   x8E,F
2468:  BNZ   246E
246A:  MOVLW  0C
246C:  MOVWF  x96
246E:  MOVLB  9
2470:  MOVLB  5
2472:  CLRF   x8E
2474:  MOVLW  01
2476:  MOVWF  x8D
2478:  MOVLW  86
247A:  MOVWF  x8C
247C:  MOVLW  A0
247E:  MOVWF  x8B
.................... 
.................... 
.................... 
....................    return modbus_rx.error;
2480:  MOVFF  596,01
2484:  MOVLB  0
2486:  RETURN 0
.................... }
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
*
3A14:  MOVFF  983,98D
3A18:  MOVLW  05
3A1A:  MOVLB  9
3A1C:  MOVWF  x8E
3A1E:  MOVLB  0
3A20:  CALL   2370
.................... 
....................    modbus_serial_putc(make8(output_address,1));
3A24:  MOVFF  985,990
3A28:  CALL   2346
....................    modbus_serial_putc(make8(output_address,0));
3A2C:  MOVFF  984,990
3A30:  CALL   2346
.................... 
....................    if(on)
3A34:  MOVLB  9
3A36:  MOVF   x86,F
3A38:  BZ    3A46
....................        modbus_serial_putc(0xFF);
3A3A:  SETF   x90
3A3C:  MOVLB  0
3A3E:  CALL   2346
3A42:  BRA    3A4E
3A44:  MOVLB  9
....................    else
....................        modbus_serial_putc(0x00);
3A46:  CLRF   x90
3A48:  MOVLB  0
3A4A:  CALL   2346
....................    
....................    modbus_serial_putc(0x00);
3A4E:  MOVLB  9
3A50:  CLRF   x90
3A52:  MOVLB  0
3A54:  CALL   2346
.................... 
....................    modbus_serial_send_stop();
3A58:  CALL   2398
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
3A5C:  MOVLB  9
3A5E:  MOVF   x83,F
3A60:  BZ    3AB6
3A62:  MOVLB  0
3A64:  CALL   23CC
3A68:  MOVF   01,F
3A6A:  BNZ   3A9E
3A6C:  MOVLW  FF
3A6E:  MOVLB  5
3A70:  ADDWF  x8B,F
3A72:  BTFSS  FD8.0
3A74:  ADDWF  x8C,F
3A76:  BTFSS  FD8.0
3A78:  ADDWF  x8D,F
3A7A:  BTFSS  FD8.0
3A7C:  ADDWF  x8E,F
3A7E:  MOVF   x8B,F
3A80:  BNZ   3A94
3A82:  MOVF   x8C,F
3A84:  BNZ   3A94
3A86:  MOVF   x8D,F
3A88:  BNZ   3A94
3A8A:  MOVF   x8E,F
3A8C:  BTFSS  FD8.2
3A8E:  BRA    3A94
3A90:  MOVLB  0
3A92:  BRA    3A9E
3A94:  CLRWDT
3A96:  NOP   
3A98:  MOVLB  9
3A9A:  BRA    3A62
3A9C:  MOVLB  0
3A9E:  MOVLB  5
3AA0:  MOVF   x8B,F
3AA2:  BNZ   3AB4
3AA4:  MOVF   x8C,F
3AA6:  BNZ   3AB4
3AA8:  MOVF   x8D,F
3AAA:  BNZ   3AB4
3AAC:  MOVF   x8E,F
3AAE:  BNZ   3AB4
3AB0:  MOVLW  0C
3AB2:  MOVWF  x96
3AB4:  MOVLB  9
3AB6:  MOVLB  5
3AB8:  CLRF   x8E
3ABA:  MOVLW  01
3ABC:  MOVWF  x8D
3ABE:  MOVLW  86
3AC0:  MOVWF  x8C
3AC2:  MOVLW  A0
3AC4:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
3AC6:  MOVFF  596,01
3ACA:  MOVLB  0
3ACC:  GOTO   3E28 (RETURN)
.................... }
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
3AD0:  MOVFF  986,98D
3AD4:  MOVLW  06
3AD6:  MOVLB  9
3AD8:  MOVWF  x8E
3ADA:  MOVLB  0
3ADC:  CALL   2370
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
3AE0:  MOVFF  988,990
3AE4:  CALL   2346
....................    modbus_serial_putc(make8(reg_address,0));
3AE8:  MOVFF  987,990
3AEC:  CALL   2346
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
3AF0:  MOVFF  98A,990
3AF4:  CALL   2346
....................    modbus_serial_putc(make8(reg_value,0));
3AF8:  MOVFF  989,990
3AFC:  CALL   2346
.................... 
....................    modbus_serial_send_stop();
3B00:  CALL   2398
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
3B04:  MOVLB  9
3B06:  MOVF   x86,F
3B08:  BZ    3B5E
3B0A:  MOVLB  0
3B0C:  CALL   23CC
3B10:  MOVF   01,F
3B12:  BNZ   3B46
3B14:  MOVLW  FF
3B16:  MOVLB  5
3B18:  ADDWF  x8B,F
3B1A:  BTFSS  FD8.0
3B1C:  ADDWF  x8C,F
3B1E:  BTFSS  FD8.0
3B20:  ADDWF  x8D,F
3B22:  BTFSS  FD8.0
3B24:  ADDWF  x8E,F
3B26:  MOVF   x8B,F
3B28:  BNZ   3B3C
3B2A:  MOVF   x8C,F
3B2C:  BNZ   3B3C
3B2E:  MOVF   x8D,F
3B30:  BNZ   3B3C
3B32:  MOVF   x8E,F
3B34:  BTFSS  FD8.2
3B36:  BRA    3B3C
3B38:  MOVLB  0
3B3A:  BRA    3B46
3B3C:  CLRWDT
3B3E:  NOP   
3B40:  MOVLB  9
3B42:  BRA    3B0A
3B44:  MOVLB  0
3B46:  MOVLB  5
3B48:  MOVF   x8B,F
3B4A:  BNZ   3B5C
3B4C:  MOVF   x8C,F
3B4E:  BNZ   3B5C
3B50:  MOVF   x8D,F
3B52:  BNZ   3B5C
3B54:  MOVF   x8E,F
3B56:  BNZ   3B5C
3B58:  MOVLW  0C
3B5A:  MOVWF  x96
3B5C:  MOVLB  9
3B5E:  MOVLB  5
3B60:  CLRF   x8E
3B62:  MOVLW  01
3B64:  MOVWF  x8D
3B66:  MOVLW  86
3B68:  MOVWF  x8C
3B6A:  MOVLW  A0
3B6C:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
3B6E:  MOVFF  596,01
3B72:  MOVLB  0
3B74:  GOTO   3E7E (RETURN)
.................... }
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity,
....................                            int8 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = (int8)((quantity/8));
....................    
....................    if(quantity%8)
....................       count++;      
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
....................    
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < quantity; ++i)
....................    {
....................       modbus_serial_putc(make8(values[i],1));
....................       modbus_serial_putc(make8(values[i],0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... exception modbus_write_multiple_registers_flip(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
3B78:  BCF    FD8.0
3B7A:  MOVLB  9
3B7C:  RLCF   x87,W
3B7E:  MOVWF  02
3B80:  RLCF   x88,W
3B82:  MOVFF  02,98C
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
3B86:  MOVFF  984,98D
3B8A:  MOVLW  10
3B8C:  MOVWF  x8E
3B8E:  MOVLB  0
3B90:  CALL   2370
.................... 
....................    modbus_serial_putc(make8(start_address,1));
3B94:  MOVFF  986,990
3B98:  CALL   2346
....................    modbus_serial_putc(make8(start_address,0));
3B9C:  MOVFF  985,990
3BA0:  CALL   2346
.................... 
....................    modbus_serial_putc(make8(quantity,1));
3BA4:  MOVFF  988,990
3BA8:  CALL   2346
....................    modbus_serial_putc(make8(quantity,0));
3BAC:  MOVFF  987,990
3BB0:  CALL   2346
....................    
....................    modbus_serial_putc(count);
3BB4:  MOVFF  98C,990
3BB8:  CALL   2346
.................... 
....................    for(i=0; i < quantity; ++i)
3BBC:  MOVLB  9
3BBE:  CLRF   x8B
3BC0:  MOVF   x88,F
3BC2:  BNZ   3BCA
3BC4:  MOVF   x87,W
3BC6:  SUBWF  x8B,W
3BC8:  BC    3C22
....................    {
....................       modbus_serial_putc(make8(values[i],0));
3BCA:  CLRF   03
3BCC:  MOVFF  98B,02
3BD0:  BCF    FD8.0
3BD2:  RLCF   02,F
3BD4:  RLCF   03,F
3BD6:  MOVF   02,W
3BD8:  ADDWF  x89,W
3BDA:  MOVWF  FE9
3BDC:  MOVF   x8A,W
3BDE:  ADDWFC 03,W
3BE0:  MOVWF  FEA
3BE2:  MOVFF  FEC,98E
3BE6:  MOVF   FED,F
3BE8:  MOVFF  FEF,990
3BEC:  MOVLB  0
3BEE:  CALL   2346
....................       modbus_serial_putc(make8(values[i],1));
3BF2:  CLRF   03
3BF4:  MOVLB  9
3BF6:  MOVFF  98B,02
3BFA:  BCF    FD8.0
3BFC:  RLCF   02,F
3BFE:  RLCF   03,F
3C00:  MOVF   02,W
3C02:  ADDWF  x89,W
3C04:  MOVWF  FE9
3C06:  MOVF   x8A,W
3C08:  ADDWFC 03,W
3C0A:  MOVWF  FEA
3C0C:  MOVFF  FEC,990
3C10:  MOVF   FED,F
3C12:  MOVFF  FEF,98D
3C16:  MOVLB  0
3C18:  CALL   2346
3C1C:  MOVLB  9
3C1E:  INCF   x8B,F
3C20:  BRA    3BC0
....................    }
.................... 
....................    modbus_serial_send_stop();
3C22:  MOVLB  0
3C24:  CALL   2398
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
3C28:  MOVLB  9
3C2A:  MOVF   x84,F
3C2C:  BZ    3C82
3C2E:  MOVLB  0
3C30:  CALL   23CC
3C34:  MOVF   01,F
3C36:  BNZ   3C6A
3C38:  MOVLW  FF
3C3A:  MOVLB  5
3C3C:  ADDWF  x8B,F
3C3E:  BTFSS  FD8.0
3C40:  ADDWF  x8C,F
3C42:  BTFSS  FD8.0
3C44:  ADDWF  x8D,F
3C46:  BTFSS  FD8.0
3C48:  ADDWF  x8E,F
3C4A:  MOVF   x8B,F
3C4C:  BNZ   3C60
3C4E:  MOVF   x8C,F
3C50:  BNZ   3C60
3C52:  MOVF   x8D,F
3C54:  BNZ   3C60
3C56:  MOVF   x8E,F
3C58:  BTFSS  FD8.2
3C5A:  BRA    3C60
3C5C:  MOVLB  0
3C5E:  BRA    3C6A
3C60:  CLRWDT
3C62:  NOP   
3C64:  MOVLB  9
3C66:  BRA    3C2E
3C68:  MOVLB  0
3C6A:  MOVLB  5
3C6C:  MOVF   x8B,F
3C6E:  BNZ   3C80
3C70:  MOVF   x8C,F
3C72:  BNZ   3C80
3C74:  MOVF   x8D,F
3C76:  BNZ   3C80
3C78:  MOVF   x8E,F
3C7A:  BNZ   3C80
3C7C:  MOVLW  0C
3C7E:  MOVWF  x96
3C80:  MOVLB  9
3C82:  MOVLB  5
3C84:  CLRF   x8E
3C86:  MOVLW  01
3C88:  MOVWF  x8D
3C8A:  MOVLW  86
3C8C:  MOVWF  x8C
3C8E:  MOVLW  A0
3C90:  MOVWF  x8B
.................... 
....................    return modbus_rx.error;
3C92:  MOVFF  596,01
3C96:  MOVLB  0
3C98:  GOTO   3EBC (RETURN)
.................... }
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(int8 address, int8 byte_count, 
....................                             modbus_read_sub_request *request)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < (byte_count/7); i+=7)
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(int8 address, int8 byte_count, 
....................                             modbus_write_sub_request *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start,
....................                                     int16 read_quantity, int16 write_start,
....................                                     int16 write_quantity,
....................                                     int16 *write_registers_value)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(read_start,1));
....................    modbus_serial_putc(make8(read_start,0));
.................... 
....................    modbus_serial_putc(make8(read_quantity,1));
....................    modbus_serial_putc(make8(read_quantity,0));
.................... 
....................    modbus_serial_putc(make8(write_start, 1));
....................    modbus_serial_putc(make8(write_start, 0));
.................... 
....................    modbus_serial_putc(make8(write_quantity, 1));
....................    modbus_serial_putc(make8(write_quantity, 0));
.................... 
....................    modbus_serial_putc((int8)(2*write_quantity));
.................... 
....................    for(i=0; i < write_quantity ; i+=2)
....................    {
....................       modbus_serial_putc(make8(write_registers_value[i], 1));
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(FIFO_address, 1));
....................    modbus_serial_putc(make8(FIFO_address, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... #else
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*reg_data);
....................       reg_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
....................    modbus_serial_putc(error);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... #endif
.................... 
.................... #include "iridium_sbd_rdTap.c"
.................... #define SBD_DEBUG 1
.................... 
.................... typedef struct {
.................... 	/* +SBDIX data from most recent */
.................... 	/* result from modem */
.................... 	int8  sbdix_response[42];
.................... 	/* parsed into */
.................... 	int8  sbdix_mo_status;
.................... 	int16 sbdix_mo_msn;
.................... 	int8  sbdix_mt_status;
.................... 	int16 sbdix_mt_msn;
.................... 	int16 sbdix_mt_length;
.................... 	int8  sbdix_mt_queued;
.................... 
.................... 
.................... 	/* "Mobile Originated" message from us to network */
.................... 	int8  mo_state;
.................... 	int8  mo_buff[272];
.................... 	int16 mo_length;
.................... 	int8  mo_try;
.................... 	int8  mo_sbdix_wait;
.................... 
.................... 	/* "Mobile Terminated" messages from network to us */
.................... 	int8  mt_ready;
.................... 	int8  mt_state;
.................... 	int8  mt_buff[256];
.................... 	int16 mt_length;
.................... 	int16 mt_checksum;
.................... 	
.................... 	/* ring alert */
.................... 	int8  ring_flag;
.................... 	int8  ring_state;
.................... 
.................... 	/* modem talking to us for status, AT commands, etc */
.................... 	int8 mr_ready;          /* 1=> message ready for consumption */
.................... 	int8 mr_buff[64];
.................... 	int8 mr_length;
.................... 	int8 mr_disable;
.................... } struct_iridium_sbd;
.................... 
.................... struct_iridium_sbd sbd={0};
.................... 
.................... int8 a_to_uint8(int8 *s) {
*
10C0:  MOVLB  9
10C2:  CLRF   x7E
....................    int8 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
10C4:  MOVFF  97D,FEA
10C8:  MOVFF  97C,FE9
10CC:  MOVF   FEF,W
10CE:  SUBLW  20
10D0:  BNZ   10DA
....................       s++;
10D2:  INCF   x7C,F
10D4:  BTFSC  FD8.2
10D6:  INCF   x7D,F
10D8:  BRA    10C4
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
10DA:  MOVFF  97D,FEA
10DE:  MOVFF  97C,FE9
10E2:  MOVFF  FEF,97F
10E6:  MOVF   x7F,W
10E8:  SUBLW  2F
10EA:  BC    1110
10EC:  MOVF   x7F,W
10EE:  SUBLW  39
10F0:  BNC   1110
....................       value *= 10;
10F2:  MOVF   x7E,W
10F4:  MULLW  0A
10F6:  MOVFF  FF3,97E
....................       value += (*s-'0');
10FA:  MOVFF  97D,FEA
10FE:  MOVFF  97C,FE9
1102:  MOVLW  30
1104:  SUBWF  FEF,W
1106:  ADDWF  x7E,F
....................       s++;
1108:  INCF   x7C,F
110A:  BTFSC  FD8.2
110C:  INCF   x7D,F
110E:  BRA    10DA
....................    }
.................... 
....................    return value;
1110:  MOVFF  97E,01
1114:  MOVLB  0
1116:  RETURN 0
.................... }
.................... 
.................... int16 a_to_uint16(int8 *s) {
*
1158:  MOVLB  9
115A:  CLRF   x7F
115C:  CLRF   x7E
....................    int16 value=0;
.................... 
....................    /* swallow white space before number */
....................    while (isspace(*s)) {
115E:  MOVFF  97D,FEA
1162:  MOVFF  97C,FE9
1166:  MOVF   FEF,W
1168:  SUBLW  20
116A:  BNZ   1174
....................       s++;
116C:  INCF   x7C,F
116E:  BTFSC  FD8.2
1170:  INCF   x7D,F
1172:  BRA    115E
....................    }
.................... 
....................    /* read number while we have digit */
....................    while (isdigit(*s)) {
1174:  MOVFF  97D,FEA
1178:  MOVFF  97C,FE9
117C:  MOVFF  FEF,980
1180:  MOVF   x80,W
1182:  SUBLW  2F
1184:  BC    11C2
1186:  MOVF   x80,W
1188:  SUBLW  39
118A:  BNC   11C2
....................       value *= 10;
118C:  MOVFF  97F,995
1190:  MOVFF  97E,994
1194:  CLRF   x97
1196:  MOVLW  0A
1198:  MOVWF  x96
119A:  MOVLB  0
119C:  RCALL  0DE0
119E:  MOVFF  02,97F
11A2:  MOVFF  01,97E
....................       value += (*s-'0');
11A6:  MOVFF  97D,FEA
11AA:  MOVLB  9
11AC:  MOVFF  97C,FE9
11B0:  MOVLW  30
11B2:  SUBWF  FEF,W
11B4:  ADDWF  x7E,F
11B6:  MOVLW  00
11B8:  ADDWFC x7F,F
....................       s++;
11BA:  INCF   x7C,F
11BC:  BTFSC  FD8.2
11BE:  INCF   x7D,F
11C0:  BRA    1174
....................    }
.................... 
....................    return value;
11C2:  MOVFF  97E,01
11C6:  MOVFF  97F,02
11CA:  MOVLB  0
11CC:  RETURN 0
.................... }
.................... 
.................... void iridium_sbdix_parse(void) {
.................... 	int8 *p;
.................... 
.................... 	/*
.................... 	 * Quick check of potential validity of response:
.................... 	 * a) valid response would need to be at least 24 characters
.................... 	 * +SBDIX: 0, 25, 0, 0, 0, 0	
.................... 	 * 012345678901234567890123456789
.................... 	 *           1         2
.................... 	 * b) mo_status always starts at character 8
.................... 	 * */
.................... 	if ( strlen(sbd.sbdix_response) < 24 || ! isdigit(sbd.sbdix_response[8] ) ) {
*
136C:  MOVLW  06
136E:  MOVLB  9
1370:  MOVWF  x7D
1372:  MOVLW  96
1374:  MOVWF  x7C
1376:  MOVLB  0
1378:  BRA    1086
137A:  MOVFF  02,97D
137E:  MOVFF  01,97C
1382:  MOVLB  9
1384:  MOVF   x7D,F
1386:  BNZ   138E
1388:  MOVF   x7C,W
138A:  SUBLW  17
138C:  BC    13A4
138E:  MOVLB  6
1390:  MOVF   x9E,W
1392:  SUBLW  2F
1394:  BTFSS  FD8.0
1396:  BRA    139C
1398:  MOVLB  9
139A:  BRA    13A4
139C:  MOVF   x9E,W
139E:  SUBLW  39
13A0:  BC    13A8
13A2:  MOVLB  9
.................... 		/* if not a digit or too short, then we give up */
.................... 		return;
13A4:  BRA    1624
13A6:  MOVLB  6
.................... 	}
.................... 	sbd.sbdix_mo_status=a_to_uint8(sbd.sbdix_response+8);
13A8:  MOVLW  06
13AA:  MOVLB  9
13AC:  MOVWF  x7D
13AE:  MOVLW  9E
13B0:  MOVWF  x7C
13B2:  MOVLB  0
13B4:  RCALL  10C0
13B6:  MOVFF  01,6C0
.................... 
.................... 	/* mo_msn (with preceeding space) starts after comma */
.................... 	p = strchr(sbd.sbdix_response+9,',');
13BA:  MOVLW  06
13BC:  MOVLB  9
13BE:  MOVWF  x7F
13C0:  MOVLW  9F
13C2:  MOVWF  x7E
13C4:  MOVLW  2C
13C6:  MOVWF  x80
13C8:  MOVLB  0
13CA:  RCALL  1118
13CC:  MOVFF  02,97B
13D0:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
13D4:  MOVLB  9
13D6:  MOVF   x7A,F
13D8:  BNZ   13E0
13DA:  MOVF   x7B,F
13DC:  BNZ   13E0
.................... 		/* not found */
.................... 		return;
13DE:  BRA    1624
.................... 	}
.................... 	p++; /* swallow the ',' */
13E0:  INCF   x7A,F
13E2:  BTFSC  FD8.2
13E4:  INCF   x7B,F
.................... 	sbd.sbdix_mo_msn=a_to_uint16(p);
13E6:  MOVFF  97B,97D
13EA:  MOVFF  97A,97C
13EE:  MOVLB  0
13F0:  RCALL  1158
13F2:  MOVFF  02,6C2
13F6:  MOVFF  01,6C1
.................... 
.................... 	/* mt_status (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
13FA:  MOVLW  01
13FC:  MOVLB  9
13FE:  ADDWF  x7A,W
1400:  MOVWF  x7C
1402:  MOVLW  00
1404:  ADDWFC x7B,W
1406:  MOVWF  x7D
1408:  MOVWF  x7F
140A:  MOVFF  97C,97E
140E:  MOVLW  2C
1410:  MOVWF  x80
1412:  MOVLB  0
1414:  RCALL  1118
1416:  MOVFF  02,97B
141A:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
141E:  MOVLB  9
1420:  MOVF   x7A,F
1422:  BNZ   142A
1424:  MOVF   x7B,F
1426:  BNZ   142A
.................... 		/* not found */
.................... 		return;
1428:  BRA    1624
.................... 	}
.................... 	p++; /* swallow the ',' */
142A:  INCF   x7A,F
142C:  BTFSC  FD8.2
142E:  INCF   x7B,F
.................... 	sbd.sbdix_mt_status=a_to_uint8(p);
1430:  MOVFF  97B,97D
1434:  MOVFF  97A,97C
1438:  MOVLB  0
143A:  RCALL  10C0
143C:  MOVFF  01,6C3
.................... 
.................... 	/* mt_msn (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
1440:  MOVLW  01
1442:  MOVLB  9
1444:  ADDWF  x7A,W
1446:  MOVWF  x7C
1448:  MOVLW  00
144A:  ADDWFC x7B,W
144C:  MOVWF  x7D
144E:  MOVWF  x7F
1450:  MOVFF  97C,97E
1454:  MOVLW  2C
1456:  MOVWF  x80
1458:  MOVLB  0
145A:  RCALL  1118
145C:  MOVFF  02,97B
1460:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
1464:  MOVLB  9
1466:  MOVF   x7A,F
1468:  BNZ   1470
146A:  MOVF   x7B,F
146C:  BNZ   1470
.................... 		/* not found */
.................... 		return;
146E:  BRA    1624
.................... 	}
.................... 	p++; /* swallow the ',' */
1470:  INCF   x7A,F
1472:  BTFSC  FD8.2
1474:  INCF   x7B,F
.................... 	sbd.sbdix_mt_msn=a_to_uint16(p);
1476:  MOVFF  97B,97D
147A:  MOVFF  97A,97C
147E:  MOVLB  0
1480:  RCALL  1158
1482:  MOVFF  02,6C5
1486:  MOVFF  01,6C4
.................... 
.................... 	/* mt_length (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
148A:  MOVLW  01
148C:  MOVLB  9
148E:  ADDWF  x7A,W
1490:  MOVWF  x7C
1492:  MOVLW  00
1494:  ADDWFC x7B,W
1496:  MOVWF  x7D
1498:  MOVWF  x7F
149A:  MOVFF  97C,97E
149E:  MOVLW  2C
14A0:  MOVWF  x80
14A2:  MOVLB  0
14A4:  RCALL  1118
14A6:  MOVFF  02,97B
14AA:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
14AE:  MOVLB  9
14B0:  MOVF   x7A,F
14B2:  BNZ   14BA
14B4:  MOVF   x7B,F
14B6:  BNZ   14BA
.................... 		/* not found */
.................... 		return;
14B8:  BRA    1624
.................... 	}
.................... 	p++; /* swallow the ',' */
14BA:  INCF   x7A,F
14BC:  BTFSC  FD8.2
14BE:  INCF   x7B,F
.................... 	sbd.sbdix_mt_length=a_to_uint16(p);
14C0:  MOVFF  97B,97D
14C4:  MOVFF  97A,97C
14C8:  MOVLB  0
14CA:  RCALL  1158
14CC:  MOVFF  02,6C7
14D0:  MOVFF  01,6C6
.................... 
.................... 	/* mt_queued (with preceeding space) starts after comma */
.................... 	p = strchr(p+1,',');
14D4:  MOVLW  01
14D6:  MOVLB  9
14D8:  ADDWF  x7A,W
14DA:  MOVWF  x7C
14DC:  MOVLW  00
14DE:  ADDWFC x7B,W
14E0:  MOVWF  x7D
14E2:  MOVWF  x7F
14E4:  MOVFF  97C,97E
14E8:  MOVLW  2C
14EA:  MOVWF  x80
14EC:  MOVLB  0
14EE:  RCALL  1118
14F0:  MOVFF  02,97B
14F4:  MOVFF  01,97A
.................... 	if ( 0 == p ) {
14F8:  MOVLB  9
14FA:  MOVF   x7A,F
14FC:  BNZ   1504
14FE:  MOVF   x7B,F
1500:  BNZ   1504
.................... 		/* not found */
.................... 		return;
1502:  BRA    1624
.................... 	}
.................... 	p++; /* swallow the ',' */
1504:  INCF   x7A,F
1506:  BTFSC  FD8.2
1508:  INCF   x7B,F
.................... 	sbd.sbdix_mt_queued=a_to_uint8(p);
150A:  MOVFF  97B,97D
150E:  MOVFF  97A,97C
1512:  MOVLB  0
1514:  RCALL  10C0
1516:  MOVFF  01,6C8
.................... 
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_sbdix_parse():\r\n");
151A:  MOVLW  E2
151C:  MOVWF  FF6
151E:  MOVLW  03
1520:  MOVWF  FF7
1522:  CALL   0C76
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_status   = %d\n",sbd.sbdix_mo_status);
1526:  MOVLW  FE
1528:  MOVWF  FF6
152A:  MOVLW  03
152C:  MOVWF  FF7
152E:  MOVLW  18
1530:  MOVLB  9
1532:  MOVWF  x7E
1534:  MOVLB  0
1536:  CALL   0C98
153A:  MOVFF  6C0,97C
153E:  MOVLW  18
1540:  MOVLB  9
1542:  MOVWF  x7D
1544:  MOVLB  0
1546:  RCALL  11FA
1548:  MOVLW  0A
154A:  BTFSS  FA4.4
154C:  BRA    154A
154E:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mo_msn      = %lu\n",sbd.sbdix_mo_msn);
1550:  MOVLW  1A
1552:  MOVWF  FF6
1554:  MOVLW  04
1556:  MOVWF  FF7
1558:  MOVLW  18
155A:  MOVLB  9
155C:  MOVWF  x7E
155E:  MOVLB  0
1560:  CALL   0C98
1564:  MOVLW  10
1566:  MOVWF  FE9
1568:  MOVFF  6C2,97D
156C:  MOVFF  6C1,97C
1570:  RCALL  12B8
1572:  MOVLW  0A
1574:  BTFSS  FA4.4
1576:  BRA    1574
1578:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_status   = %d\n",sbd.sbdix_mt_status);
157A:  MOVLW  38
157C:  MOVWF  FF6
157E:  MOVLW  04
1580:  MOVWF  FF7
1582:  MOVLW  18
1584:  MOVLB  9
1586:  MOVWF  x7E
1588:  MOVLB  0
158A:  CALL   0C98
158E:  MOVFF  6C3,97C
1592:  MOVLW  18
1594:  MOVLB  9
1596:  MOVWF  x7D
1598:  MOVLB  0
159A:  RCALL  11FA
159C:  MOVLW  0A
159E:  BTFSS  FA4.4
15A0:  BRA    159E
15A2:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_msn      = %lu\n",sbd.sbdix_mt_msn);
15A4:  MOVLW  54
15A6:  MOVWF  FF6
15A8:  MOVLW  04
15AA:  MOVWF  FF7
15AC:  MOVLW  18
15AE:  MOVLB  9
15B0:  MOVWF  x7E
15B2:  MOVLB  0
15B4:  CALL   0C98
15B8:  MOVLW  10
15BA:  MOVWF  FE9
15BC:  MOVFF  6C5,97D
15C0:  MOVFF  6C4,97C
15C4:  RCALL  12B8
15C6:  MOVLW  0A
15C8:  BTFSS  FA4.4
15CA:  BRA    15C8
15CC:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_length   = %lu\n",sbd.sbdix_mt_length);
15CE:  MOVLW  72
15D0:  MOVWF  FF6
15D2:  MOVLW  04
15D4:  MOVWF  FF7
15D6:  MOVLW  18
15D8:  MOVLB  9
15DA:  MOVWF  x7E
15DC:  MOVLB  0
15DE:  CALL   0C98
15E2:  MOVLW  10
15E4:  MOVWF  FE9
15E6:  MOVFF  6C7,97D
15EA:  MOVFF  6C6,97C
15EE:  RCALL  12B8
15F0:  MOVLW  0A
15F2:  BTFSS  FA4.4
15F4:  BRA    15F2
15F6:  MOVWF  F79
.................... 	fprintf(STREAM_WORLD,"#   sbdix_mt_queued   = %d\n",sbd.sbdix_mt_queued);
15F8:  MOVLW  90
15FA:  MOVWF  FF6
15FC:  MOVLW  04
15FE:  MOVWF  FF7
1600:  MOVLW  18
1602:  MOVLB  9
1604:  MOVWF  x7E
1606:  MOVLB  0
1608:  CALL   0C98
160C:  MOVFF  6C8,97C
1610:  MOVLW  18
1612:  MOVLB  9
1614:  MOVWF  x7D
1616:  MOVLB  0
1618:  RCALL  11FA
161A:  MOVLW  0A
161C:  BTFSS  FA4.4
161E:  BRA    161C
1620:  MOVWF  F79
1622:  MOVLB  9
.................... #endif
1624:  MOVLB  0
1626:  GOTO   44B0 (RETURN)
.................... 
.................... }
.................... 
.................... #if 0
.................... void _iridium_on(void) {
.................... 	/* turn power switch on */
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_high(CTRL_0); break;
.................... 		case 2: output_high(CTRL_1); break;
.................... 		case 3: output_high(CTRL_2); break;
.................... 		case 4: output_high(CTRL_3); break;
.................... 		case 5: output_high(CTRL_4); break;
.................... 	}
.................... 	
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000000);
.................... 
.................... }
.................... 
.................... void _iridium_off(void) {
.................... 	switch ( config.sbd_config ) {
.................... 		case 1: output_low(CTRL_0); break;
.................... 		case 2: output_low(CTRL_1); break;
.................... 		case 3: output_low(CTRL_2); break;
.................... 		case 4: output_low(CTRL_3); break;
.................... 		case 5: output_low(CTRL_4); break;
.................... 	}
.................... 
.................... 	/* set UART NRTS to turn on Iridium modem ON/OFF input */
.................... 	uart_write(UART_MCR, 0b00000010);
.................... }
.................... #endif
.................... 
.................... void iridium_mr_clear(void) {
.................... 	sbd.mr_ready=0;
*
1052:  MOVLB  8
1054:  CLRF   xE6
.................... 	sbd.mr_length=0;
1056:  MOVLB  9
1058:  CLRF   x27
105A:  MOVLB  0
105C:  RETURN 0
.................... }
.................... 
.................... void iridium_mo_clear(void) {
.................... 	sbd.mo_length=0;
*
1D74:  MOVLB  7
1D76:  CLRF   xDB
1D78:  CLRF   xDA
.................... 	sbd.mo_state=0;
1D7A:  MOVLB  6
1D7C:  CLRF   xC9
1D7E:  MOVLB  0
1D80:  RETURN 0
.................... }
.................... 
.................... void iridium_mt_clear(void) {
.................... 	sbd.mt_length=0;
.................... 	sbd.mt_state=0;
.................... }
.................... 
.................... /* if we have characters to be received, this function reads them */
.................... void iridium_getc(void) {
.................... 	int8 c;
.................... 
.................... 
.................... 	/* read character from UART */
.................... 	c = uart_getc();
*
174C:  MOVFF  01,97A
.................... 
.................... 
.................... 	if ( '\r' == c ) {
1750:  MOVLB  9
1752:  MOVF   x7A,W
1754:  SUBLW  0D
1756:  BNZ   175A
.................... 		/* except when receiving binary data, we don't care about '\r' */
.................... 		return;
1758:  BRA    17EE
.................... 	}
.................... 
.................... 	/* modem always appears to send '\r' '\n' */
.................... 	
.................... 
.................... 	if ( 0 == sbd.mr_ready ) {
175A:  MOVLB  8
175C:  MOVF   xE6,F
175E:  BNZ   17F0
.................... 		/* receiving data */
.................... 
.................... 		if ( '\n' == c && 0==sbd.mr_length ) {
1760:  MOVLB  9
1762:  MOVF   x7A,W
1764:  SUBLW  0A
1766:  BNZ   176E
1768:  MOVF   x27,F
176A:  BNZ   176E
.................... 			/* responses usually appear to be \r\nOK\r\n ... this skips the empty message */
.................... 			return;
176C:  BRA    17EE
.................... 		}
.................... 
.................... 		
.................... 		/* check for 'SBDRING' message and deal with it accordingly */
.................... 		if ( 'S'==sbd.mr_buff[0] && 'B'==sbd.mr_buff[1] && 'D'==sbd.mr_buff[2] 
.................... 			&& 'R'==sbd.mr_buff[3] && 'I'==sbd.mr_buff[4] && 'N'==sbd.mr_buff[5] && 'G'==c ) {
176E:  MOVLB  8
1770:  MOVF   xE7,W
1772:  SUBLW  53
1774:  BNZ   17B2
1776:  MOVF   xE8,W
1778:  SUBLW  42
177A:  BNZ   17B2
177C:  MOVF   xE9,W
177E:  SUBLW  44
1780:  BNZ   17B2
1782:  MOVF   xEA,W
1784:  SUBLW  52
1786:  BNZ   17B2
1788:  MOVF   xEB,W
178A:  SUBLW  49
178C:  BNZ   17B2
178E:  MOVF   xEC,W
1790:  SUBLW  4E
1792:  BNZ   17B2
1794:  MOVLB  9
1796:  MOVF   x7A,W
1798:  SUBLW  47
179A:  BTFSC  FD8.2
179C:  BRA    17A2
179E:  MOVLB  8
17A0:  BRA    17B2
.................... 			sbd.ring_flag=1;
17A2:  MOVLW  01
17A4:  MOVLB  8
17A6:  MOVWF  xE4
.................... 			iridium_mr_clear();
17A8:  MOVLB  0
17AA:  RCALL  1052
.................... 			return;
17AC:  MOVLB  9
17AE:  BRA    17EE
17B0:  MOVLB  8
.................... 		 }
.................... 
.................... 		if ( '\n' == c ) {
17B2:  MOVLB  9
17B4:  MOVF   x7A,W
17B6:  SUBLW  0A
17B8:  BNZ   17D4
.................... 			/* replace '\n' with '\0' */
.................... 			sbd.mr_buff[sbd.mr_length]='\0';
17BA:  MOVLW  E7
17BC:  ADDWF  x27,W
17BE:  MOVWF  FE9
17C0:  MOVLW  08
17C2:  MOVWF  FEA
17C4:  BTFSC  FD8.0
17C6:  INCF   FEA,F
17C8:  CLRF   FEF
.................... 			
.................... 			/* mark that we have a message ready */
.................... 			sbd.mr_ready=1;
17CA:  MOVLW  01
17CC:  MOVLB  8
17CE:  MOVWF  xE6
.................... 
.................... 			/* done */
.................... 			return;
17D0:  MOVLB  9
17D2:  BRA    17EE
.................... 		}
.................... 
.................... 
.................... 		/* put in response buffer if not full */
.................... 		if ( sbd.mr_length < ( sizeof(sbd.mr_buff) - 1 ) ) {
17D4:  MOVF   x27,W
17D6:  SUBLW  3E
17D8:  BNC   17EE
.................... 			sbd.mr_buff[sbd.mr_length]=c;
17DA:  MOVLW  E7
17DC:  ADDWF  x27,W
17DE:  MOVWF  FE9
17E0:  MOVLW  08
17E2:  MOVWF  FEA
17E4:  BTFSC  FD8.0
17E6:  INCF   FEA,F
17E8:  MOVFF  97A,FEF
.................... 			sbd.mr_length++;
17EC:  INCF   x27,F
.................... 		} else {
17EE:  MOVLB  8
.................... 			/* buffer is full ... do nothing and wait for message to be terminated */
.................... 		}
.................... 	}
17F0:  MOVLB  0
17F2:  GOTO   4520 (RETURN)
.................... }
.................... 
.................... void iridium_ringing(void) {
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_ringing() sbd.ring_state=%u\r\n",sbd.ring_state);
.................... #endif
.................... 
.................... 	if ( 0 == sbd.ring_state ) {
.................... 		/* nothing to do */
.................... 		return;
.................... 	}else if ( 1 == sbd.ring_state ) {
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"ATE0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.ring_state ) {
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT&K0\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}	
.................... 	} else if ( 5 == sbd.ring_state ) {
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.ring_state ) {
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
.................... 				sbd.ring_state++;
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
.................... 		}
.................... 	} else if ( 7 == sbd.ring_state ) {
.................... 		/* send 'AT+CRIS' to determine why we rang */
.................... 		iridium_mr_clear();
.................... 		printf(uart_putc,"AT+CRIS\r");
.................... 		sbd.ring_state++;
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.ring_state ) {
.................... 		/* parse CRIS response. But in reality, with an SBD only device it can only be SBD message that causes us to ring */
.................... 	} 
.................... 
.................... }
.................... 
.................... void iridium_mo_send(void) {
.................... 	int16 l;
.................... 	int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... //	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u sbd.mo_sbdix_wait=%u\r\n",sbd.mo_state,sbd.mo_try,sbd.mo_sbdix_wait);
.................... #endif
.................... 
.................... 
.................... 	if ( 0 == sbd.mo_state ) {
*
1D82:  MOVLB  6
1D84:  MOVF   xC9,F
1D86:  BNZ   1D8C
.................... 		/* nothing to do */
.................... 		return;
1D88:  BRA    2336
.................... 
.................... 	} else if ( 1 == sbd.mo_state ) {
1D8A:  BRA    2332
1D8C:  DECFSZ xC9,W
1D8E:  BRA    1DA6
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
1D90:  MOVLB  0
1D92:  CALL   1052
.................... 		printf(uart_putc,"ATE0\r");
1D96:  MOVLW  FA
1D98:  MOVWF  FF6
1D9A:  MOVLW  04
1D9C:  MOVWF  FF7
1D9E:  RCALL  1806
.................... 		sbd.mo_state++;
1DA0:  MOVLB  6
1DA2:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mo_state ) {
1DA4:  BRA    2332
1DA6:  MOVF   xC9,W
1DA8:  SUBLW  02
1DAA:  BNZ   1DD0
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1DAC:  MOVLB  8
1DAE:  DECFSZ xE6,W
1DB0:  BRA    1DCC
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1DB2:  MOVF   xE7,W
1DB4:  SUBLW  4F
1DB6:  BNZ   1DC4
1DB8:  MOVF   xE8,W
1DBA:  SUBLW  4B
1DBC:  BNZ   1DC4
.................... 				sbd.mo_state++;
1DBE:  MOVLB  6
1DC0:  INCF   xC9,F
1DC2:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
1DC4:  MOVLB  0
1DC6:  CALL   1052
1DCA:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mo_state ) {
1DCC:  BRA    2334
1DCE:  MOVLB  6
1DD0:  MOVF   xC9,W
1DD2:  SUBLW  03
1DD4:  BNZ   1DEC
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
1DD6:  MOVLB  0
1DD8:  CALL   1052
.................... 		printf(uart_putc,"AT&K0\r");
1DDC:  MOVLW  00
1DDE:  MOVWF  FF6
1DE0:  MOVLW  05
1DE2:  MOVWF  FF7
1DE4:  RCALL  1806
.................... 		sbd.mo_state++;
1DE6:  MOVLB  6
1DE8:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mo_state ) {
1DEA:  BRA    2332
1DEC:  MOVF   xC9,W
1DEE:  SUBLW  04
1DF0:  BNZ   1E16
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1DF2:  MOVLB  8
1DF4:  DECFSZ xE6,W
1DF6:  BRA    1E12
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1DF8:  MOVF   xE7,W
1DFA:  SUBLW  4F
1DFC:  BNZ   1E0A
1DFE:  MOVF   xE8,W
1E00:  SUBLW  4B
1E02:  BNZ   1E0A
.................... 				sbd.mo_state++;
1E04:  MOVLB  6
1E06:  INCF   xC9,F
1E08:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1E0A:  MOVLB  0
1E0C:  CALL   1052
1E10:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mo_state ) {
1E12:  BRA    2334
1E14:  MOVLB  6
1E16:  MOVF   xC9,W
1E18:  SUBLW  05
1E1A:  BNZ   1E32
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
1E1C:  MOVLB  0
1E1E:  CALL   1052
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
1E22:  MOVLW  08
1E24:  MOVWF  FF6
1E26:  MOVLW  05
1E28:  MOVWF  FF7
1E2A:  RCALL  1806
.................... 		sbd.mo_state++;
1E2C:  MOVLB  6
1E2E:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mo_state ) {
1E30:  BRA    2332
1E32:  MOVF   xC9,W
1E34:  SUBLW  06
1E36:  BNZ   1E5C
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
1E38:  MOVLB  8
1E3A:  DECFSZ xE6,W
1E3C:  BRA    1E58
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1E3E:  MOVF   xE7,W
1E40:  SUBLW  4F
1E42:  BNZ   1E50
1E44:  MOVF   xE8,W
1E46:  SUBLW  4B
1E48:  BNZ   1E50
.................... 				sbd.mo_state++;
1E4A:  MOVLB  6
1E4C:  INCF   xC9,F
1E4E:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1E50:  MOVLB  0
1E52:  CALL   1052
1E56:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mo_state ) {
1E58:  BRA    2334
1E5A:  MOVLB  6
1E5C:  MOVF   xC9,W
1E5E:  SUBLW  07
1E60:  BNZ   1E98
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDWB=[<SBD Message Length>]' to tell modem how long our MO */
.................... 		iridium_mr_clear();
1E62:  MOVLB  0
1E64:  CALL   1052
.................... 		printf(uart_putc,"AT+SBDWB=%lu\r",sbd.mo_length);
1E68:  MOVLW  16
1E6A:  MOVWF  FF6
1E6C:  MOVLW  05
1E6E:  MOVWF  FF7
1E70:  MOVLW  09
1E72:  MOVLB  9
1E74:  MOVWF  x7E
1E76:  MOVLB  0
1E78:  BRA    1BD4
1E7A:  MOVLW  10
1E7C:  MOVWF  FE9
1E7E:  MOVFF  7DB,97F
1E82:  MOVFF  7DA,97E
1E86:  BRA    1BFE
1E88:  MOVLW  0D
1E8A:  MOVLB  9
1E8C:  MOVWF  x87
1E8E:  MOVLB  0
1E90:  RCALL  17F6
.................... 		sbd.mo_state++;
1E92:  MOVLB  6
1E94:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mo_state ) {
1E96:  BRA    2332
1E98:  MOVF   xC9,W
1E9A:  SUBLW  08
1E9C:  BNZ   1ED4
.................... 		/* receive response 'READY' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1E9E:  MOVLB  8
1EA0:  DECFSZ xE6,W
1EA2:  BRA    1ED0
.................... 			if ( 'R'==sbd.mr_buff[0] 
....................                  && 'E'==sbd.mr_buff[1] 
....................                  && 'A'==sbd.mr_buff[2]
.................... 			     && 'D'==sbd.mr_buff[3]
.................... 			     && 'Y'==sbd.mr_buff[4]
1EA4:  MOVF   xE7,W
1EA6:  SUBLW  52
1EA8:  BNZ   1EC8
1EAA:  MOVF   xE8,W
1EAC:  SUBLW  45
1EAE:  BNZ   1EC8
1EB0:  MOVF   xE9,W
1EB2:  SUBLW  41
1EB4:  BNZ   1EC8
1EB6:  MOVF   xEA,W
1EB8:  SUBLW  44
1EBA:  BNZ   1EC8
1EBC:  MOVF   xEB,W
1EBE:  SUBLW  59
1EC0:  BNZ   1EC8
.................... 			    ) {
.................... 				sbd.mo_state++;
1EC2:  MOVLB  6
1EC4:  INCF   xC9,F
1EC6:  MOVLB  8
.................... 			}
.................... 		
.................... 			/* clear mr because either we got READY or we got a bad response */
.................... 			iridium_mr_clear();				
1EC8:  MOVLB  0
1ECA:  CALL   1052
1ECE:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 9 == sbd.mo_state ) {
1ED0:  BRA    2334
1ED2:  MOVLB  6
1ED4:  MOVF   xC9,W
1ED6:  SUBLW  09
1ED8:  BNZ   1F62
.................... 		/* send binary message and 2 byte checksum */
.................... 		iridium_mr_clear();
1EDA:  MOVLB  0
1EDC:  CALL   1052
.................... 		checksum=0;
1EE0:  MOVLB  9
1EE2:  CLRF   x7D
1EE4:  CLRF   x7C
.................... 		/* send data bytes and update checksum */
.................... 		for ( l=0 ; l<sbd.mo_length ; l++ ) {
1EE6:  CLRF   x7B
1EE8:  CLRF   x7A
1EEA:  MOVF   x7B,W
1EEC:  MOVLB  7
1EEE:  SUBWF  xDB,W
1EF0:  BNC   1F4E
1EF2:  BNZ   1F04
1EF4:  MOVF   xDA,W
1EF6:  MOVLB  9
1EF8:  SUBWF  x7A,W
1EFA:  BTFSS  FD8.0
1EFC:  BRA    1F02
1EFE:  MOVLB  7
1F00:  BRA    1F4E
1F02:  MOVLB  7
.................... 			uart_putc(sbd.mo_buff[l]);
1F04:  MOVLW  CA
1F06:  MOVLB  9
1F08:  ADDWF  x7A,W
1F0A:  MOVWF  FE9
1F0C:  MOVLW  06
1F0E:  ADDWFC x7B,W
1F10:  MOVWF  FEA
1F12:  MOVFF  FEF,987
1F16:  MOVLB  0
1F18:  RCALL  17F6
.................... 			delay_us(500);
1F1A:  CLRWDT
1F1C:  MOVLW  02
1F1E:  MOVLB  9
1F20:  MOVWF  x7E
1F22:  MOVLW  F7
1F24:  MOVWF  x7F
1F26:  MOVLB  0
1F28:  BRA    1CC6
1F2A:  MOVLB  9
1F2C:  DECFSZ x7E,F
1F2E:  BRA    1F22
.................... 			checksum += sbd.mo_buff[l];
1F30:  MOVLW  CA
1F32:  ADDWF  x7A,W
1F34:  MOVWF  FE9
1F36:  MOVLW  06
1F38:  ADDWFC x7B,W
1F3A:  MOVWF  FEA
1F3C:  MOVF   FEF,W
1F3E:  ADDWF  x7C,F
1F40:  MOVLW  00
1F42:  ADDWFC x7D,F
1F44:  INCF   x7A,F
1F46:  BTFSC  FD8.2
1F48:  INCF   x7B,F
1F4A:  BRA    1EEA
1F4C:  MOVLB  7
.................... 		}
.................... 
.................... 		/* send checksum bytes */
.................... 		uart_putc(make8(checksum,1));
1F4E:  MOVFF  97D,987
1F52:  MOVLB  0
1F54:  RCALL  17F6
.................... 		uart_putc(make8(checksum,0));
1F56:  MOVFF  97C,987
1F5A:  RCALL  17F6
.................... 
.................... 		sbd.mo_state++;
1F5C:  MOVLB  6
1F5E:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		
.................... 	} else if ( 10 == sbd.mo_state ) {
1F60:  BRA    2332
1F62:  MOVF   xC9,W
1F64:  SUBLW  0A
1F66:  BNZ   1F8A
.................... 		/* 
.................... 		receive response <Status> which means 
.................... 		
.................... 		0 => SBD message successfully written to the ISU.
.................... 
.................... 		1 => SBD message write timeout. An insufficient number of bytes were transferred 
.................... 		to ISU during the transfer period of 60 seconds.
.................... 
.................... 		2 => SBD message checksum sent from DTE does not match the checksum calculated at 
.................... 		the ISU.
.................... 
.................... 		3 => SBD message size is not correct. The maximum mobile originated SBD message 
.................... 		length is 340 bytes. The minimum mobile originated SBD message length is 1 byte.
.................... 		*/
.................... 
.................... 		/* status must be 0 */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1F68:  MOVLB  8
1F6A:  DECFSZ xE6,W
1F6C:  BRA    1F86
.................... 			if ( '0'==sbd.mr_buff[0] ) {
1F6E:  MOVF   xE7,W
1F70:  SUBLW  30
1F72:  BNZ   1F7C
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
1F74:  MOVLB  6
1F76:  INCF   xC9,F
.................... 			} else {
1F78:  BRA    1F84
1F7A:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
1F7C:  MOVLB  0
1F7E:  CALL   1052
1F82:  MOVLB  6
1F84:  MOVLB  8
.................... 			}
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mo_state ) {
1F86:  BRA    2334
1F88:  MOVLB  6
1F8A:  MOVF   xC9,W
1F8C:  SUBLW  0B
1F8E:  BNZ   1FB4
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1F90:  MOVLB  8
1F92:  DECFSZ xE6,W
1F94:  BRA    1FB0
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1F96:  MOVF   xE7,W
1F98:  SUBLW  4F
1F9A:  BNZ   1FA8
1F9C:  MOVF   xE8,W
1F9E:  SUBLW  4B
1FA0:  BNZ   1FA8
.................... 				sbd.mo_state++;
1FA2:  MOVLB  6
1FA4:  INCF   xC9,F
1FA6:  MOVLB  8
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
1FA8:  MOVLB  0
1FAA:  CALL   1052
1FAE:  MOVLB  8
.................... 		}
.................... 
.................... 	} else if ( 12 == sbd.mo_state ) {
1FB0:  BRA    2334
1FB2:  MOVLB  6
1FB4:  MOVF   xC9,W
1FB6:  SUBLW  0C
1FB8:  BNZ   201A
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
1FBA:  MOVLW  24
1FBC:  MOVWF  FF6
1FBE:  MOVLW  05
1FC0:  MOVWF  FF7
1FC2:  MOVLW  21
1FC4:  MOVLB  9
1FC6:  MOVWF  x7E
1FC8:  MOVLB  0
1FCA:  CALL   0C98
1FCE:  MOVFF  6C9,97E
1FD2:  MOVLW  1B
1FD4:  MOVLB  9
1FD6:  MOVWF  x7F
1FD8:  MOVLB  0
1FDA:  CALL   162A
1FDE:  MOVLW  47
1FE0:  MOVWF  FF6
1FE2:  MOVLW  05
1FE4:  MOVWF  FF7
1FE6:  MOVLW  08
1FE8:  MOVLB  9
1FEA:  MOVWF  x7E
1FEC:  MOVLB  0
1FEE:  CALL   0C98
.................... #endif
.................... 		/* send 'AT+SBDIX' to initiate Extended SBD Session */
.................... 
.................... 		if ( sbd.mo_try > 0 && 0 != sbd.mo_sbdix_wait ) {
1FF2:  MOVLB  7
1FF4:  MOVF   xDC,F
1FF6:  BZ    2002
1FF8:  MOVF   xDD,F
1FFA:  BZ    2002
.................... 			/* external function decrements sbd.mo_sbdix_wait once per second */
.................... 			return;
1FFC:  MOVLB  6
1FFE:  BRA    2336
2000:  MOVLB  7
.................... 		}
.................... 
.................... 		iridium_mr_clear();
2002:  MOVLB  0
2004:  CALL   1052
.................... 		printf(uart_putc,"AT+SBDIX\r");
2008:  MOVLW  50
200A:  MOVWF  FF6
200C:  MOVLW  05
200E:  MOVWF  FF7
2010:  CALL   1806
.................... 		sbd.mo_state++;
2014:  MOVLB  6
2016:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 13 == sbd.mo_state ) {
2018:  BRA    2332
201A:  MOVF   xC9,W
201C:  SUBLW  0D
201E:  BNZ   20E4
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
2020:  MOVLW  5A
2022:  MOVWF  FF6
2024:  MOVLW  05
2026:  MOVWF  FF7
2028:  MOVLW  21
202A:  MOVLB  9
202C:  MOVWF  x7E
202E:  MOVLB  0
2030:  CALL   0C98
2034:  MOVFF  6C9,97E
2038:  MOVLW  1B
203A:  MOVLB  9
203C:  MOVWF  x7F
203E:  MOVLB  0
2040:  CALL   162A
2044:  MOVLW  7D
2046:  MOVWF  FF6
2048:  MOVLW  05
204A:  MOVWF  FF7
204C:  MOVLW  08
204E:  MOVLB  9
2050:  MOVWF  x7E
2052:  MOVLB  0
2054:  CALL   0C98
.................... #endif
.................... 		/*
.................... 		receive response:
.................... 			 +SBDIX: <MO status>, <MOMSN>, <MT status>, <MTMSN>, <MT length>, <MT queued>
.................... 		which means
.................... 
.................... 		<MO status> - Any returned number with a value of 0 to 2 indicates your message 
.................... 		has been successfully transmitted. Any number above 2 indicates that the message 
.................... 		has not been successfully transmitted.
.................... 
.................... 		Per rock7 website (https://docs.rockblock.rock7.com/reference/sbdix):
.................... 		0	MO message, if any, transferred successfully.
.................... 		1	MO message, if any, transferred successfully, but the MT message in the queue was too big to be transferred.
.................... 		2	MO message, if any, transferred successfully, but the requested Location Update was not accepted.
.................... 		3 .. 4	Reserved, but indicate MO session success if used.
.................... 		5 .. 8	Reserved, but indicate MO session failure if used.
.................... 		10	GSS reported that the call did not complete in the allowed time.
.................... 		11	MO message queue at the GSS is full.
.................... 		12	MO message has too many segments.
.................... 		13	GSS reported that the session did not complete.
.................... 		14	Invalid segment size.
.................... 		15	Access is denied.
.................... 		16	ISU has been locked and may not make SBD calls (see +CULK command).
.................... 		17	Gateway not responding (local session timeout).
.................... 		18	Connection lost (RF drop).
.................... 		19	Link failure (A protocol error caused termination of the call).
.................... 		20 .. 31	Reserved, but indicate failure if used.
.................... 		32	No network service, unable to initiate call.
.................... 		33	Antenna fault, unable to initiate call.
.................... 		34	Radio is disabled, unable to initiate call (see *Rn command).
.................... 		35	ISU is busy, unable to initiate call.
.................... 		36	Try later, must wait 3 minutes since last registration.
.................... 		37	SBD service is temporarily disabled.
.................... 		38	Try later, traffic management period (see +SBDLOE command)
.................... 		39 .. 63	Reserved, but indicate failure if used.
.................... 		64	Band violation (attempt to transmit outside permitted frequency band).
.................... 		65	PLL lock failure; hardware error during attempted transmit.
.................... 
.................... 		<MOMSN> - This number denotes the MO message number and cycles between 0 and 65535.
.................... 
.................... 		<MT status>
.................... 			0 => No messages waiting to be received.
.................... 			1 => New message successfully received.
.................... 			2 => Error during mailbox check / message reception.
.................... 
.................... 		<MTMSN> - This number denotes the MT message number and cycles between 0 and 65535.
.................... 
.................... 		<MT length> - The size (in bytes) of the MT message.
.................... 
.................... 		<MT queued> - The number of MT messages in the queue waiting to be downloaded.
.................... 
.................... 		+SBDIX:32,22, 2, 0, 0, 0
....................         012345678901234567890123
....................         0         1         2
.................... 		*/
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
2058:  MOVLB  8
205A:  DECFSZ xE6,W
205C:  BRA    20E0
.................... 			if ( '+'==sbd.mr_buff[0] && 'S'==sbd.mr_buff[1] &&
.................... 			     'B'==sbd.mr_buff[2] && 'D'==sbd.mr_buff[3] &&
.................... 			     'I'==sbd.mr_buff[4] && 'X'==sbd.mr_buff[5] 
205E:  MOVF   xE7,W
2060:  SUBLW  2B
2062:  BNZ   20D8
2064:  MOVF   xE8,W
2066:  SUBLW  53
2068:  BNZ   20D8
206A:  MOVF   xE9,W
206C:  SUBLW  42
206E:  BNZ   20D8
2070:  MOVF   xEA,W
2072:  SUBLW  44
2074:  BNZ   20D8
2076:  MOVF   xEB,W
2078:  SUBLW  49
207A:  BNZ   20D8
207C:  MOVF   xEC,W
207E:  SUBLW  58
2080:  BNZ   20D8
.................... 			) {
.................... 				/* copy +SBDIX result to seperate buffer so it can be further processed for message downloading */
.................... 				if ( '\0' == sbd.sbdix_response[0] ) {
2082:  MOVLB  6
2084:  MOVF   x96,F
2086:  BNZ   20A8
.................... 					strncpy(sbd.sbdix_response,sbd.mr_buff,sizeof(sbd.sbdix_response)-1);
2088:  MOVLW  06
208A:  MOVLB  9
208C:  MOVWF  x7F
208E:  MOVLW  96
2090:  MOVWF  x7E
2092:  MOVLW  08
2094:  MOVWF  x81
2096:  MOVLW  E7
2098:  MOVWF  x80
209A:  CLRF   x83
209C:  MOVLW  29
209E:  MOVWF  x82
20A0:  MOVLB  0
20A2:  BRA    1CEC
.................... 					sbd.sbdix_response[sizeof(sbd.sbdix_response)-1]='\0';
20A4:  MOVLB  6
20A6:  CLRF   xBF
.................... 				}
.................... 
.................... 
.................... 				/* so we got an +SBDIX response. If first byte ([8]) is '0', '1', '2' and second byte ([9]) is ',' 
.................... 				we are okay to proceed and clear buffer. If it is anything else, we need to wait and try again */
.................... 				/* TODO: white space location / pading may not be consistent. Use atoi style parsing to determine MO_STATUS reliably */
.................... 				if ( ' '==sbd.mr_buff[7] && ( sbd.mr_buff[8] >= '0' && sbd.mr_buff[8] <= '2'  && ',' == sbd.mr_buff[9]) ) {
20A8:  MOVLB  8
20AA:  MOVF   xEE,W
20AC:  SUBLW  20
20AE:  BNZ   20CE
20B0:  MOVF   xEF,W
20B2:  SUBLW  2F
20B4:  BC    20CE
20B6:  MOVF   xEF,W
20B8:  SUBLW  32
20BA:  BNC   20CE
20BC:  MOVF   xF0,W
20BE:  SUBLW  2C
20C0:  BNZ   20CE
.................... 					sbd.mo_state++;
20C2:  MOVLB  6
20C4:  INCF   xC9,F
.................... 					sbd.mo_try=0;
20C6:  MOVLB  7
20C8:  CLRF   xDC
.................... 				} else {
20CA:  BRA    20D6
20CC:  MOVLB  8
.................... 					/* didn't get a 0 or 1 or 2 ... but still go on to next state for OK */
.................... 					sbd.mo_state++;
20CE:  MOVLB  6
20D0:  INCF   xC9,F
.................... 					sbd.mo_try++;
20D2:  MOVLB  7
20D4:  INCF   xDC,F
20D6:  MOVLB  8
.................... 				}
.................... 			}
.................... 
.................... 			iridium_mr_clear();				
20D8:  MOVLB  0
20DA:  CALL   1052
20DE:  MOVLB  8
.................... 		}
.................... 	} else if ( 14 == sbd.mo_state ) {
20E0:  BRA    2334
20E2:  MOVLB  6
20E4:  MOVF   xC9,W
20E6:  SUBLW  0E
20E8:  BTFSS  FD8.2
20EA:  BRA    220E
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u start\r\n",sbd.mo_state,sbd.mo_try);
20EC:  MOVLW  86
20EE:  MOVWF  FF6
20F0:  MOVLW  05
20F2:  MOVWF  FF7
20F4:  MOVLW  21
20F6:  MOVLB  9
20F8:  MOVWF  x7E
20FA:  MOVLB  0
20FC:  CALL   0C98
2100:  MOVFF  6C9,97E
2104:  MOVLW  1B
2106:  MOVLB  9
2108:  MOVWF  x7F
210A:  MOVLB  0
210C:  CALL   162A
2110:  MOVLW  A9
2112:  MOVWF  FF6
2114:  MOVLW  05
2116:  MOVWF  FF7
2118:  MOVLW  0C
211A:  MOVLB  9
211C:  MOVWF  x7E
211E:  MOVLB  0
2120:  CALL   0C98
2124:  MOVFF  7DC,97E
2128:  MOVLW  1B
212A:  MOVLB  9
212C:  MOVWF  x7F
212E:  MOVLB  0
2130:  CALL   162A
2134:  MOVLW  B7
2136:  MOVWF  FF6
2138:  MOVLW  05
213A:  MOVWF  FF7
213C:  MOVLW  08
213E:  MOVLB  9
2140:  MOVWF  x7E
2142:  MOVLB  0
2144:  CALL   0C98
.................... #endif
.................... 
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
2148:  MOVLB  8
214A:  DECFSZ xE6,W
214C:  BRA    2168
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
214E:  MOVF   xE7,W
2150:  SUBLW  4F
2152:  BNZ   2160
2154:  MOVF   xE8,W
2156:  SUBLW  4B
2158:  BNZ   2160
.................... 				sbd.mo_state++;
215A:  MOVLB  6
215C:  INCF   xC9,F
215E:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
2160:  MOVLB  0
2162:  CALL   1052
2166:  MOVLB  8
.................... 		}
.................... 
.................... 		if ( 0 != sbd.mo_try ) {
2168:  MOVLB  7
216A:  MOVF   xDC,F
216C:  BZ    21AE
.................... 			/* need to try SBDIX again */
.................... 			sbd.mo_state=12;
216E:  MOVLW  0C
2170:  MOVLB  6
2172:  MOVWF  xC9
.................... 			/* back off */
.................... 			if ( 1 == sbd.mo_try || 2 == sbd.mo_try ) {
2174:  MOVLB  7
2176:  DECFSZ xDC,W
2178:  BRA    217C
217A:  BRA    2182
217C:  MOVF   xDC,W
217E:  SUBLW  02
2180:  BNZ   2188
.................... 				sbd.mo_sbdix_wait=3;
2182:  MOVLW  03
2184:  MOVWF  xDD
.................... 			} else if ( 3 == sbd.mo_try || 4 == sbd.mo_try ) {
2186:  BRA    21AE
2188:  MOVF   xDC,W
218A:  SUBLW  03
218C:  BZ    2194
218E:  MOVF   xDC,W
2190:  SUBLW  04
2192:  BNZ   219A
.................... 				sbd.mo_sbdix_wait=21;
2194:  MOVLW  15
2196:  MOVWF  xDD
.................... 			} else if ( 5 == sbd.mo_try ) {
2198:  BRA    21AE
219A:  MOVF   xDC,W
219C:  SUBLW  05
219E:  BNZ   21A6
.................... 				sbd.mo_sbdix_wait=251;
21A0:  MOVLW  FB
21A2:  MOVWF  xDD
.................... 			} else {
21A4:  BRA    21AE
.................... 				/* give up and clear buffer */
.................... 				sbd.mo_state=15;
21A6:  MOVLW  0F
21A8:  MOVLB  6
21AA:  MOVWF  xC9
21AC:  MOVLB  7
.................... 			}
.................... 		}
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u sbd.mo_try=%u finish\r\n",sbd.mo_state,sbd.mo_try);
21AE:  MOVLW  C0
21B0:  MOVWF  FF6
21B2:  MOVLW  05
21B4:  MOVWF  FF7
21B6:  MOVLW  21
21B8:  MOVLB  9
21BA:  MOVWF  x7E
21BC:  MOVLB  0
21BE:  CALL   0C98
21C2:  MOVFF  6C9,97E
21C6:  MOVLW  1B
21C8:  MOVLB  9
21CA:  MOVWF  x7F
21CC:  MOVLB  0
21CE:  CALL   162A
21D2:  MOVLW  E3
21D4:  MOVWF  FF6
21D6:  MOVLW  05
21D8:  MOVWF  FF7
21DA:  MOVLW  0C
21DC:  MOVLB  9
21DE:  MOVWF  x7E
21E0:  MOVLB  0
21E2:  CALL   0C98
21E6:  MOVFF  7DC,97E
21EA:  MOVLW  1B
21EC:  MOVLB  9
21EE:  MOVWF  x7F
21F0:  MOVLB  0
21F2:  CALL   162A
21F6:  MOVLW  F1
21F8:  MOVWF  FF6
21FA:  MOVLW  05
21FC:  MOVWF  FF7
21FE:  MOVLW  09
2200:  MOVLB  9
2202:  MOVWF  x7E
2204:  MOVLB  0
2206:  CALL   0C98
.................... #endif
.................... 	} else if ( 15 == sbd.mo_state ) {
220A:  BRA    2332
220C:  MOVLB  6
220E:  MOVF   xC9,W
2210:  SUBLW  0F
2212:  BNZ   222C
.................... 
.................... 		/* send 'AT+SBDD=0' to clear MO buffer */
.................... 		iridium_mr_clear();
2214:  MOVLB  0
2216:  CALL   1052
.................... 		printf(uart_putc,"AT+SBDD0\r");
221A:  MOVLW  FC
221C:  MOVWF  FF6
221E:  MOVLW  05
2220:  MOVWF  FF7
2222:  CALL   1806
.................... 		sbd.mo_state++;
2226:  MOVLB  6
2228:  INCF   xC9,F
.................... 		/* TODO set response timeout */
.................... 		/* TODO ... be careful about starting over without buffer being cleared */
.................... 	} else if ( 16 == sbd.mo_state ) {
222A:  BRA    2332
222C:  MOVF   xC9,W
222E:  SUBLW  10
2230:  BNZ   228C
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
2232:  MOVLW  06
2234:  MOVWF  FF6
2236:  MOVLW  06
2238:  MOVWF  FF7
223A:  MOVLW  21
223C:  MOVLB  9
223E:  MOVWF  x7E
2240:  MOVLB  0
2242:  CALL   0C98
2246:  MOVFF  6C9,97E
224A:  MOVLW  1B
224C:  MOVLB  9
224E:  MOVWF  x7F
2250:  MOVLB  0
2252:  CALL   162A
2256:  MOVLW  29
2258:  MOVWF  FF6
225A:  MOVLW  06
225C:  MOVWF  FF7
225E:  MOVLW  08
2260:  MOVLB  9
2262:  MOVWF  x7E
2264:  MOVLB  0
2266:  CALL   0C98
.................... #endif
.................... 		if ( 1 == sbd.mr_ready ) {
226A:  MOVLB  8
226C:  DECFSZ xE6,W
226E:  BRA    2288
.................... 			if ( '0'==sbd.mr_buff[0] ) {
2270:  MOVF   xE7,W
2272:  SUBLW  30
2274:  BNZ   227E
.................... 				/* TODO BUG ... what about non-zero response */
.................... 				sbd.mo_state++;
2276:  MOVLB  6
2278:  INCF   xC9,F
.................... 			} else {
227A:  BRA    2286
227C:  MOVLB  8
.................... 				/* didn't get '0' ... clear mr message */
.................... 				iridium_mr_clear();				
227E:  MOVLB  0
2280:  CALL   1052
2284:  MOVLB  6
2286:  MOVLB  8
.................... 			}
.................... 		}
.................... 	} else if ( 17 == sbd.mo_state ) {
2288:  BRA    2334
228A:  MOVLB  6
228C:  MOVF   xC9,W
228E:  SUBLW  11
2290:  BNZ   22EE
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
2292:  MOVLW  32
2294:  MOVWF  FF6
2296:  MOVLW  06
2298:  MOVWF  FF7
229A:  MOVLW  21
229C:  MOVLB  9
229E:  MOVWF  x7E
22A0:  MOVLB  0
22A2:  CALL   0C98
22A6:  MOVFF  6C9,97E
22AA:  MOVLW  1B
22AC:  MOVLB  9
22AE:  MOVWF  x7F
22B0:  MOVLB  0
22B2:  CALL   162A
22B6:  MOVLW  55
22B8:  MOVWF  FF6
22BA:  MOVLW  06
22BC:  MOVWF  FF7
22BE:  MOVLW  08
22C0:  MOVLB  9
22C2:  MOVWF  x7E
22C4:  MOVLB  0
22C6:  CALL   0C98
.................... #endif
.................... 
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
22CA:  MOVLB  8
22CC:  DECFSZ xE6,W
22CE:  BRA    22EA
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
22D0:  MOVF   xE7,W
22D2:  SUBLW  4F
22D4:  BNZ   22E2
22D6:  MOVF   xE8,W
22D8:  SUBLW  4B
22DA:  BNZ   22E2
.................... 				sbd.mo_state++;
22DC:  MOVLB  6
22DE:  INCF   xC9,F
22E0:  MOVLB  8
.................... 			}
.................... 		
.................... 			iridium_mr_clear();				
22E2:  MOVLB  0
22E4:  CALL   1052
22E8:  MOVLB  8
.................... 		}
.................... 	} else if ( 18 == sbd.mo_state ) {
22EA:  BRA    2334
22EC:  MOVLB  6
22EE:  MOVF   xC9,W
22F0:  SUBLW  12
22F2:  BNZ   2332
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mo_send() sbd.mo_state=%u start\r\n",sbd.mo_state);
22F4:  MOVLW  5E
22F6:  MOVWF  FF6
22F8:  MOVLW  06
22FA:  MOVWF  FF7
22FC:  MOVLW  21
22FE:  MOVLB  9
2300:  MOVWF  x7E
2302:  MOVLB  0
2304:  CALL   0C98
2308:  MOVFF  6C9,97E
230C:  MOVLW  1B
230E:  MOVLB  9
2310:  MOVWF  x7F
2312:  MOVLB  0
2314:  CALL   162A
2318:  MOVLW  81
231A:  MOVWF  FF6
231C:  MOVLW  06
231E:  MOVWF  FF7
2320:  MOVLW  08
2322:  MOVLB  9
2324:  MOVWF  x7E
2326:  MOVLB  0
2328:  CALL   0C98
.................... #endif
.................... 
.................... 		/* done sending */
.................... 		/* download MT if needed? */
.................... 		/* turn off modem */
.................... //		iridium_off();
.................... 
.................... 		/* go back to waiting */
.................... 		iridium_mr_clear();
232C:  CALL   1052
.................... 		iridium_mo_clear();	
2330:  RCALL  1D74
2332:  MOVLB  8
2334:  MOVLB  6
.................... 	}
2336:  MOVLB  0
2338:  GOTO   4552 (RETURN)
.................... }
.................... 
.................... void iridium_mt_receive(void) {
.................... 	int8 c;
.................... 	static int16 l;
.................... 	static int16 checksum;
.................... 
.................... #if DEBUG_SBD
.................... 	fprintf(STREAM_WORLD,"# iridium_mt_receive() sbd.mt_state=%u\r\n",sbd.mt_state);
*
1826:  MOVLW  8A
1828:  MOVWF  FF6
182A:  MOVLW  06
182C:  MOVWF  FF7
182E:  MOVLW  24
1830:  MOVLB  9
1832:  MOVWF  x7E
1834:  MOVLB  0
1836:  CALL   0C98
183A:  MOVFF  7DF,97E
183E:  MOVLW  1B
1840:  MOVLB  9
1842:  MOVWF  x7F
1844:  MOVLB  0
1846:  RCALL  162A
1848:  MOVLW  0D
184A:  BTFSS  FA4.4
184C:  BRA    184A
184E:  MOVWF  F79
1850:  MOVLW  0A
1852:  BTFSS  FA4.4
1854:  BRA    1852
1856:  MOVWF  F79
.................... #endif
.................... 
.................... 
.................... 	if ( sbd.mt_state <= 1 ) {
1858:  MOVLB  7
185A:  MOVF   xDF,W
185C:  SUBLW  01
185E:  BNC   1878
.................... 		/* send 'ATE0' to turn off modem echo for subsequent commands */
.................... 		iridium_mr_clear();
1860:  MOVLB  0
1862:  CALL   1052
.................... 		printf(uart_putc,"ATE0\r");
1866:  MOVLW  B4
1868:  MOVWF  FF6
186A:  MOVLW  06
186C:  MOVWF  FF7
186E:  RCALL  1806
.................... 		sbd.mt_state = 2;
1870:  MOVLW  02
1872:  MOVLB  7
1874:  MOVWF  xDF
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 2 == sbd.mt_state ) {
1876:  BRA    1BCC
1878:  MOVF   xDF,W
187A:  SUBLW  02
187C:  BNZ   18A2
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
187E:  MOVLB  8
1880:  DECFSZ xE6,W
1882:  BRA    189E
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1884:  MOVF   xE7,W
1886:  SUBLW  4F
1888:  BNZ   1896
188A:  MOVF   xE8,W
188C:  SUBLW  4B
188E:  BNZ   1896
.................... 				sbd.mt_state++;
1890:  MOVLB  7
1892:  INCF   xDF,F
1894:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();				
1896:  MOVLB  0
1898:  CALL   1052
189C:  MOVLB  8
.................... 		}	
.................... 
.................... 	} else if ( 3 == sbd.mt_state ) {
189E:  BRA    1BCC
18A0:  MOVLB  7
18A2:  MOVF   xDF,W
18A4:  SUBLW  03
18A6:  BNZ   18BE
.................... 		/* send 'AT&K0' to turn off flow control */
.................... 		iridium_mr_clear();
18A8:  MOVLB  0
18AA:  CALL   1052
.................... 		printf(uart_putc,"AT&K0\r");
18AE:  MOVLW  BA
18B0:  MOVWF  FF6
18B2:  MOVLW  06
18B4:  MOVWF  FF7
18B6:  RCALL  1806
.................... 		sbd.mt_state++;
18B8:  MOVLB  7
18BA:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 4 == sbd.mt_state ) {
18BC:  BRA    1BCC
18BE:  MOVF   xDF,W
18C0:  SUBLW  04
18C2:  BNZ   18E8
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
18C4:  MOVLB  8
18C6:  DECFSZ xE6,W
18C8:  BRA    18E4
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
18CA:  MOVF   xE7,W
18CC:  SUBLW  4F
18CE:  BNZ   18DC
18D0:  MOVF   xE8,W
18D2:  SUBLW  4B
18D4:  BNZ   18DC
.................... 				sbd.mt_state++;
18D6:  MOVLB  7
18D8:  INCF   xDF,F
18DA:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
18DC:  MOVLB  0
18DE:  CALL   1052
18E2:  MOVLB  8
.................... 		}	
.................... 	} else if ( 5 == sbd.mt_state ) {
18E4:  BRA    1BCC
18E6:  MOVLB  7
18E8:  MOVF   xDF,W
18EA:  SUBLW  05
18EC:  BNZ   1904
.................... 		/* send 'AT+SBDMTA=1' to turn on ring alerts */
.................... 		iridium_mr_clear();
18EE:  MOVLB  0
18F0:  CALL   1052
.................... 		printf(uart_putc,"AT+SBDMTA=1\r");
18F4:  MOVLW  C2
18F6:  MOVWF  FF6
18F8:  MOVLW  06
18FA:  MOVWF  FF7
18FC:  RCALL  1806
.................... 		sbd.mt_state++;
18FE:  MOVLB  7
1900:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 6 == sbd.mt_state ) {
1902:  BRA    1BCC
1904:  MOVF   xDF,W
1906:  SUBLW  06
1908:  BNZ   192E
.................... 		/* receive response 'OK' */
.................... 		if ( 1 == sbd.mr_ready ) {
190A:  MOVLB  8
190C:  DECFSZ xE6,W
190E:  BRA    192A
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1910:  MOVF   xE7,W
1912:  SUBLW  4F
1914:  BNZ   1922
1916:  MOVF   xE8,W
1918:  SUBLW  4B
191A:  BNZ   1922
.................... 				sbd.mt_state++;
191C:  MOVLB  7
191E:  INCF   xDF,F
1920:  MOVLB  8
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1922:  MOVLB  0
1924:  CALL   1052
1928:  MOVLB  8
.................... 		}
.................... 	} else if ( 7 == sbd.mt_state ) {
192A:  BRA    1BCC
192C:  MOVLB  7
192E:  MOVF   xDF,W
1930:  SUBLW  07
1932:  BNZ   1952
.................... 		/* TODO do we want to clear buffer first? */
.................... 
.................... 		/* send 'AT+SBDRB' to tell modem to send us our MT */
.................... 		iridium_mr_clear();
1934:  MOVLB  0
1936:  CALL   1052
.................... 		sbd.mr_disable=1; /* switch iridum character receiver to binary */
193A:  MOVLW  01
193C:  MOVLB  9
193E:  MOVWF  x28
.................... 		printf(uart_putc,"AT+SBDRB\r");
1940:  MOVLW  D0
1942:  MOVWF  FF6
1944:  MOVLW  06
1946:  MOVWF  FF7
1948:  MOVLB  0
194A:  RCALL  1806
.................... 		sbd.mt_state++;
194C:  MOVLB  7
194E:  INCF   xDF,F
.................... 		/* TODO set response timeout */
.................... 
.................... 	} else if ( 8 == sbd.mt_state ) {
1950:  BRA    1BCC
1952:  MOVF   xDF,W
1954:  SUBLW  08
1956:  BNZ   197A
.................... 		/* receive first byte of length */
.................... 		if ( ! uart_kbhit() ) {
1958:  MOVLB  0
195A:  RCALL  1730
195C:  MOVF   01,F
195E:  BNZ   1962
.................... 			/* no character available */
.................... 			return;
1960:  BRA    1BCE
.................... 		}
.................... 	
.................... 		sbd.mt_length=make16(uart_getc(),0);
*
196C:  MOVFF  01,8E1
1970:  MOVLB  8
1972:  CLRF   xE0
.................... 		sbd.mt_state++;
1974:  MOVLB  7
1976:  INCF   xDF,F
.................... 	} else if ( 9 == sbd.mt_state ) {
1978:  BRA    1BCC
197A:  MOVF   xDF,W
197C:  SUBLW  09
197E:  BNZ   19B0
.................... 		/* receive second byte of length */
.................... 		if ( ! uart_kbhit() ) {
1980:  MOVLB  0
1982:  RCALL  1730
1984:  MOVF   01,F
1986:  BNZ   198A
.................... 			/* no character available */
.................... 			return;
1988:  BRA    1BCE
.................... 		}
.................... 	
.................... 		sbd.mt_length += uart_getc();
*
1994:  MOVF   01,W
1996:  MOVLB  8
1998:  ADDWF  xE0,F
199A:  MOVLW  00
199C:  ADDWFC xE1,F
.................... 		sbd.mt_state++;
199E:  MOVLB  7
19A0:  INCF   xDF,F
.................... 
.................... 		checksum=0;
19A2:  MOVLB  9
19A4:  CLRF   x2E
19A6:  CLRF   x2D
.................... 		l=0;
19A8:  CLRF   x2C
19AA:  CLRF   x2B
.................... 	} else if ( 10 == sbd.mt_state ) {
19AC:  BRA    1BCE
19AE:  MOVLB  7
19B0:  MOVF   xDF,W
19B2:  SUBLW  0A
19B4:  BNZ   1A20
.................... 		/* receive MT length of characters and calculate checksum */
.................... 		if ( ! uart_kbhit() ) {
19B6:  MOVLB  0
19B8:  RCALL  1730
19BA:  MOVF   01,F
19BC:  BNZ   19C0
.................... 			/* no character available */
.................... 			return;
19BE:  BRA    1BCE
.................... 		}
.................... 
.................... 		if ( 0 == sbd.mt_length ) {
19C0:  MOVLB  8
19C2:  MOVF   xE0,F
19C4:  BNZ   19D4
19C6:  MOVF   xE1,F
19C8:  BNZ   19D4
.................... 			/* zero byte message skips this state */
.................... 			sbd.mt_state++;
19CA:  MOVLB  7
19CC:  INCF   xDF,F
.................... 			return;
19CE:  MOVLB  0
19D0:  BRA    1BCE
19D2:  MOVLB  8
.................... 		}
.................... 
.................... 		c = uart_getc();
*
19DE:  MOVFF  01,97A
.................... 		sbd.mt_buff[l]=c;
19E2:  MOVLW  E0
19E4:  MOVLB  9
19E6:  ADDWF  x2B,W
19E8:  MOVWF  FE9
19EA:  MOVLW  07
19EC:  ADDWFC x2C,W
19EE:  MOVWF  FEA
19F0:  MOVFF  97A,FEF
.................... 		checksum += c;
19F4:  MOVF   x7A,W
19F6:  ADDWF  x2D,F
19F8:  MOVLW  00
19FA:  ADDWFC x2E,F
.................... 		l++;
19FC:  INCF   x2B,F
19FE:  BTFSC  FD8.2
1A00:  INCF   x2C,F
.................... 
.................... 		if ( l == sbd.mt_length ) {
1A02:  MOVLB  8
1A04:  MOVF   xE0,W
1A06:  MOVLB  9
1A08:  SUBWF  x2B,W
1A0A:  BNZ   1A1C
1A0C:  MOVLB  8
1A0E:  MOVF   xE1,W
1A10:  MOVLB  9
1A12:  SUBWF  x2C,W
1A14:  BNZ   1A1C
.................... 			/* received right number of characters */
.................... 			sbd.mt_state++;
1A16:  MOVLB  7
1A18:  INCF   xDF,F
1A1A:  MOVLB  9
.................... 		}
.................... 
.................... 	} else if ( 11 == sbd.mt_state ) {
1A1C:  BRA    1BCE
1A1E:  MOVLB  7
1A20:  MOVF   xDF,W
1A22:  SUBLW  0B
1A24:  BNZ   1A48
.................... 		if ( ! uart_kbhit() ) {
1A26:  MOVLB  0
1A28:  RCALL  1730
1A2A:  MOVF   01,F
1A2C:  BNZ   1A30
.................... 			/* no character available */
.................... 			return;
1A2E:  BRA    1BCE
.................... 		}
.................... 
.................... 		/* high byte of checksum */
.................... 		l=make16(uart_getc(),0);
*
1A3A:  MOVFF  01,92C
1A3E:  MOVLB  9
1A40:  CLRF   x2B
.................... 		sbd.mt_state++;
1A42:  MOVLB  7
1A44:  INCF   xDF,F
.................... 	} else if ( 12 == sbd.mt_state ) {
1A46:  BRA    1BCC
1A48:  MOVF   xDF,W
1A4A:  SUBLW  0C
1A4C:  BNZ   1A78
.................... 		if ( ! uart_kbhit() ) {
1A4E:  MOVLB  0
1A50:  RCALL  1730
1A52:  MOVF   01,F
1A54:  BNZ   1A58
.................... 			/* no character available */
.................... 			return;
1A56:  BRA    1BCE
.................... 		}
.................... 
.................... 		/* low byte of checksum */
.................... 		l += uart_getc();
*
1A62:  MOVF   01,W
1A64:  MOVLB  9
1A66:  ADDWF  x2B,F
1A68:  MOVLW  00
1A6A:  ADDWFC x2C,F
.................... 		sbd.mt_state++;
1A6C:  MOVLB  7
1A6E:  INCF   xDF,F
.................... 
.................... 		sbd.mr_disable=0;
1A70:  MOVLB  9
1A72:  CLRF   x28
.................... 	} else if ( 13 == sbd.mt_state ) {
1A74:  BRA    1BCE
1A76:  MOVLB  7
1A78:  MOVF   xDF,W
1A7A:  SUBLW  0D
1A7C:  BTFSS  FD8.2
1A7E:  BRA    1B86
.................... 		/* compare local and remote checksum */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# iridium_mt_receive() checksum l=%lu r=%lu\r\n",checksum,l);
1A80:  MOVLW  DA
1A82:  MOVWF  FF6
1A84:  MOVLW  06
1A86:  MOVWF  FF7
1A88:  MOVLW  22
1A8A:  MOVLB  9
1A8C:  MOVWF  x7E
1A8E:  MOVLB  0
1A90:  CALL   0C98
1A94:  MOVLW  10
1A96:  MOVWF  FE9
1A98:  MOVFF  92E,97D
1A9C:  MOVFF  92D,97C
1AA0:  RCALL  12B8
1AA2:  MOVLW  FF
1AA4:  MOVWF  FF6
1AA6:  MOVLW  06
1AA8:  MOVWF  FF7
1AAA:  MOVLW  03
1AAC:  MOVLB  9
1AAE:  MOVWF  x7E
1AB0:  MOVLB  0
1AB2:  CALL   0C98
1AB6:  MOVLW  10
1AB8:  MOVWF  FE9
1ABA:  MOVFF  92C,97D
1ABE:  MOVFF  92B,97C
1AC2:  CALL   12B8
1AC6:  MOVLW  0D
1AC8:  BTFSS  FA4.4
1ACA:  BRA    1AC8
1ACC:  MOVWF  F79
1ACE:  MOVLW  0A
1AD0:  BTFSS  FA4.4
1AD2:  BRA    1AD0
1AD4:  MOVWF  F79
.................... #endif
.................... 
.................... 		if ( checksum == l ) {
1AD6:  MOVLB  9
1AD8:  MOVF   x2B,W
1ADA:  SUBWF  x2D,W
1ADC:  BNZ   1B7E
1ADE:  MOVF   x2C,W
1AE0:  SUBWF  x2E,W
1AE2:  BNZ   1B7E
.................... 			/* checksums matched, we have a good message! */
.................... 			sbd.mt_ready=1;
1AE4:  MOVLW  01
1AE6:  MOVLB  7
1AE8:  MOVWF  xDE
.................... 
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# iridium_mt_receive() mt_ready=1, here is our message:\r\n");
1AEA:  MOVLW  08
1AEC:  MOVWF  FF6
1AEE:  MOVLW  07
1AF0:  MOVWF  FF7
1AF2:  MOVLB  0
1AF4:  CALL   0C76
.................... 			for ( l=0 ; l<sbd.mt_length ; l++ ) {
1AF8:  MOVLB  9
1AFA:  CLRF   x2C
1AFC:  CLRF   x2B
1AFE:  MOVF   x2C,W
1B00:  MOVLB  8
1B02:  SUBWF  xE1,W
1B04:  BNC   1B80
1B06:  BNZ   1B18
1B08:  MOVF   xE0,W
1B0A:  MOVLB  9
1B0C:  SUBWF  x2B,W
1B0E:  BTFSS  FD8.0
1B10:  BRA    1B16
1B12:  MOVLB  8
1B14:  BRA    1B80
1B16:  MOVLB  8
.................... 				fprintf(STREAM_WORLD,"# mt_buff[%lu]=%c\r\n",l,sbd.mt_buff[l]);
1B18:  MOVLW  E0
1B1A:  MOVLB  9
1B1C:  ADDWF  x2B,W
1B1E:  MOVWF  FE9
1B20:  MOVLW  07
1B22:  ADDWFC x2C,W
1B24:  MOVWF  FEA
1B26:  MOVFF  FEF,97B
1B2A:  MOVLW  42
1B2C:  MOVWF  FF6
1B2E:  MOVLW  07
1B30:  MOVWF  FF7
1B32:  MOVLW  0A
1B34:  MOVWF  x7E
1B36:  MOVLB  0
1B38:  CALL   0C98
1B3C:  MOVLW  10
1B3E:  MOVWF  FE9
1B40:  MOVFF  92C,97D
1B44:  MOVFF  92B,97C
1B48:  CALL   12B8
1B4C:  MOVLW  5D
1B4E:  BTFSS  FA4.4
1B50:  BRA    1B4E
1B52:  MOVWF  F79
1B54:  MOVLW  3D
1B56:  BTFSS  FA4.4
1B58:  BRA    1B56
1B5A:  MOVWF  F79
1B5C:  MOVLB  9
1B5E:  MOVF   x7B,W
1B60:  BTFSS  FA4.4
1B62:  BRA    1B60
1B64:  MOVWF  F79
1B66:  MOVLW  0D
1B68:  BTFSS  FA4.4
1B6A:  BRA    1B68
1B6C:  MOVWF  F79
1B6E:  MOVLW  0A
1B70:  BTFSS  FA4.4
1B72:  BRA    1B70
1B74:  MOVWF  F79
1B76:  INCF   x2B,F
1B78:  BTFSC  FD8.2
1B7A:  INCF   x2C,F
1B7C:  BRA    1AFE
1B7E:  MOVLB  8
.................... 			}
.................... #endif
.................... 		}
.................... 
.................... 		/* even if we have a bad checksum, we advance to next state and watch for OK */
.................... 		sbd.mt_state++;
1B80:  MOVLB  7
1B82:  INCF   xDF,F
.................... 
.................... 	} else if ( 14 == sbd.mt_state ) {
1B84:  BRA    1BCC
1B86:  MOVF   xDF,W
1B88:  SUBLW  0E
1B8A:  BNZ   1BBE
.................... 		/* 
.................... 		Iridium reference manual says:
.................... 		"There are no response codes generated by the ISU for this command".
.................... 		But it does, in fact, give an "OK" (0x0D 0x0A 0x4F 0x4B 0x0D 0x0A) 
.................... 		about 2.7ms after finishing send the SBD data 
.................... 		*/
.................... 		/* receive response 'OK' */
.................... 
.................... 		if ( 1 == sbd.mr_ready ) {
1B8C:  MOVLB  8
1B8E:  DECFSZ xE6,W
1B90:  BRA    1BBA
.................... 			if ( 'O'==sbd.mr_buff[0] && 'K'==sbd.mr_buff[1] ) {
1B92:  MOVF   xE7,W
1B94:  SUBLW  4F
1B96:  BNZ   1BB2
1B98:  MOVF   xE8,W
1B9A:  SUBLW  4B
1B9C:  BNZ   1BB2
.................... 				sbd.mt_state++;
1B9E:  MOVLB  7
1BA0:  INCF   xDF,F
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# iridium_mt_receive() got final OK\r\n");
1BA2:  MOVLW  56
1BA4:  MOVWF  FF6
1BA6:  MOVLW  07
1BA8:  MOVWF  FF7
1BAA:  MOVLB  0
1BAC:  CALL   0C76
1BB0:  MOVLB  8
.................... #endif
.................... 			} 
.................... 			/* clear mr because either we got OK or we got a bad response */
.................... 			iridium_mr_clear();	
1BB2:  MOVLB  0
1BB4:  CALL   1052
1BB8:  MOVLB  8
.................... 		}	
.................... 	} else if ( 15 == sbd.mt_state ) {
1BBA:  BRA    1BCC
1BBC:  MOVLB  7
1BBE:  MOVF   xDF,W
1BC0:  SUBLW  0F
1BC2:  BNZ   1BCC
.................... 		/* message has processed */
.................... 		sbd.sbdix_mt_status=0;
1BC4:  MOVLB  6
1BC6:  CLRF   xC3
.................... 		sbd.mt_state=0;
1BC8:  MOVLB  7
1BCA:  CLRF   xDF
1BCC:  MOVLB  9
1BCE:  MOVLB  0
.................... 	}
1BD0:  GOTO   453A (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #if 0
.................... 			/* if not using RING ALERT through the UART, we can do this */
.................... 			/* check if RING ALERT is active via the !CTS pin connected to RING ALERT line on the SBD modem */
.................... 			if ( bit_test(uart_read(UART_MSR),4) ) {
.................... 				sbd.ring_flag=1;
.................... 			}
.................... #endif
.................... 
.................... #include "interrupt_rdTap.c"
.................... /* int_timer2 in modbus_int_uart.c */
.................... 
.................... #int_timer4
.................... void isr_10ms(void) {
.................... 	static int8 sc=0;
.................... 	static int16 li=0;
.................... 
.................... 	/* once per second */
.................... 	sc++;
*
077C:  MOVLB  9
077E:  INCF   x2F,F
.................... 	if ( 100==sc ) {
0780:  MOVF   x2F,W
0782:  SUBLW  64
0784:  BNZ   07BA
.................... 		sc=0;
0786:  CLRF   x2F
.................... 
.................... 		li++;
0788:  INCF   x30,F
078A:  BTFSC  FD8.2
078C:  INCF   x31,F
.................... 		if ( li >= config.live_interval ) {
078E:  MOVLB  5
0790:  MOVF   x87,W
0792:  MOVLB  9
0794:  SUBWF  x31,W
0796:  BNC   07B0
0798:  BNZ   07A4
079A:  MOVLB  5
079C:  MOVF   x86,W
079E:  MOVLB  9
07A0:  SUBWF  x30,W
07A2:  BNC   07B0
.................... 			li=0;
07A4:  CLRF   x31
07A6:  CLRF   x30
.................... 			timers.now_poll=1;
07A8:  MOVLW  01
07AA:  MOVLB  3
07AC:  MOVWF  x61
07AE:  MOVLB  9
.................... 		}
.................... 
.................... 
.................... 		if ( sbd.mo_sbdix_wait > 0 ) {
07B0:  MOVLB  7
07B2:  MOVF   xDD,F
07B4:  BZ    07B8
.................... 			sbd.mo_sbdix_wait--;
07B6:  DECF   xDD,F
07B8:  MOVLB  9
.................... 		}
.................... 	}
.................... 
.................... 	if ( timers.world_timeout < 255 ) {
07BA:  MOVLB  3
07BC:  INCFSZ x62,W
07BE:  BRA    07C2
07C0:  BRA    07C4
.................... 		timers.world_timeout++;
07C2:  INCF   x62,F
.................... 	}
.................... 
.................... 	/* LEDs */
.................... 	if ( 0==timers.led_on_green ) {
07C4:  MOVF   x64,F
07C6:  BNZ   07CE
.................... 		output_low(LED_GREEN);
07C8:  BCF    F93.5
07CA:  BCF    F8A.5
.................... 	} else {
07CC:  BRA    07D4
.................... 		output_high(LED_GREEN);
07CE:  BCF    F93.5
07D0:  BSF    F8A.5
.................... 		timers.led_on_green--;
07D2:  DECF   x64,F
.................... 	}
.................... 
.................... }
.................... 
.................... 
.................... /* int_rda in modbus_int_uart.c */
.................... 
07D4:  BCF    FB7.7
07D6:  MOVLB  0
07D8:  GOTO   0084
.................... #int_rda2
.................... void isr_world(void) {
.................... 	static int8 pre[5];
.................... 
.................... 
.................... 
.................... 	if ( query.buff_ready ) {
*
07F2:  MOVLB  5
07F4:  MOVF   x6D,F
07F6:  BZ    07FE
.................... 		/* throw out data received while processing previous query */
.................... 		fgetc(STREAM_WORLD);
07F8:  MOVLB  0
07FA:  RCALL  07DC
07FC:  MOVLB  5
.................... 	}
.................... 
.................... 	/* timeout after 100 milliseconds */
.................... 	if ( timers.world_timeout > 10 ) {
07FE:  MOVLB  3
0800:  MOVF   x62,W
0802:  SUBLW  0A
0804:  BC    080C
.................... 		query.buff_pos=0;
0806:  MOVLB  5
0808:  CLRF   x6C
080A:  MOVLB  3
.................... //		output_toggle(LED_RED);
.................... 	}
.................... 	timers.world_timeout=0;
080C:  CLRF   x62
.................... 
.................... 	if ( 0 == query.buff_pos ) {
080E:  MOVLB  5
0810:  MOVF   x6C,F
0812:  BNZ   0884
.................... 		pre[0]=pre[1];
0814:  MOVFF  933,932
.................... 		pre[1]=pre[2];
0818:  MOVFF  934,933
.................... 		pre[2]=pre[3];
081C:  MOVFF  935,934
.................... 		pre[3]=pre[4];
0820:  MOVFF  936,935
.................... 		pre[4]=fgetc(STREAM_WORLD);
0824:  MOVLB  0
0826:  RCALL  07DC
0828:  MOVFF  01,936
.................... 
.................... 		/* packet addressed to us */
.................... 		if ( '#'==pre[0] && config.serial_prefix==pre[1] && config.serial_number==make16(pre[2],pre[3]) ) {
082C:  MOVLB  9
082E:  MOVF   x32,W
0830:  SUBLW  23
0832:  BNZ   0880
0834:  MOVF   x33,W
0836:  MOVLB  5
0838:  SUBWF  x83,W
083A:  BTFSC  FD8.2
083C:  BRA    0842
083E:  MOVLB  9
0840:  BRA    0880
0842:  MOVFF  934,03
0846:  MOVLB  9
0848:  MOVF   x35,W
084A:  MOVLB  5
084C:  SUBWF  x84,W
084E:  BTFSC  FD8.2
0850:  BRA    0856
0852:  MOVLB  9
0854:  BRA    0880
0856:  MOVF   03,W
0858:  SUBWF  x85,W
085A:  BTFSC  FD8.2
085C:  BRA    0862
085E:  MOVLB  9
0860:  BRA    0880
.................... 			output_high(CTRL_1);
0862:  BCF    F92.1
0864:  BSF    F89.1
.................... 			query.buff[0]=pre[0];
0866:  MOVFF  932,46C
.................... 			query.buff[1]=pre[1];
086A:  MOVFF  933,46D
.................... 			query.buff[2]=pre[2];
086E:  MOVFF  934,46E
.................... 			query.buff[3]=pre[3];
0872:  MOVFF  935,46F
.................... 			query.buff[4]=pre[4];
0876:  MOVFF  936,470
.................... 			query.buff_pos=5;
087A:  MOVLW  05
087C:  MOVWF  x6C
087E:  MOVLB  9
.................... 		}
.................... 	} else {
0880:  BRA    08C0
0882:  MOVLB  5
.................... 		query.buff[query.buff_pos++]=fgetc(STREAM_WORLD);
0884:  MOVF   x6C,W
0886:  INCF   x6C,F
0888:  ADDLW  6C
088A:  MOVWF  FE9
088C:  MOVLW  04
088E:  MOVWF  FEA
0890:  BTFSC  FD8.0
0892:  INCF   FEA,F
0894:  MOVFF  FEA,99E
0898:  MOVFF  FE9,99D
089C:  MOVLB  0
089E:  RCALL  07DC
08A0:  MOVFF  99E,FEA
08A4:  MOVFF  99D,FE9
08A8:  MOVFF  01,FEF
.................... 
.................... 		if ( query.buff_pos == query.buff[4] ) {
08AC:  MOVLB  4
08AE:  MOVF   x70,W
08B0:  MOVLB  5
08B2:  SUBWF  x6C,W
08B4:  BNZ   08BE
.................... 			output_toggle(CTRL_1);
08B6:  BCF    F92.1
08B8:  BTG    F89.1
.................... 			query.buff_ready=1;
08BA:  MOVLW  01
08BC:  MOVWF  x6D
08BE:  MOVLB  9
.................... 		}
.................... 	}
.................... }
.................... 
08C0:  BCF    FA4.5
08C2:  MOVLB  0
08C4:  GOTO   0084
.................... #include "live_rdTap.c"
.................... /* pass reg_crc value of 0xFFFF to reset */
.................... int16 crc_chk_pass(int16 reg_crc, int8 *data, int8 length) {
.................... 	int8 j;
.................... 	
.................... 	while ( length-- ) {
*
2520:  MOVLB  9
2522:  MOVF   x97,W
2524:  DECF   x97,F
2526:  XORLW  00
2528:  BZ    2572
.................... 		reg_crc ^= *data++;
252A:  MOVFF  996,FEA
252E:  MOVF   x95,W
2530:  INCF   x95,F
2532:  BTFSC  FD8.2
2534:  INCF   x96,F
2536:  MOVWF  FE9
2538:  MOVF   FEF,W
253A:  XORWF  x93,F
.................... 
.................... 		for ( j=0 ; j<8 ; j++ ) {
253C:  CLRF   x98
253E:  MOVF   x98,W
2540:  SUBLW  07
2542:  BNC   2570
.................... 			if ( reg_crc & 0x01 ) {
2544:  MOVF   x93,W
2546:  ANDLW  01
2548:  MOVWF  00
254A:  CLRF   03
254C:  MOVF   00,W
254E:  IORWF  03,W
2550:  BZ    2566
.................... 				reg_crc=(reg_crc>>1) ^ 0xA001;
2552:  BCF    FD8.0
2554:  RRCF   x94,W
2556:  MOVWF  x9A
2558:  RRCF   x93,W
255A:  XORLW  01
255C:  MOVWF  x93
255E:  MOVF   x9A,W
2560:  XORLW  A0
2562:  MOVWF  x94
.................... 			} else {
2564:  BRA    256C
.................... 				reg_crc=reg_crc>>1;
2566:  BCF    FD8.0
2568:  RRCF   x94,F
256A:  RRCF   x93,F
.................... 			}
256C:  INCF   x98,F
256E:  BRA    253E
.................... 		}	
2570:  BRA    2522
.................... 	}
.................... 	
.................... 	return reg_crc;
2572:  MOVFF  993,01
2576:  MOVFF  994,02
257A:  MOVLB  0
257C:  RETURN 0
.................... }
.................... 
.................... void live_send(void) {
.................... 	int16 lCRC;
.................... 	int8 i;
.................... 	int8 buff[17];
.................... 	int16 completeLength;
.................... 
.................... 	completeLength=sizeof(buff) + qbuff.rResultLength + 2;
*
2586:  MOVLW  11
2588:  MOVLB  4
258A:  ADDWF  x68,W
258C:  ADDLW  02
258E:  MOVLB  9
2590:  MOVWF  x91
2592:  CLRF   x92
2594:  BTFSC  FD8.0
2596:  INCF   x92,F
.................... 
.................... 	buff[0]='#';
2598:  MOVLW  23
259A:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
259C:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
25A0:  MOVFF  585,982
25A4:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0); 
25A6:  MOVFF  584,983
25AA:  MOVLB  9
.................... 	buff[4]=255; /* tell packet length to be read from 6 and 7 */
25AC:  SETF   x84
.................... 	buff[5]=18; /* packet type */
25AE:  MOVLW  12
25B0:  MOVWF  x85
.................... 	buff[6]=make8(completeLength,1);
25B2:  MOVFF  992,986
.................... 	buff[7]=make8(completeLength,0);
25B6:  MOVFF  991,987
.................... 
.................... 	buff[8]=make8(qbuff.measurementNumber,1);
25BA:  MOVFF  46B,988
25BE:  MOVLB  9
.................... 	buff[9]=make8(qbuff.measurementNumber,0);
25C0:  MOVFF  46A,989
25C4:  MOVLB  9
.................... 
.................... 	/* device info */
.................... 	/* WorldData device type identifier (16-bit) */
.................... 	i=qbuff.deviceNumber;
25C6:  MOVFF  469,97F
.................... 	buff[10]=make8(device[i].typeWorld,1);
25CA:  CLRF   x95
25CC:  MOVFF  97F,994
25D0:  CLRF   x97
25D2:  MOVLW  0D
25D4:  MOVWF  x96
25D6:  MOVLB  0
25D8:  CALL   0DE0
25DC:  MOVFF  01,993
25E0:  MOVLW  01
25E2:  MOVLB  9
25E4:  ADDWF  01,W
25E6:  MOVWF  01
25E8:  MOVLW  00
25EA:  ADDWFC 02,W
25EC:  MOVWF  03
25EE:  MOVF   01,W
25F0:  ADDLW  21
25F2:  MOVWF  FE9
25F4:  MOVLW  00
25F6:  ADDWFC 03,W
25F8:  MOVWF  FEA
25FA:  MOVFF  FEC,98A
25FE:  MOVF   FED,F
2600:  MOVFF  FEF,993
.................... 	buff[11]=make8(device[i].typeWorld,0);
2604:  CLRF   x95
2606:  MOVFF  97F,994
260A:  CLRF   x97
260C:  MOVLW  0D
260E:  MOVWF  x96
2610:  MOVLB  0
2612:  CALL   0DE0
2616:  MOVFF  01,993
261A:  MOVLW  01
261C:  MOVLB  9
261E:  ADDWF  01,W
2620:  MOVWF  01
2622:  MOVLW  00
2624:  ADDWFC 02,W
2626:  MOVWF  03
2628:  MOVF   01,W
262A:  ADDLW  21
262C:  MOVWF  FE9
262E:  MOVLW  00
2630:  ADDWFC 03,W
2632:  MOVWF  FEA
2634:  MOVFF  FEC,994
2638:  MOVF   FED,F
263A:  MOVFF  FEF,98B
.................... 	/* manufacturers serial number */
.................... 	buff[12]=make8(device[i].serialNumber,3);
263E:  CLRF   x95
2640:  MOVFF  97F,994
2644:  CLRF   x97
2646:  MOVLW  0D
2648:  MOVWF  x96
264A:  MOVLB  0
264C:  CALL   0DE0
2650:  MOVFF  01,993
2654:  MOVLW  05
2656:  MOVLB  9
2658:  ADDWF  01,W
265A:  MOVWF  01
265C:  MOVLW  00
265E:  ADDWFC 02,W
2660:  MOVWF  03
2662:  MOVF   01,W
2664:  ADDLW  21
2666:  MOVWF  FE9
2668:  MOVLW  00
266A:  ADDWFC 03,W
266C:  MOVWF  FEA
266E:  MOVFF  FEF,993
2672:  MOVFF  FEC,994
2676:  MOVFF  FEC,995
267A:  MOVFF  FEC,98C
.................... 	buff[13]=make8(device[i].serialNumber,2);
267E:  CLRF   x95
2680:  MOVFF  97F,994
2684:  CLRF   x97
2686:  MOVLW  0D
2688:  MOVWF  x96
268A:  MOVLB  0
268C:  CALL   0DE0
2690:  MOVFF  01,993
2694:  MOVLW  05
2696:  MOVLB  9
2698:  ADDWF  01,W
269A:  MOVWF  01
269C:  MOVLW  00
269E:  ADDWFC 02,W
26A0:  MOVWF  03
26A2:  MOVF   01,W
26A4:  ADDLW  21
26A6:  MOVWF  FE9
26A8:  MOVLW  00
26AA:  ADDWFC 03,W
26AC:  MOVWF  FEA
26AE:  MOVFF  FEF,993
26B2:  MOVFF  FEC,994
26B6:  MOVFF  FEC,98D
26BA:  MOVFF  FEC,996
.................... 	buff[14]=make8(device[i].serialNumber,1);
26BE:  CLRF   x95
26C0:  MOVFF  97F,994
26C4:  CLRF   x97
26C6:  MOVLW  0D
26C8:  MOVWF  x96
26CA:  MOVLB  0
26CC:  CALL   0DE0
26D0:  MOVFF  01,993
26D4:  MOVLW  05
26D6:  MOVLB  9
26D8:  ADDWF  01,W
26DA:  MOVWF  01
26DC:  MOVLW  00
26DE:  ADDWFC 02,W
26E0:  MOVWF  03
26E2:  MOVF   01,W
26E4:  ADDLW  21
26E6:  MOVWF  FE9
26E8:  MOVLW  00
26EA:  ADDWFC 03,W
26EC:  MOVWF  FEA
26EE:  MOVFF  FEF,993
26F2:  MOVFF  FEC,98E
26F6:  MOVFF  FEC,995
26FA:  MOVFF  FEC,996
.................... 	buff[15]=make8(device[i].serialNumber,0);
26FE:  CLRF   x95
2700:  MOVFF  97F,994
2704:  CLRF   x97
2706:  MOVLW  0D
2708:  MOVWF  x96
270A:  MOVLB  0
270C:  CALL   0DE0
2710:  MOVFF  01,993
2714:  MOVLW  05
2716:  MOVLB  9
2718:  ADDWF  01,W
271A:  MOVWF  01
271C:  MOVLW  00
271E:  ADDWFC 02,W
2720:  MOVWF  03
2722:  MOVF   01,W
2724:  ADDLW  21
2726:  MOVWF  FE9
2728:  MOVLW  00
272A:  ADDWFC 03,W
272C:  MOVWF  FEA
272E:  MOVFF  FEF,98F
2732:  MOVFF  FEC,994
2736:  MOVFF  FEC,995
273A:  MOVFF  FEC,996
.................... 	/* status of the data read */
.................... 	buff[16]=qbuff.rException;
273E:  MOVFF  367,990
.................... 
.................... 	/* compute CRC on header and result data */
.................... 	lCRC=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
2742:  SETF   x94
2744:  SETF   x93
2746:  MOVLW  09
2748:  MOVWF  x96
274A:  MOVLW  81
274C:  MOVWF  x95
274E:  MOVLW  10
2750:  MOVWF  x97
2752:  MOVLB  0
2754:  RCALL  2520
2756:  MOVFF  02,97E
275A:  MOVFF  01,97D
.................... 	lCRC=crc_chk_pass(lCRC,qbuff.rResult,qbuff.rResultLength);
275E:  MOVFF  97E,994
2762:  MOVFF  97D,993
2766:  MOVLW  03
2768:  MOVLB  9
276A:  MOVWF  x96
276C:  MOVLW  68
276E:  MOVWF  x95
2770:  MOVFF  468,997
2774:  MOVLB  0
2776:  RCALL  2520
2778:  MOVFF  02,97E
277C:  MOVFF  01,97D
.................... 
.................... 	/* send buff, qbuff.rResult, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
2780:  MOVLB  9
2782:  CLRF   x7F
2784:  MOVF   x7F,W
2786:  SUBLW  10
2788:  BNC   27A8
.................... 		fputc(buff[i],STREAM_WORLD);
278A:  CLRF   03
278C:  MOVF   x7F,W
278E:  ADDLW  80
2790:  MOVWF  FE9
2792:  MOVLW  09
2794:  ADDWFC 03,W
2796:  MOVWF  FEA
2798:  MOVFF  FEF,993
279C:  MOVF   x93,W
279E:  MOVLB  0
27A0:  RCALL  257E
27A2:  MOVLB  9
27A4:  INCF   x7F,F
27A6:  BRA    2784
.................... 	}	
.................... 	for ( i=0 ; i<qbuff.rResultLength ; i++ ) {
27A8:  CLRF   x7F
27AA:  MOVLB  4
27AC:  MOVF   x68,W
27AE:  MOVLB  9
27B0:  SUBWF  x7F,W
27B2:  BC    27D2
.................... 		fputc(qbuff.rResult[i],STREAM_WORLD);
27B4:  MOVLW  68
27B6:  ADDWF  x7F,W
27B8:  MOVWF  FE9
27BA:  MOVLW  03
27BC:  MOVWF  FEA
27BE:  BTFSC  FD8.0
27C0:  INCF   FEA,F
27C2:  MOVFF  FEF,993
27C6:  MOVF   x93,W
27C8:  MOVLB  0
27CA:  RCALL  257E
27CC:  MOVLB  9
27CE:  INCF   x7F,F
27D0:  BRA    27AA
.................... 	}
.................... 	fputc(make8(lCRC,1),STREAM_WORLD);
27D2:  MOVFF  97E,993
27D6:  MOVF   x93,W
27D8:  MOVLB  0
27DA:  RCALL  257E
.................... 	fputc(make8(lCRC,0),STREAM_WORLD);
27DC:  MOVFF  97D,993
27E0:  MOVLB  9
27E2:  MOVF   x93,W
27E4:  MOVLB  0
27E6:  RCALL  257E
27E8:  RETURN 0
.................... }
.................... 
.................... 
.................... #include "queryHandler_rdTap.c"
.................... /* this will do an arbitrary query to some other device on the network */
.................... void query_other(void) {
.................... 	int8 parseType;
.................... 	int8 i;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_other()\r\n");
.................... 	fprintf(STREAM_WORLD,"# query function=%lu\r\n",query.function);
.................... #endif
.................... 
.................... 	if ( query.function <= DEV_TYPE_MODBUS_MAX ) {
*
3CD8:  MOVLB  5
3CDA:  MOVF   x7A,F
3CDC:  BTFSS  FD8.2
3CDE:  BRA    3F30
3CE0:  MOVF   x79,W
3CE2:  SUBLW  07
3CE4:  BTFSS  FD8.0
3CE6:  BRA    3F30
.................... 		/* modbus device type */
.................... 		switch ( query.function ) {
3CE8:  MOVF   x79,W
3CEA:  MOVWF  00
3CEC:  MOVF   x7A,W
3CEE:  MOVWF  03
3CF0:  MOVF   03,W
3CF2:  BNZ   3CFC
3CF4:  MOVF   00,F
3CF6:  MOVLB  0
3CF8:  BZ    3D64
3CFA:  MOVLB  5
3CFC:  MOVF   03,W
3CFE:  BNZ   3D0A
3D00:  MOVLW  01
3D02:  SUBWF  00,W
3D04:  MOVLB  0
3D06:  BZ    3D66
3D08:  MOVLB  5
3D0A:  MOVF   03,W
3D0C:  BNZ   3D18
3D0E:  MOVLW  02
3D10:  SUBWF  00,W
3D12:  MOVLB  0
3D14:  BZ    3D8E
3D16:  MOVLB  5
3D18:  MOVF   03,W
3D1A:  BNZ   3D26
3D1C:  MOVLW  03
3D1E:  SUBWF  00,W
3D20:  MOVLB  0
3D22:  BZ    3DB4
3D24:  MOVLB  5
3D26:  MOVF   03,W
3D28:  BNZ   3D34
3D2A:  MOVLW  04
3D2C:  SUBWF  00,W
3D2E:  MOVLB  0
3D30:  BZ    3DDC
3D32:  MOVLB  5
3D34:  MOVF   03,W
3D36:  BNZ   3D42
3D38:  MOVLW  05
3D3A:  SUBWF  00,W
3D3C:  MOVLB  0
3D3E:  BZ    3E04
3D40:  MOVLB  5
3D42:  MOVF   03,W
3D44:  BNZ   3D52
3D46:  MOVLW  06
3D48:  SUBWF  00,W
3D4A:  MOVLB  0
3D4C:  BTFSC  FD8.2
3D4E:  BRA    3E36
3D50:  MOVLB  5
3D52:  MOVF   03,W
3D54:  BNZ   3D62
3D56:  MOVLW  07
3D58:  SUBWF  00,W
3D5A:  MOVLB  0
3D5C:  BTFSC  FD8.2
3D5E:  BRA    3E8C
3D60:  MOVLB  5
3D62:  BRA    3ECC
.................... 			case DEV_TYPE_DISABLED:
.................... 				return;
3D64:  BRA    3FF6
.................... 			case DEV_TYPE_MODBUS_1: /* not very well tested */
.................... 				query.resultException=modbus_read_coils(query.network_address, query.start_address, query.n_words);
3D66:  MOVFF  577,982
3D6A:  MOVFF  57C,984
3D6E:  MOVFF  57B,983
3D72:  MOVLB  9
3D74:  CLRF   x86
3D76:  MOVFF  57D,985
3D7A:  MOVLB  0
3D7C:  CALL   27EA
3D80:  MOVFF  01,581
.................... 				parseType=1;
3D84:  MOVLW  01
3D86:  MOVLB  9
3D88:  MOVWF  x80
.................... 				break;
3D8A:  MOVLB  5
3D8C:  BRA    3ECC
.................... 			case DEV_TYPE_MODBUS_2: /* not very well tested */
.................... 				query.resultException=modbus_read_discrete_input(query.network_address, query.start_address, query.n_words);
3D8E:  MOVFF  577,982
3D92:  MOVFF  57C,984
3D96:  MOVFF  57B,983
3D9A:  MOVLB  9
3D9C:  CLRF   x86
3D9E:  MOVFF  57D,985
3DA2:  MOVLB  0
3DA4:  BRA    396C
3DA6:  MOVFF  01,581
.................... 				parseType=1;
3DAA:  MOVLW  01
3DAC:  MOVLB  9
3DAE:  MOVWF  x80
.................... 				break;
3DB0:  MOVLB  5
3DB2:  BRA    3ECC
.................... 			case DEV_TYPE_MODBUS_3: /* tested */
.................... 				query.resultException=modbus_read_holding_registers(query.network_address, query.start_address, query.n_words);
3DB4:  MOVFF  577,982
3DB8:  MOVFF  57C,984
3DBC:  MOVFF  57B,983
3DC0:  MOVLB  9
3DC2:  CLRF   x86
3DC4:  MOVFF  57D,985
3DC8:  MOVLB  0
3DCA:  CALL   2488
3DCE:  MOVFF  01,581
.................... 				parseType=1;
3DD2:  MOVLW  01
3DD4:  MOVLB  9
3DD6:  MOVWF  x80
.................... 				break;
3DD8:  MOVLB  5
3DDA:  BRA    3ECC
.................... 			case DEV_TYPE_MODBUS_4: /* tested */
.................... 				query.resultException=modbus_read_input_registers(query.network_address, query.start_address, query.n_words);
3DDC:  MOVFF  577,982
3DE0:  MOVFF  57C,984
3DE4:  MOVFF  57B,983
3DE8:  MOVLB  9
3DEA:  CLRF   x86
3DEC:  MOVFF  57D,985
3DF0:  MOVLB  0
3DF2:  CALL   23F0
3DF6:  MOVFF  01,581
.................... 				parseType=1;
3DFA:  MOVLW  01
3DFC:  MOVLB  9
3DFE:  MOVWF  x80
.................... 				break;
3E00:  MOVLB  5
3E02:  BRA    3ECC
.................... 			case DEV_TYPE_MODBUS_5: /* tested */
.................... 				query.resultException=modbus_write_single_coil(query.network_address, query.start_address, query.buff[query.data_start_offset]);
3E04:  MOVLW  6C
3E06:  MOVLB  5
3E08:  ADDWF  x7E,W
3E0A:  MOVWF  FE9
3E0C:  MOVLW  04
3E0E:  MOVWF  FEA
3E10:  BTFSC  FD8.0
3E12:  INCF   FEA,F
3E14:  MOVFF  FEF,986
3E18:  MOVFF  577,983
3E1C:  MOVFF  57C,985
3E20:  MOVFF  57B,984
3E24:  MOVLB  0
3E26:  BRA    3A14
3E28:  MOVFF  01,581
.................... 				parseType=2;
3E2C:  MOVLW  02
3E2E:  MOVLB  9
3E30:  MOVWF  x80
.................... 				break;
3E32:  MOVLB  5
3E34:  BRA    3ECC
.................... 			case DEV_TYPE_MODBUS_6: /* tested */
.................... 				query.resultException=modbus_write_single_register(query.network_address, query.start_address, 
.................... 					make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
3E36:  MOVLW  6C
3E38:  MOVLB  5
3E3A:  ADDWF  x7E,W
3E3C:  MOVWF  FE9
3E3E:  MOVLW  04
3E40:  MOVWF  FEA
3E42:  BTFSC  FD8.0
3E44:  INCF   FEA,F
3E46:  MOVFF  FEF,982
3E4A:  MOVLW  01
3E4C:  ADDWF  x7E,W
3E4E:  ADDLW  6C
3E50:  MOVWF  FE9
3E52:  MOVLW  04
3E54:  MOVWF  FEA
3E56:  BTFSC  FD8.0
3E58:  INCF   FEA,F
3E5A:  MOVFF  FEF,983
3E5E:  MOVFF  982,985
3E62:  MOVFF  983,984
3E66:  MOVFF  577,986
3E6A:  MOVFF  57C,988
3E6E:  MOVFF  57B,987
3E72:  MOVFF  982,98A
3E76:  MOVFF  983,989
3E7A:  MOVLB  0
3E7C:  BRA    3AD0
3E7E:  MOVFF  01,581
.................... 				parseType=2;
3E82:  MOVLW  02
3E84:  MOVLB  9
3E86:  MOVWF  x80
.................... 				return;
3E88:  MOVLB  0
3E8A:  BRA    3FF6
.................... 			case DEV_TYPE_MODBUS_16: /* tested ... endian issues lead to having to send data in a (backwards?) order */
.................... 				query.resultException=modbus_write_multiple_registers_flip(query.network_address, query.start_address, 
.................... 					query.n_words,&query.buff+query.data_start_offset
.................... 				);
3E8C:  MOVLW  6C
3E8E:  MOVLB  5
3E90:  ADDWF  x7E,W
3E92:  MOVLB  9
3E94:  MOVWF  x82
3E96:  MOVLW  04
3E98:  MOVWF  x83
3E9A:  BTFSC  FD8.0
3E9C:  INCF   x83,F
3E9E:  MOVFF  577,984
3EA2:  MOVFF  57C,986
3EA6:  MOVFF  57B,985
3EAA:  CLRF   x88
3EAC:  MOVFF  57D,987
3EB0:  MOVFF  983,98A
3EB4:  MOVFF  982,989
3EB8:  MOVLB  0
3EBA:  BRA    3B78
3EBC:  MOVFF  01,581
.................... 				parseType=2;
3EC0:  MOVLW  02
3EC2:  MOVLB  9
3EC4:  MOVWF  x80
.................... 				return;
3EC6:  MOVLB  0
3EC8:  BRA    3FF6
3ECA:  MOVLB  5
.................... 		}	
.................... 
.................... 		/* Modbus query performed above. */
.................... 		/* no error, copy data to buffer to send response */
.................... 		if ( 1==parseType && 0==query.resultException ) {
3ECC:  MOVLB  9
3ECE:  DECFSZ x80,W
3ED0:  BRA    3F0C
3ED2:  MOVLB  5
3ED4:  MOVF   x81,F
3ED6:  BTFSC  FD8.2
3ED8:  BRA    3EDE
3EDA:  MOVLB  9
3EDC:  BRA    3F0C
.................... 			query.resultLength=modbus_rx.len-1;
3EDE:  MOVLW  01
3EE0:  SUBWF  x94,W
3EE2:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[1],modbus_rx.len-1); 
3EE4:  MOVLW  01
3EE6:  SUBWF  x94,W
3EE8:  MOVLB  9
3EEA:  MOVWF  x82
3EEC:  MOVLW  04
3EEE:  MOVWF  FEA
3EF0:  MOVLW  6C
3EF2:  MOVWF  FE9
3EF4:  MOVLW  05
3EF6:  MOVWF  FE2
3EF8:  MOVLW  98
3EFA:  MOVWF  FE1
3EFC:  MOVF   x82,W
3EFE:  MOVWF  01
3F00:  BZ    3F0A
3F02:  MOVFF  FE6,FEE
3F06:  DECFSZ 01,F
3F08:  BRA    3F02
.................... 		} else if ( 2==parseType && 0==query.resultException ) {
3F0A:  BRA    3F2C
3F0C:  MOVF   x80,W
3F0E:  SUBLW  02
3F10:  BNZ   3F2C
3F12:  MOVLB  5
3F14:  MOVF   x81,F
3F16:  BTFSC  FD8.2
3F18:  BRA    3F1E
3F1A:  MOVLB  9
3F1C:  BRA    3F2C
.................... 			/* return the value of the coil we wrote */
.................... 			query.resultLength=2;
3F1E:  MOVLW  02
3F20:  MOVWF  x82
.................... 			memcpy(&query.buff,&modbus_rx.data[3],2); 
3F22:  MOVFF  59A,46C
3F26:  MOVFF  59B,46D
3F2A:  MOVLB  9
.................... 		}
.................... 	} else if ( query.function <= DEV_TYPE_I2C_MAX ) {
3F2C:  BRA    3FF4
3F2E:  MOVLB  5
3F30:  MOVF   x7A,F
3F32:  BNZ   3FF6
3F34:  MOVF   x79,W
3F36:  SUBLW  17
3F38:  BNC   3FF6
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# query_other for I2C network_adress=%lu, start_address=%lu n_words=%u\r\n",
.................... 			query.network_address,
.................... 			query.start_address,
.................... 			query.n_words
.................... 		);
.................... #endif
.................... 
.................... 		if ( DEV_TYPE_I2C_READ_8 == query.function ) {
3F3A:  MOVF   x79,W
3F3C:  SUBLW  10
3F3E:  BNZ   3F6A
3F40:  MOVF   x7A,F
3F42:  BNZ   3F6A
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_READ_8\r\n");
.................... #endif
.................... 
.................... 			/* start a read at start address then just read a byte at a time. n_words is actually bytes */
.................... 			i2c_buff_read(query.network_address, query.start_address, query.buff, query.n_words);
3F44:  MOVFF  577,982
3F48:  MOVFF  57B,983
3F4C:  MOVLW  04
3F4E:  MOVLB  9
3F50:  MOVWF  x85
3F52:  MOVLW  6C
3F54:  MOVWF  x84
3F56:  MOVFF  57D,986
3F5A:  MOVLB  0
3F5C:  CALL   2882
.................... 			query.resultLength = query.n_words; /* in bytes */
3F60:  MOVFF  57D,582
.................... 			query.resultException=0;
3F64:  MOVLB  5
3F66:  CLRF   x81
.................... 		} else if ( DEV_TYPE_I2C_WRITE_16 == query.function ) {
3F68:  BRA    3FF6
3F6A:  MOVF   x79,W
3F6C:  SUBLW  15
3F6E:  BNZ   3FF6
3F70:  MOVF   x7A,F
3F72:  BNZ   3FF6
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# DEV_TYPE_I2C_WRITE_16\r\n");
.................... #endif
.................... 
.................... 			for ( i=0 ; i<query.n_words ; i++ ) {
3F74:  MOVLB  9
3F76:  CLRF   x81
3F78:  MOVLB  5
3F7A:  MOVF   x7D,W
3F7C:  MOVLB  9
3F7E:  SUBWF  x81,W
3F80:  BC    3FF4
.................... #if DEBUG_ASCII
.................... 				fprintf(STREAM_WORLD,"# writing 0x%04lx to I2C device 0x%02x at address %lu\r\n",
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1]),
.................... 					query.network_address,
.................... 					(query.start_address+i*2)
.................... 				);
.................... #endif
.................... 
.................... 				i2c_register_write16(
.................... 					query.network_address,
.................... 					(query.start_address+i*2),
.................... 					make16(query.buff[query.data_start_offset+i*2],query.buff[query.data_start_offset+i*2+1])
.................... 				);
3F82:  BCF    FD8.0
3F84:  RLCF   x81,W
3F86:  MOVLB  5
3F88:  ADDWF  x7B,W
3F8A:  MOVLB  9
3F8C:  MOVWF  x82
3F8E:  MOVLW  00
3F90:  MOVLB  5
3F92:  ADDWFC x7C,W
3F94:  MOVLB  9
3F96:  MOVWF  x83
3F98:  BCF    FD8.0
3F9A:  RLCF   x81,W
3F9C:  MOVLB  5
3F9E:  ADDWF  x7E,W
3FA0:  ADDLW  6C
3FA2:  MOVWF  FE9
3FA4:  MOVLW  04
3FA6:  MOVWF  FEA
3FA8:  BTFSC  FD8.0
3FAA:  INCF   FEA,F
3FAC:  MOVFF  FEF,984
3FB0:  BCF    FD8.0
3FB2:  MOVLB  9
3FB4:  RLCF   x81,W
3FB6:  MOVLB  5
3FB8:  ADDWF  x7E,W
3FBA:  ADDLW  01
3FBC:  ADDLW  6C
3FBE:  MOVWF  FE9
3FC0:  MOVLW  04
3FC2:  MOVWF  FEA
3FC4:  BTFSC  FD8.0
3FC6:  INCF   FEA,F
3FC8:  MOVFF  FEF,985
3FCC:  MOVFF  984,987
3FD0:  MOVFF  985,986
3FD4:  MOVFF  577,988
3FD8:  MOVFF  982,989
3FDC:  MOVFF  984,98B
3FE0:  MOVFF  985,98A
3FE4:  MOVLB  0
3FE6:  BRA    3C9C
.................... 
.................... 				query.resultLength = 0; /* in bytes */
3FE8:  MOVLB  5
3FEA:  CLRF   x82
.................... 				query.resultException=0;
3FEC:  CLRF   x81
3FEE:  MOVLB  9
3FF0:  INCF   x81,F
3FF2:  BRA    3F78
.................... 
.................... 			}
.................... 
.................... 		} else {
3FF4:  MOVLB  5
3FF6:  MOVLB  0
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# un-implemented I2C query function\r\n");
.................... #endif
.................... 		}
.................... 
.................... 	}
3FF8:  GOTO   421A (RETURN)
.................... }
.................... 
.................... 
.................... /* 
.................... try to write the specified register
.................... if successful, return 0, otherwise return a modbus exception
.................... */
.................... exception query_self_write_register(int16 address, int16 value) {
.................... 	int8 dev, offset;
.................... 	int16 last;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_write_register address=%lu value=%lu\r\n",address,value);
.................... #endif
.................... 
.................... 	/* if we have been unlocked, then we can modify serial number */
.................... 	if ( timers.factory_unlocked ) {
*
355E:  MOVLB  3
3560:  MOVF   x63,F
3562:  BZ    359A
.................... 		if ( 1000 == address ) {
3564:  MOVLB  9
3566:  MOVF   x84,W
3568:  SUBLW  E8
356A:  BNZ   357E
356C:  MOVF   x85,W
356E:  SUBLW  03
3570:  BNZ   357E
.................... 			config.serial_prefix=value;
3572:  MOVFF  986,583
.................... 			return 0;
3576:  MOVLW  00
3578:  MOVWF  01
357A:  BRA    3888
.................... 		} else if ( 1001 == address ) {
357C:  BRA    3598
357E:  MOVF   x84,W
3580:  SUBLW  E9
3582:  BNZ   3598
3584:  MOVF   x85,W
3586:  SUBLW  03
3588:  BNZ   3598
.................... 			config.serial_number=value;
358A:  MOVFF  987,585
358E:  MOVFF  986,584
.................... 			return 0;
3592:  MOVLW  00
3594:  MOVWF  01
3596:  BRA    3888
3598:  MOVLB  3
.................... 		}
.................... 	}
.................... 
.................... 	if ( address < 1000 ) {
359A:  MOVLB  9
359C:  MOVF   x85,W
359E:  SUBLW  03
35A0:  BTFSS  FD8.0
35A2:  BRA    37AC
35A4:  BNZ   35AE
35A6:  MOVF   x84,W
35A8:  SUBLW  E7
35AA:  BTFSS  FD8.0
35AC:  BRA    37AC
.................... 		dev=address>>3;
35AE:  RRCF   x85,W
35B0:  MOVWF  03
35B2:  RRCF   x84,W
35B4:  MOVWF  02
35B6:  RRCF   03,F
35B8:  RRCF   02,F
35BA:  RRCF   03,F
35BC:  RRCF   02,F
35BE:  MOVFF  02,988
.................... 		offset=address&0b111;
35C2:  MOVF   x84,W
35C4:  ANDLW  07
35C6:  MOVWF  x89
.................... 
.................... 		if ( dev > DEV_MAX_N )
35C8:  MOVF   x88,W
35CA:  SUBLW  40
35CC:  BC    35D4
.................... 			return ILLEGAL_DATA_ADDRESS;
35CE:  MOVLW  02
35D0:  MOVWF  01
35D2:  BRA    3888
.................... 
.................... 		switch ( offset ) {
35D4:  MOVF   x89,W
35D6:  ADDLW  F8
35D8:  BTFSC  FD8.0
35DA:  BRA    37AA
35DC:  ADDLW  08
35DE:  MOVLB  0
35E0:  GOTO   388E
.................... 			case 0: device[dev].type=make8(value,0); break;
35E4:  MOVLB  9
35E6:  CLRF   x95
35E8:  MOVFF  988,994
35EC:  CLRF   x97
35EE:  MOVLW  0D
35F0:  MOVWF  x96
35F2:  MOVLB  0
35F4:  CALL   0DE0
35F8:  MOVFF  02,98D
35FC:  MOVFF  01,98C
3600:  MOVLW  21
3602:  MOVLB  9
3604:  ADDWF  01,W
3606:  MOVWF  FE9
3608:  MOVLW  00
360A:  ADDWFC 02,W
360C:  MOVWF  FEA
360E:  MOVFF  986,FEF
3612:  BRA    37AA
.................... 			case 1: device[dev].typeWorld=value; break;
3614:  MOVLB  9
3616:  CLRF   x95
3618:  MOVFF  988,994
361C:  CLRF   x97
361E:  MOVLW  0D
3620:  MOVWF  x96
3622:  MOVLB  0
3624:  CALL   0DE0
3628:  MOVFF  02,98D
362C:  MOVFF  01,98C
3630:  MOVLW  01
3632:  MOVLB  9
3634:  ADDWF  01,W
3636:  MOVWF  01
3638:  MOVLW  00
363A:  ADDWFC 02,W
363C:  MOVWF  03
363E:  MOVF   01,W
3640:  ADDLW  21
3642:  MOVWF  FE9
3644:  MOVLW  00
3646:  ADDWFC 03,W
3648:  MOVWF  FEA
364A:  MOVFF  987,FEC
364E:  MOVF   FED,F
3650:  MOVFF  986,FEF
3654:  BRA    37AA
.................... 			case 2: device[dev].transmitEvery=make8(value,0); break;
3656:  MOVLB  9
3658:  CLRF   x95
365A:  MOVFF  988,994
365E:  CLRF   x97
3660:  MOVLW  0D
3662:  MOVWF  x96
3664:  MOVLB  0
3666:  CALL   0DE0
366A:  MOVFF  02,98D
366E:  MOVFF  01,98C
3672:  MOVLW  03
3674:  MOVLB  9
3676:  ADDWF  01,W
3678:  MOVWF  01
367A:  MOVLW  00
367C:  ADDWFC 02,W
367E:  MOVWF  03
3680:  MOVF   01,W
3682:  ADDLW  21
3684:  MOVWF  FE9
3686:  MOVLW  00
3688:  ADDWFC 03,W
368A:  MOVWF  FEA
368C:  MOVFF  986,FEF
3690:  BRA    37AA
.................... 			case 3: device[dev].networkAddress=make8(value,0); break;
3692:  MOVLB  9
3694:  CLRF   x95
3696:  MOVFF  988,994
369A:  CLRF   x97
369C:  MOVLW  0D
369E:  MOVWF  x96
36A0:  MOVLB  0
36A2:  CALL   0DE0
36A6:  MOVFF  02,98D
36AA:  MOVFF  01,98C
36AE:  MOVLW  04
36B0:  MOVLB  9
36B2:  ADDWF  01,W
36B4:  MOVWF  01
36B6:  MOVLW  00
36B8:  ADDWFC 02,W
36BA:  MOVWF  03
36BC:  MOVF   01,W
36BE:  ADDLW  21
36C0:  MOVWF  FE9
36C2:  MOVLW  00
36C4:  ADDWFC 03,W
36C6:  MOVWF  FEA
36C8:  MOVFF  986,FEF
36CC:  BRA    37AA
.................... 			/* first pass get the high word of serial number */
.................... 			case 4: last=value; break;
36CE:  MOVFF  987,98B
36D2:  MOVFF  986,98A
36D6:  MOVLB  9
36D8:  BRA    37AA
.................... 			/* second pass, combine last value and current value */
.................... 			case 5: device[dev].serialNumber=make32(last,value); break; /* was missing a break prior to 2024-04-03 */
36DA:  MOVLB  9
36DC:  CLRF   x95
36DE:  MOVFF  988,994
36E2:  CLRF   x97
36E4:  MOVLW  0D
36E6:  MOVWF  x96
36E8:  MOVLB  0
36EA:  CALL   0DE0
36EE:  MOVFF  02,98D
36F2:  MOVFF  01,98C
36F6:  MOVLW  05
36F8:  MOVLB  9
36FA:  ADDWF  01,W
36FC:  MOVWF  01
36FE:  MOVLW  00
3700:  ADDWFC 02,W
3702:  MOVWF  03
3704:  MOVF   01,W
3706:  ADDLW  21
3708:  MOVWF  FE9
370A:  MOVLW  00
370C:  ADDWFC 03,W
370E:  MOVWF  FEA
3710:  MOVF   FEE,F
3712:  MOVFF  98A,FEC
3716:  MOVFF  98B,FEC
371A:  MOVF   FED,F
371C:  MOVF   FED,F
371E:  MOVF   FED,F
3720:  MOVFF  986,FEF
3724:  MOVFF  987,FEC
3728:  BRA    37AA
.................... 			case 6: device[dev].startRegister=value; break;
372A:  MOVLB  9
372C:  CLRF   x95
372E:  MOVFF  988,994
3732:  CLRF   x97
3734:  MOVLW  0D
3736:  MOVWF  x96
3738:  MOVLB  0
373A:  CALL   0DE0
373E:  MOVFF  02,98D
3742:  MOVFF  01,98C
3746:  MOVLW  09
3748:  MOVLB  9
374A:  ADDWF  01,W
374C:  MOVWF  01
374E:  MOVLW  00
3750:  ADDWFC 02,W
3752:  MOVWF  03
3754:  MOVF   01,W
3756:  ADDLW  21
3758:  MOVWF  FE9
375A:  MOVLW  00
375C:  ADDWFC 03,W
375E:  MOVWF  FEA
3760:  MOVFF  987,FEC
3764:  MOVF   FED,F
3766:  MOVFF  986,FEF
376A:  BRA    37AA
.................... 			case 7: device[dev].nRegisters=make8(value,0); break;
376C:  MOVLB  9
376E:  CLRF   x95
3770:  MOVFF  988,994
3774:  CLRF   x97
3776:  MOVLW  0D
3778:  MOVWF  x96
377A:  MOVLB  0
377C:  CALL   0DE0
3780:  MOVFF  02,98D
3784:  MOVFF  01,98C
3788:  MOVLW  0B
378A:  MOVLB  9
378C:  ADDWF  01,W
378E:  MOVWF  01
3790:  MOVLW  00
3792:  ADDWFC 02,W
3794:  MOVWF  03
3796:  MOVF   01,W
3798:  ADDLW  21
379A:  MOVWF  FE9
379C:  MOVLW  00
379E:  ADDWFC 03,W
37A0:  MOVWF  FEA
37A2:  MOVFF  986,FEF
37A6:  BRA    37AA
37A8:  MOVLB  9
.................... 		}
.................... 	} else {
37AA:  BRA    3880
.................... 		/* publicly writeable addresses */
.................... 
.................... 		switch ( address ) {
37AC:  MOVF   x84,W
37AE:  MOVWF  00
37B0:  MOVF   x85,W
37B2:  MOVWF  03
37B4:  MOVLW  04
37B6:  SUBWF  03,W
37B8:  BNZ   37C4
37BA:  MOVLW  4C
37BC:  SUBWF  00,W
37BE:  MOVLB  0
37C0:  BZ    3806
37C2:  MOVLB  9
37C4:  MOVLW  07
37C6:  SUBWF  03,W
37C8:  BNZ   37D4
37CA:  MOVLW  CD
37CC:  SUBWF  00,W
37CE:  MOVLB  0
37D0:  BZ    3810
37D2:  MOVLB  9
37D4:  MOVLW  07
37D6:  SUBWF  03,W
37D8:  BNZ   37E4
37DA:  MOVLW  CE
37DC:  SUBWF  00,W
37DE:  MOVLB  0
37E0:  BZ    3814
37E2:  MOVLB  9
37E4:  MOVLW  07
37E6:  SUBWF  03,W
37E8:  BNZ   37F4
37EA:  MOVLW  CF
37EC:  SUBWF  00,W
37EE:  MOVLB  0
37F0:  BZ    3834
37F2:  MOVLB  9
37F4:  MOVLW  4E
37F6:  SUBWF  03,W
37F8:  BNZ   3804
37FA:  MOVLW  1F
37FC:  SUBWF  00,W
37FE:  MOVLB  0
3800:  BZ    3850
3802:  MOVLB  9
3804:  BRA    387A
.................... 			case 1100: config.live_interval=value; break;
3806:  MOVFF  987,587
380A:  MOVFF  986,586
380E:  BRA    3882
.................... 
.................... 			case 1997:
.................... 				reset_cpu(); break; /* break doesn't do anything, but makes the compiler complain less */
3810:  RESET
3812:  BRA    3882
.................... 			case 1998:
.................... 				if ( 1998 != value ) return ILLEGAL_DATA_VALUE;
3814:  MOVLB  9
3816:  MOVF   x86,W
3818:  SUBLW  CE
381A:  BNZ   3822
381C:  MOVF   x87,W
381E:  SUBLW  07
3820:  BZ    3828
3822:  MOVLW  03
3824:  MOVWF  01
3826:  BRA    3888
.................... 				write_default_param_file();
3828:  MOVLB  0
382A:  CALL   0DB6
.................... 				write_default_device_file();
382E:  CALL   0E54
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# writing default files\r\n");
.................... #endif
.................... 				break;
3832:  BRA    3882
.................... 			case 1999:
.................... 				/* write config to EEPROM */
.................... 				if ( 1 != value ) return ILLEGAL_DATA_VALUE;
3834:  MOVLB  9
3836:  DECFSZ x86,W
3838:  BRA    383E
383A:  MOVF   x87,F
383C:  BZ    3844
383E:  MOVLW  03
3840:  MOVWF  01
3842:  BRA    3888
.................... 				write_param_file();
3844:  MOVLB  0
3846:  CALL   0D62
.................... 				write_device_file();
384A:  CALL   0E02
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# config.live_interval=%lu\r\n",config.live_interval);
.................... #endif
.................... 
.................... 				break;
384E:  BRA    3882
.................... 
.................... 			case 19999:
.................... 				/* unlock factory programming registers when we get 1802 in passcode register */
.................... 				if ( 1802 != value ) {
3850:  MOVLB  9
3852:  MOVF   x86,W
3854:  SUBLW  0A
3856:  BNZ   385E
3858:  MOVF   x87,W
385A:  SUBLW  07
385C:  BZ    386A
.................... 					timers.factory_unlocked=0;
385E:  MOVLB  3
3860:  CLRF   x63
.................... 					return ILLEGAL_DATA_VALUE;
3862:  MOVLW  03
3864:  MOVWF  01
3866:  MOVLB  9
3868:  BRA    3888
.................... 				}
.................... 				timers.factory_unlocked=1;
386A:  MOVLW  01
386C:  MOVLB  3
386E:  MOVWF  x63
.................... 				/* green LED for 2 seconds */
.................... 				timers.led_on_green=200;
3870:  MOVLW  C8
3872:  MOVWF  x64
.................... 				break;
3874:  MOVLB  0
3876:  BRA    3882
3878:  MOVLB  9
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# factory unlocked\r\n");
.................... #endif
.................... 
.................... 			default:
.................... 				return ILLEGAL_DATA_ADDRESS;
387A:  MOVLW  02
387C:  MOVWF  01
387E:  BRA    3888
3880:  MOVLB  0
.................... 		}
.................... 	}
.................... 
.................... 	/* must not have triggered an exception */
.................... 	return 0;
3882:  MOVLW  00
3884:  MOVWF  01
3886:  MOVLB  9
3888:  MOVLB  0
388A:  GOTO   3956 (RETURN)
.................... }
.................... 
.................... 
.................... /* address to read, put 16-bit results in query.buff[n] and query.buff[n+1] */
.................... exception query_self_read_register(int16 address, int8 n) {
.................... 	int16 result;
.................... 	int8 dev;
.................... 	int8 offset;
.................... 
.................... 
.................... 	if ( address < 1000 ) {
*
310C:  MOVLB  9
310E:  MOVF   x89,W
3110:  SUBLW  03
3112:  BTFSS  FD8.0
3114:  BRA    33F2
3116:  BNZ   3120
3118:  MOVF   x88,W
311A:  SUBLW  E7
311C:  BTFSS  FD8.0
311E:  BRA    33F2
.................... 		dev=address>>3;
3120:  RRCF   x89,W
3122:  MOVWF  03
3124:  RRCF   x88,W
3126:  MOVWF  02
3128:  RRCF   03,F
312A:  RRCF   02,F
312C:  RRCF   03,F
312E:  RRCF   02,F
3130:  MOVFF  02,98D
.................... 		offset=address&0b111;
3134:  MOVF   x88,W
3136:  ANDLW  07
3138:  MOVWF  x8E
.................... 
.................... 		if ( dev > DEV_MAX_N )
313A:  MOVF   x8D,W
313C:  SUBLW  40
313E:  BC    3146
.................... 			return ILLEGAL_DATA_ADDRESS;
3140:  MOVLW  02
3142:  MOVWF  01
3144:  BRA    34EA
.................... 
.................... 		switch ( offset ) {
3146:  MOVF   x8E,W
3148:  ADDLW  F8
314A:  BTFSC  FD8.0
314C:  BRA    33F0
314E:  ADDLW  08
3150:  MOVLB  0
3152:  GOTO   34F0
.................... 			case 0: result=device[dev].type; break;
3156:  MOVLB  9
3158:  CLRF   x95
315A:  MOVFF  98D,994
315E:  CLRF   x97
3160:  MOVLW  0D
3162:  MOVWF  x96
3164:  MOVLB  0
3166:  CALL   0DE0
316A:  MOVFF  02,990
316E:  MOVFF  01,98F
3172:  MOVLW  21
3174:  MOVLB  9
3176:  ADDWF  01,W
3178:  MOVWF  FE9
317A:  MOVLW  00
317C:  ADDWFC 02,W
317E:  MOVWF  FEA
3180:  CLRF   x8C
3182:  MOVFF  FEF,98B
3186:  BRA    33F0
.................... 			case 1: result=device[dev].typeWorld; break;
3188:  MOVLB  9
318A:  CLRF   x95
318C:  MOVFF  98D,994
3190:  CLRF   x97
3192:  MOVLW  0D
3194:  MOVWF  x96
3196:  MOVLB  0
3198:  CALL   0DE0
319C:  MOVFF  02,990
31A0:  MOVFF  01,98F
31A4:  MOVLW  01
31A6:  MOVLB  9
31A8:  ADDWF  01,W
31AA:  MOVWF  01
31AC:  MOVLW  00
31AE:  ADDWFC 02,W
31B0:  MOVWF  03
31B2:  MOVF   01,W
31B4:  ADDLW  21
31B6:  MOVWF  FE9
31B8:  MOVLW  00
31BA:  ADDWFC 03,W
31BC:  MOVWF  FEA
31BE:  MOVFF  FEC,98C
31C2:  MOVF   FED,F
31C4:  MOVFF  FEF,98B
31C8:  BRA    33F0
.................... 			case 2: result=device[dev].transmitEvery; break;
31CA:  MOVLB  9
31CC:  CLRF   x95
31CE:  MOVFF  98D,994
31D2:  CLRF   x97
31D4:  MOVLW  0D
31D6:  MOVWF  x96
31D8:  MOVLB  0
31DA:  CALL   0DE0
31DE:  MOVFF  02,990
31E2:  MOVFF  01,98F
31E6:  MOVLW  03
31E8:  MOVLB  9
31EA:  ADDWF  01,W
31EC:  MOVWF  01
31EE:  MOVLW  00
31F0:  ADDWFC 02,W
31F2:  MOVWF  03
31F4:  MOVF   01,W
31F6:  ADDLW  21
31F8:  MOVWF  FE9
31FA:  MOVLW  00
31FC:  ADDWFC 03,W
31FE:  MOVWF  FEA
3200:  CLRF   x8C
3202:  MOVFF  FEF,98B
3206:  BRA    33F0
.................... 			case 3: result=device[dev].networkAddress; break;
3208:  MOVLB  9
320A:  CLRF   x95
320C:  MOVFF  98D,994
3210:  CLRF   x97
3212:  MOVLW  0D
3214:  MOVWF  x96
3216:  MOVLB  0
3218:  CALL   0DE0
321C:  MOVFF  02,990
3220:  MOVFF  01,98F
3224:  MOVLW  04
3226:  MOVLB  9
3228:  ADDWF  01,W
322A:  MOVWF  01
322C:  MOVLW  00
322E:  ADDWFC 02,W
3230:  MOVWF  03
3232:  MOVF   01,W
3234:  ADDLW  21
3236:  MOVWF  FE9
3238:  MOVLW  00
323A:  ADDWFC 03,W
323C:  MOVWF  FEA
323E:  CLRF   x8C
3240:  MOVFF  FEF,98B
3244:  BRA    33F0
.................... 			case 4: result=make16(make8(device[dev].serialNumber,3),make8(device[dev].serialNumber,2)); break;
3246:  MOVLB  9
3248:  CLRF   x95
324A:  MOVFF  98D,994
324E:  CLRF   x97
3250:  MOVLW  0D
3252:  MOVWF  x96
3254:  MOVLB  0
3256:  CALL   0DE0
325A:  MOVFF  01,98F
325E:  MOVLW  05
3260:  MOVLB  9
3262:  ADDWF  01,W
3264:  MOVWF  01
3266:  MOVLW  00
3268:  ADDWFC 02,W
326A:  MOVWF  03
326C:  MOVF   01,W
326E:  ADDLW  21
3270:  MOVWF  FE9
3272:  MOVLW  00
3274:  ADDWFC 03,W
3276:  MOVWF  FEA
3278:  MOVFF  FEF,98F
327C:  MOVFF  FEC,990
3280:  MOVFF  FEC,991
3284:  MOVFF  FEC,992
3288:  MOVFF  992,993
328C:  CLRF   x95
328E:  MOVFF  98D,994
3292:  CLRF   x97
3294:  MOVLW  0D
3296:  MOVWF  x96
3298:  MOVLB  0
329A:  CALL   0DE0
329E:  MOVFF  01,994
32A2:  MOVLW  05
32A4:  MOVLB  9
32A6:  ADDWF  01,W
32A8:  MOVWF  01
32AA:  MOVLW  00
32AC:  ADDWFC 02,W
32AE:  MOVWF  03
32B0:  MOVF   01,W
32B2:  ADDLW  21
32B4:  MOVWF  FE9
32B6:  MOVLW  00
32B8:  ADDWFC 03,W
32BA:  MOVWF  FEA
32BC:  MOVFF  FEF,994
32C0:  MOVFF  FEC,995
32C4:  MOVFF  FEC,996
32C8:  MOVFF  FEC,997
32CC:  MOVFF  996,998
32D0:  MOVFF  992,98C
32D4:  MOVFF  996,98B
32D8:  BRA    33F0
.................... 			case 5: result=make16(make8(device[dev].serialNumber,1),make8(device[dev].serialNumber,0)); break;
32DA:  MOVLB  9
32DC:  CLRF   x95
32DE:  MOVFF  98D,994
32E2:  CLRF   x97
32E4:  MOVLW  0D
32E6:  MOVWF  x96
32E8:  MOVLB  0
32EA:  CALL   0DE0
32EE:  MOVFF  01,98F
32F2:  MOVLW  05
32F4:  MOVLB  9
32F6:  ADDWF  01,W
32F8:  MOVWF  01
32FA:  MOVLW  00
32FC:  ADDWFC 02,W
32FE:  MOVWF  03
3300:  MOVF   01,W
3302:  ADDLW  21
3304:  MOVWF  FE9
3306:  MOVLW  00
3308:  ADDWFC 03,W
330A:  MOVWF  FEA
330C:  MOVFF  FEF,98F
3310:  MOVFF  FEC,990
3314:  MOVFF  FEC,991
3318:  MOVFF  FEC,992
331C:  MOVFF  990,993
3320:  CLRF   x95
3322:  MOVFF  98D,994
3326:  CLRF   x97
3328:  MOVLW  0D
332A:  MOVWF  x96
332C:  MOVLB  0
332E:  CALL   0DE0
3332:  MOVFF  01,994
3336:  MOVLW  05
3338:  MOVLB  9
333A:  ADDWF  01,W
333C:  MOVWF  01
333E:  MOVLW  00
3340:  ADDWFC 02,W
3342:  MOVWF  03
3344:  MOVF   01,W
3346:  ADDLW  21
3348:  MOVWF  FE9
334A:  MOVLW  00
334C:  ADDWFC 03,W
334E:  MOVWF  FEA
3350:  MOVFF  FEF,994
3354:  MOVFF  FEC,995
3358:  MOVFF  FEC,996
335C:  MOVFF  FEC,997
3360:  MOVFF  994,998
3364:  MOVFF  990,98C
3368:  MOVFF  994,98B
336C:  BRA    33F0
.................... 			case 6: result=device[dev].startRegister; break;
336E:  MOVLB  9
3370:  CLRF   x95
3372:  MOVFF  98D,994
3376:  CLRF   x97
3378:  MOVLW  0D
337A:  MOVWF  x96
337C:  MOVLB  0
337E:  CALL   0DE0
3382:  MOVFF  02,990
3386:  MOVFF  01,98F
338A:  MOVLW  09
338C:  MOVLB  9
338E:  ADDWF  01,W
3390:  MOVWF  01
3392:  MOVLW  00
3394:  ADDWFC 02,W
3396:  MOVWF  03
3398:  MOVF   01,W
339A:  ADDLW  21
339C:  MOVWF  FE9
339E:  MOVLW  00
33A0:  ADDWFC 03,W
33A2:  MOVWF  FEA
33A4:  MOVFF  FEC,98C
33A8:  MOVF   FED,F
33AA:  MOVFF  FEF,98B
33AE:  BRA    33F0
.................... 			case 7: result=device[dev].nRegisters; break;
33B0:  MOVLB  9
33B2:  CLRF   x95
33B4:  MOVFF  98D,994
33B8:  CLRF   x97
33BA:  MOVLW  0D
33BC:  MOVWF  x96
33BE:  MOVLB  0
33C0:  CALL   0DE0
33C4:  MOVFF  02,990
33C8:  MOVFF  01,98F
33CC:  MOVLW  0B
33CE:  MOVLB  9
33D0:  ADDWF  01,W
33D2:  MOVWF  01
33D4:  MOVLW  00
33D6:  ADDWFC 02,W
33D8:  MOVWF  03
33DA:  MOVF   01,W
33DC:  ADDLW  21
33DE:  MOVWF  FE9
33E0:  MOVLW  00
33E2:  ADDWFC 03,W
33E4:  MOVWF  FEA
33E6:  CLRF   x8C
33E8:  MOVFF  FEF,98B
33EC:  BRA    33F0
33EE:  MOVLB  9
.................... 		}
.................... 	} else {
33F0:  BRA    34B8
.................... 		switch ( address ) {
33F2:  MOVF   x88,W
33F4:  MOVWF  00
33F6:  MOVF   x89,W
33F8:  MOVWF  03
33FA:  MOVLW  03
33FC:  SUBWF  03,W
33FE:  BNZ   340A
3400:  MOVLW  E8
3402:  SUBWF  00,W
3404:  MOVLB  0
3406:  BZ    346C
3408:  MOVLB  9
340A:  MOVLW  03
340C:  SUBWF  03,W
340E:  BNZ   341A
3410:  MOVLW  E9
3412:  SUBWF  00,W
3414:  MOVLB  0
3416:  BZ    3476
3418:  MOVLB  9
341A:  MOVLW  03
341C:  SUBWF  03,W
341E:  BNZ   342A
3420:  MOVLW  EA
3422:  SUBWF  00,W
3424:  MOVLB  0
3426:  BZ    3482
3428:  MOVLB  9
342A:  MOVLW  03
342C:  SUBWF  03,W
342E:  BNZ   343A
3430:  MOVLW  EB
3432:  SUBWF  00,W
3434:  MOVLB  0
3436:  BZ    348C
3438:  MOVLB  9
343A:  MOVLW  03
343C:  SUBWF  03,W
343E:  BNZ   344A
3440:  MOVLW  EC
3442:  SUBWF  00,W
3444:  MOVLB  0
3446:  BZ    3494
3448:  MOVLB  9
344A:  MOVLW  03
344C:  SUBWF  03,W
344E:  BNZ   345A
3450:  MOVLW  ED
3452:  SUBWF  00,W
3454:  MOVLB  0
3456:  BZ    349E
3458:  MOVLB  9
345A:  MOVLW  04
345C:  SUBWF  03,W
345E:  BNZ   346A
3460:  MOVLW  4C
3462:  SUBWF  00,W
3464:  MOVLB  0
3466:  BZ    34A6
3468:  MOVLB  9
346A:  BRA    34B2
.................... 			case 1000: result=config.serial_prefix; break;
346C:  MOVLB  9
346E:  CLRF   x8C
3470:  MOVFF  583,98B
3474:  BRA    34B8
.................... 			case 1001: result=config.serial_number; break;
3476:  MOVFF  585,98C
347A:  MOVFF  584,98B
347E:  MOVLB  9
3480:  BRA    34B8
.................... 			case 1002: result='R'; break;
3482:  MOVLB  9
3484:  CLRF   x8C
3486:  MOVLW  52
3488:  MOVWF  x8B
348A:  BRA    34B8
.................... 			case 1003: result=0; break;
348C:  MOVLB  9
348E:  CLRF   x8C
3490:  CLRF   x8B
3492:  BRA    34B8
.................... 			case 1004: result='4'; break;
3494:  MOVLB  9
3496:  CLRF   x8C
3498:  MOVLW  34
349A:  MOVWF  x8B
349C:  BRA    34B8
.................... 			case 1005: result=0; break;
349E:  MOVLB  9
34A0:  CLRF   x8C
34A2:  CLRF   x8B
34A4:  BRA    34B8
.................... 	
.................... 			case 1100: result=config.live_interval; break;
34A6:  MOVFF  587,98C
34AA:  MOVFF  586,98B
34AE:  MOVLB  9
34B0:  BRA    34B8
.................... 	
.................... 			default: return ILLEGAL_DATA_ADDRESS;
34B2:  MOVLW  02
34B4:  MOVWF  01
34B6:  BRA    34EA
.................... 		}
.................... 	}
.................... 
.................... //	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u) result=%lu\r\n",address,n,result);
.................... 
.................... 	query.buff[n]  =make8(result,1);
34B8:  MOVLW  6C
34BA:  ADDWF  x8A,W
34BC:  MOVWF  FE9
34BE:  MOVLW  04
34C0:  MOVWF  FEA
34C2:  BTFSC  FD8.0
34C4:  INCF   FEA,F
34C6:  MOVFF  98C,FEF
.................... 	query.buff[n+1]=make8(result,0);
34CA:  MOVLW  01
34CC:  ADDWF  x8A,W
34CE:  ADDLW  6C
34D0:  MOVWF  FE9
34D2:  MOVLW  04
34D4:  MOVWF  FEA
34D6:  BTFSC  FD8.0
34D8:  INCF   FEA,F
34DA:  MOVFF  98B,FEF
.................... 	query.resultLength += 2;
34DE:  MOVLW  02
34E0:  MOVLB  5
34E2:  ADDWF  x82,F
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_register(address=%lu, n=%u, result=%lu, query.resultLength=%u)\r\n",
.................... 		address,
.................... 		n,
.................... 		result,
.................... 		query.resultLength
.................... 	);
.................... #endif
.................... 
.................... 
.................... 	return 0;
34E4:  MOVLW  00
34E6:  MOVWF  01
34E8:  MOVLB  9
34EA:  MOVLB  0
34EC:  GOTO   354A (RETURN)
.................... }
.................... 
.................... exception query_self_read_registers(int16 address, int8 nRegisters) {
*
351A:  MOVLB  9
351C:  CLRF   x84
.................... 	int8 i;
.................... 	exception e=0;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers (address=%lu, nRegisters=%u)\r\n",address,nRegisters);
.................... #endif
.................... 
.................... 	for ( i=0 ; i<nRegisters && 0==e ; i++ ) {
351E:  CLRF   x83
3520:  MOVF   x82,W
3522:  SUBWF  x83,W
3524:  BC    3554
3526:  MOVF   x84,F
3528:  BNZ   3554
.................... 		e=query_self_read_register(address+i,i*2);
352A:  MOVF   x83,W
352C:  ADDWF  x80,W
352E:  MOVWF  x85
3530:  MOVLW  00
3532:  ADDWFC x81,W
3534:  MOVWF  x86
3536:  BCF    FD8.0
3538:  RLCF   x83,W
353A:  MOVWF  x87
353C:  MOVFF  986,989
3540:  MOVFF  985,988
3544:  MOVWF  x8A
3546:  MOVLB  0
3548:  BRA    310C
354A:  MOVFF  01,984
.................... 	}
.................... 
.................... 
.................... #if DEBUG_ASCII
354E:  MOVLB  9
3550:  INCF   x83,F
3552:  BRA    3520
.................... 	fprintf(STREAM_WORLD,"# query_self_read_registers returning e=%u\r\n",e);
.................... #endif
.................... 
.................... 
.................... 	return e;
3554:  MOVFF  984,01
3558:  MOVLB  0
355A:  GOTO   390C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void query_self(void) {
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# query_self( query.function=%lu, query.start_address=%lu, query.n_words=%u)\r\n",
.................... 		query.function,
.................... 		query.start_address,
.................... 		query.n_words
.................... 	);
.................... #endif
.................... 
.................... 	query.resultLength=0;
*
38B8:  MOVLB  5
38BA:  CLRF   x82
.................... 
.................... 	switch ( query.function ) {
38BC:  MOVF   x79,W
38BE:  MOVWF  00
38C0:  MOVF   x7A,W
38C2:  MOVWF  03
38C4:  MOVF   03,W
38C6:  BNZ   38D2
38C8:  MOVLW  03
38CA:  SUBWF  00,W
38CC:  MOVLB  0
38CE:  BZ    38FE
38D0:  MOVLB  5
38D2:  MOVF   03,W
38D4:  BNZ   38E0
38D6:  MOVLW  04
38D8:  SUBWF  00,W
38DA:  MOVLB  0
38DC:  BZ    38FE
38DE:  MOVLB  5
38E0:  MOVF   03,W
38E2:  BNZ   38EE
38E4:  MOVLW  06
38E6:  SUBWF  00,W
38E8:  MOVLB  0
38EA:  BZ    3912
38EC:  MOVLB  5
38EE:  MOVF   03,W
38F0:  BNZ   38FC
38F2:  MOVLW  07
38F4:  SUBWF  00,W
38F6:  MOVLB  0
38F8:  BZ    395C
38FA:  MOVLB  5
38FC:  BRA    3960
.................... 		case DEV_TYPE_MODBUS_3:
.................... 		case DEV_TYPE_MODBUS_4:
.................... 			/* read registers */
.................... 			query.resultException=query_self_read_registers(query.start_address, query.n_words);
38FE:  MOVFF  57C,981
3902:  MOVFF  57B,980
3906:  MOVFF  57D,982
390A:  BRA    351A
390C:  MOVFF  01,581
.................... 			break;
3910:  BRA    3966
.................... 		case DEV_TYPE_MODBUS_6:
.................... 			/* write single register */
.................... 			query.resultException=query_self_write_register(query.start_address, 
.................... 				make16(query.buff[query.data_start_offset],query.buff[query.data_start_offset+1]));
3912:  MOVLW  6C
3914:  MOVLB  5
3916:  ADDWF  x7E,W
3918:  MOVWF  FE9
391A:  MOVLW  04
391C:  MOVWF  FEA
391E:  BTFSC  FD8.0
3920:  INCF   FEA,F
3922:  MOVFF  FEF,980
3926:  MOVLW  01
3928:  ADDWF  x7E,W
392A:  ADDLW  6C
392C:  MOVWF  FE9
392E:  MOVLW  04
3930:  MOVWF  FEA
3932:  BTFSC  FD8.0
3934:  INCF   FEA,F
3936:  MOVFF  FEF,981
393A:  MOVFF  980,983
393E:  MOVFF  981,982
3942:  MOVFF  57C,985
3946:  MOVFF  57B,984
394A:  MOVFF  980,987
394E:  MOVFF  981,986
3952:  MOVLB  0
3954:  BRA    355E
3956:  MOVFF  01,581
.................... 			break;
395A:  BRA    3966
.................... 		case DEV_TYPE_MODBUS_16:
.................... 			/* write multiple registers */
.................... 			break;
395C:  BRA    3966
395E:  MOVLB  5
.................... 		default:
.................... 			query.resultException=ILLEGAL_FUNCTION;
3960:  MOVLW  01
3962:  MOVWF  x81
.................... 			query.resultLength=0;
3964:  CLRF   x82
3966:  MOVLB  0
.................... 	}
3968:  GOTO   4212 (RETURN)
.................... }
.................... 
.................... /*
.................... Remote query (from WorldData to us) syntax
.................... '#'                 0  STX
.................... RECV'R ID PREFIX    1  First character (A-Z) for gateway serial number
.................... RECV'R ID MSB       2  gateway serial number
.................... RECV'R ID LSB       3  
.................... PACKET LENGTH       4  
.................... PACKET TYPE         5  type of packet we are receiving (19)
.................... QUERY ID MSB        6  32 bit query id that we must answer with
.................... QUERY ID            7
.................... QUERY ID            8
.................... QUERY ID LSB        9
.................... QUERY DEV SN MSB    10 32 bit serial number of device to query
.................... QUERY DEV SN        11
.................... QUERY DEV SN        12
.................... QUERY DEV SN LSB    13
.................... Q NETWORK ADDR MSB  14 Network address of device to query, if SN not specified
.................... Q NETWORK ADDR LSB  15
.................... QUERY FUNCTION MSB  16 type of query to perform
.................... QUERY FUNCTION LSB  17
.................... QUERY ADDRESS MSB   18 start address for query
.................... QUERY ADDRESS LSB   19
.................... QUERY N WORDS       20 number of 16-bit words in query data
.................... QUERY DATA[0] MSB   [] first word of query data
.................... QUERY DATA[0] LSB   [+1]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... 
.................... Parse first four bytes for match to our serial number. If matched, receive rest 
.................... of packet and do checksum.
.................... 
.................... Send query to network one of two ways:
.................... if ( 0 != query_dev_sn ) then scan device table to determine network id
.................... else use network id
.................... 
.................... if ( 0==network id || our_serial_number==query_dev_sn ) then use local registers
.................... else perform network query
.................... */
.................... 
.................... void query_reset(void) {
.................... 	query.buff_pos=0;
*
0B00:  MOVLB  5
0B02:  CLRF   x6C
.................... 	
.................... 	/* !buff_ready causes serial receive interrupt to throw out data ... so clear last */
.................... 	query.buff_ready=0;
0B04:  CLRF   x6D
0B06:  MOVLB  0
0B08:  RETURN 0
.................... }
.................... 
.................... /* 
.................... response to remote query (from us to WorldData)
.................... '#'                 0  STX
.................... SERIAL PREFIX       1  First character (A-Z) for serial number
.................... SERIAL MSB          2  high byte of sending station ID
.................... SERIAL LSB          3  low byte of sending station ID
.................... PACKET LENGTH       4  always 0xff
.................... PACKET TYPE         5  type of packet we are sending (20)
.................... PACKET LENGTH MSB   6  number of byte for packet including STX through CRC
.................... PACKET LENGTH LSB   7
.................... QUERY ID MSB        8  32 bit query id that we are answering
.................... QUERY ID            9
.................... QUERY ID            10
.................... QUERY ID LSB        11
.................... QUERY EXCEPTION     12 exception encountered in performing query
.................... QUERY DATA[0] MSB [13] first word of query data
.................... QUERY DATA[0] LSB [14]
.................... CRC MSB       length-1 CRC of data
.................... CRC LSB         length
.................... */
.................... void query_response(void) {
.................... 	int8 buff[13];
.................... 	int16 l;
.................... 	int8 i;
.................... 
.................... 	buff[0]='#';
*
3FFC:  MOVLW  23
3FFE:  MOVLB  9
4000:  MOVWF  x80
.................... 	buff[1]=config.serial_prefix;
4002:  MOVFF  583,981
.................... 	buff[2]=make8(config.serial_number,1);
4006:  MOVFF  585,982
400A:  MOVLB  9
.................... 	buff[3]=make8(config.serial_number,0);
400C:  MOVFF  584,983
4010:  MOVLB  9
.................... 	buff[4]=0xff;
4012:  SETF   x84
.................... 	buff[5]=20;
4014:  MOVLW  14
4016:  MOVWF  x85
.................... 	/* packet length */
.................... 	l=sizeof(buff)+query.resultLength+2;
4018:  MOVLW  0D
401A:  MOVLB  5
401C:  ADDWF  x82,W
401E:  ADDLW  02
4020:  MOVLB  9
4022:  MOVWF  x8D
4024:  CLRF   x8E
4026:  BTFSC  FD8.0
4028:  INCF   x8E,F
.................... 	buff[6]=make8(l,1);
402A:  MOVFF  98E,986
.................... 	buff[7]=make8(l,0);
402E:  MOVFF  98D,987
.................... 
.................... 	buff[8]=make8(query.query_id,3);
4032:  MOVFF  572,988
4036:  MOVLB  9
.................... 	buff[9]=make8(query.query_id,2);
4038:  MOVFF  571,989
403C:  MOVLB  9
.................... 	buff[10]=make8(query.query_id,1);
403E:  MOVFF  570,98A
4042:  MOVLB  9
.................... 	buff[11]=make8(query.query_id,0);
4044:  MOVFF  56F,98B
4048:  MOVLB  9
.................... 	buff[12]=query.resultException;
404A:  MOVFF  581,98C
.................... 
.................... 	/* compute CRC on header (skip STX) and result data */
.................... 	l=crc_chk_pass(0xFFFF,buff+1,sizeof(buff)-1);
404E:  SETF   x94
4050:  SETF   x93
4052:  MOVLW  09
4054:  MOVWF  x96
4056:  MOVLW  81
4058:  MOVWF  x95
405A:  MOVLW  0C
405C:  MOVWF  x97
405E:  MOVLB  0
4060:  CALL   2520
4064:  MOVFF  02,98E
4068:  MOVFF  01,98D
.................... 	l=crc_chk_pass(l,query.buff,query.resultLength);
406C:  MOVFF  98E,994
4070:  MOVFF  98D,993
4074:  MOVLW  04
4076:  MOVLB  9
4078:  MOVWF  x96
407A:  MOVLW  6C
407C:  MOVWF  x95
407E:  MOVFF  582,997
4082:  MOVLB  0
4084:  CALL   2520
4088:  MOVFF  02,98E
408C:  MOVFF  01,98D
.................... 
.................... 	output_high(CTRL_0);
4090:  BCF    F92.0
4092:  BSF    F89.0
.................... 	/* send buff, result, CRC */
.................... 	for ( i=0 ; i<sizeof(buff) ; i++ ) {
4094:  MOVLB  9
4096:  CLRF   x8F
4098:  MOVF   x8F,W
409A:  SUBLW  0C
409C:  BNC   40BE
.................... 		fputc(buff[i],STREAM_WORLD);
409E:  CLRF   03
40A0:  MOVF   x8F,W
40A2:  ADDLW  80
40A4:  MOVWF  FE9
40A6:  MOVLW  09
40A8:  ADDWFC 03,W
40AA:  MOVWF  FEA
40AC:  MOVFF  FEF,990
40B0:  MOVF   x90,W
40B2:  MOVLB  0
40B4:  CALL   257E
40B8:  MOVLB  9
40BA:  INCF   x8F,F
40BC:  BRA    4098
.................... 	}	
.................... 	for ( i=0 ; i<query.resultLength ; i++ ) {
40BE:  CLRF   x8F
40C0:  MOVLB  5
40C2:  MOVF   x82,W
40C4:  MOVLB  9
40C6:  SUBWF  x8F,W
40C8:  BC    40EA
.................... 		fputc(query.buff[i],STREAM_WORLD);
40CA:  MOVLW  6C
40CC:  ADDWF  x8F,W
40CE:  MOVWF  FE9
40D0:  MOVLW  04
40D2:  MOVWF  FEA
40D4:  BTFSC  FD8.0
40D6:  INCF   FEA,F
40D8:  MOVFF  FEF,990
40DC:  MOVF   x90,W
40DE:  MOVLB  0
40E0:  CALL   257E
40E4:  MOVLB  9
40E6:  INCF   x8F,F
40E8:  BRA    40C0
.................... 	}
.................... 	fputc(make8(l,1),STREAM_WORLD);
40EA:  MOVFF  98E,990
40EE:  MOVF   x90,W
40F0:  MOVLB  0
40F2:  CALL   257E
.................... 	fputc(make8(l,0),STREAM_WORLD);
40F6:  MOVFF  98D,990
40FA:  MOVLB  9
40FC:  MOVF   x90,W
40FE:  MOVLB  0
4100:  CALL   257E
.................... 
.................... 
.................... 	delay_ms(10);
4104:  MOVLW  0A
4106:  MOVLB  9
4108:  MOVWF  x90
410A:  MOVLB  0
410C:  CALL   0BD2
.................... 	output_low(CTRL_0);
4110:  BCF    F92.0
4112:  BCF    F89.0
.................... 
.................... #if 0
4114:  GOTO   421C (RETURN)
.................... 	fprintf(STREAM_WORLD,"# query result (query.resultLength=%u query.resultException=%u):\r\n",query.resultLength,query.resultException);
.................... 	/* query.resultLength is in bytes  .... result is in 16-bit words */
.................... 	for ( i=0 ; i<query.resultLength ; i+=2 ) {
.................... 		fprintf(STREAM_WORLD,"# query.buff[%u]=%lu (0x%04lX)\r\n",
.................... 			i/2,
.................... 			make16(query.buff[i],query.buff[i+1]),
.................... 			make16(query.buff[i],query.buff[i+1])
.................... 		);
.................... 		query.buff[i]=0xff;
.................... 		query.buff[i+1]=0xff;
.................... 	}
.................... #endif
.................... }
.................... 
.................... /* we received a query addressed to us */
.................... void query_process(void) {
.................... 	int32 our_serial;
.................... //	int8 i;
.................... 	int16 lCRC;
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# in query_process()\r\n");
.................... #endif
.................... 
.................... 	query.packet_length=query.buff[4];
4118:  MOVFF  470,56E
.................... 	query.crc=make16(query.buff[query.packet_length-2],query.buff[query.packet_length-1]);	
411C:  MOVLW  02
411E:  MOVLB  5
4120:  SUBWF  x6E,W
4122:  ADDLW  6C
4124:  MOVWF  FE9
4126:  MOVLW  04
4128:  MOVWF  FEA
412A:  BTFSC  FD8.0
412C:  INCF   FEA,F
412E:  MOVFF  FEF,580
4132:  MOVLW  01
4134:  SUBWF  x6E,W
4136:  ADDLW  6C
4138:  MOVWF  FE9
413A:  MOVLW  04
413C:  MOVWF  FEA
413E:  BTFSC  FD8.0
4140:  INCF   FEA,F
4142:  MOVFF  FEF,57F
.................... 	lCRC = crc_chk_pass(0xFFFF,query.buff+1,query.packet_length-3);
4146:  MOVLW  03
4148:  SUBWF  x6E,W
414A:  MOVLB  9
414C:  MOVWF  x80
414E:  SETF   x94
4150:  SETF   x93
4152:  MOVLW  04
4154:  MOVWF  x96
4156:  MOVLW  6D
4158:  MOVWF  x95
415A:  MOVFF  980,997
415E:  MOVLB  0
4160:  CALL   2520
4164:  MOVFF  02,97F
4168:  MOVFF  01,97E
.................... 
.................... 	if ( lCRC != query.crc ) {
416C:  MOVLB  5
416E:  MOVF   x7F,W
4170:  MOVLB  9
4172:  SUBWF  x7E,W
4174:  BNZ   4180
4176:  MOVLB  5
4178:  MOVF   x80,W
417A:  MOVLB  9
417C:  SUBWF  x7F,W
417E:  BZ    4182
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# CRC 0x%04lX != 0x%04lX (LOCAL)\r\n",query.crc,lCRC);
.................... #endif
.................... 		return;
4180:  BRA    421E
.................... 	}
.................... 
.................... 
.................... 	if ( 19 != query.buff[5] ) {
4182:  MOVLB  4
4184:  MOVF   x71,W
4186:  SUBLW  13
4188:  BZ    4190
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# not query type 19 ... don't know how to handle!\r\n");
.................... #endif
.................... 		return;
418A:  MOVLB  9
418C:  BRA    421E
418E:  MOVLB  4
.................... 	}
.................... 
.................... 	
.................... 	query.query_id=make32(query.buff[6],query.buff[7],query.buff[8],query.buff[9]);
4190:  MOVFF  472,572
4194:  MOVFF  473,571
4198:  MOVFF  474,570
419C:  MOVFF  475,56F
.................... 	query.device_serial=make32(query.buff[10],query.buff[11],query.buff[12],query.buff[13]);
41A0:  MOVFF  476,576
41A4:  MOVFF  477,575
41A8:  MOVFF  478,574
41AC:  MOVFF  479,573
.................... 	query.network_address=make16(query.buff[14],query.buff[15]);
41B0:  MOVFF  47A,578
41B4:  MOVFF  47B,577
.................... 	query.function=make16(query.buff[16],query.buff[17]);
41B8:  MOVFF  47C,57A
41BC:  MOVFF  47D,579
.................... 	query.start_address=make16(query.buff[18],query.buff[19]);
41C0:  MOVFF  47E,57C
41C4:  MOVFF  47F,57B
.................... 	query.n_words=query.buff[20];
41C8:  MOVFF  480,57D
.................... 	query.data_start_offset=21;
41CC:  MOVLW  15
41CE:  MOVLB  5
41D0:  MOVWF  x7E
.................... 	
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# length=%u (query.buff_pos=%u)\r\n",query.packet_length,query.buff_pos);
.................... 	fprintf(STREAM_WORLD,"# query_id=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.query_id,3),
.................... 		make8(query.query_id,2),
.................... 		make8(query.query_id,1),
.................... 		make8(query.query_id,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# device serial=0x%02X %02X %02X %02X\r\n",
.................... 		make8(query.device_serial,3),
.................... 		make8(query.device_serial,2),
.................... 		make8(query.device_serial,1),
.................... 		make8(query.device_serial,0)
.................... 	);
.................... 	fprintf(STREAM_WORLD,"# network address=%lu\r\n",query.network_address);
.................... 	fprintf(STREAM_WORLD,"# function=%lu\r\n",query.function);
.................... 	fprintf(STREAM_WORLD,"# start address=%lu\r\n",query.start_address);
.................... 	fprintf(STREAM_WORLD,"# n_words=%u\r\n",query.n_words);
.................... 
.................... 	/* n words can be the number of query words, in which case we won't have any data besides the CRC */
.................... 	for ( i=0 ; i<query.n_words && i<query.packet_length-2 ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# word[%u]=%lu\r\n",i,make16(query.buff[21+i*2],query.buff[22+i*2]));
.................... 	}
.................... 
.................... 	fprintf(STREAM_WORLD,"# rCRC=%lu\r\n",query.crc);
.................... #endif
.................... 
.................... #if 0
.................... 	fprintf(STREAM_WORLD,"# dump whole packet:\r\n");
.................... 	for ( i=0 ; i<query.packet_length ; i++ ) {
.................... 		fprintf(STREAM_WORLD,"# buff[%u]=0x%02X",i,query.buff[i]);
.................... 		if ( i==query.data_start_offset )
.................... 			fprintf(STREAM_WORLD," (start)");
.................... 		fprintf(STREAM_WORLD,"\r\n");
.................... 	}
.................... #endif
.................... 
.................... 	query.resultLength=0;
41D2:  CLRF   x82
.................... 	/* check to see who handles this query */
.................... 	our_serial=make32(0,config.serial_prefix,config.serial_number);
41D4:  MOVLB  9
41D6:  CLRF   x7D
41D8:  MOVFF  583,97C
41DC:  MOVFF  584,97A
41E0:  MOVFF  585,97B
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"#   our serial=%c%lu\r\n",config.serial_prefix,config.serial_number);
.................... 	fprintf(STREAM_WORLD,"# query serial=%c%lu\r\n",make8(query.device_serial,2),(int16) query.device_serial);
.................... #endif
.................... 
.................... 	if ( our_serial == query.device_serial ) {
41E4:  MOVLB  5
41E6:  MOVF   x73,W
41E8:  MOVLB  9
41EA:  SUBWF  x7A,W
41EC:  BNZ   4216
41EE:  MOVLB  5
41F0:  MOVF   x74,W
41F2:  MOVLB  9
41F4:  SUBWF  x7B,W
41F6:  BNZ   4216
41F8:  MOVLB  5
41FA:  MOVF   x75,W
41FC:  MOVLB  9
41FE:  SUBWF  x7C,W
4200:  BNZ   4216
4202:  MOVLB  5
4204:  MOVF   x76,W
4206:  MOVLB  9
4208:  SUBWF  x7D,W
420A:  BNZ   4216
.................... 		query_self();
420C:  MOVLB  0
420E:  GOTO   38B8
.................... 	} else {
4212:  BRA    421A
4214:  MOVLB  9
.................... 		query_other();
4216:  MOVLB  0
4218:  BRA    3CD8
.................... 		
.................... 	}	
.................... 
.................... 	query_response();
421A:  BRA    3FFC
421C:  MOVLB  9
421E:  MOVLB  0
4220:  GOTO   459E (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void deviceQuery(void) {
.................... 	static int16 measurementNumber=0;
.................... 	static int8  nCycles[DEV_MAX_N];
.................... 	int8 n;
.................... 	int16 l;
.................... #if DEBUG_ASCII
.................... 	int8 i;
.................... #endif
.................... 
.................... 	/* check if next cycle will be an SBD transmission. */
.................... 	if ( 1 == timers.sbd_cycle ) {
*
290C:  MOVLB  3
290E:  DECFSZ x65,W
2910:  BRA    292A
2912:  MOVF   x66,F
2914:  BNZ   292A
.................... 		/* next cycle will be an Iridium transmit cycle, so turn on modem and clear outgoing buffer */
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() next cycle will be SBD transmit cycle.\r\n");
2916:  MOVLW  C8
2918:  MOVWF  FF6
291A:  MOVLW  08
291C:  MOVWF  FF7
291E:  MOVLB  0
2920:  CALL   0C76
.................... #endif
.................... //		iridium_on();
.................... 		iridium_mo_clear();
2924:  CALL   1D74
2928:  MOVLB  3
.................... 	}
.................... 
.................... 	/* check if we are going to be doing a SBD transmision */
.................... 	if ( 0 == timers.sbd_cycle ) {
292A:  MOVF   x65,F
292C:  BNZ   298A
292E:  MOVF   x66,F
2930:  BNZ   298A
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() this cycle is an SBD transmit cycle.\r\n");
2932:  MOVLW  02
2934:  MOVWF  FF6
2936:  MOVLW  09
2938:  MOVWF  FF7
293A:  MOVLB  0
293C:  CALL   0C76
.................... #endif
.................... 		/* turn on modem in case it isn't already on */
.................... //		iridium_on();
.................... 		/* clear MO buffer */
.................... 		iridium_mo_clear();
2940:  CALL   1D74
.................... 
.................... 		/* build header */
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,1);
2944:  MOVLB  7
2946:  MOVFF  7DB,03
294A:  MOVF   xDA,W
294C:  INCF   xDA,F
294E:  BTFSC  FD8.2
2950:  INCF   xDB,F
2952:  MOVLB  9
2954:  MOVWF  x7D
2956:  MOVLW  CA
2958:  ADDWF  x7D,W
295A:  MOVWF  FE9
295C:  MOVLW  06
295E:  ADDWFC 03,W
2960:  MOVWF  FEA
2962:  MOVFF  938,FEF
.................... 		sbd.mo_buff[sbd.mo_length++]=make8(measurementNumber,0);
2966:  MOVLB  7
2968:  MOVFF  7DB,03
296C:  MOVF   xDA,W
296E:  INCF   xDA,F
2970:  BTFSC  FD8.2
2972:  INCF   xDB,F
2974:  MOVLB  9
2976:  MOVWF  x7D
2978:  MOVLW  CA
297A:  ADDWF  x7D,W
297C:  MOVWF  FE9
297E:  MOVLW  06
2980:  ADDWFC 03,W
2982:  MOVWF  FEA
2984:  MOVFF  937,FEF
2988:  MOVLB  3
.................... 	}
.................... 
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() querying all enabled devices:\r\n");
.................... #endif
.................... 
.................... 	for ( n=0 ; n<DEV_MAX_N ; n++ ) {
298A:  MOVLB  9
298C:  CLRF   x7A
298E:  MOVF   x7A,W
2990:  SUBLW  3F
2992:  BTFSS  FD8.0
2994:  BRA    30A6
.................... 		restart_wdt();
2996:  CLRWDT
.................... 		timers.led_on_green=100;
2998:  MOVLW  64
299A:  MOVLB  3
299C:  MOVWF  x64
.................... 
.................... 		/* skip disabled devices */
.................... 		if ( DEV_TYPE_DISABLED == device[n].type ) 
299E:  MOVLB  9
29A0:  CLRF   x95
29A2:  MOVFF  97A,994
29A6:  CLRF   x97
29A8:  MOVLW  0D
29AA:  MOVWF  x96
29AC:  MOVLB  0
29AE:  CALL   0DE0
29B2:  MOVFF  02,97E
29B6:  MOVFF  01,97D
29BA:  MOVLW  21
29BC:  MOVLB  9
29BE:  ADDWF  01,W
29C0:  MOVWF  FE9
29C2:  MOVLW  00
29C4:  ADDWFC 02,W
29C6:  MOVWF  FEA
29C8:  MOVF   FEF,W
29CA:  BNZ   29CE
.................... 			continue;
29CC:  BRA    309E
.................... 
.................... 		nCycles[n]++;
29CE:  CLRF   03
29D0:  MOVF   x7A,W
29D2:  ADDLW  39
29D4:  MOVWF  FE9
29D6:  MOVLW  09
29D8:  ADDWFC 03,W
29DA:  MOVWF  FEA
29DC:  INCF   FEF,F
.................... 		if ( nCycles[n] < device[n].transmitEvery ) {
29DE:  CLRF   03
29E0:  MOVF   x7A,W
29E2:  ADDLW  39
29E4:  MOVWF  FE9
29E6:  MOVLW  09
29E8:  ADDWFC 03,W
29EA:  MOVWF  FEA
29EC:  MOVFF  FEF,97D
29F0:  CLRF   x95
29F2:  MOVFF  97A,994
29F6:  CLRF   x97
29F8:  MOVLW  0D
29FA:  MOVWF  x96
29FC:  MOVLB  0
29FE:  CALL   0DE0
2A02:  MOVFF  02,97F
2A06:  MOVFF  01,97E
2A0A:  MOVLW  03
2A0C:  MOVLB  9
2A0E:  ADDWF  01,W
2A10:  MOVWF  01
2A12:  MOVLW  00
2A14:  ADDWFC 02,W
2A16:  MOVWF  03
2A18:  MOVF   01,W
2A1A:  ADDLW  21
2A1C:  MOVWF  FE9
2A1E:  MOVLW  00
2A20:  ADDWFC 03,W
2A22:  MOVWF  FEA
2A24:  MOVF   FEF,W
2A26:  SUBWF  x7D,W
2A28:  BC    2A2E
.................... 			continue;
2A2A:  BRA    309E
.................... 		} else {
2A2C:  BRA    2A3E
.................... 			nCycles[n]=0;
2A2E:  CLRF   03
2A30:  MOVF   x7A,W
2A32:  ADDLW  39
2A34:  MOVWF  FE9
2A36:  MOVLW  09
2A38:  ADDWFC 03,W
2A3A:  MOVWF  FEA
2A3C:  CLRF   FEF
.................... 		}
.................... 
.................... 
.................... 
.................... 		qbuff.deviceNumber=n;
2A3E:  MOVFF  97A,469
.................... 		qbuff.measurementNumber=measurementNumber;
2A42:  MOVFF  938,46B
2A46:  MOVFF  937,46A
.................... 
.................... 
.................... 		if ( device[n].type <= DEV_TYPE_MODBUS_MAX ) {
2A4A:  CLRF   x95
2A4C:  MOVFF  97A,994
2A50:  CLRF   x97
2A52:  MOVLW  0D
2A54:  MOVWF  x96
2A56:  MOVLB  0
2A58:  CALL   0DE0
2A5C:  MOVFF  02,97E
2A60:  MOVFF  01,97D
2A64:  MOVLW  21
2A66:  MOVLB  9
2A68:  ADDWF  01,W
2A6A:  MOVWF  FE9
2A6C:  MOVLW  00
2A6E:  ADDWFC 02,W
2A70:  MOVWF  FEA
2A72:  MOVF   FEF,W
2A74:  SUBLW  07
2A76:  BTFSS  FD8.0
2A78:  BRA    2E8A
.................... 			/* modbus device type */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() MODBUS device\r\n");
.................... #endif
.................... 			/* set serial port speed */
.................... 			if ( DEV_SERIAL_19200 == device[n].serialSpeed ) {
2A7A:  CLRF   x95
2A7C:  MOVFF  97A,994
2A80:  CLRF   x97
2A82:  MOVLW  0D
2A84:  MOVWF  x96
2A86:  MOVLB  0
2A88:  CALL   0DE0
2A8C:  MOVFF  02,97E
2A90:  MOVFF  01,97D
2A94:  MOVLW  0C
2A96:  MOVLB  9
2A98:  ADDWF  01,W
2A9A:  MOVWF  01
2A9C:  MOVLW  00
2A9E:  ADDWFC 02,W
2AA0:  MOVWF  03
2AA2:  MOVF   01,W
2AA4:  ADDLW  21
2AA6:  MOVWF  FE9
2AA8:  MOVLW  00
2AAA:  ADDWFC 03,W
2AAC:  MOVWF  FEA
2AAE:  MOVF   FEF,W
2AB0:  SUBLW  01
2AB2:  BNZ   2AC4
.................... 				set_uart_speed(19200,MODBUS_SERIAL);
2AB4:  BCF    FA7.3
2AB6:  MOVLW  19
2AB8:  MOVWF  FAF
2ABA:  MOVLW  A6
2ABC:  MOVWF  FAC
2ABE:  MOVLW  90
2AC0:  MOVWF  FAB
.................... 			} else {
2AC2:  BRA    2AD2
.................... 				set_uart_speed(9600,MODBUS_SERIAL);
2AC4:  BCF    FA7.3
2AC6:  MOVLW  0C
2AC8:  MOVWF  FAF
2ACA:  MOVLW  A2
2ACC:  MOVWF  FAC
2ACE:  MOVLW  90
2AD0:  MOVWF  FAB
.................... 			}
.................... 
.................... 			if ( DEV_TYPE_MODBUS_3 == device[n].type || DEV_TYPE_MODBUS_4 == device[n].type ) {
2AD2:  CLRF   x95
2AD4:  MOVFF  97A,994
2AD8:  CLRF   x97
2ADA:  MOVLW  0D
2ADC:  MOVWF  x96
2ADE:  MOVLB  0
2AE0:  CALL   0DE0
2AE4:  MOVFF  02,97E
2AE8:  MOVFF  01,97D
2AEC:  MOVLW  21
2AEE:  MOVLB  9
2AF0:  ADDWF  01,W
2AF2:  MOVWF  FE9
2AF4:  MOVLW  00
2AF6:  ADDWFC 02,W
2AF8:  MOVWF  FEA
2AFA:  MOVF   FEF,W
2AFC:  SUBLW  03
2AFE:  BZ    2B30
2B00:  CLRF   x95
2B02:  MOVFF  97A,994
2B06:  CLRF   x97
2B08:  MOVLW  0D
2B0A:  MOVWF  x96
2B0C:  MOVLB  0
2B0E:  CALL   0DE0
2B12:  MOVFF  02,980
2B16:  MOVFF  01,97F
2B1A:  MOVLW  21
2B1C:  MOVLB  9
2B1E:  ADDWF  01,W
2B20:  MOVWF  FE9
2B22:  MOVLW  00
2B24:  ADDWFC 02,W
2B26:  MOVWF  FEA
2B28:  MOVF   FEF,W
2B2A:  SUBLW  04
2B2C:  BTFSS  FD8.2
2B2E:  BRA    2D28
.................... 				/* Modbus read input or holding registers */
.................... 				if ( DEV_TYPE_MODBUS_4 == device[n].type ) {
2B30:  CLRF   x95
2B32:  MOVFF  97A,994
2B36:  CLRF   x97
2B38:  MOVLW  0D
2B3A:  MOVWF  x96
2B3C:  MOVLB  0
2B3E:  CALL   0DE0
2B42:  MOVFF  02,97E
2B46:  MOVFF  01,97D
2B4A:  MOVLW  21
2B4C:  MOVLB  9
2B4E:  ADDWF  01,W
2B50:  MOVWF  FE9
2B52:  MOVLW  00
2B54:  ADDWFC 02,W
2B56:  MOVWF  FEA
2B58:  MOVF   FEF,W
2B5A:  SUBLW  04
2B5C:  BNZ   2C24
.................... 					qbuff.rException=modbus_read_input_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
2B5E:  CLRF   x95
2B60:  MOVFF  97A,994
2B64:  CLRF   x97
2B66:  MOVLW  0D
2B68:  MOVWF  x96
2B6A:  MOVLB  0
2B6C:  CALL   0DE0
2B70:  MOVFF  02,97E
2B74:  MOVFF  01,97D
2B78:  MOVLW  04
2B7A:  MOVLB  9
2B7C:  ADDWF  01,W
2B7E:  MOVWF  01
2B80:  MOVLW  00
2B82:  ADDWFC 02,W
2B84:  MOVWF  03
2B86:  MOVF   01,W
2B88:  ADDLW  21
2B8A:  MOVWF  FE9
2B8C:  MOVLW  00
2B8E:  ADDWFC 03,W
2B90:  MOVWF  FEA
2B92:  MOVFF  FEF,97D
2B96:  CLRF   x95
2B98:  MOVFF  97A,994
2B9C:  CLRF   x97
2B9E:  MOVLW  0D
2BA0:  MOVWF  x96
2BA2:  MOVLB  0
2BA4:  CALL   0DE0
2BA8:  MOVFF  01,97E
2BAC:  MOVLW  09
2BAE:  MOVLB  9
2BB0:  ADDWF  01,W
2BB2:  MOVWF  01
2BB4:  MOVLW  00
2BB6:  ADDWFC 02,W
2BB8:  MOVWF  03
2BBA:  MOVF   01,W
2BBC:  ADDLW  21
2BBE:  MOVWF  FE9
2BC0:  MOVLW  00
2BC2:  ADDWFC 03,W
2BC4:  MOVWF  FEA
2BC6:  MOVFF  FEC,97F
2BCA:  MOVF   FED,F
2BCC:  MOVFF  FEF,97E
2BD0:  CLRF   x95
2BD2:  MOVFF  97A,994
2BD6:  CLRF   x97
2BD8:  MOVLW  0D
2BDA:  MOVWF  x96
2BDC:  MOVLB  0
2BDE:  CALL   0DE0
2BE2:  MOVFF  02,981
2BE6:  MOVFF  01,980
2BEA:  MOVLW  0B
2BEC:  MOVLB  9
2BEE:  ADDWF  01,W
2BF0:  MOVWF  01
2BF2:  MOVLW  00
2BF4:  ADDWFC 02,W
2BF6:  MOVWF  03
2BF8:  MOVF   01,W
2BFA:  ADDLW  21
2BFC:  MOVWF  FE9
2BFE:  MOVLW  00
2C00:  ADDWFC 03,W
2C02:  MOVWF  FEA
2C04:  MOVFF  FEF,985
2C08:  MOVFF  97D,982
2C0C:  MOVFF  97F,984
2C10:  MOVFF  97E,983
2C14:  CLRF   x86
2C16:  MOVLB  0
2C18:  CALL   23F0
2C1C:  MOVFF  01,367
.................... 				} else {
2C20:  BRA    2CE6
2C22:  MOVLB  9
.................... 					qbuff.rException=modbus_read_holding_registers(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
2C24:  CLRF   x95
2C26:  MOVFF  97A,994
2C2A:  CLRF   x97
2C2C:  MOVLW  0D
2C2E:  MOVWF  x96
2C30:  MOVLB  0
2C32:  CALL   0DE0
2C36:  MOVFF  02,97E
2C3A:  MOVFF  01,97D
2C3E:  MOVLW  04
2C40:  MOVLB  9
2C42:  ADDWF  01,W
2C44:  MOVWF  01
2C46:  MOVLW  00
2C48:  ADDWFC 02,W
2C4A:  MOVWF  03
2C4C:  MOVF   01,W
2C4E:  ADDLW  21
2C50:  MOVWF  FE9
2C52:  MOVLW  00
2C54:  ADDWFC 03,W
2C56:  MOVWF  FEA
2C58:  MOVFF  FEF,97D
2C5C:  CLRF   x95
2C5E:  MOVFF  97A,994
2C62:  CLRF   x97
2C64:  MOVLW  0D
2C66:  MOVWF  x96
2C68:  MOVLB  0
2C6A:  CALL   0DE0
2C6E:  MOVFF  01,97E
2C72:  MOVLW  09
2C74:  MOVLB  9
2C76:  ADDWF  01,W
2C78:  MOVWF  01
2C7A:  MOVLW  00
2C7C:  ADDWFC 02,W
2C7E:  MOVWF  03
2C80:  MOVF   01,W
2C82:  ADDLW  21
2C84:  MOVWF  FE9
2C86:  MOVLW  00
2C88:  ADDWFC 03,W
2C8A:  MOVWF  FEA
2C8C:  MOVFF  FEC,97F
2C90:  MOVF   FED,F
2C92:  MOVFF  FEF,97E
2C96:  CLRF   x95
2C98:  MOVFF  97A,994
2C9C:  CLRF   x97
2C9E:  MOVLW  0D
2CA0:  MOVWF  x96
2CA2:  MOVLB  0
2CA4:  CALL   0DE0
2CA8:  MOVFF  02,981
2CAC:  MOVFF  01,980
2CB0:  MOVLW  0B
2CB2:  MOVLB  9
2CB4:  ADDWF  01,W
2CB6:  MOVWF  01
2CB8:  MOVLW  00
2CBA:  ADDWFC 02,W
2CBC:  MOVWF  03
2CBE:  MOVF   01,W
2CC0:  ADDLW  21
2CC2:  MOVWF  FE9
2CC4:  MOVLW  00
2CC6:  ADDWFC 03,W
2CC8:  MOVWF  FEA
2CCA:  MOVFF  FEF,985
2CCE:  MOVFF  97D,982
2CD2:  MOVFF  97F,984
2CD6:  MOVFF  97E,983
2CDA:  CLRF   x86
2CDC:  MOVLB  0
2CDE:  CALL   2488
2CE2:  MOVFF  01,367
.................... 				}
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
2CE6:  MOVLB  3
2CE8:  MOVF   x67,F
2CEA:  BNZ   2D24
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
2CEC:  MOVLW  01
2CEE:  MOVLB  5
2CF0:  SUBWF  x94,W
2CF2:  MOVLB  4
2CF4:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
2CF6:  MOVLW  01
2CF8:  MOVLB  5
2CFA:  SUBWF  x94,W
2CFC:  MOVLB  9
2CFE:  MOVWF  x7D
2D00:  MOVLW  03
2D02:  MOVWF  FEA
2D04:  MOVLW  68
2D06:  MOVWF  FE9
2D08:  MOVLW  05
2D0A:  MOVWF  FE2
2D0C:  MOVLW  98
2D0E:  MOVWF  FE1
2D10:  MOVF   x7D,W
2D12:  MOVWF  01
2D14:  BZ    2D1E
2D16:  MOVFF  FE6,FEE
2D1A:  DECFSZ 01,F
2D1C:  BRA    2D16
.................... 
.................... 					live_send();
2D1E:  MOVLB  0
2D20:  RCALL  2586
2D22:  MOVLB  3
.................... 				}
.................... 			} else if ( DEV_TYPE_MODBUS_1==device[n].type || DEV_TYPE_MODBUS_2==device[n].type ) {
2D24:  BRA    2E86
2D26:  MOVLB  9
2D28:  CLRF   x95
2D2A:  MOVFF  97A,994
2D2E:  CLRF   x97
2D30:  MOVLW  0D
2D32:  MOVWF  x96
2D34:  MOVLB  0
2D36:  CALL   0DE0
2D3A:  MOVFF  02,97E
2D3E:  MOVFF  01,97D
2D42:  MOVLW  21
2D44:  MOVLB  9
2D46:  ADDWF  01,W
2D48:  MOVWF  FE9
2D4A:  MOVLW  00
2D4C:  ADDWFC 02,W
2D4E:  MOVWF  FEA
2D50:  MOVF   FEF,W
2D52:  SUBLW  01
2D54:  BZ    2D86
2D56:  CLRF   x95
2D58:  MOVFF  97A,994
2D5C:  CLRF   x97
2D5E:  MOVLW  0D
2D60:  MOVWF  x96
2D62:  MOVLB  0
2D64:  CALL   0DE0
2D68:  MOVFF  02,980
2D6C:  MOVFF  01,97F
2D70:  MOVLW  21
2D72:  MOVLB  9
2D74:  ADDWF  01,W
2D76:  MOVWF  FE9
2D78:  MOVLW  00
2D7A:  ADDWFC 02,W
2D7C:  MOVWF  FEA
2D7E:  MOVF   FEF,W
2D80:  SUBLW  02
2D82:  BTFSS  FD8.2
2D84:  BRA    2E88
.................... 				/* Modbus read coil or discrete input */
.................... 				qbuff.rException=modbus_read_coils(device[n].networkAddress, device[n].startRegister, device[n].nRegisters);
2D86:  CLRF   x95
2D88:  MOVFF  97A,994
2D8C:  CLRF   x97
2D8E:  MOVLW  0D
2D90:  MOVWF  x96
2D92:  MOVLB  0
2D94:  CALL   0DE0
2D98:  MOVFF  02,97E
2D9C:  MOVFF  01,97D
2DA0:  MOVLW  04
2DA2:  MOVLB  9
2DA4:  ADDWF  01,W
2DA6:  MOVWF  01
2DA8:  MOVLW  00
2DAA:  ADDWFC 02,W
2DAC:  MOVWF  03
2DAE:  MOVF   01,W
2DB0:  ADDLW  21
2DB2:  MOVWF  FE9
2DB4:  MOVLW  00
2DB6:  ADDWFC 03,W
2DB8:  MOVWF  FEA
2DBA:  MOVFF  FEF,97D
2DBE:  CLRF   x95
2DC0:  MOVFF  97A,994
2DC4:  CLRF   x97
2DC6:  MOVLW  0D
2DC8:  MOVWF  x96
2DCA:  MOVLB  0
2DCC:  CALL   0DE0
2DD0:  MOVFF  01,97E
2DD4:  MOVLW  09
2DD6:  MOVLB  9
2DD8:  ADDWF  01,W
2DDA:  MOVWF  01
2DDC:  MOVLW  00
2DDE:  ADDWFC 02,W
2DE0:  MOVWF  03
2DE2:  MOVF   01,W
2DE4:  ADDLW  21
2DE6:  MOVWF  FE9
2DE8:  MOVLW  00
2DEA:  ADDWFC 03,W
2DEC:  MOVWF  FEA
2DEE:  MOVFF  FEC,97F
2DF2:  MOVF   FED,F
2DF4:  MOVFF  FEF,97E
2DF8:  CLRF   x95
2DFA:  MOVFF  97A,994
2DFE:  CLRF   x97
2E00:  MOVLW  0D
2E02:  MOVWF  x96
2E04:  MOVLB  0
2E06:  CALL   0DE0
2E0A:  MOVFF  02,981
2E0E:  MOVFF  01,980
2E12:  MOVLW  0B
2E14:  MOVLB  9
2E16:  ADDWF  01,W
2E18:  MOVWF  01
2E1A:  MOVLW  00
2E1C:  ADDWFC 02,W
2E1E:  MOVWF  03
2E20:  MOVF   01,W
2E22:  ADDLW  21
2E24:  MOVWF  FE9
2E26:  MOVLW  00
2E28:  ADDWFC 03,W
2E2A:  MOVWF  FEA
2E2C:  MOVFF  FEF,985
2E30:  MOVFF  97D,982
2E34:  MOVFF  97F,984
2E38:  MOVFF  97E,983
2E3C:  CLRF   x86
2E3E:  MOVLB  0
2E40:  RCALL  27EA
2E42:  MOVFF  01,367
.................... 
.................... 				/* no error, copy data to buffer to send */
.................... 				if ( 0 == qbuff.rException ) {
2E46:  MOVLB  3
2E48:  MOVF   x67,F
2E4A:  BNZ   2E86
.................... 					/* prepare qbuff with data to live send */
.................... 					qbuff.rResultLength=modbus_rx.len-1;
2E4C:  MOVLW  01
2E4E:  MOVLB  5
2E50:  SUBWF  x94,W
2E52:  MOVLB  4
2E54:  MOVWF  x68
.................... 					/* copy Modbus results to live buffer */
.................... 					memcpy(&qbuff.rResult,&modbus_rx.data[1],modbus_rx.len-1); 
2E56:  MOVLW  01
2E58:  MOVLB  5
2E5A:  SUBWF  x94,W
2E5C:  MOVLB  9
2E5E:  MOVWF  x7D
2E60:  MOVLW  03
2E62:  MOVWF  FEA
2E64:  MOVLW  68
2E66:  MOVWF  FE9
2E68:  MOVLW  05
2E6A:  MOVWF  FE2
2E6C:  MOVLW  98
2E6E:  MOVWF  FE1
2E70:  MOVF   x7D,W
2E72:  MOVWF  01
2E74:  BZ    2E7E
2E76:  MOVFF  FE6,FEE
2E7A:  DECFSZ 01,F
2E7C:  BRA    2E76
.................... 
.................... 					live_send();
2E7E:  MOVLB  0
2E80:  CALL   2586
2E84:  MOVLB  3
2E86:  MOVLB  9
.................... 				}
.................... 			}
.................... 		} else if ( device[n].type <= DEV_TYPE_I2C_MAX ) {
2E88:  BRA    2FEA
2E8A:  CLRF   x95
2E8C:  MOVFF  97A,994
2E90:  CLRF   x97
2E92:  MOVLW  0D
2E94:  MOVWF  x96
2E96:  MOVLB  0
2E98:  CALL   0DE0
2E9C:  MOVFF  02,97E
2EA0:  MOVFF  01,97D
2EA4:  MOVLW  21
2EA6:  MOVLB  9
2EA8:  ADDWF  01,W
2EAA:  MOVWF  FE9
2EAC:  MOVLW  00
2EAE:  ADDWFC 02,W
2EB0:  MOVWF  FEA
2EB2:  MOVF   FEF,W
2EB4:  SUBLW  17
2EB6:  BTFSS  FD8.0
2EB8:  BRA    2FEA
.................... 			/* I2C device */
.................... 
.................... #if DEBUG_ASCII
.................... 			restart_wdt();
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() I2C device\r\n");
.................... 			fprintf(STREAM_WORLD,"device[%u]\r\n",n);
.................... 			fprintf(STREAM_WORLD,"\ttype=%u\r\n",device[n].type);
.................... 			fprintf(STREAM_WORLD,"\ttransmitEvery=%u\r\n",device[n].transmitEvery);
.................... 			fprintf(STREAM_WORLD,"\tnetworkAddress=0x%02x\r\n",device[n].networkAddress);
.................... 			fprintf(STREAM_WORLD,"\tserialNumber=0x%02x%02x%02x%02x\r\n",
.................... 				make8(device[n].serialNumber,3),
.................... 				make8(device[n].serialNumber,2),
.................... 				make8(device[n].serialNumber,1),
.................... 				make8(device[n].serialNumber,0)
.................... 			);
.................... 			fprintf(STREAM_WORLD,"\tstartRegister=%lu\r\n",device[n].startRegister);
.................... 			fprintf(STREAM_WORLD,"\tnRegisters=%u\r\n",device[n].nRegisters);
.................... #endif
.................... 
.................... 			if ( DEV_TYPE_I2C_READ_8 == device[n].type ) {
2EBA:  CLRF   x95
2EBC:  MOVFF  97A,994
2EC0:  CLRF   x97
2EC2:  MOVLW  0D
2EC4:  MOVWF  x96
2EC6:  MOVLB  0
2EC8:  CALL   0DE0
2ECC:  MOVFF  02,97E
2ED0:  MOVFF  01,97D
2ED4:  MOVLW  21
2ED6:  MOVLB  9
2ED8:  ADDWF  01,W
2EDA:  MOVWF  FE9
2EDC:  MOVLW  00
2EDE:  ADDWFC 02,W
2EE0:  MOVWF  FEA
2EE2:  MOVF   FEF,W
2EE4:  SUBLW  10
2EE6:  BTFSS  FD8.2
2EE8:  BRA    2FEA
.................... 				/* start a read at start address then just read a byte at a time. nRegisters is bytes */
.................... //fprintf(STREAM_WORLD,"z");
.................... 				i2c_buff_read(device[n].networkAddress, device[n].startRegister, qbuff.rResult, device[n].nRegisters);
2EEA:  CLRF   x95
2EEC:  MOVFF  97A,994
2EF0:  CLRF   x97
2EF2:  MOVLW  0D
2EF4:  MOVWF  x96
2EF6:  MOVLB  0
2EF8:  CALL   0DE0
2EFC:  MOVFF  02,97E
2F00:  MOVFF  01,97D
2F04:  MOVLW  04
2F06:  MOVLB  9
2F08:  ADDWF  01,W
2F0A:  MOVWF  01
2F0C:  MOVLW  00
2F0E:  ADDWFC 02,W
2F10:  MOVWF  03
2F12:  MOVF   01,W
2F14:  ADDLW  21
2F16:  MOVWF  FE9
2F18:  MOVLW  00
2F1A:  ADDWFC 03,W
2F1C:  MOVWF  FEA
2F1E:  MOVFF  FEF,97D
2F22:  CLRF   x95
2F24:  MOVFF  97A,994
2F28:  CLRF   x97
2F2A:  MOVLW  0D
2F2C:  MOVWF  x96
2F2E:  MOVLB  0
2F30:  CALL   0DE0
2F34:  MOVFF  01,97E
2F38:  MOVLW  09
2F3A:  MOVLB  9
2F3C:  ADDWF  01,W
2F3E:  MOVWF  01
2F40:  MOVLW  00
2F42:  ADDWFC 02,W
2F44:  MOVWF  03
2F46:  MOVF   01,W
2F48:  ADDLW  21
2F4A:  MOVWF  FE9
2F4C:  MOVLW  00
2F4E:  ADDWFC 03,W
2F50:  MOVWF  FEA
2F52:  MOVFF  FEC,97F
2F56:  MOVF   FED,F
2F58:  MOVFF  FEF,97E
2F5C:  CLRF   x95
2F5E:  MOVFF  97A,994
2F62:  CLRF   x97
2F64:  MOVLW  0D
2F66:  MOVWF  x96
2F68:  MOVLB  0
2F6A:  CALL   0DE0
2F6E:  MOVFF  02,981
2F72:  MOVFF  01,980
2F76:  MOVLW  0B
2F78:  MOVLB  9
2F7A:  ADDWF  01,W
2F7C:  MOVWF  01
2F7E:  MOVLW  00
2F80:  ADDWFC 02,W
2F82:  MOVWF  03
2F84:  MOVF   01,W
2F86:  ADDLW  21
2F88:  MOVWF  FE9
2F8A:  MOVLW  00
2F8C:  ADDWFC 03,W
2F8E:  MOVWF  FEA
2F90:  MOVFF  FEF,986
2F94:  MOVFF  97D,982
2F98:  MOVFF  97E,983
2F9C:  MOVLW  03
2F9E:  MOVWF  x85
2FA0:  MOVLW  68
2FA2:  MOVWF  x84
2FA4:  MOVLB  0
2FA6:  RCALL  2882
.................... 
.................... 				qbuff.rException=0;
2FA8:  MOVLB  3
2FAA:  CLRF   x67
.................... 				qbuff.rResultLength=device[n].nRegisters;
2FAC:  MOVLB  9
2FAE:  CLRF   x95
2FB0:  MOVFF  97A,994
2FB4:  CLRF   x97
2FB6:  MOVLW  0D
2FB8:  MOVWF  x96
2FBA:  MOVLB  0
2FBC:  CALL   0DE0
2FC0:  MOVFF  01,97D
2FC4:  MOVLW  0B
2FC6:  MOVLB  9
2FC8:  ADDWF  01,W
2FCA:  MOVWF  01
2FCC:  MOVLW  00
2FCE:  ADDWFC 02,W
2FD0:  MOVWF  03
2FD2:  MOVF   01,W
2FD4:  ADDLW  21
2FD6:  MOVWF  FE9
2FD8:  MOVLW  00
2FDA:  ADDWFC 03,W
2FDC:  MOVWF  FEA
2FDE:  MOVFF  FEF,468
.................... //fprintf(STREAM_WORLD,"Z");
.................... #if DEBUG_ASCII
.................... 				/* debug dump */
.................... 				restart_wdt();
.................... 				for ( i=0 ; i<device[n].nRegisters ; i++ ) {
.................... 					fprintf(STREAM_WORLD,"# reg addr[0x%02x]=0x%02x (%u)\r\n",i+device[n].startRegister,qbuff.rResult[i],qbuff.rResult[i]);
.................... 				}
.................... #endif
.................... 
.................... 				live_send();
2FE2:  MOVLB  0
2FE4:  CALL   2586
2FE8:  MOVLB  9
.................... 
.................... 			}
.................... 
.................... 		} else {
.................... 			/* local */
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() local (not implemented) device\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* Add data to SBD if this is an SBD cycle and we have valid data */
.................... 		if ( 0 == timers.sbd_cycle && 0 == qbuff.rException ) {
2FEA:  MOVLB  3
2FEC:  MOVF   x65,F
2FEE:  BNZ   30A0
2FF0:  MOVF   x66,F
2FF2:  BNZ   30A0
2FF4:  MOVF   x67,F
2FF6:  BNZ   30A0
.................... #if DEBUG_SBD
.................... 			fprintf(STREAM_WORLD,"# deviceQuery() adding to sbd.mo_buff since qbuff.rException=0\r\n");
2FF8:  MOVLW  3A
2FFA:  MOVWF  FF6
2FFC:  MOVLW  09
2FFE:  MOVWF  FF7
3000:  MOVLB  0
3002:  CALL   0C76
.................... #endif
.................... 			/* sub-header, 2 bytes, device number, and data length */
.................... 			sbd.mo_buff[sbd.mo_length++]=n;
3006:  MOVLB  7
3008:  MOVFF  7DB,03
300C:  MOVF   xDA,W
300E:  INCF   xDA,F
3010:  BTFSC  FD8.2
3012:  INCF   xDB,F
3014:  MOVLB  9
3016:  MOVWF  x7D
3018:  MOVLW  CA
301A:  ADDWF  x7D,W
301C:  MOVWF  FE9
301E:  MOVLW  06
3020:  ADDWFC 03,W
3022:  MOVWF  FEA
3024:  MOVFF  97A,FEF
.................... 			sbd.mo_buff[sbd.mo_length++]=qbuff.rResultLength;
3028:  MOVLB  7
302A:  MOVFF  7DB,03
302E:  MOVF   xDA,W
3030:  INCF   xDA,F
3032:  BTFSC  FD8.2
3034:  INCF   xDB,F
3036:  MOVLB  9
3038:  MOVWF  x7D
303A:  MOVLW  CA
303C:  ADDWF  x7D,W
303E:  MOVWF  FE9
3040:  MOVLW  06
3042:  ADDWFC 03,W
3044:  MOVWF  FEA
3046:  MOVFF  468,FEF
.................... 		
.................... 			/* sub-message */
.................... 			for ( l=0 ; l<qbuff.rResultLength ; l++ ) {
304A:  CLRF   x7C
304C:  CLRF   x7B
304E:  MOVF   x7C,F
3050:  BNZ   309E
3052:  MOVLB  4
3054:  MOVF   x68,W
3056:  MOVLB  9
3058:  SUBWF  x7B,W
305A:  BC    309E
.................... 				sbd.mo_buff[sbd.mo_length++]=qBuff.rResult[l];
305C:  MOVLB  7
305E:  MOVFF  7DB,97E
3062:  MOVF   xDA,W
3064:  INCF   xDA,F
3066:  BTFSC  FD8.2
3068:  INCF   xDB,F
306A:  MOVLB  9
306C:  MOVWF  x7D
306E:  MOVLW  CA
3070:  ADDWF  x7D,W
3072:  MOVWF  01
3074:  MOVLW  06
3076:  ADDWFC x7E,W
3078:  MOVWF  03
307A:  MOVLW  68
307C:  ADDWF  x7B,W
307E:  MOVWF  FE9
3080:  MOVLW  03
3082:  ADDWFC x7C,W
3084:  MOVWF  FEA
3086:  MOVFF  FEF,981
308A:  MOVFF  03,FEA
308E:  MOVFF  01,FE9
3092:  MOVFF  981,FEF
3096:  INCF   x7B,F
3098:  BTFSC  FD8.2
309A:  INCF   x7C,F
309C:  BRA    304E
309E:  MOVLB  3
.................... 			}
.................... 		}
30A0:  MOVLB  9
30A2:  INCF   x7A,F
30A4:  BRA    298E
.................... 
.................... 	}
.................... 
.................... 	/* if we have data to send, then we sent it */
.................... 	if ( 0 == timers.sbd_cycle && sbd.mo_length > 0 ) {
30A6:  MOVLB  3
30A8:  MOVF   x65,F
30AA:  BNZ   30D6
30AC:  MOVF   x66,F
30AE:  BNZ   30D6
30B0:  MOVLB  7
30B2:  MOVF   xDA,F
30B4:  BNZ   30C0
30B6:  MOVF   xDB,F
30B8:  BTFSS  FD8.2
30BA:  BRA    30C0
30BC:  MOVLB  3
30BE:  BRA    30D6
.................... #if DEBUG_SBD
.................... 		fprintf(STREAM_WORLD,"# deviceQuery() setting sbd.mo_state=1\r\n");
30C0:  MOVLW  7C
30C2:  MOVWF  FF6
30C4:  MOVLW  09
30C6:  MOVWF  FF7
30C8:  MOVLB  0
30CA:  CALL   0C76
.................... #endif
.................... 		sbd.mo_state=1;
30CE:  MOVLW  01
30D0:  MOVLB  6
30D2:  MOVWF  xC9
30D4:  MOVLB  3
.................... 	}
.................... 
.................... 	measurementNumber++;
30D6:  MOVLB  9
30D8:  INCF   x37,F
30DA:  BTFSC  FD8.2
30DC:  INCF   x38,F
.................... 
.................... 	if ( 0 == timers.sbd_cycle ) {
30DE:  MOVLB  3
30E0:  MOVF   x65,F
30E2:  BNZ   30FE
30E4:  MOVF   x66,F
30E6:  BNZ   30FE
.................... 		timers.sbd_cycle=(config.sbd_every-1);
30E8:  MOVLW  01
30EA:  MOVLB  5
30EC:  SUBWF  x89,W
30EE:  MOVLB  3
30F0:  MOVWF  x65
30F2:  MOVLW  00
30F4:  MOVLB  5
30F6:  SUBWFB x8A,W
30F8:  MOVLB  3
30FA:  MOVWF  x66
.................... 	} else {
30FC:  BRA    3106
.................... 		timers.sbd_cycle--;
30FE:  MOVF   x65,W
3100:  BTFSC  FD8.2
3102:  DECF   x66,F
3104:  DECF   x65,F
.................... 	}
3106:  MOVLB  0
3108:  GOTO   4592 (RETURN)
.................... }
.................... 
.................... void init() {
.................... 	setup_oscillator(OSC_8MHZ | OSC_INTRC); 
*
0C02:  MOVLW  62
0C04:  MOVWF  FD3
0C06:  CLRF   F9B
0C08:  CLRF   F64
.................... 	setup_adc_ports(NO_ANALOGS);
0C0A:  MOVLB  F
0C0C:  MOVF   x5C,W
0C0E:  ANDLW  80
0C10:  MOVWF  x5C
0C12:  MOVLW  00
0C14:  MOVWF  x5D
0C16:  BCF    FC1.3
0C18:  BCF    FC1.4
0C1A:  BCF    FC1.5
.................... 	setup_wdt(WDT_ON);
0C1C:  BSF    FD1.0
.................... 
.................... 	/* 
.................... 	Manually set ANCON0 to 0xff and ANCON1 to 0x1f for all digital
.................... 	Otherwise set high bit of ANCON1 for VbGen enable, then remaining bits are AN12 ... AN8
.................... 	ANCON1 AN7 ... AN0
.................... 	set bit to make input digital
.................... 	*/
.................... 	/* AN7 AN6 AN5 AN4 AN3 AN2 AN1 AN0 */
.................... 	ANCON0=0xff;
0C1E:  SETF   x5D
.................... 	/* VbGen x x 12 11 10 9 8 */
.................... 	ANCON1=0x1f;
0C20:  MOVLW  1F
0C22:  MOVWF  x5C
.................... 
.................... 	setup_ccp1(CCP_OFF);
0C24:  MOVLW  F0
0C26:  ANDWF  FBB,F
.................... 	setup_ccp2(CCP_OFF);
0C28:  ANDWF  x50,F
.................... 	setup_ccp3(CCP_OFF);
0C2A:  ANDWF  x4D,F
.................... 	setup_ccp4(CCP_OFF);
0C2C:  ANDWF  x4A,F
.................... 	setup_ccp5(CCP_OFF);
0C2E:  ANDWF  x47,F
.................... 
.................... 	output_low(RS485_DE); /* shut off RS-485 transmitter */
0C30:  BCF    F94.5
0C32:  BCF    F8B.5
.................... 
.................... 	setup_timer_4(T4_DIV_BY_16,77,16); 
0C34:  MOVLW  78
0C36:  IORLW  06
0C38:  MOVWF  F88
0C3A:  MOVLW  4D
0C3C:  MOVWF  FA9
.................... 	enable_interrupts(INT_TIMER4);	
0C3E:  BSF    FB6.7
.................... 
.................... 	/* global structures initialized to 0, set something else below if needed */
.................... 	timers.now_poll=1;
0C40:  MOVLW  01
0C42:  MOVLB  3
0C44:  MOVWF  x61
.................... 	timers.sbd_cycle=1; /* next packet will be an SBD packet */
0C46:  CLRF   x66
0C48:  MOVWF  x65
.................... 	timers.world_timeout=255;
0C4A:  SETF   x62
.................... 	timers.factory_unlocked=0;
0C4C:  CLRF   x63
.................... 	timers.led_on_green=0;
0C4E:  CLRF   x64
.................... 
.................... 	query_reset();
0C50:  MOVLB  0
0C52:  RCALL  0B00
.................... 
.................... 	/* receive data from serial ports */
.................... 	enable_interrupts(INT_RDA2);
0C54:  BSF    FA3.5
.................... 
.................... #if MCP3208_ENABLED
.................... 	/* initialize MCP3208 external ADCs */
.................... 	mcp3208_init();
.................... #endif
.................... 
.................... 
.................... 	if ( config.sbd_config ) {
0C56:  MOVLB  5
0C58:  MOVF   x88,F
0C5A:  BZ    0C68
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# init() initializing I2C Uart for SBD @ 19200\r\n");
.................... #endif
.................... 		/* initialize I2C UART for Iridium @ 19200 */
.................... 		uart_init(6); /* 2=>57600 (tested, works) 6=>19200 */
0C5C:  MOVLW  06
0C5E:  MOVLB  9
0C60:  MOVWF  x7A
0C62:  MOVLB  0
0C64:  BRA    0B66
0C66:  MOVLB  5
.................... 	}
.................... 
.................... 	delay_ms(14);
0C68:  MOVLW  0E
0C6A:  MOVLB  9
0C6C:  MOVWF  x90
0C6E:  MOVLB  0
0C70:  RCALL  0BD2
0C72:  GOTO   42EE (RETURN)
.................... }
.................... 
.................... void main(void) {
*
4224:  CLRF   FF8
4226:  BCF    FD0.7
4228:  BSF    07.7
422A:  MOVLW  62
422C:  MOVWF  FD3
422E:  CLRF   F9B
4230:  CLRF   F64
4232:  CLRF   20
4234:  BSF    FB9.3
4236:  MOVLW  22
4238:  MOVWF  F7B
423A:  MOVLW  00
423C:  MOVWF  F7C
423E:  MOVLW  A6
4240:  MOVWF  FBA
4242:  MOVLW  90
4244:  MOVWF  FA6
4246:  BSF    F94.3
4248:  BSF    F94.4
424A:  MOVLW  04
424C:  MOVWF  FC8
424E:  MOVLW  28
4250:  MOVWF  FC6
4252:  BCF    FC7.7
4254:  BCF    FC7.6
4256:  BCF    FA7.3
4258:  MOVLW  0C
425A:  MOVWF  FAF
425C:  MOVLW  A2
425E:  MOVWF  FAC
4260:  MOVLW  90
4262:  MOVWF  FAB
4264:  MOVLB  5
4266:  CLRF   x8E
4268:  MOVLW  01
426A:  MOVWF  x8D
426C:  MOVLW  86
426E:  MOVWF  x8C
4270:  MOVLW  A0
4272:  MOVWF  x8B
4274:  BCF    x8F.0
4276:  CLRF   x90
4278:  MOVLB  9
427A:  CLRF   x2A
427C:  CLRF   x29
427E:  MOVLB  F
4280:  MOVF   x5C,W
4282:  ANDLW  80
4284:  MOVWF  x5C
4286:  MOVLW  00
4288:  MOVWF  x5D
428A:  BCF    FC1.3
428C:  BCF    FC1.4
428E:  BCF    FC1.5
4290:  CLRF   x5E
4292:  CLRF   x5F
4294:  BRA    42AA
4296:  DATA 02,00
4298:  DATA 1A,00
429A:  DATA 00,FF
429C:  DATA 46,96
429E:  DATA 00,FF
42A0:  DATA C0,00
42A2:  DATA 95,C0
42A4:  DATA 00,4E
42A6:  DATA 49,2B
42A8:  DATA 00,00
42AA:  MOVLW  00
42AC:  MOVWF  FF8
42AE:  MOVLW  42
42B0:  MOVWF  FF7
42B2:  MOVLW  96
42B4:  MOVWF  FF6
42B6:  TBLRD*+
42B8:  MOVF   FF5,W
42BA:  MOVWF  00
42BC:  XORLW  00
42BE:  BZ    42E6
42C0:  TBLRD*+
42C2:  MOVF   FF5,W
42C4:  MOVWF  01
42C6:  BTFSC  FE8.7
42C8:  BRA    42D4
42CA:  ANDLW  3F
42CC:  MOVWF  FEA
42CE:  TBLRD*+
42D0:  MOVFF  FF5,FE9
42D4:  BTFSC  01.6
42D6:  TBLRD*+
42D8:  BTFSS  01.6
42DA:  TBLRD*+
42DC:  MOVFF  FF5,FEE
42E0:  DCFSNZ 00,F
42E2:  BRA    42B6
42E4:  BRA    42D8
42E6:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	/* normal device startup */
.................... 	init();
42E8:  MOVLB  0
42EA:  GOTO   0C02
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking wait\r\n");
.................... #endif
.................... 	for ( i=0 ; i<STARTUP_BLINKS ; i++ ) {
42EE:  MOVLB  9
42F0:  CLRF   x79
42F2:  MOVF   x79,W
42F4:  SUBLW  31
42F6:  BNC   431E
.................... 		restart_wdt();
42F8:  CLRWDT
.................... 
.................... 		output_high(LED_GREEN);
42FA:  BCF    F93.5
42FC:  BSF    F8A.5
.................... 		delay_ms(100);
42FE:  MOVLW  64
4300:  MOVWF  x90
4302:  MOVLB  0
4304:  CALL   0BD2
.................... 		output_low(LED_GREEN);
4308:  BCF    F93.5
430A:  BCF    F8A.5
.................... 		delay_ms(100);
430C:  MOVLW  64
430E:  MOVLB  9
4310:  MOVWF  x90
4312:  MOVLB  0
4314:  CALL   0BD2
.................... #if DEBUG_ASCII
.................... 		fprintf(STREAM_WORLD,"# main() blink=%u\r\n",i);
.................... #endif
.................... 	}
.................... 
.................... #if 1
4318:  MOVLB  9
431A:  INCF   x79,F
431C:  BRA    42F2
.................... 	fprintf(STREAM_WORLD,"# main() startup blinking done\r\n");
431E:  MOVLW  A6
4320:  MOVWF  FF6
4322:  MOVLW  09
4324:  MOVWF  FF7
4326:  MOVLB  0
4328:  CALL   0C76
.................... 
.................... 	fprintf(STREAM_WORLD,"# rdTap %s %sr\n",__DATE__,__TIME__);
432C:  MOVLW  C8
432E:  MOVWF  FF6
4330:  MOVLW  09
4332:  MOVWF  FF7
4334:  MOVLW  08
4336:  MOVLB  9
4338:  MOVWF  x7E
433A:  MOVLB  0
433C:  CALL   0C98
4340:  MOVLW  D8
4342:  MOVWF  FF6
4344:  MOVLW  09
4346:  MOVWF  FF7
4348:  CALL   0C76
434C:  MOVLW  20
434E:  BTFSS  FA4.4
4350:  BRA    434E
4352:  MOVWF  F79
4354:  MOVLW  E2
4356:  MOVWF  FF6
4358:  MOVLW  09
435A:  MOVWF  FF7
435C:  CALL   0C76
4360:  MOVLW  72
4362:  BTFSS  FA4.4
4364:  BRA    4362
4366:  MOVWF  F79
4368:  MOVLW  0A
436A:  BTFSS  FA4.4
436C:  BRA    436A
436E:  MOVWF  F79
.................... 
.................... 	fprintf(STREAM_WORLD,"# restart cause: ");
4370:  MOVLW  EC
4372:  MOVWF  FF6
4374:  MOVLW  09
4376:  MOVWF  FF7
4378:  CALL   0C76
.................... 	switch ( restart_cause ) {
437C:  MOVLW  07
437E:  SUBWF  00,W
4380:  BZ    43A6
4382:  MOVLW  0B
4384:  SUBWF  00,W
4386:  BZ    43B4
4388:  MOVLW  0F
438A:  SUBWF  00,W
438C:  BZ    43C2
438E:  MOVLW  0C
4390:  SUBWF  00,W
4392:  BZ    43D0
4394:  MOVLW  0E
4396:  SUBWF  00,W
4398:  BZ    43DE
439A:  MOVLW  03
439C:  SUBWF  00,W
439E:  BZ    43EC
43A0:  MOVF   00,F
43A2:  BZ    43FA
43A4:  BRA    4408
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_WORLD,"WDT TIMEOUT"); break;
43A6:  MOVLW  FE
43A8:  MOVWF  FF6
43AA:  MOVLW  09
43AC:  MOVWF  FF7
43AE:  CALL   0C76
43B2:  BRA    4414
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_WORLD,"MCLR FROM SLEEP"); break;
43B4:  MOVLW  0A
43B6:  MOVWF  FF6
43B8:  MOVLW  0A
43BA:  MOVWF  FF7
43BC:  CALL   0C76
43C0:  BRA    4414
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_WORLD,"MCLR FROM RUN"); break;
43C2:  MOVLW  1A
43C4:  MOVWF  FF6
43C6:  MOVLW  0A
43C8:  MOVWF  FF7
43CA:  CALL   0C76
43CE:  BRA    4414
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_WORLD,"NORMAL POWER UP"); break;
43D0:  MOVLW  28
43D2:  MOVWF  FF6
43D4:  MOVLW  0A
43D6:  MOVWF  FF7
43D8:  CALL   0C76
43DC:  BRA    4414
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_WORLD,"BROWNOUT RESTART"); break;
43DE:  MOVLW  38
43E0:  MOVWF  FF6
43E2:  MOVLW  0A
43E4:  MOVWF  FF7
43E6:  CALL   0C76
43EA:  BRA    4414
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_WORLD,"WDT FROM SLEEP"); break;
43EC:  MOVLW  4A
43EE:  MOVWF  FF6
43F0:  MOVLW  0A
43F2:  MOVWF  FF7
43F4:  CALL   0C76
43F8:  BRA    4414
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_WORLD,"RESET INSTRUCTION"); break;
43FA:  MOVLW  5A
43FC:  MOVWF  FF6
43FE:  MOVLW  0A
4400:  MOVWF  FF7
4402:  CALL   0C76
4406:  BRA    4414
.................... 		default:                fprintf(STREAM_WORLD,"UNKNOWN!");
4408:  MOVLW  6C
440A:  MOVWF  FF6
440C:  MOVLW  0A
440E:  MOVWF  FF7
4410:  CALL   0C76
.................... 	}
.................... 	fprintf(STREAM_WORLD,"\r\n");
4414:  MOVLW  0D
4416:  BTFSS  FA4.4
4418:  BRA    4416
441A:  MOVWF  F79
441C:  MOVLW  0A
441E:  BTFSS  FA4.4
4420:  BRA    441E
4422:  MOVWF  F79
.................... #endif
.................... 
.................... 	restart_wdt();
4424:  CLRWDT
.................... 	enable_interrupts(GLOBAL);
4426:  MOVLW  C0
4428:  IORWF  FF2,F
.................... 
.................... 	write_default_param_file();
442A:  CALL   0DB6
.................... 	write_default_device_file();
442E:  CALL   0E54
.................... 
.................... 	read_param_file();
4432:  GOTO   0F8C
.................... 	read_device_file();
4436:  GOTO   0FDA
.................... 
.................... 	restart_wdt();
443A:  CLRWDT
.................... 	modbus_init();
443C:  GOTO   103A
.................... 
.................... #if DEBUG_ASCII
.................... 	devicesDump();
.................... #endif
.................... 
.................... 	iridium_mr_clear();
4440:  CALL   1052
.................... 
.................... #if DEBUG_ASCII
.................... 	fprintf(STREAM_WORLD,"# main() starting for ( ; ; ) loop\r\n");
.................... #endif
.................... 
.................... 
.................... 	/* main loop */
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
4444:  CLRWDT
.................... 
.................... 		if ( config.sbd_config ) {
4446:  MOVLB  5
4448:  MOVF   x88,F
444A:  BTFSC  FD8.2
444C:  BRA    4580
.................... 			/* iridium enabled */
.................... 
.................... 			/* act on flag set by SBDRING in UART character processor or RING ALERT line */
.................... 			if ( sbd.ring_flag ) {
444E:  MOVLB  8
4450:  MOVF   xE4,F
4452:  BZ    446E
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# main() sbd.ring_flag=1\r\n");
4454:  MOVLW  76
4456:  MOVWF  FF6
4458:  MOVLW  0A
445A:  MOVWF  FF7
445C:  MOVLB  0
445E:  CALL   0C76
.................... #endif
.................... 				/* our easiest way to get the ringing message is to send another message. This also
.................... 				would help capture the results from a query */
.................... 				timers.sbd_cycle=1; /* next packet will be an SBD packet */
4462:  MOVLB  3
4464:  CLRF   x66
4466:  MOVLW  01
4468:  MOVWF  x65
.................... 
.................... 				sbd.ring_flag=0;
446A:  MOVLB  8
446C:  CLRF   xE4
.................... 			}
.................... 
.................... 			if ( '\0' != sbd.sbdix_response[0] && 0 == sbd.mo_state ) {
446E:  MOVLB  6
4470:  MOVF   x96,F
4472:  BZ    44FA
4474:  MOVF   xC9,F
4476:  BNZ   44FA
.................... 				/* 
.................... 				if there is something in our +SBDIX response we should check if we have a message or need to 
.................... 				get a message. But wait until MO sending is done (state machine idle).
.................... 				*/
.................... 
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_response='%s'\r\n",sbd.sbdix_response);
4478:  MOVLW  92
447A:  MOVWF  FF6
447C:  MOVLW  0A
447E:  MOVWF  FF7
4480:  MOVLW  16
4482:  MOVLB  9
4484:  MOVWF  x7E
4486:  MOVLB  0
4488:  CALL   0C98
448C:  MOVLW  06
448E:  MOVWF  FEA
4490:  MOVLW  96
4492:  MOVWF  FE9
4494:  GOTO   105E
4498:  MOVLW  AA
449A:  MOVWF  FF6
449C:  MOVLW  0A
449E:  MOVWF  FF7
44A0:  MOVLW  03
44A2:  MOVLB  9
44A4:  MOVWF  x7E
44A6:  MOVLB  0
44A8:  CALL   0C98
.................... #endif
.................... 
....................  				iridium_sbdix_parse();
44AC:  GOTO   136C
.................... 
.................... 				/* clear the unparsed buffer so we don't get back here */
.................... 				sbd.sbdix_response[0]='\0';
44B0:  MOVLB  6
44B2:  CLRF   x96
.................... 
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
44B4:  MOVF   xC8,F
44B6:  BZ    44FA
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
44B8:  MOVLB  3
44BA:  CLRF   x66
44BC:  MOVLW  01
44BE:  MOVWF  x65
.................... 					
.................... #if DEBUG_SBD
.................... 					fprintf(STREAM_WORLD,"# sbd.sbdix_mt_queued > 0 (is %u)\r\n",sbd.sbdix_mt_queued);
44C0:  MOVLW  AE
44C2:  MOVWF  FF6
44C4:  MOVLW  0A
44C6:  MOVWF  FF7
44C8:  MOVLW  1E
44CA:  MOVLB  9
44CC:  MOVWF  x7E
44CE:  MOVLB  0
44D0:  CALL   0C98
44D4:  MOVFF  6C8,97E
44D8:  MOVLW  1B
44DA:  MOVLB  9
44DC:  MOVWF  x7F
44DE:  MOVLB  0
44E0:  CALL   162A
44E4:  MOVLW  CE
44E6:  MOVWF  FF6
44E8:  MOVLW  0A
44EA:  MOVWF  FF7
44EC:  MOVLW  03
44EE:  MOVLB  9
44F0:  MOVWF  x7E
44F2:  MOVLB  0
44F4:  CALL   0C98
44F8:  MOVLB  6
.................... #endif
.................... 				}
.................... 			}
.................... 
.................... 			/* read character into MR if we don't have an unprocessed message and there is a character available */
.................... 			if ( 0==sbd.mr_ready && ! sbd.mr_disable && uart_kbhit() ) {
44FA:  MOVLB  8
44FC:  MOVF   xE6,F
44FE:  BNZ   4522
4500:  MOVLB  9
4502:  MOVF   x28,F
4504:  BTFSC  FD8.2
4506:  BRA    450C
4508:  MOVLB  8
450A:  BRA    4522
450C:  MOVLB  0
450E:  CALL   1730
4512:  MOVF   01,F
4514:  BTFSS  FD8.2
4516:  BRA    451C
4518:  MOVLB  8
451A:  BRA    4522
.................... 				iridium_getc();
451C:  GOTO   1742
4520:  MOVLB  8
.................... 			}
.................... 
.................... 			/* download message from SBD modem */
.................... 			if ( 1 == sbd.sbdix_mt_status ) {
4522:  MOVLB  6
4524:  DECFSZ xC3,W
4526:  BRA    453C
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.sbdix_mt_status=1\r\n");
4528:  MOVLW  D2
452A:  MOVWF  FF6
452C:  MOVLW  0A
452E:  MOVWF  FF7
4530:  MOVLB  0
4532:  CALL   0C76
.................... #endif
.................... 				iridium_mt_receive();
4536:  GOTO   1826
453A:  MOVLB  6
.................... 			}
.................... 
.................... 			/* send messages to SBD modem */
.................... 			if ( 0 != sbd.mo_state && 0 == sbd.mt_state ) {
453C:  MOVF   xC9,F
453E:  BZ    4554
4540:  MOVLB  7
4542:  MOVF   xDF,F
4544:  BTFSC  FD8.2
4546:  BRA    454C
4548:  MOVLB  6
454A:  BRA    4554
.................... 				iridium_mo_send();
454C:  MOVLB  0
454E:  GOTO   1D82
4552:  MOVLB  6
.................... 			}
.................... 
.................... 			if ( 1 == sbd.mt_ready ) {
4554:  MOVLB  7
4556:  DECFSZ xDE,W
4558:  BRA    457E
.................... #if DEBUG_SBD
.................... 				fprintf(STREAM_WORLD,"# sbd.mt_ready=1\r\n");
455A:  MOVLW  EC
455C:  MOVWF  FF6
455E:  MOVLW  0A
4560:  MOVWF  FF7
4562:  MOVLB  0
4564:  CALL   0C76
.................... #endif
.................... 				/* TODO: send to message parser */
.................... 				sbd.mt_ready=0;
4568:  MOVLB  7
456A:  CLRF   xDE
.................... 
.................... 				/* do another SBDIX if we have sbd.mt_queued > 0 */
.................... 				if ( sbd.sbdix_mt_queued > 0 ) {
456C:  MOVLB  6
456E:  MOVF   xC8,F
4570:  BZ    457C
.................... 					/* our easiest way to get the next message is to send another message. This also
.................... 					would help capture the results from a query */
.................... 					timers.sbd_cycle=1; /* next packet will be an SBD packet */
4572:  MOVLB  3
4574:  CLRF   x66
4576:  MOVLW  01
4578:  MOVWF  x65
457A:  MOVLB  6
457C:  MOVLB  7
457E:  MOVLB  5
.................... 				}
.................... 			} 
.................... 		}
.................... 
.................... 
.................... 		if ( timers.now_poll ) {
4580:  MOVLB  3
4582:  MOVF   x61,F
4584:  BZ    4594
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll\r\n");
.................... #endif
.................... 			timers.now_poll=0;
4586:  CLRF   x61
.................... 			timers.led_on_green=200;
4588:  MOVLW  C8
458A:  MOVWF  x64
.................... 			deviceQuery();
458C:  MOVLB  0
458E:  GOTO   290C
4592:  MOVLB  3
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() timers.now_poll done\r\n");
.................... #endif
.................... 		}
.................... 
.................... 		/* queries are messages send to us that we respond to */
.................... 		if ( query.buff_ready ) {
4594:  MOVLB  5
4596:  MOVF   x6D,F
4598:  BZ    45A4
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_process()\r\n");
.................... #endif
.................... 
.................... 			query_process();
459A:  MOVLB  0
459C:  BRA    4118
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() starting query_reset()\r\n");
.................... #endif
.................... 	
.................... 			query_reset();
459E:  CALL   0B00
45A2:  MOVLB  5
.................... 
.................... #if DEBUG_ASCII
.................... 			fprintf(STREAM_WORLD,"# main() done with query.buff_ready()\r\n");
.................... #endif
.................... 		}
45A4:  MOVLB  0
45A6:  BRA    4444
.................... 	}
.................... }
.................... 
45A8:  SLEEP 

Configuration Fuses:
   Word  1: 0815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN NOFCMEN NOIESO
   Word  2: 2B67   NOPUT BROWNOUT BORV30 ZPBORM WDT WDT1024
   Word  3: 0900   CANB MSSPMSK7 NOMCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
